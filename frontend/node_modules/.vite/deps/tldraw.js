import {
  require_jsx_runtime
} from "./chunk-CCEUJESP.js";
import {
  require_client
} from "./chunk-4DQEIEFE.js";
import {
  require_react_dom
} from "./chunk-KINVOPIH.js";
import {
  require_react
} from "./chunk-AN235OLU.js";
import {
  ArrayOfValidator,
  DEFAULT_SUPPORTED_IMAGE_TYPES,
  DEFAULT_SUPPORTED_MEDIA_TYPES,
  DEFAULT_SUPPORTED_MEDIA_TYPE_LIST,
  DEFAULT_SUPPORT_VIDEO_TYPES,
  DictValidator,
  ExecutionQueue,
  FileHelpers,
  Image,
  MediaHelpers,
  ObjectValidator,
  PerformanceTracker,
  PngHelpers,
  Result,
  STRUCTURED_CLONE_OBJECT_PROTOTYPE,
  Timers,
  UnionValidator,
  Validator,
  WeakCache,
  ZERO_INDEX_KEY,
  annotateError,
  areArraysShallowEqual,
  areObjectsShallowEqual,
  assert,
  assertExists,
  bind,
  clearLocalStorage,
  clearSessionStorage,
  compact,
  debounce,
  dedupe,
  deleteFromLocalStorage,
  deleteFromSessionStorage,
  exhaustiveSwitchError,
  fetch as fetch2,
  filterEntries,
  fpsThrottle,
  getChangedKeys,
  getErrorAnnotations,
  getFirstFromIterable,
  getFromLocalStorage,
  getFromSessionStorage,
  getHashForBuffer,
  getHashForObject,
  getHashForString,
  getIndexAbove,
  getIndexBelow,
  getIndexBetween,
  getIndices,
  getIndicesAbove,
  getIndicesBelow,
  getIndicesBetween,
  getOwnProperty,
  groupBy,
  hasOwnProperty,
  import_lodash,
  import_lodash2,
  import_lodash3,
  import_lodash4,
  invLerp,
  isDefined,
  isEqualAllowingForFloatingPointErrors,
  isNativeStructuredClone,
  isNonNull,
  isNonNullish,
  last,
  lerp,
  lns,
  mapObjectMapValues,
  maxBy,
  measureAverageDuration,
  measureCbDuration,
  measureDuration,
  mergeArraysAndReplaceDefaults,
  minBy,
  mockUniqueId,
  modulate,
  noop,
  objectMapEntries,
  objectMapEntriesIterable,
  objectMapFromEntries,
  objectMapKeys,
  objectMapValues,
  omit,
  omitFromStackTrace,
  partition,
  promiseWithResolve,
  registerTldrawLibraryVersion,
  restoreUniqueId,
  retry,
  rng,
  rotateArray,
  safeParseUrl,
  setInLocalStorage,
  setInSessionStorage,
  sleep,
  sortById,
  sortByIndex,
  sortByMaybeIndex,
  stringEnum,
  structuredClone,
  throttleToNextFrame,
  uniqueId,
  validateIndexKey,
  validation_exports,
  warnDeprecatedGetter,
  warnOnce
} from "./chunk-3MXFBIWP.js";
import {
  __commonJS,
  __export,
  __privateAdd,
  __privateGet,
  __privateSet,
  __publicField,
  __toESM
} from "./chunk-DP4XHQAG.js";

// ../node_modules/core-js/internals/global-this.js
var require_global_this = __commonJS({
  "../node_modules/core-js/internals/global-this.js"(exports, module) {
    "use strict";
    var check = function(it) {
      return it && it.Math === Math && it;
    };
    module.exports = // eslint-disable-next-line es/no-global-this -- safe
    check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
    check(typeof self == "object" && self) || check(typeof global == "object" && global) || check(typeof exports == "object" && exports) || // eslint-disable-next-line no-new-func -- fallback
    /* @__PURE__ */ (function() {
      return this;
    })() || Function("return this")();
  }
});

// ../node_modules/core-js/internals/fails.js
var require_fails = __commonJS({
  "../node_modules/core-js/internals/fails.js"(exports, module) {
    "use strict";
    module.exports = function(exec) {
      try {
        return !!exec();
      } catch (error) {
        return true;
      }
    };
  }
});

// ../node_modules/core-js/internals/descriptors.js
var require_descriptors = __commonJS({
  "../node_modules/core-js/internals/descriptors.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    module.exports = !fails(function() {
      return Object.defineProperty({}, 1, { get: function() {
        return 7;
      } })[1] !== 7;
    });
  }
});

// ../node_modules/core-js/internals/function-bind-native.js
var require_function_bind_native = __commonJS({
  "../node_modules/core-js/internals/function-bind-native.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    module.exports = !fails(function() {
      var test = (function() {
      }).bind();
      return typeof test != "function" || test.hasOwnProperty("prototype");
    });
  }
});

// ../node_modules/core-js/internals/function-call.js
var require_function_call = __commonJS({
  "../node_modules/core-js/internals/function-call.js"(exports, module) {
    "use strict";
    var NATIVE_BIND = require_function_bind_native();
    var call2 = Function.prototype.call;
    module.exports = NATIVE_BIND ? call2.bind(call2) : function() {
      return call2.apply(call2, arguments);
    };
  }
});

// ../node_modules/core-js/internals/object-property-is-enumerable.js
var require_object_property_is_enumerable = __commonJS({
  "../node_modules/core-js/internals/object-property-is-enumerable.js"(exports) {
    "use strict";
    var $propertyIsEnumerable = {}.propertyIsEnumerable;
    var getOwnPropertyDescriptor2 = Object.getOwnPropertyDescriptor;
    var NASHORN_BUG = getOwnPropertyDescriptor2 && !$propertyIsEnumerable.call({ 1: 2 }, 1);
    exports.f = NASHORN_BUG ? function propertyIsEnumerable(V2) {
      var descriptor = getOwnPropertyDescriptor2(this, V2);
      return !!descriptor && descriptor.enumerable;
    } : $propertyIsEnumerable;
  }
});

// ../node_modules/core-js/internals/create-property-descriptor.js
var require_create_property_descriptor = __commonJS({
  "../node_modules/core-js/internals/create-property-descriptor.js"(exports, module) {
    "use strict";
    module.exports = function(bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value
      };
    };
  }
});

// ../node_modules/core-js/internals/function-uncurry-this.js
var require_function_uncurry_this = __commonJS({
  "../node_modules/core-js/internals/function-uncurry-this.js"(exports, module) {
    "use strict";
    var NATIVE_BIND = require_function_bind_native();
    var FunctionPrototype = Function.prototype;
    var call2 = FunctionPrototype.call;
    var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call2, call2);
    module.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
      return function() {
        return call2.apply(fn, arguments);
      };
    };
  }
});

// ../node_modules/core-js/internals/classof-raw.js
var require_classof_raw = __commonJS({
  "../node_modules/core-js/internals/classof-raw.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toString2 = uncurryThis({}.toString);
    var stringSlice = uncurryThis("".slice);
    module.exports = function(it) {
      return stringSlice(toString2(it), 8, -1);
    };
  }
});

// ../node_modules/core-js/internals/indexed-object.js
var require_indexed_object = __commonJS({
  "../node_modules/core-js/internals/indexed-object.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var classof = require_classof_raw();
    var $Object = Object;
    var split2 = uncurryThis("".split);
    module.exports = fails(function() {
      return !$Object("z").propertyIsEnumerable(0);
    }) ? function(it) {
      return classof(it) === "String" ? split2(it, "") : $Object(it);
    } : $Object;
  }
});

// ../node_modules/core-js/internals/is-null-or-undefined.js
var require_is_null_or_undefined = __commonJS({
  "../node_modules/core-js/internals/is-null-or-undefined.js"(exports, module) {
    "use strict";
    module.exports = function(it) {
      return it === null || it === void 0;
    };
  }
});

// ../node_modules/core-js/internals/require-object-coercible.js
var require_require_object_coercible = __commonJS({
  "../node_modules/core-js/internals/require-object-coercible.js"(exports, module) {
    "use strict";
    var isNullOrUndefined = require_is_null_or_undefined();
    var $TypeError = TypeError;
    module.exports = function(it) {
      if (isNullOrUndefined(it)) throw new $TypeError("Can't call method on " + it);
      return it;
    };
  }
});

// ../node_modules/core-js/internals/to-indexed-object.js
var require_to_indexed_object = __commonJS({
  "../node_modules/core-js/internals/to-indexed-object.js"(exports, module) {
    "use strict";
    var IndexedObject = require_indexed_object();
    var requireObjectCoercible = require_require_object_coercible();
    module.exports = function(it) {
      return IndexedObject(requireObjectCoercible(it));
    };
  }
});

// ../node_modules/core-js/internals/is-callable.js
var require_is_callable = __commonJS({
  "../node_modules/core-js/internals/is-callable.js"(exports, module) {
    "use strict";
    var documentAll = typeof document == "object" && document.all;
    module.exports = typeof documentAll == "undefined" && documentAll !== void 0 ? function(argument) {
      return typeof argument == "function" || argument === documentAll;
    } : function(argument) {
      return typeof argument == "function";
    };
  }
});

// ../node_modules/core-js/internals/is-object.js
var require_is_object = __commonJS({
  "../node_modules/core-js/internals/is-object.js"(exports, module) {
    "use strict";
    var isCallable = require_is_callable();
    module.exports = function(it) {
      return typeof it == "object" ? it !== null : isCallable(it);
    };
  }
});

// ../node_modules/core-js/internals/get-built-in.js
var require_get_built_in = __commonJS({
  "../node_modules/core-js/internals/get-built-in.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var isCallable = require_is_callable();
    var aFunction = function(argument) {
      return isCallable(argument) ? argument : void 0;
    };
    module.exports = function(namespace, method) {
      return arguments.length < 2 ? aFunction(globalThis2[namespace]) : globalThis2[namespace] && globalThis2[namespace][method];
    };
  }
});

// ../node_modules/core-js/internals/object-is-prototype-of.js
var require_object_is_prototype_of = __commonJS({
  "../node_modules/core-js/internals/object-is-prototype-of.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    module.exports = uncurryThis({}.isPrototypeOf);
  }
});

// ../node_modules/core-js/internals/environment-user-agent.js
var require_environment_user_agent = __commonJS({
  "../node_modules/core-js/internals/environment-user-agent.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var navigator2 = globalThis2.navigator;
    var userAgent = navigator2 && navigator2.userAgent;
    module.exports = userAgent ? String(userAgent) : "";
  }
});

// ../node_modules/core-js/internals/environment-v8-version.js
var require_environment_v8_version = __commonJS({
  "../node_modules/core-js/internals/environment-v8-version.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var userAgent = require_environment_user_agent();
    var process2 = globalThis2.process;
    var Deno = globalThis2.Deno;
    var versions = process2 && process2.versions || Deno && Deno.version;
    var v8 = versions && versions.v8;
    var match;
    var version2;
    if (v8) {
      match = v8.split(".");
      version2 = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
    }
    if (!version2 && userAgent) {
      match = userAgent.match(/Edge\/(\d+)/);
      if (!match || match[1] >= 74) {
        match = userAgent.match(/Chrome\/(\d+)/);
        if (match) version2 = +match[1];
      }
    }
    module.exports = version2;
  }
});

// ../node_modules/core-js/internals/symbol-constructor-detection.js
var require_symbol_constructor_detection = __commonJS({
  "../node_modules/core-js/internals/symbol-constructor-detection.js"(exports, module) {
    "use strict";
    var V8_VERSION = require_environment_v8_version();
    var fails = require_fails();
    var globalThis2 = require_global_this();
    var $String = globalThis2.String;
    module.exports = !!Object.getOwnPropertySymbols && !fails(function() {
      var symbol = Symbol("symbol detection");
      return !$String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
      !Symbol.sham && V8_VERSION && V8_VERSION < 41;
    });
  }
});

// ../node_modules/core-js/internals/use-symbol-as-uid.js
var require_use_symbol_as_uid = __commonJS({
  "../node_modules/core-js/internals/use-symbol-as-uid.js"(exports, module) {
    "use strict";
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    module.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
  }
});

// ../node_modules/core-js/internals/is-symbol.js
var require_is_symbol = __commonJS({
  "../node_modules/core-js/internals/is-symbol.js"(exports, module) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    var isCallable = require_is_callable();
    var isPrototypeOf = require_object_is_prototype_of();
    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
    var $Object = Object;
    module.exports = USE_SYMBOL_AS_UID ? function(it) {
      return typeof it == "symbol";
    } : function(it) {
      var $Symbol = getBuiltIn("Symbol");
      return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
    };
  }
});

// ../node_modules/core-js/internals/try-to-string.js
var require_try_to_string = __commonJS({
  "../node_modules/core-js/internals/try-to-string.js"(exports, module) {
    "use strict";
    var $String = String;
    module.exports = function(argument) {
      try {
        return $String(argument);
      } catch (error) {
        return "Object";
      }
    };
  }
});

// ../node_modules/core-js/internals/a-callable.js
var require_a_callable = __commonJS({
  "../node_modules/core-js/internals/a-callable.js"(exports, module) {
    "use strict";
    var isCallable = require_is_callable();
    var tryToString = require_try_to_string();
    var $TypeError = TypeError;
    module.exports = function(argument) {
      if (isCallable(argument)) return argument;
      throw new $TypeError(tryToString(argument) + " is not a function");
    };
  }
});

// ../node_modules/core-js/internals/get-method.js
var require_get_method = __commonJS({
  "../node_modules/core-js/internals/get-method.js"(exports, module) {
    "use strict";
    var aCallable = require_a_callable();
    var isNullOrUndefined = require_is_null_or_undefined();
    module.exports = function(V2, P) {
      var func = V2[P];
      return isNullOrUndefined(func) ? void 0 : aCallable(func);
    };
  }
});

// ../node_modules/core-js/internals/ordinary-to-primitive.js
var require_ordinary_to_primitive = __commonJS({
  "../node_modules/core-js/internals/ordinary-to-primitive.js"(exports, module) {
    "use strict";
    var call2 = require_function_call();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var $TypeError = TypeError;
    module.exports = function(input, pref) {
      var fn, val;
      if (pref === "string" && isCallable(fn = input.toString) && !isObject(val = call2(fn, input))) return val;
      if (isCallable(fn = input.valueOf) && !isObject(val = call2(fn, input))) return val;
      if (pref !== "string" && isCallable(fn = input.toString) && !isObject(val = call2(fn, input))) return val;
      throw new $TypeError("Can't convert object to primitive value");
    };
  }
});

// ../node_modules/core-js/internals/is-pure.js
var require_is_pure = __commonJS({
  "../node_modules/core-js/internals/is-pure.js"(exports, module) {
    "use strict";
    module.exports = false;
  }
});

// ../node_modules/core-js/internals/define-global-property.js
var require_define_global_property = __commonJS({
  "../node_modules/core-js/internals/define-global-property.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var defineProperty = Object.defineProperty;
    module.exports = function(key, value) {
      try {
        defineProperty(globalThis2, key, { value, configurable: true, writable: true });
      } catch (error) {
        globalThis2[key] = value;
      }
      return value;
    };
  }
});

// ../node_modules/core-js/internals/shared-store.js
var require_shared_store = __commonJS({
  "../node_modules/core-js/internals/shared-store.js"(exports, module) {
    "use strict";
    var IS_PURE = require_is_pure();
    var globalThis2 = require_global_this();
    var defineGlobalProperty = require_define_global_property();
    var SHARED = "__core-js_shared__";
    var store = module.exports = globalThis2[SHARED] || defineGlobalProperty(SHARED, {});
    (store.versions || (store.versions = [])).push({
      version: "3.48.0",
      mode: IS_PURE ? "pure" : "global",
      copyright: "© 2013–2025 Denis Pushkarev (zloirock.ru), 2025–2026 CoreJS Company (core-js.io). All rights reserved.",
      license: "https://github.com/zloirock/core-js/blob/v3.48.0/LICENSE",
      source: "https://github.com/zloirock/core-js"
    });
  }
});

// ../node_modules/core-js/internals/shared.js
var require_shared = __commonJS({
  "../node_modules/core-js/internals/shared.js"(exports, module) {
    "use strict";
    var store = require_shared_store();
    module.exports = function(key, value) {
      return store[key] || (store[key] = value || {});
    };
  }
});

// ../node_modules/core-js/internals/to-object.js
var require_to_object = __commonJS({
  "../node_modules/core-js/internals/to-object.js"(exports, module) {
    "use strict";
    var requireObjectCoercible = require_require_object_coercible();
    var $Object = Object;
    module.exports = function(argument) {
      return $Object(requireObjectCoercible(argument));
    };
  }
});

// ../node_modules/core-js/internals/has-own-property.js
var require_has_own_property = __commonJS({
  "../node_modules/core-js/internals/has-own-property.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toObject = require_to_object();
    var hasOwnProperty3 = uncurryThis({}.hasOwnProperty);
    module.exports = Object.hasOwn || function hasOwn2(it, key) {
      return hasOwnProperty3(toObject(it), key);
    };
  }
});

// ../node_modules/core-js/internals/uid.js
var require_uid = __commonJS({
  "../node_modules/core-js/internals/uid.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var id = 0;
    var postfix = Math.random();
    var toString2 = uncurryThis(1.1.toString);
    module.exports = function(key) {
      return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString2(++id + postfix, 36);
    };
  }
});

// ../node_modules/core-js/internals/well-known-symbol.js
var require_well_known_symbol = __commonJS({
  "../node_modules/core-js/internals/well-known-symbol.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var shared = require_shared();
    var hasOwn2 = require_has_own_property();
    var uid = require_uid();
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
    var Symbol2 = globalThis2.Symbol;
    var WellKnownSymbolsStore = shared("wks");
    var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2["for"] || Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
    module.exports = function(name) {
      if (!hasOwn2(WellKnownSymbolsStore, name)) {
        WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn2(Symbol2, name) ? Symbol2[name] : createWellKnownSymbol("Symbol." + name);
      }
      return WellKnownSymbolsStore[name];
    };
  }
});

// ../node_modules/core-js/internals/to-primitive.js
var require_to_primitive = __commonJS({
  "../node_modules/core-js/internals/to-primitive.js"(exports, module) {
    "use strict";
    var call2 = require_function_call();
    var isObject = require_is_object();
    var isSymbol = require_is_symbol();
    var getMethod2 = require_get_method();
    var ordinaryToPrimitive = require_ordinary_to_primitive();
    var wellKnownSymbol = require_well_known_symbol();
    var $TypeError = TypeError;
    var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
    module.exports = function(input, pref) {
      if (!isObject(input) || isSymbol(input)) return input;
      var exoticToPrim = getMethod2(input, TO_PRIMITIVE);
      var result;
      if (exoticToPrim) {
        if (pref === void 0) pref = "default";
        result = call2(exoticToPrim, input, pref);
        if (!isObject(result) || isSymbol(result)) return result;
        throw new $TypeError("Can't convert object to primitive value");
      }
      if (pref === void 0) pref = "number";
      return ordinaryToPrimitive(input, pref);
    };
  }
});

// ../node_modules/core-js/internals/to-property-key.js
var require_to_property_key = __commonJS({
  "../node_modules/core-js/internals/to-property-key.js"(exports, module) {
    "use strict";
    var toPrimitive = require_to_primitive();
    var isSymbol = require_is_symbol();
    module.exports = function(argument) {
      var key = toPrimitive(argument, "string");
      return isSymbol(key) ? key : key + "";
    };
  }
});

// ../node_modules/core-js/internals/document-create-element.js
var require_document_create_element = __commonJS({
  "../node_modules/core-js/internals/document-create-element.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var isObject = require_is_object();
    var document2 = globalThis2.document;
    var EXISTS = isObject(document2) && isObject(document2.createElement);
    module.exports = function(it) {
      return EXISTS ? document2.createElement(it) : {};
    };
  }
});

// ../node_modules/core-js/internals/ie8-dom-define.js
var require_ie8_dom_define = __commonJS({
  "../node_modules/core-js/internals/ie8-dom-define.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var fails = require_fails();
    var createElement9 = require_document_create_element();
    module.exports = !DESCRIPTORS && !fails(function() {
      return Object.defineProperty(createElement9("div"), "a", {
        get: function() {
          return 7;
        }
      }).a !== 7;
    });
  }
});

// ../node_modules/core-js/internals/object-get-own-property-descriptor.js
var require_object_get_own_property_descriptor = __commonJS({
  "../node_modules/core-js/internals/object-get-own-property-descriptor.js"(exports) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var call2 = require_function_call();
    var propertyIsEnumerableModule = require_object_property_is_enumerable();
    var createPropertyDescriptor = require_create_property_descriptor();
    var toIndexedObject = require_to_indexed_object();
    var toPropertyKey = require_to_property_key();
    var hasOwn2 = require_has_own_property();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor2(O, P) {
      O = toIndexedObject(O);
      P = toPropertyKey(P);
      if (IE8_DOM_DEFINE) try {
        return $getOwnPropertyDescriptor(O, P);
      } catch (error) {
      }
      if (hasOwn2(O, P)) return createPropertyDescriptor(!call2(propertyIsEnumerableModule.f, O, P), O[P]);
    };
  }
});

// ../node_modules/core-js/internals/v8-prototype-define-bug.js
var require_v8_prototype_define_bug = __commonJS({
  "../node_modules/core-js/internals/v8-prototype-define-bug.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var fails = require_fails();
    module.exports = DESCRIPTORS && fails(function() {
      return Object.defineProperty(function() {
      }, "prototype", {
        value: 42,
        writable: false
      }).prototype !== 42;
    });
  }
});

// ../node_modules/core-js/internals/an-object.js
var require_an_object = __commonJS({
  "../node_modules/core-js/internals/an-object.js"(exports, module) {
    "use strict";
    var isObject = require_is_object();
    var $String = String;
    var $TypeError = TypeError;
    module.exports = function(argument) {
      if (isObject(argument)) return argument;
      throw new $TypeError($String(argument) + " is not an object");
    };
  }
});

// ../node_modules/core-js/internals/object-define-property.js
var require_object_define_property = __commonJS({
  "../node_modules/core-js/internals/object-define-property.js"(exports) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
    var anObject = require_an_object();
    var toPropertyKey = require_to_property_key();
    var $TypeError = TypeError;
    var $defineProperty = Object.defineProperty;
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var ENUMERABLE = "enumerable";
    var CONFIGURABLE = "configurable";
    var WRITABLE = "writable";
    exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
      anObject(O);
      P = toPropertyKey(P);
      anObject(Attributes);
      if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
        var current = $getOwnPropertyDescriptor(O, P);
        if (current && current[WRITABLE]) {
          O[P] = Attributes.value;
          Attributes = {
            configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
            enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
            writable: false
          };
        }
      }
      return $defineProperty(O, P, Attributes);
    } : $defineProperty : function defineProperty(O, P, Attributes) {
      anObject(O);
      P = toPropertyKey(P);
      anObject(Attributes);
      if (IE8_DOM_DEFINE) try {
        return $defineProperty(O, P, Attributes);
      } catch (error) {
      }
      if ("get" in Attributes || "set" in Attributes) throw new $TypeError("Accessors not supported");
      if ("value" in Attributes) O[P] = Attributes.value;
      return O;
    };
  }
});

// ../node_modules/core-js/internals/create-non-enumerable-property.js
var require_create_non_enumerable_property = __commonJS({
  "../node_modules/core-js/internals/create-non-enumerable-property.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var definePropertyModule = require_object_define_property();
    var createPropertyDescriptor = require_create_property_descriptor();
    module.exports = DESCRIPTORS ? function(object, key, value) {
      return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
    } : function(object, key, value) {
      object[key] = value;
      return object;
    };
  }
});

// ../node_modules/core-js/internals/function-name.js
var require_function_name = __commonJS({
  "../node_modules/core-js/internals/function-name.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var hasOwn2 = require_has_own_property();
    var FunctionPrototype = Function.prototype;
    var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
    var EXISTS = hasOwn2(FunctionPrototype, "name");
    var PROPER = EXISTS && (function something() {
    }).name === "something";
    var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
    module.exports = {
      EXISTS,
      PROPER,
      CONFIGURABLE
    };
  }
});

// ../node_modules/core-js/internals/inspect-source.js
var require_inspect_source = __commonJS({
  "../node_modules/core-js/internals/inspect-source.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var isCallable = require_is_callable();
    var store = require_shared_store();
    var functionToString = uncurryThis(Function.toString);
    if (!isCallable(store.inspectSource)) {
      store.inspectSource = function(it) {
        return functionToString(it);
      };
    }
    module.exports = store.inspectSource;
  }
});

// ../node_modules/core-js/internals/weak-map-basic-detection.js
var require_weak_map_basic_detection = __commonJS({
  "../node_modules/core-js/internals/weak-map-basic-detection.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var isCallable = require_is_callable();
    var WeakMap2 = globalThis2.WeakMap;
    module.exports = isCallable(WeakMap2) && /native code/.test(String(WeakMap2));
  }
});

// ../node_modules/core-js/internals/shared-key.js
var require_shared_key = __commonJS({
  "../node_modules/core-js/internals/shared-key.js"(exports, module) {
    "use strict";
    var shared = require_shared();
    var uid = require_uid();
    var keys3 = shared("keys");
    module.exports = function(key) {
      return keys3[key] || (keys3[key] = uid(key));
    };
  }
});

// ../node_modules/core-js/internals/hidden-keys.js
var require_hidden_keys = __commonJS({
  "../node_modules/core-js/internals/hidden-keys.js"(exports, module) {
    "use strict";
    module.exports = {};
  }
});

// ../node_modules/core-js/internals/internal-state.js
var require_internal_state = __commonJS({
  "../node_modules/core-js/internals/internal-state.js"(exports, module) {
    "use strict";
    var NATIVE_WEAK_MAP = require_weak_map_basic_detection();
    var globalThis2 = require_global_this();
    var isObject = require_is_object();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var hasOwn2 = require_has_own_property();
    var shared = require_shared_store();
    var sharedKey = require_shared_key();
    var hiddenKeys = require_hidden_keys();
    var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
    var TypeError2 = globalThis2.TypeError;
    var WeakMap2 = globalThis2.WeakMap;
    var set;
    var get2;
    var has;
    var enforce = function(it) {
      return has(it) ? get2(it) : set(it, {});
    };
    var getterFor = function(TYPE) {
      return function(it) {
        var state;
        if (!isObject(it) || (state = get2(it)).type !== TYPE) {
          throw new TypeError2("Incompatible receiver, " + TYPE + " required");
        }
        return state;
      };
    };
    if (NATIVE_WEAK_MAP || shared.state) {
      store = shared.state || (shared.state = new WeakMap2());
      store.get = store.get;
      store.has = store.has;
      store.set = store.set;
      set = function(it, metadata) {
        if (store.has(it)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        store.set(it, metadata);
        return metadata;
      };
      get2 = function(it) {
        return store.get(it) || {};
      };
      has = function(it) {
        return store.has(it);
      };
    } else {
      STATE = sharedKey("state");
      hiddenKeys[STATE] = true;
      set = function(it, metadata) {
        if (hasOwn2(it, STATE)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        createNonEnumerableProperty(it, STATE, metadata);
        return metadata;
      };
      get2 = function(it) {
        return hasOwn2(it, STATE) ? it[STATE] : {};
      };
      has = function(it) {
        return hasOwn2(it, STATE);
      };
    }
    var store;
    var STATE;
    module.exports = {
      set,
      get: get2,
      has,
      enforce,
      getterFor
    };
  }
});

// ../node_modules/core-js/internals/make-built-in.js
var require_make_built_in = __commonJS({
  "../node_modules/core-js/internals/make-built-in.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var isCallable = require_is_callable();
    var hasOwn2 = require_has_own_property();
    var DESCRIPTORS = require_descriptors();
    var CONFIGURABLE_FUNCTION_NAME = require_function_name().CONFIGURABLE;
    var inspectSource = require_inspect_source();
    var InternalStateModule = require_internal_state();
    var enforceInternalState = InternalStateModule.enforce;
    var getInternalState = InternalStateModule.get;
    var $String = String;
    var defineProperty = Object.defineProperty;
    var stringSlice = uncurryThis("".slice);
    var replace3 = uncurryThis("".replace);
    var join2 = uncurryThis([].join);
    var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function() {
      return defineProperty(function() {
      }, "length", { value: 8 }).length !== 8;
    });
    var TEMPLATE = String(String).split("String");
    var makeBuiltIn = module.exports = function(value, name, options2) {
      if (stringSlice($String(name), 0, 7) === "Symbol(") {
        name = "[" + replace3($String(name), /^Symbol\(([^)]*)\).*$/, "$1") + "]";
      }
      if (options2 && options2.getter) name = "get " + name;
      if (options2 && options2.setter) name = "set " + name;
      if (!hasOwn2(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
        if (DESCRIPTORS) defineProperty(value, "name", { value: name, configurable: true });
        else value.name = name;
      }
      if (CONFIGURABLE_LENGTH && options2 && hasOwn2(options2, "arity") && value.length !== options2.arity) {
        defineProperty(value, "length", { value: options2.arity });
      }
      try {
        if (options2 && hasOwn2(options2, "constructor") && options2.constructor) {
          if (DESCRIPTORS) defineProperty(value, "prototype", { writable: false });
        } else if (value.prototype) value.prototype = void 0;
      } catch (error) {
      }
      var state = enforceInternalState(value);
      if (!hasOwn2(state, "source")) {
        state.source = join2(TEMPLATE, typeof name == "string" ? name : "");
      }
      return value;
    };
    Function.prototype.toString = makeBuiltIn(function toString2() {
      return isCallable(this) && getInternalState(this).source || inspectSource(this);
    }, "toString");
  }
});

// ../node_modules/core-js/internals/define-built-in.js
var require_define_built_in = __commonJS({
  "../node_modules/core-js/internals/define-built-in.js"(exports, module) {
    "use strict";
    var isCallable = require_is_callable();
    var definePropertyModule = require_object_define_property();
    var makeBuiltIn = require_make_built_in();
    var defineGlobalProperty = require_define_global_property();
    module.exports = function(O, key, value, options2) {
      if (!options2) options2 = {};
      var simple = options2.enumerable;
      var name = options2.name !== void 0 ? options2.name : key;
      if (isCallable(value)) makeBuiltIn(value, name, options2);
      if (options2.global) {
        if (simple) O[key] = value;
        else defineGlobalProperty(key, value);
      } else {
        try {
          if (!options2.unsafe) delete O[key];
          else if (O[key]) simple = true;
        } catch (error) {
        }
        if (simple) O[key] = value;
        else definePropertyModule.f(O, key, {
          value,
          enumerable: false,
          configurable: !options2.nonConfigurable,
          writable: !options2.nonWritable
        });
      }
      return O;
    };
  }
});

// ../node_modules/core-js/internals/math-trunc.js
var require_math_trunc = __commonJS({
  "../node_modules/core-js/internals/math-trunc.js"(exports, module) {
    "use strict";
    var ceil = Math.ceil;
    var floor2 = Math.floor;
    module.exports = Math.trunc || function trunc(x) {
      var n = +x;
      return (n > 0 ? floor2 : ceil)(n);
    };
  }
});

// ../node_modules/core-js/internals/to-integer-or-infinity.js
var require_to_integer_or_infinity = __commonJS({
  "../node_modules/core-js/internals/to-integer-or-infinity.js"(exports, module) {
    "use strict";
    var trunc = require_math_trunc();
    module.exports = function(argument) {
      var number = +argument;
      return number !== number || number === 0 ? 0 : trunc(number);
    };
  }
});

// ../node_modules/core-js/internals/to-absolute-index.js
var require_to_absolute_index = __commonJS({
  "../node_modules/core-js/internals/to-absolute-index.js"(exports, module) {
    "use strict";
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var max2 = Math.max;
    var min3 = Math.min;
    module.exports = function(index2, length) {
      var integer = toIntegerOrInfinity(index2);
      return integer < 0 ? max2(integer + length, 0) : min3(integer, length);
    };
  }
});

// ../node_modules/core-js/internals/to-length.js
var require_to_length = __commonJS({
  "../node_modules/core-js/internals/to-length.js"(exports, module) {
    "use strict";
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var min3 = Math.min;
    module.exports = function(argument) {
      var len = toIntegerOrInfinity(argument);
      return len > 0 ? min3(len, 9007199254740991) : 0;
    };
  }
});

// ../node_modules/core-js/internals/length-of-array-like.js
var require_length_of_array_like = __commonJS({
  "../node_modules/core-js/internals/length-of-array-like.js"(exports, module) {
    "use strict";
    var toLength = require_to_length();
    module.exports = function(obj) {
      return toLength(obj.length);
    };
  }
});

// ../node_modules/core-js/internals/array-includes.js
var require_array_includes = __commonJS({
  "../node_modules/core-js/internals/array-includes.js"(exports, module) {
    "use strict";
    var toIndexedObject = require_to_indexed_object();
    var toAbsoluteIndex = require_to_absolute_index();
    var lengthOfArrayLike = require_length_of_array_like();
    var createMethod = function(IS_INCLUDES) {
      return function($this, el, fromIndex) {
        var O = toIndexedObject($this);
        var length = lengthOfArrayLike(O);
        if (length === 0) return !IS_INCLUDES && -1;
        var index2 = toAbsoluteIndex(fromIndex, length);
        var value;
        if (IS_INCLUDES && el !== el) while (length > index2) {
          value = O[index2++];
          if (value !== value) return true;
        }
        else for (; length > index2; index2++) {
          if ((IS_INCLUDES || index2 in O) && O[index2] === el) return IS_INCLUDES || index2 || 0;
        }
        return !IS_INCLUDES && -1;
      };
    };
    module.exports = {
      // `Array.prototype.includes` method
      // https://tc39.es/ecma262/#sec-array.prototype.includes
      includes: createMethod(true),
      // `Array.prototype.indexOf` method
      // https://tc39.es/ecma262/#sec-array.prototype.indexof
      indexOf: createMethod(false)
    };
  }
});

// ../node_modules/core-js/internals/object-keys-internal.js
var require_object_keys_internal = __commonJS({
  "../node_modules/core-js/internals/object-keys-internal.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var hasOwn2 = require_has_own_property();
    var toIndexedObject = require_to_indexed_object();
    var indexOf = require_array_includes().indexOf;
    var hiddenKeys = require_hidden_keys();
    var push = uncurryThis([].push);
    module.exports = function(object, names) {
      var O = toIndexedObject(object);
      var i = 0;
      var result = [];
      var key;
      for (key in O) !hasOwn2(hiddenKeys, key) && hasOwn2(O, key) && push(result, key);
      while (names.length > i) if (hasOwn2(O, key = names[i++])) {
        ~indexOf(result, key) || push(result, key);
      }
      return result;
    };
  }
});

// ../node_modules/core-js/internals/enum-bug-keys.js
var require_enum_bug_keys = __commonJS({
  "../node_modules/core-js/internals/enum-bug-keys.js"(exports, module) {
    "use strict";
    module.exports = [
      "constructor",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "toLocaleString",
      "toString",
      "valueOf"
    ];
  }
});

// ../node_modules/core-js/internals/object-get-own-property-names.js
var require_object_get_own_property_names = __commonJS({
  "../node_modules/core-js/internals/object-get-own-property-names.js"(exports) {
    "use strict";
    var internalObjectKeys = require_object_keys_internal();
    var enumBugKeys = require_enum_bug_keys();
    var hiddenKeys = enumBugKeys.concat("length", "prototype");
    exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames2(O) {
      return internalObjectKeys(O, hiddenKeys);
    };
  }
});

// ../node_modules/core-js/internals/object-get-own-property-symbols.js
var require_object_get_own_property_symbols = __commonJS({
  "../node_modules/core-js/internals/object-get-own-property-symbols.js"(exports) {
    "use strict";
    exports.f = Object.getOwnPropertySymbols;
  }
});

// ../node_modules/core-js/internals/own-keys.js
var require_own_keys = __commonJS({
  "../node_modules/core-js/internals/own-keys.js"(exports, module) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    var uncurryThis = require_function_uncurry_this();
    var getOwnPropertyNamesModule = require_object_get_own_property_names();
    var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
    var anObject = require_an_object();
    var concat = uncurryThis([].concat);
    module.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys2(it) {
      var keys3 = getOwnPropertyNamesModule.f(anObject(it));
      var getOwnPropertySymbols2 = getOwnPropertySymbolsModule.f;
      return getOwnPropertySymbols2 ? concat(keys3, getOwnPropertySymbols2(it)) : keys3;
    };
  }
});

// ../node_modules/core-js/internals/copy-constructor-properties.js
var require_copy_constructor_properties = __commonJS({
  "../node_modules/core-js/internals/copy-constructor-properties.js"(exports, module) {
    "use strict";
    var hasOwn2 = require_has_own_property();
    var ownKeys2 = require_own_keys();
    var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
    var definePropertyModule = require_object_define_property();
    module.exports = function(target, source, exceptions) {
      var keys3 = ownKeys2(source);
      var defineProperty = definePropertyModule.f;
      var getOwnPropertyDescriptor2 = getOwnPropertyDescriptorModule.f;
      for (var i = 0; i < keys3.length; i++) {
        var key = keys3[i];
        if (!hasOwn2(target, key) && !(exceptions && hasOwn2(exceptions, key))) {
          defineProperty(target, key, getOwnPropertyDescriptor2(source, key));
        }
      }
    };
  }
});

// ../node_modules/core-js/internals/is-forced.js
var require_is_forced = __commonJS({
  "../node_modules/core-js/internals/is-forced.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var isCallable = require_is_callable();
    var replacement = /#|\.prototype\./;
    var isForced = function(feature, detection) {
      var value = data[normalize2(feature)];
      return value === POLYFILL ? true : value === NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
    };
    var normalize2 = isForced.normalize = function(string) {
      return String(string).replace(replacement, ".").toLowerCase();
    };
    var data = isForced.data = {};
    var NATIVE = isForced.NATIVE = "N";
    var POLYFILL = isForced.POLYFILL = "P";
    module.exports = isForced;
  }
});

// ../node_modules/core-js/internals/export.js
var require_export = __commonJS({
  "../node_modules/core-js/internals/export.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var getOwnPropertyDescriptor2 = require_object_get_own_property_descriptor().f;
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var defineBuiltIn = require_define_built_in();
    var defineGlobalProperty = require_define_global_property();
    var copyConstructorProperties = require_copy_constructor_properties();
    var isForced = require_is_forced();
    module.exports = function(options2, source) {
      var TARGET = options2.target;
      var GLOBAL = options2.global;
      var STATIC = options2.stat;
      var FORCED, target, key, targetProperty, sourceProperty, descriptor;
      if (GLOBAL) {
        target = globalThis2;
      } else if (STATIC) {
        target = globalThis2[TARGET] || defineGlobalProperty(TARGET, {});
      } else {
        target = globalThis2[TARGET] && globalThis2[TARGET].prototype;
      }
      if (target) for (key in source) {
        sourceProperty = source[key];
        if (options2.dontCallGetSet) {
          descriptor = getOwnPropertyDescriptor2(target, key);
          targetProperty = descriptor && descriptor.value;
        } else targetProperty = target[key];
        FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options2.forced);
        if (!FORCED && targetProperty !== void 0) {
          if (typeof sourceProperty == typeof targetProperty) continue;
          copyConstructorProperties(sourceProperty, targetProperty);
        }
        if (options2.sham || targetProperty && targetProperty.sham) {
          createNonEnumerableProperty(sourceProperty, "sham", true);
        }
        defineBuiltIn(target, key, sourceProperty, options2);
      }
    };
  }
});

// ../node_modules/core-js/internals/object-keys.js
var require_object_keys = __commonJS({
  "../node_modules/core-js/internals/object-keys.js"(exports, module) {
    "use strict";
    var internalObjectKeys = require_object_keys_internal();
    var enumBugKeys = require_enum_bug_keys();
    module.exports = Object.keys || function keys3(O) {
      return internalObjectKeys(O, enumBugKeys);
    };
  }
});

// ../node_modules/core-js/internals/object-define-properties.js
var require_object_define_properties = __commonJS({
  "../node_modules/core-js/internals/object-define-properties.js"(exports) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
    var definePropertyModule = require_object_define_property();
    var anObject = require_an_object();
    var toIndexedObject = require_to_indexed_object();
    var objectKeys = require_object_keys();
    exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
      anObject(O);
      var props = toIndexedObject(Properties);
      var keys3 = objectKeys(Properties);
      var length = keys3.length;
      var index2 = 0;
      var key;
      while (length > index2) definePropertyModule.f(O, key = keys3[index2++], props[key]);
      return O;
    };
  }
});

// ../node_modules/core-js/internals/html.js
var require_html = __commonJS({
  "../node_modules/core-js/internals/html.js"(exports, module) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    module.exports = getBuiltIn("document", "documentElement");
  }
});

// ../node_modules/core-js/internals/object-create.js
var require_object_create = __commonJS({
  "../node_modules/core-js/internals/object-create.js"(exports, module) {
    "use strict";
    var anObject = require_an_object();
    var definePropertiesModule = require_object_define_properties();
    var enumBugKeys = require_enum_bug_keys();
    var hiddenKeys = require_hidden_keys();
    var html = require_html();
    var documentCreateElement = require_document_create_element();
    var sharedKey = require_shared_key();
    var GT = ">";
    var LT = "<";
    var PROTOTYPE = "prototype";
    var SCRIPT = "script";
    var IE_PROTO = sharedKey("IE_PROTO");
    var EmptyConstructor = function() {
    };
    var scriptTag = function(content) {
      return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
    };
    var NullProtoObjectViaActiveX = function(activeXDocument2) {
      activeXDocument2.write(scriptTag(""));
      activeXDocument2.close();
      var temp = activeXDocument2.parentWindow.Object;
      activeXDocument2 = null;
      return temp;
    };
    var NullProtoObjectViaIFrame = function() {
      var iframe = documentCreateElement("iframe");
      var JS = "java" + SCRIPT + ":";
      var iframeDocument;
      iframe.style.display = "none";
      html.appendChild(iframe);
      iframe.src = String(JS);
      iframeDocument = iframe.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(scriptTag("document.F=Object"));
      iframeDocument.close();
      return iframeDocument.F;
    };
    var activeXDocument;
    var NullProtoObject = function() {
      try {
        activeXDocument = new ActiveXObject("htmlfile");
      } catch (error) {
      }
      NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
      var length = enumBugKeys.length;
      while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
      return NullProtoObject();
    };
    hiddenKeys[IE_PROTO] = true;
    module.exports = Object.create || function create(O, Properties) {
      var result;
      if (O !== null) {
        EmptyConstructor[PROTOTYPE] = anObject(O);
        result = new EmptyConstructor();
        EmptyConstructor[PROTOTYPE] = null;
        result[IE_PROTO] = O;
      } else result = NullProtoObject();
      return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
    };
  }
});

// ../node_modules/core-js/internals/add-to-unscopables.js
var require_add_to_unscopables = __commonJS({
  "../node_modules/core-js/internals/add-to-unscopables.js"(exports, module) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var create = require_object_create();
    var defineProperty = require_object_define_property().f;
    var UNSCOPABLES = wellKnownSymbol("unscopables");
    var ArrayPrototype = Array.prototype;
    if (ArrayPrototype[UNSCOPABLES] === void 0) {
      defineProperty(ArrayPrototype, UNSCOPABLES, {
        configurable: true,
        value: create(null)
      });
    }
    module.exports = function(key) {
      ArrayPrototype[UNSCOPABLES][key] = true;
    };
  }
});

// ../node_modules/core-js/modules/es.array.at.js
var require_es_array_at = __commonJS({
  "../node_modules/core-js/modules/es.array.at.js"() {
    "use strict";
    var $ = require_export();
    var toObject = require_to_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var addToUnscopables = require_add_to_unscopables();
    $({ target: "Array", proto: true }, {
      at: function at2(index2) {
        var O = toObject(this);
        var len = lengthOfArrayLike(O);
        var relativeIndex = toIntegerOrInfinity(index2);
        var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
        return k < 0 || k >= len ? void 0 : O[k];
      }
    });
    addToUnscopables("at");
  }
});

// ../node_modules/core-js/internals/entry-unbind.js
var require_entry_unbind = __commonJS({
  "../node_modules/core-js/internals/entry-unbind.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var uncurryThis = require_function_uncurry_this();
    module.exports = function(CONSTRUCTOR, METHOD) {
      return uncurryThis(globalThis2[CONSTRUCTOR].prototype[METHOD]);
    };
  }
});

// ../node_modules/core-js/es/array/at.js
var require_at = __commonJS({
  "../node_modules/core-js/es/array/at.js"(exports, module) {
    "use strict";
    require_es_array_at();
    var entryUnbind = require_entry_unbind();
    module.exports = entryUnbind("Array", "at");
  }
});

// ../node_modules/core-js/stable/array/at.js
var require_at2 = __commonJS({
  "../node_modules/core-js/stable/array/at.js"(exports, module) {
    "use strict";
    var parent = require_at();
    module.exports = parent;
  }
});

// ../node_modules/core-js/internals/is-array.js
var require_is_array = __commonJS({
  "../node_modules/core-js/internals/is-array.js"(exports, module) {
    "use strict";
    var classof = require_classof_raw();
    module.exports = Array.isArray || function isArray(argument) {
      return classof(argument) === "Array";
    };
  }
});

// ../node_modules/core-js/internals/does-not-exceed-safe-integer.js
var require_does_not_exceed_safe_integer = __commonJS({
  "../node_modules/core-js/internals/does-not-exceed-safe-integer.js"(exports, module) {
    "use strict";
    var $TypeError = TypeError;
    var MAX_SAFE_INTEGER = 9007199254740991;
    module.exports = function(it) {
      if (it > MAX_SAFE_INTEGER) throw $TypeError("Maximum allowed index exceeded");
      return it;
    };
  }
});

// ../node_modules/core-js/internals/function-uncurry-this-clause.js
var require_function_uncurry_this_clause = __commonJS({
  "../node_modules/core-js/internals/function-uncurry-this-clause.js"(exports, module) {
    "use strict";
    var classofRaw = require_classof_raw();
    var uncurryThis = require_function_uncurry_this();
    module.exports = function(fn) {
      if (classofRaw(fn) === "Function") return uncurryThis(fn);
    };
  }
});

// ../node_modules/core-js/internals/function-bind-context.js
var require_function_bind_context = __commonJS({
  "../node_modules/core-js/internals/function-bind-context.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this_clause();
    var aCallable = require_a_callable();
    var NATIVE_BIND = require_function_bind_native();
    var bind3 = uncurryThis(uncurryThis.bind);
    module.exports = function(fn, that) {
      aCallable(fn);
      return that === void 0 ? fn : NATIVE_BIND ? bind3(fn, that) : function() {
        return fn.apply(that, arguments);
      };
    };
  }
});

// ../node_modules/core-js/internals/create-property.js
var require_create_property = __commonJS({
  "../node_modules/core-js/internals/create-property.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var definePropertyModule = require_object_define_property();
    var createPropertyDescriptor = require_create_property_descriptor();
    module.exports = function(object, key, value) {
      if (DESCRIPTORS) definePropertyModule.f(object, key, createPropertyDescriptor(0, value));
      else object[key] = value;
    };
  }
});

// ../node_modules/core-js/internals/flatten-into-array.js
var require_flatten_into_array = __commonJS({
  "../node_modules/core-js/internals/flatten-into-array.js"(exports, module) {
    "use strict";
    var isArray = require_is_array();
    var lengthOfArrayLike = require_length_of_array_like();
    var doesNotExceedSafeInteger = require_does_not_exceed_safe_integer();
    var bind3 = require_function_bind_context();
    var createProperty = require_create_property();
    var flattenIntoArray = function(target, original, source, sourceLen, start, depth, mapper, thisArg) {
      var targetIndex = start;
      var sourceIndex = 0;
      var mapFn = mapper ? bind3(mapper, thisArg) : false;
      var element, elementLen;
      while (sourceIndex < sourceLen) {
        if (sourceIndex in source) {
          element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
          if (depth > 0 && isArray(element)) {
            elementLen = lengthOfArrayLike(element);
            targetIndex = flattenIntoArray(target, original, element, elementLen, targetIndex, depth - 1) - 1;
          } else {
            doesNotExceedSafeInteger(targetIndex + 1);
            createProperty(target, targetIndex, element);
          }
          targetIndex++;
        }
        sourceIndex++;
      }
      return targetIndex;
    };
    module.exports = flattenIntoArray;
  }
});

// ../node_modules/core-js/internals/to-string-tag-support.js
var require_to_string_tag_support = __commonJS({
  "../node_modules/core-js/internals/to-string-tag-support.js"(exports, module) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var test = {};
    test[TO_STRING_TAG] = "z";
    module.exports = String(test) === "[object z]";
  }
});

// ../node_modules/core-js/internals/classof.js
var require_classof = __commonJS({
  "../node_modules/core-js/internals/classof.js"(exports, module) {
    "use strict";
    var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
    var isCallable = require_is_callable();
    var classofRaw = require_classof_raw();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var $Object = Object;
    var CORRECT_ARGUMENTS = classofRaw(/* @__PURE__ */ (function() {
      return arguments;
    })()) === "Arguments";
    var tryGet = function(it, key) {
      try {
        return it[key];
      } catch (error) {
      }
    };
    module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
      var O, tag, result;
      return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) === "Object" && isCallable(O.callee) ? "Arguments" : result;
    };
  }
});

// ../node_modules/core-js/internals/is-constructor.js
var require_is_constructor = __commonJS({
  "../node_modules/core-js/internals/is-constructor.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var isCallable = require_is_callable();
    var classof = require_classof();
    var getBuiltIn = require_get_built_in();
    var inspectSource = require_inspect_source();
    var noop6 = function() {
    };
    var construct = getBuiltIn("Reflect", "construct");
    var constructorRegExp = /^\s*(?:class|function)\b/;
    var exec = uncurryThis(constructorRegExp.exec);
    var INCORRECT_TO_STRING = !constructorRegExp.test(noop6);
    var isConstructorModern = function isConstructor(argument) {
      if (!isCallable(argument)) return false;
      try {
        construct(noop6, [], argument);
        return true;
      } catch (error) {
        return false;
      }
    };
    var isConstructorLegacy = function isConstructor(argument) {
      if (!isCallable(argument)) return false;
      switch (classof(argument)) {
        case "AsyncFunction":
        case "GeneratorFunction":
        case "AsyncGeneratorFunction":
          return false;
      }
      try {
        return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
      } catch (error) {
        return true;
      }
    };
    isConstructorLegacy.sham = true;
    module.exports = !construct || fails(function() {
      var called;
      return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
        called = true;
      }) || called;
    }) ? isConstructorLegacy : isConstructorModern;
  }
});

// ../node_modules/core-js/internals/array-species-constructor.js
var require_array_species_constructor = __commonJS({
  "../node_modules/core-js/internals/array-species-constructor.js"(exports, module) {
    "use strict";
    var isArray = require_is_array();
    var isConstructor = require_is_constructor();
    var isObject = require_is_object();
    var wellKnownSymbol = require_well_known_symbol();
    var SPECIES = wellKnownSymbol("species");
    var $Array = Array;
    module.exports = function(originalArray) {
      var C;
      if (isArray(originalArray)) {
        C = originalArray.constructor;
        if (isConstructor(C) && (C === $Array || isArray(C.prototype))) C = void 0;
        else if (isObject(C)) {
          C = C[SPECIES];
          if (C === null) C = void 0;
        }
      }
      return C === void 0 ? $Array : C;
    };
  }
});

// ../node_modules/core-js/internals/array-species-create.js
var require_array_species_create = __commonJS({
  "../node_modules/core-js/internals/array-species-create.js"(exports, module) {
    "use strict";
    var arraySpeciesConstructor = require_array_species_constructor();
    module.exports = function(originalArray, length) {
      return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
    };
  }
});

// ../node_modules/core-js/modules/es.array.flat-map.js
var require_es_array_flat_map = __commonJS({
  "../node_modules/core-js/modules/es.array.flat-map.js"() {
    "use strict";
    var $ = require_export();
    var flattenIntoArray = require_flatten_into_array();
    var aCallable = require_a_callable();
    var toObject = require_to_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var arraySpeciesCreate = require_array_species_create();
    $({ target: "Array", proto: true }, {
      flatMap: function flatMap(callbackfn) {
        var O = toObject(this);
        var sourceLen = lengthOfArrayLike(O);
        var A;
        aCallable(callbackfn);
        A = arraySpeciesCreate(O, 0);
        flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        return A;
      }
    });
  }
});

// ../node_modules/core-js/modules/es.array.unscopables.flat-map.js
var require_es_array_unscopables_flat_map = __commonJS({
  "../node_modules/core-js/modules/es.array.unscopables.flat-map.js"() {
    "use strict";
    var addToUnscopables = require_add_to_unscopables();
    addToUnscopables("flatMap");
  }
});

// ../node_modules/core-js/es/array/flat-map.js
var require_flat_map = __commonJS({
  "../node_modules/core-js/es/array/flat-map.js"(exports, module) {
    "use strict";
    require_es_array_flat_map();
    require_es_array_unscopables_flat_map();
    var entryUnbind = require_entry_unbind();
    module.exports = entryUnbind("Array", "flatMap");
  }
});

// ../node_modules/core-js/stable/array/flat-map.js
var require_flat_map2 = __commonJS({
  "../node_modules/core-js/stable/array/flat-map.js"(exports, module) {
    "use strict";
    var parent = require_flat_map();
    module.exports = parent;
  }
});

// ../node_modules/core-js/modules/es.array.flat.js
var require_es_array_flat = __commonJS({
  "../node_modules/core-js/modules/es.array.flat.js"() {
    "use strict";
    var $ = require_export();
    var flattenIntoArray = require_flatten_into_array();
    var toObject = require_to_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var arraySpeciesCreate = require_array_species_create();
    $({ target: "Array", proto: true }, {
      flat: function flat() {
        var depthArg = arguments.length ? arguments[0] : void 0;
        var O = toObject(this);
        var sourceLen = lengthOfArrayLike(O);
        var A = arraySpeciesCreate(O, 0);
        flattenIntoArray(A, O, O, sourceLen, 0, depthArg === void 0 ? 1 : toIntegerOrInfinity(depthArg));
        return A;
      }
    });
  }
});

// ../node_modules/core-js/modules/es.array.unscopables.flat.js
var require_es_array_unscopables_flat = __commonJS({
  "../node_modules/core-js/modules/es.array.unscopables.flat.js"() {
    "use strict";
    var addToUnscopables = require_add_to_unscopables();
    addToUnscopables("flat");
  }
});

// ../node_modules/core-js/es/array/flat.js
var require_flat = __commonJS({
  "../node_modules/core-js/es/array/flat.js"(exports, module) {
    "use strict";
    require_es_array_flat();
    require_es_array_unscopables_flat();
    var entryUnbind = require_entry_unbind();
    module.exports = entryUnbind("Array", "flat");
  }
});

// ../node_modules/core-js/stable/array/flat.js
var require_flat2 = __commonJS({
  "../node_modules/core-js/stable/array/flat.js"(exports, module) {
    "use strict";
    var parent = require_flat();
    module.exports = parent;
  }
});

// ../node_modules/core-js/internals/to-string.js
var require_to_string = __commonJS({
  "../node_modules/core-js/internals/to-string.js"(exports, module) {
    "use strict";
    var classof = require_classof();
    var $String = String;
    module.exports = function(argument) {
      if (classof(argument) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
      return $String(argument);
    };
  }
});

// ../node_modules/core-js/modules/es.string.at-alternative.js
var require_es_string_at_alternative = __commonJS({
  "../node_modules/core-js/modules/es.string.at-alternative.js"() {
    "use strict";
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var requireObjectCoercible = require_require_object_coercible();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var toString2 = require_to_string();
    var fails = require_fails();
    var charAt = uncurryThis("".charAt);
    var FORCED = fails(function() {
      return "𠮷".at(-2) !== "\uD842";
    });
    $({ target: "String", proto: true, forced: FORCED }, {
      at: function at2(index2) {
        var S = toString2(requireObjectCoercible(this));
        var len = S.length;
        var relativeIndex = toIntegerOrInfinity(index2);
        var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
        return k < 0 || k >= len ? void 0 : charAt(S, k);
      }
    });
  }
});

// ../node_modules/core-js/es/string/at.js
var require_at3 = __commonJS({
  "../node_modules/core-js/es/string/at.js"(exports, module) {
    "use strict";
    require_es_string_at_alternative();
    var entryUnbind = require_entry_unbind();
    module.exports = entryUnbind("String", "at");
  }
});

// ../node_modules/core-js/stable/string/at.js
var require_at4 = __commonJS({
  "../node_modules/core-js/stable/string/at.js"(exports, module) {
    "use strict";
    var parent = require_at3();
    module.exports = parent;
  }
});

// ../node_modules/core-js/internals/regexp-flags.js
var require_regexp_flags = __commonJS({
  "../node_modules/core-js/internals/regexp-flags.js"(exports, module) {
    "use strict";
    var anObject = require_an_object();
    module.exports = function() {
      var that = anObject(this);
      var result = "";
      if (that.hasIndices) result += "d";
      if (that.global) result += "g";
      if (that.ignoreCase) result += "i";
      if (that.multiline) result += "m";
      if (that.dotAll) result += "s";
      if (that.unicode) result += "u";
      if (that.unicodeSets) result += "v";
      if (that.sticky) result += "y";
      return result;
    };
  }
});

// ../node_modules/core-js/internals/regexp-sticky-helpers.js
var require_regexp_sticky_helpers = __commonJS({
  "../node_modules/core-js/internals/regexp-sticky-helpers.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var globalThis2 = require_global_this();
    var $RegExp = globalThis2.RegExp;
    var UNSUPPORTED_Y = fails(function() {
      var re = $RegExp("a", "y");
      re.lastIndex = 2;
      return re.exec("abcd") !== null;
    });
    var MISSED_STICKY = UNSUPPORTED_Y || fails(function() {
      return !$RegExp("a", "y").sticky;
    });
    var BROKEN_CARET = UNSUPPORTED_Y || fails(function() {
      var re = $RegExp("^r", "gy");
      re.lastIndex = 2;
      return re.exec("str") !== null;
    });
    module.exports = {
      BROKEN_CARET,
      MISSED_STICKY,
      UNSUPPORTED_Y
    };
  }
});

// ../node_modules/core-js/internals/regexp-unsupported-dot-all.js
var require_regexp_unsupported_dot_all = __commonJS({
  "../node_modules/core-js/internals/regexp-unsupported-dot-all.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var globalThis2 = require_global_this();
    var $RegExp = globalThis2.RegExp;
    module.exports = fails(function() {
      var re = $RegExp(".", "s");
      return !(re.dotAll && re.test("\n") && re.flags === "s");
    });
  }
});

// ../node_modules/core-js/internals/regexp-unsupported-ncg.js
var require_regexp_unsupported_ncg = __commonJS({
  "../node_modules/core-js/internals/regexp-unsupported-ncg.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var globalThis2 = require_global_this();
    var $RegExp = globalThis2.RegExp;
    module.exports = fails(function() {
      var re = $RegExp("(?<a>b)", "g");
      return re.exec("b").groups.a !== "b" || "b".replace(re, "$<a>c") !== "bc";
    });
  }
});

// ../node_modules/core-js/internals/regexp-exec.js
var require_regexp_exec = __commonJS({
  "../node_modules/core-js/internals/regexp-exec.js"(exports, module) {
    "use strict";
    var call2 = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var toString2 = require_to_string();
    var regexpFlags = require_regexp_flags();
    var stickyHelpers = require_regexp_sticky_helpers();
    var shared = require_shared();
    var create = require_object_create();
    var getInternalState = require_internal_state().get;
    var UNSUPPORTED_DOT_ALL = require_regexp_unsupported_dot_all();
    var UNSUPPORTED_NCG = require_regexp_unsupported_ncg();
    var nativeReplace = shared("native-string-replace", String.prototype.replace);
    var nativeExec = RegExp.prototype.exec;
    var patchedExec = nativeExec;
    var charAt = uncurryThis("".charAt);
    var indexOf = uncurryThis("".indexOf);
    var replace3 = uncurryThis("".replace);
    var stringSlice = uncurryThis("".slice);
    var UPDATES_LAST_INDEX_WRONG = (function() {
      var re1 = /a/;
      var re2 = /b*/g;
      call2(nativeExec, re1, "a");
      call2(nativeExec, re2, "a");
      return re1.lastIndex !== 0 || re2.lastIndex !== 0;
    })();
    var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;
    var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
    var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;
    if (PATCH) {
      patchedExec = function exec(string) {
        var re = this;
        var state = getInternalState(re);
        var str = toString2(string);
        var raw = state.raw;
        var result, reCopy, lastIndex, match, i, object, group;
        if (raw) {
          raw.lastIndex = re.lastIndex;
          result = call2(patchedExec, raw, str);
          re.lastIndex = raw.lastIndex;
          return result;
        }
        var groups = state.groups;
        var sticky = UNSUPPORTED_Y && re.sticky;
        var flags = call2(regexpFlags, re);
        var source = re.source;
        var charsAdded = 0;
        var strCopy = str;
        if (sticky) {
          flags = replace3(flags, "y", "");
          if (indexOf(flags, "g") === -1) {
            flags += "g";
          }
          strCopy = stringSlice(str, re.lastIndex);
          if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt(str, re.lastIndex - 1) !== "\n")) {
            source = "(?: " + source + ")";
            strCopy = " " + strCopy;
            charsAdded++;
          }
          reCopy = new RegExp("^(?:" + source + ")", flags);
        }
        if (NPCG_INCLUDED) {
          reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
        }
        if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;
        match = call2(nativeExec, sticky ? reCopy : re, strCopy);
        if (sticky) {
          if (match) {
            match.input = stringSlice(match.input, charsAdded);
            match[0] = stringSlice(match[0], charsAdded);
            match.index = re.lastIndex;
            re.lastIndex += match[0].length;
          } else re.lastIndex = 0;
        } else if (UPDATES_LAST_INDEX_WRONG && match) {
          re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
        }
        if (NPCG_INCLUDED && match && match.length > 1) {
          call2(nativeReplace, match[0], reCopy, function() {
            for (i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === void 0) match[i] = void 0;
            }
          });
        }
        if (match && groups) {
          match.groups = object = create(null);
          for (i = 0; i < groups.length; i++) {
            group = groups[i];
            object[group[0]] = match[group[1]];
          }
        }
        return match;
      };
    }
    module.exports = patchedExec;
  }
});

// ../node_modules/core-js/modules/es.regexp.exec.js
var require_es_regexp_exec = __commonJS({
  "../node_modules/core-js/modules/es.regexp.exec.js"() {
    "use strict";
    var $ = require_export();
    var exec = require_regexp_exec();
    $({ target: "RegExp", proto: true, forced: /./.exec !== exec }, {
      exec
    });
  }
});

// ../node_modules/core-js/internals/function-apply.js
var require_function_apply = __commonJS({
  "../node_modules/core-js/internals/function-apply.js"(exports, module) {
    "use strict";
    var NATIVE_BIND = require_function_bind_native();
    var FunctionPrototype = Function.prototype;
    var apply2 = FunctionPrototype.apply;
    var call2 = FunctionPrototype.call;
    module.exports = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call2.bind(apply2) : function() {
      return call2.apply(apply2, arguments);
    });
  }
});

// ../node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js
var require_fix_regexp_well_known_symbol_logic = __commonJS({
  "../node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js"(exports, module) {
    "use strict";
    require_es_regexp_exec();
    var call2 = require_function_call();
    var defineBuiltIn = require_define_built_in();
    var regexpExec = require_regexp_exec();
    var fails = require_fails();
    var wellKnownSymbol = require_well_known_symbol();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var SPECIES = wellKnownSymbol("species");
    var RegExpPrototype = RegExp.prototype;
    module.exports = function(KEY, exec, FORCED, SHAM) {
      var SYMBOL = wellKnownSymbol(KEY);
      var DELEGATES_TO_SYMBOL = !fails(function() {
        var O = {};
        O[SYMBOL] = function() {
          return 7;
        };
        return ""[KEY](O) !== 7;
      });
      var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function() {
        var execCalled = false;
        var re = /a/;
        if (KEY === "split") {
          var constructor = {};
          constructor[SPECIES] = function() {
            return re;
          };
          re = { constructor, flags: "" };
          re[SYMBOL] = /./[SYMBOL];
        }
        re.exec = function() {
          execCalled = true;
          return null;
        };
        re[SYMBOL]("");
        return !execCalled;
      });
      if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED) {
        var nativeRegExpMethod = /./[SYMBOL];
        var methods = exec(SYMBOL, ""[KEY], function(nativeMethod, regexp2, str, arg2, forceStringMethod) {
          var $exec = regexp2.exec;
          if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
            if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
              return { done: true, value: call2(nativeRegExpMethod, regexp2, str, arg2) };
            }
            return { done: true, value: call2(nativeMethod, str, regexp2, arg2) };
          }
          return { done: false };
        });
        defineBuiltIn(String.prototype, KEY, methods[0]);
        defineBuiltIn(RegExpPrototype, SYMBOL, methods[1]);
      }
      if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], "sham", true);
    };
  }
});

// ../node_modules/core-js/internals/string-multibyte.js
var require_string_multibyte = __commonJS({
  "../node_modules/core-js/internals/string-multibyte.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var toString2 = require_to_string();
    var requireObjectCoercible = require_require_object_coercible();
    var charAt = uncurryThis("".charAt);
    var charCodeAt = uncurryThis("".charCodeAt);
    var stringSlice = uncurryThis("".slice);
    var createMethod = function(CONVERT_TO_STRING) {
      return function($this, pos) {
        var S = toString2(requireObjectCoercible($this));
        var position = toIntegerOrInfinity(pos);
        var size4 = S.length;
        var first2, second;
        if (position < 0 || position >= size4) return CONVERT_TO_STRING ? "" : void 0;
        first2 = charCodeAt(S, position);
        return first2 < 55296 || first2 > 56319 || position + 1 === size4 || (second = charCodeAt(S, position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt(S, position) : first2 : CONVERT_TO_STRING ? stringSlice(S, position, position + 2) : (first2 - 55296 << 10) + (second - 56320) + 65536;
      };
    };
    module.exports = {
      // `String.prototype.codePointAt` method
      // https://tc39.es/ecma262/#sec-string.prototype.codepointat
      codeAt: createMethod(false),
      // `String.prototype.at` method
      // https://github.com/mathiasbynens/String.prototype.at
      charAt: createMethod(true)
    };
  }
});

// ../node_modules/core-js/internals/advance-string-index.js
var require_advance_string_index = __commonJS({
  "../node_modules/core-js/internals/advance-string-index.js"(exports, module) {
    "use strict";
    var charAt = require_string_multibyte().charAt;
    module.exports = function(S, index2, unicode) {
      return index2 + (unicode ? charAt(S, index2).length : 1);
    };
  }
});

// ../node_modules/core-js/internals/get-substitution.js
var require_get_substitution = __commonJS({
  "../node_modules/core-js/internals/get-substitution.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toObject = require_to_object();
    var floor2 = Math.floor;
    var charAt = uncurryThis("".charAt);
    var replace3 = uncurryThis("".replace);
    var stringSlice = uncurryThis("".slice);
    var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
    var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
    module.exports = function(matched, str, position, captures, namedCaptures, replacement) {
      var tailPos = position + matched.length;
      var m = captures.length;
      var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
      if (namedCaptures !== void 0) {
        namedCaptures = toObject(namedCaptures);
        symbols = SUBSTITUTION_SYMBOLS;
      }
      return replace3(replacement, symbols, function(match, ch) {
        var capture;
        switch (charAt(ch, 0)) {
          case "$":
            return "$";
          case "&":
            return matched;
          case "`":
            return stringSlice(str, 0, position);
          case "'":
            return stringSlice(str, tailPos);
          case "<":
            capture = namedCaptures[stringSlice(ch, 1, -1)];
            break;
          default:
            var n = +ch;
            if (n === 0) return match;
            if (n > m) {
              var f = floor2(n / 10);
              if (f === 0) return match;
              if (f <= m) return captures[f - 1] === void 0 ? charAt(ch, 1) : captures[f - 1] + charAt(ch, 1);
              return match;
            }
            capture = captures[n - 1];
        }
        return capture === void 0 ? "" : capture;
      });
    };
  }
});

// ../node_modules/core-js/internals/regexp-flags-detection.js
var require_regexp_flags_detection = __commonJS({
  "../node_modules/core-js/internals/regexp-flags-detection.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var fails = require_fails();
    var RegExp2 = globalThis2.RegExp;
    var FLAGS_GETTER_IS_CORRECT = !fails(function() {
      var INDICES_SUPPORT = true;
      try {
        RegExp2(".", "d");
      } catch (error) {
        INDICES_SUPPORT = false;
      }
      var O = {};
      var calls = "";
      var expected = INDICES_SUPPORT ? "dgimsy" : "gimsy";
      var addGetter = function(key2, chr) {
        Object.defineProperty(O, key2, { get: function() {
          calls += chr;
          return true;
        } });
      };
      var pairs = {
        dotAll: "s",
        global: "g",
        ignoreCase: "i",
        multiline: "m",
        sticky: "y"
      };
      if (INDICES_SUPPORT) pairs.hasIndices = "d";
      for (var key in pairs) addGetter(key, pairs[key]);
      var result = Object.getOwnPropertyDescriptor(RegExp2.prototype, "flags").get.call(O);
      return result !== expected || calls !== expected;
    });
    module.exports = { correct: FLAGS_GETTER_IS_CORRECT };
  }
});

// ../node_modules/core-js/internals/regexp-get-flags.js
var require_regexp_get_flags = __commonJS({
  "../node_modules/core-js/internals/regexp-get-flags.js"(exports, module) {
    "use strict";
    var call2 = require_function_call();
    var hasOwn2 = require_has_own_property();
    var isPrototypeOf = require_object_is_prototype_of();
    var regExpFlagsDetection = require_regexp_flags_detection();
    var regExpFlagsGetterImplementation = require_regexp_flags();
    var RegExpPrototype = RegExp.prototype;
    module.exports = regExpFlagsDetection.correct ? function(it) {
      return it.flags;
    } : function(it) {
      return !regExpFlagsDetection.correct && isPrototypeOf(RegExpPrototype, it) && !hasOwn2(it, "flags") ? call2(regExpFlagsGetterImplementation, it) : it.flags;
    };
  }
});

// ../node_modules/core-js/internals/regexp-exec-abstract.js
var require_regexp_exec_abstract = __commonJS({
  "../node_modules/core-js/internals/regexp-exec-abstract.js"(exports, module) {
    "use strict";
    var call2 = require_function_call();
    var anObject = require_an_object();
    var isCallable = require_is_callable();
    var classof = require_classof_raw();
    var regexpExec = require_regexp_exec();
    var $TypeError = TypeError;
    module.exports = function(R, S) {
      var exec = R.exec;
      if (isCallable(exec)) {
        var result = call2(exec, R, S);
        if (result !== null) anObject(result);
        return result;
      }
      if (classof(R) === "RegExp") return call2(regexpExec, R, S);
      throw new $TypeError("RegExp#exec called on incompatible receiver");
    };
  }
});

// ../node_modules/core-js/modules/es.string.replace.js
var require_es_string_replace = __commonJS({
  "../node_modules/core-js/modules/es.string.replace.js"() {
    "use strict";
    var apply2 = require_function_apply();
    var call2 = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
    var fails = require_fails();
    var anObject = require_an_object();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var toLength = require_to_length();
    var toString2 = require_to_string();
    var requireObjectCoercible = require_require_object_coercible();
    var advanceStringIndex = require_advance_string_index();
    var getMethod2 = require_get_method();
    var getSubstitution = require_get_substitution();
    var getRegExpFlags = require_regexp_get_flags();
    var regExpExec = require_regexp_exec_abstract();
    var wellKnownSymbol = require_well_known_symbol();
    var REPLACE = wellKnownSymbol("replace");
    var max2 = Math.max;
    var min3 = Math.min;
    var concat = uncurryThis([].concat);
    var push = uncurryThis([].push);
    var stringIndexOf = uncurryThis("".indexOf);
    var stringSlice = uncurryThis("".slice);
    var maybeToString = function(it) {
      return it === void 0 ? it : String(it);
    };
    var REPLACE_KEEPS_$0 = (function() {
      return "a".replace(/./, "$0") === "$0";
    })();
    var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function() {
      if (/./[REPLACE]) {
        return /./[REPLACE]("a", "$0") === "";
      }
      return false;
    })();
    var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
      var re = /./;
      re.exec = function() {
        var result = [];
        result.groups = { a: "7" };
        return result;
      };
      return "".replace(re, "$<a>") !== "7";
    });
    fixRegExpWellKnownSymbolLogic("replace", function(_, nativeReplace, maybeCallNative) {
      var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
      return [
        // `String.prototype.replace` method
        // https://tc39.es/ecma262/#sec-string.prototype.replace
        function replace3(searchValue, replaceValue) {
          var O = requireObjectCoercible(this);
          var replacer = isObject(searchValue) ? getMethod2(searchValue, REPLACE) : void 0;
          return replacer ? call2(replacer, searchValue, O, replaceValue) : call2(nativeReplace, toString2(O), searchValue, replaceValue);
        },
        // `RegExp.prototype[@@replace]` method
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
        function(string, replaceValue) {
          var rx = anObject(this);
          var S = toString2(string);
          if (typeof replaceValue == "string" && stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf(replaceValue, "$<") === -1) {
            var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
            if (res.done) return res.value;
          }
          var functionalReplace = isCallable(replaceValue);
          if (!functionalReplace) replaceValue = toString2(replaceValue);
          var flags = toString2(getRegExpFlags(rx));
          var global2 = stringIndexOf(flags, "g") !== -1;
          var fullUnicode;
          if (global2) {
            fullUnicode = stringIndexOf(flags, "u") !== -1;
            rx.lastIndex = 0;
          }
          var results = [];
          var result;
          while (true) {
            result = regExpExec(rx, S);
            if (result === null) break;
            push(results, result);
            if (!global2) break;
            var matchStr = toString2(result[0]);
            if (matchStr === "") rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
          }
          var accumulatedResult = "";
          var nextSourcePosition = 0;
          for (var i = 0; i < results.length; i++) {
            result = results[i];
            var matched = toString2(result[0]);
            var position = max2(min3(toIntegerOrInfinity(result.index), S.length), 0);
            var captures = [];
            var replacement;
            for (var j = 1; j < result.length; j++) push(captures, maybeToString(result[j]));
            var namedCaptures = result.groups;
            if (functionalReplace) {
              var replacerArgs = concat([matched], captures, position, S);
              if (namedCaptures !== void 0) push(replacerArgs, namedCaptures);
              replacement = toString2(apply2(replaceValue, void 0, replacerArgs));
            } else {
              replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
            }
            if (position >= nextSourcePosition) {
              accumulatedResult += stringSlice(S, nextSourcePosition, position) + replacement;
              nextSourcePosition = position + matched.length;
            }
          }
          return accumulatedResult + stringSlice(S, nextSourcePosition);
        }
      ];
    }, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);
  }
});

// ../node_modules/core-js/internals/is-regexp.js
var require_is_regexp = __commonJS({
  "../node_modules/core-js/internals/is-regexp.js"(exports, module) {
    "use strict";
    var isObject = require_is_object();
    var classof = require_classof_raw();
    var wellKnownSymbol = require_well_known_symbol();
    var MATCH = wellKnownSymbol("match");
    module.exports = function(it) {
      var isRegExp2;
      return isObject(it) && ((isRegExp2 = it[MATCH]) !== void 0 ? !!isRegExp2 : classof(it) === "RegExp");
    };
  }
});

// ../node_modules/core-js/modules/es.string.replace-all.js
var require_es_string_replace_all = __commonJS({
  "../node_modules/core-js/modules/es.string.replace-all.js"() {
    "use strict";
    var $ = require_export();
    var call2 = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var requireObjectCoercible = require_require_object_coercible();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var isRegExp2 = require_is_regexp();
    var toString2 = require_to_string();
    var getMethod2 = require_get_method();
    var getRegExpFlags = require_regexp_get_flags();
    var getSubstitution = require_get_substitution();
    var wellKnownSymbol = require_well_known_symbol();
    var IS_PURE = require_is_pure();
    var REPLACE = wellKnownSymbol("replace");
    var $TypeError = TypeError;
    var indexOf = uncurryThis("".indexOf);
    var replace3 = uncurryThis("".replace);
    var stringSlice = uncurryThis("".slice);
    var max2 = Math.max;
    $({ target: "String", proto: true }, {
      replaceAll: function replaceAll(searchValue, replaceValue) {
        var O = requireObjectCoercible(this);
        var IS_REG_EXP, flags, replacer, string, searchString, functionalReplace, searchLength, advanceBy, position, replacement;
        var endOfLastMatch = 0;
        var result = "";
        if (isObject(searchValue)) {
          IS_REG_EXP = isRegExp2(searchValue);
          if (IS_REG_EXP) {
            flags = toString2(requireObjectCoercible(getRegExpFlags(searchValue)));
            if (!~indexOf(flags, "g")) throw new $TypeError("`.replaceAll` does not allow non-global regexes");
          }
          replacer = getMethod2(searchValue, REPLACE);
          if (replacer) return call2(replacer, searchValue, O, replaceValue);
          if (IS_PURE && IS_REG_EXP) return replace3(toString2(O), searchValue, replaceValue);
        }
        string = toString2(O);
        searchString = toString2(searchValue);
        functionalReplace = isCallable(replaceValue);
        if (!functionalReplace) replaceValue = toString2(replaceValue);
        searchLength = searchString.length;
        advanceBy = max2(1, searchLength);
        position = indexOf(string, searchString);
        while (position !== -1) {
          replacement = functionalReplace ? toString2(replaceValue(searchString, position, string)) : getSubstitution(searchString, string, position, [], void 0, replaceValue);
          result += stringSlice(string, endOfLastMatch, position) + replacement;
          endOfLastMatch = position + searchLength;
          position = position + advanceBy > string.length ? -1 : indexOf(string, searchString, position + advanceBy);
        }
        if (endOfLastMatch < string.length) {
          result += stringSlice(string, endOfLastMatch);
        }
        return result;
      }
    });
  }
});

// ../node_modules/core-js/es/string/replace-all.js
var require_replace_all = __commonJS({
  "../node_modules/core-js/es/string/replace-all.js"(exports, module) {
    "use strict";
    require_es_regexp_exec();
    require_es_string_replace();
    require_es_string_replace_all();
    var entryUnbind = require_entry_unbind();
    module.exports = entryUnbind("String", "replaceAll");
  }
});

// ../node_modules/core-js/stable/string/replace-all.js
var require_replace_all2 = __commonJS({
  "../node_modules/core-js/stable/string/replace-all.js"(exports, module) {
    "use strict";
    var parent = require_replace_all();
    module.exports = parent;
  }
});

// ../node_modules/classnames/index.js
var require_classnames = __commonJS({
  "../node_modules/classnames/index.js"(exports, module) {
    (function() {
      "use strict";
      var hasOwn2 = {}.hasOwnProperty;
      function classNames39() {
        var classes = "";
        for (var i = 0; i < arguments.length; i++) {
          var arg = arguments[i];
          if (arg) {
            classes = appendClass(classes, parseValue(arg));
          }
        }
        return classes;
      }
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames39.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes = "";
        for (var key in arg) {
          if (hasOwn2.call(arg, key) && arg[key]) {
            classes = appendClass(classes, key);
          }
        }
        return classes;
      }
      function appendClass(value, newClass) {
        if (!newClass) {
          return value;
        }
        if (value) {
          return value + " " + newClass;
        }
        return value + newClass;
      }
      if (typeof module !== "undefined" && module.exports) {
        classNames39.default = classNames39;
        module.exports = classNames39;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames39;
        });
      } else {
        window.classNames = classNames39;
      }
    })();
  }
});

// ../node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "../node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter3() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter3.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers2 = this._events[evt];
      if (!handlers2) return [];
      if (handlers2.fn) return [handlers2.fn];
      for (var i = 0, l = handlers2.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers2[i].fn;
      }
      return ee;
    };
    EventEmitter3.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter3.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter3.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter3.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter3.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
    EventEmitter3.prefixed = prefix;
    EventEmitter3.EventEmitter = EventEmitter3;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter3;
    }
  }
});

// ../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    (function() {
      function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
      }
      function useSyncExternalStore$2(subscribe2, getSnapshot2) {
        didWarnOld18Alpha || void 0 === React105.startTransition || (didWarnOld18Alpha = true, console.error(
          "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
        ));
        var value = getSnapshot2();
        if (!didWarnUncachedGetSnapshot) {
          var cachedValue = getSnapshot2();
          objectIs(value, cachedValue) || (console.error(
            "The result of getSnapshot should be cached to avoid an infinite loop"
          ), didWarnUncachedGetSnapshot = true);
        }
        cachedValue = useState80({
          inst: { value, getSnapshot: getSnapshot2 }
        });
        var inst3 = cachedValue[0].inst, forceUpdate = cachedValue[1];
        useLayoutEffect26(
          function() {
            inst3.value = value;
            inst3.getSnapshot = getSnapshot2;
            checkIfSnapshotChanged(inst3) && forceUpdate({ inst: inst3 });
          },
          [subscribe2, value, getSnapshot2]
        );
        useEffect96(
          function() {
            checkIfSnapshotChanged(inst3) && forceUpdate({ inst: inst3 });
            return subscribe2(function() {
              checkIfSnapshotChanged(inst3) && forceUpdate({ inst: inst3 });
            });
          },
          [subscribe2]
        );
        useDebugValue4(value);
        return value;
      }
      function checkIfSnapshotChanged(inst3) {
        var latestGetSnapshot = inst3.getSnapshot;
        inst3 = inst3.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst3, nextValue);
        } catch (error) {
          return true;
        }
      }
      function useSyncExternalStore$1(subscribe2, getSnapshot2) {
        return getSnapshot2();
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React105 = require_react(), objectIs = "function" === typeof Object.is ? Object.is : is, useState80 = React105.useState, useEffect96 = React105.useEffect, useLayoutEffect26 = React105.useLayoutEffect, useDebugValue4 = React105.useDebugValue, didWarnOld18Alpha = false, didWarnUncachedGetSnapshot = false, shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
      exports.useSyncExternalStore = void 0 !== React105.useSyncExternalStore ? React105.useSyncExternalStore : shim;
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// ../node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "../node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// ../node_modules/lz-string/libs/lz-string.js
var require_lz_string = __commonJS({
  "../node_modules/lz-string/libs/lz-string.js"(exports, module) {
    var LZString = (function() {
      var f = String.fromCharCode;
      var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
      var baseReverseDic = {};
      function getBaseValue(alphabet, character) {
        if (!baseReverseDic[alphabet]) {
          baseReverseDic[alphabet] = {};
          for (var i = 0; i < alphabet.length; i++) {
            baseReverseDic[alphabet][alphabet.charAt(i)] = i;
          }
        }
        return baseReverseDic[alphabet][character];
      }
      var LZString2 = {
        compressToBase64: function(input) {
          if (input == null) return "";
          var res = LZString2._compress(input, 6, function(a) {
            return keyStrBase64.charAt(a);
          });
          switch (res.length % 4) {
            // To produce valid Base64
            default:
            // When could this happen ?
            case 0:
              return res;
            case 1:
              return res + "===";
            case 2:
              return res + "==";
            case 3:
              return res + "=";
          }
        },
        decompressFromBase64: function(input) {
          if (input == null) return "";
          if (input == "") return null;
          return LZString2._decompress(input.length, 32, function(index2) {
            return getBaseValue(keyStrBase64, input.charAt(index2));
          });
        },
        compressToUTF16: function(input) {
          if (input == null) return "";
          return LZString2._compress(input, 15, function(a) {
            return f(a + 32);
          }) + " ";
        },
        decompressFromUTF16: function(compressed) {
          if (compressed == null) return "";
          if (compressed == "") return null;
          return LZString2._decompress(compressed.length, 16384, function(index2) {
            return compressed.charCodeAt(index2) - 32;
          });
        },
        //compress into uint8array (UCS-2 big endian format)
        compressToUint8Array: function(uncompressed) {
          var compressed = LZString2.compress(uncompressed);
          var buf = new Uint8Array(compressed.length * 2);
          for (var i = 0, TotalLen = compressed.length; i < TotalLen; i++) {
            var current_value = compressed.charCodeAt(i);
            buf[i * 2] = current_value >>> 8;
            buf[i * 2 + 1] = current_value % 256;
          }
          return buf;
        },
        //decompress from uint8array (UCS-2 big endian format)
        decompressFromUint8Array: function(compressed) {
          if (compressed === null || compressed === void 0) {
            return LZString2.decompress(compressed);
          } else {
            var buf = new Array(compressed.length / 2);
            for (var i = 0, TotalLen = buf.length; i < TotalLen; i++) {
              buf[i] = compressed[i * 2] * 256 + compressed[i * 2 + 1];
            }
            var result = [];
            buf.forEach(function(c) {
              result.push(f(c));
            });
            return LZString2.decompress(result.join(""));
          }
        },
        //compress into a string that is already URI encoded
        compressToEncodedURIComponent: function(input) {
          if (input == null) return "";
          return LZString2._compress(input, 6, function(a) {
            return keyStrUriSafe.charAt(a);
          });
        },
        //decompress from an output of compressToEncodedURIComponent
        decompressFromEncodedURIComponent: function(input) {
          if (input == null) return "";
          if (input == "") return null;
          input = input.replace(/ /g, "+");
          return LZString2._decompress(input.length, 32, function(index2) {
            return getBaseValue(keyStrUriSafe, input.charAt(index2));
          });
        },
        compress: function(uncompressed) {
          return LZString2._compress(uncompressed, 16, function(a) {
            return f(a);
          });
        },
        _compress: function(uncompressed, bitsPerChar, getCharFromInt) {
          if (uncompressed == null) return "";
          var i, value, context_dictionary = {}, context_dictionaryToCreate = {}, context_c = "", context_wc = "", context_w = "", context_enlargeIn = 2, context_dictSize = 3, context_numBits = 2, context_data = [], context_data_val = 0, context_data_position = 0, ii;
          for (ii = 0; ii < uncompressed.length; ii += 1) {
            context_c = uncompressed.charAt(ii);
            if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
              context_dictionary[context_c] = context_dictSize++;
              context_dictionaryToCreate[context_c] = true;
            }
            context_wc = context_w + context_c;
            if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
              context_w = context_wc;
            } else {
              if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
                if (context_w.charCodeAt(0) < 256) {
                  for (i = 0; i < context_numBits; i++) {
                    context_data_val = context_data_val << 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                  }
                  value = context_w.charCodeAt(0);
                  for (i = 0; i < 8; i++) {
                    context_data_val = context_data_val << 1 | value & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = value >> 1;
                  }
                } else {
                  value = 1;
                  for (i = 0; i < context_numBits; i++) {
                    context_data_val = context_data_val << 1 | value;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = 0;
                  }
                  value = context_w.charCodeAt(0);
                  for (i = 0; i < 16; i++) {
                    context_data_val = context_data_val << 1 | value & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = value >> 1;
                  }
                }
                context_enlargeIn--;
                if (context_enlargeIn == 0) {
                  context_enlargeIn = Math.pow(2, context_numBits);
                  context_numBits++;
                }
                delete context_dictionaryToCreate[context_w];
              } else {
                value = context_dictionary[context_w];
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
              context_dictionary[context_wc] = context_dictSize++;
              context_w = String(context_c);
            }
          }
          if (context_w !== "") {
            if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
              if (context_w.charCodeAt(0) < 256) {
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                }
                value = context_w.charCodeAt(0);
                for (i = 0; i < 8; i++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              } else {
                value = 1;
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1 | value;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = 0;
                }
                value = context_w.charCodeAt(0);
                for (i = 0; i < 16; i++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
              delete context_dictionaryToCreate[context_w];
            } else {
              value = context_dictionary[context_w];
              for (i = 0; i < context_numBits; i++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn == 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
          }
          value = 2;
          for (i = 0; i < context_numBits; i++) {
            context_data_val = context_data_val << 1 | value & 1;
            if (context_data_position == bitsPerChar - 1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
          while (true) {
            context_data_val = context_data_val << 1;
            if (context_data_position == bitsPerChar - 1) {
              context_data.push(getCharFromInt(context_data_val));
              break;
            } else context_data_position++;
          }
          return context_data.join("");
        },
        decompress: function(compressed) {
          if (compressed == null) return "";
          if (compressed == "") return null;
          return LZString2._decompress(compressed.length, 32768, function(index2) {
            return compressed.charCodeAt(index2);
          });
        },
        _decompress: function(length, resetValue, getNextValue) {
          var dictionary = [], next, enlargeIn = 4, dictSize = 4, numBits = 3, entry = "", result = [], i, w, bits, resb, maxpower, power, c, data = { val: getNextValue(0), position: resetValue, index: 1 };
          for (i = 0; i < 3; i += 1) {
            dictionary[i] = i;
          }
          bits = 0;
          maxpower = Math.pow(2, 2);
          power = 1;
          while (power != maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }
          switch (next = bits) {
            case 0:
              bits = 0;
              maxpower = Math.pow(2, 8);
              power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              c = f(bits);
              break;
            case 1:
              bits = 0;
              maxpower = Math.pow(2, 16);
              power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              c = f(bits);
              break;
            case 2:
              return "";
          }
          dictionary[3] = c;
          w = c;
          result.push(c);
          while (true) {
            if (data.index > length) {
              return "";
            }
            bits = 0;
            maxpower = Math.pow(2, numBits);
            power = 1;
            while (power != maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;
              if (data.position == 0) {
                data.position = resetValue;
                data.val = getNextValue(data.index++);
              }
              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }
            switch (c = bits) {
              case 0:
                bits = 0;
                maxpower = Math.pow(2, 8);
                power = 1;
                while (power != maxpower) {
                  resb = data.val & data.position;
                  data.position >>= 1;
                  if (data.position == 0) {
                    data.position = resetValue;
                    data.val = getNextValue(data.index++);
                  }
                  bits |= (resb > 0 ? 1 : 0) * power;
                  power <<= 1;
                }
                dictionary[dictSize++] = f(bits);
                c = dictSize - 1;
                enlargeIn--;
                break;
              case 1:
                bits = 0;
                maxpower = Math.pow(2, 16);
                power = 1;
                while (power != maxpower) {
                  resb = data.val & data.position;
                  data.position >>= 1;
                  if (data.position == 0) {
                    data.position = resetValue;
                    data.val = getNextValue(data.index++);
                  }
                  bits |= (resb > 0 ? 1 : 0) * power;
                  power <<= 1;
                }
                dictionary[dictSize++] = f(bits);
                c = dictSize - 1;
                enlargeIn--;
                break;
              case 2:
                return result.join("");
            }
            if (enlargeIn == 0) {
              enlargeIn = Math.pow(2, numBits);
              numBits++;
            }
            if (dictionary[c]) {
              entry = dictionary[c];
            } else {
              if (c === dictSize) {
                entry = w + w.charAt(0);
              } else {
                return null;
              }
            }
            result.push(entry);
            dictionary[dictSize++] = w + entry.charAt(0);
            enlargeIn--;
            w = entry;
            if (enlargeIn == 0) {
              enlargeIn = Math.pow(2, numBits);
              numBits++;
            }
          }
        }
      };
      return LZString2;
    })();
    if (typeof define === "function" && define.amd) {
      define(function() {
        return LZString;
      });
    } else if (typeof module !== "undefined" && module != null) {
      module.exports = LZString;
    } else if (typeof angular !== "undefined" && angular != null) {
      angular.module("LZString", []).factory("LZString", function() {
        return LZString;
      });
    }
  }
});

// ../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js
var require_with_selector_development = __commonJS({
  "../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js"(exports) {
    "use strict";
    (function() {
      function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React105 = require_react(), shim = require_shim(), objectIs = "function" === typeof Object.is ? Object.is : is, useSyncExternalStore5 = shim.useSyncExternalStore, useRef100 = React105.useRef, useEffect96 = React105.useEffect, useMemo45 = React105.useMemo, useDebugValue4 = React105.useDebugValue;
      exports.useSyncExternalStoreWithSelector = function(subscribe2, getSnapshot2, getServerSnapshot, selector, isEqual) {
        var instRef = useRef100(null);
        if (null === instRef.current) {
          var inst3 = { hasValue: false, value: null };
          instRef.current = inst3;
        } else inst3 = instRef.current;
        instRef = useMemo45(
          function() {
            function memoizedSelector(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                nextSnapshot = selector(nextSnapshot);
                if (void 0 !== isEqual && inst3.hasValue) {
                  var currentSelection = inst3.value;
                  if (isEqual(currentSelection, nextSnapshot))
                    return memoizedSelection = currentSelection;
                }
                return memoizedSelection = nextSnapshot;
              }
              currentSelection = memoizedSelection;
              if (objectIs(memoizedSnapshot, nextSnapshot))
                return currentSelection;
              var nextSelection = selector(nextSnapshot);
              if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
                return memoizedSnapshot = nextSnapshot, currentSelection;
              memoizedSnapshot = nextSnapshot;
              return memoizedSelection = nextSelection;
            }
            var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
            return [
              function() {
                return memoizedSelector(getSnapshot2());
              },
              null === maybeGetServerSnapshot ? void 0 : function() {
                return memoizedSelector(maybeGetServerSnapshot());
              }
            ];
          },
          [getSnapshot2, getServerSnapshot, selector, isEqual]
        );
        var value = useSyncExternalStore5(subscribe2, instRef[0], instRef[1]);
        useEffect96(
          function() {
            inst3.hasValue = true;
            inst3.value = value;
          },
          [value]
        );
        useDebugValue4(value);
        return value;
      };
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// ../node_modules/use-sync-external-store/shim/with-selector.js
var require_with_selector = __commonJS({
  "../node_modules/use-sync-external-store/shim/with-selector.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_with_selector_development();
    }
  }
});

// ../node_modules/@tldraw/editor/dist-esm/index.mjs
var import_at = __toESM(require_at2(), 1);
var import_flat_map = __toESM(require_flat_map2(), 1);
var import_flat = __toESM(require_flat2(), 1);
var import_at2 = __toESM(require_at4(), 1);
var import_replace_all = __toESM(require_replace_all2(), 1);

// ../node_modules/@tldraw/state/dist-esm/lib/helpers.mjs
function isChild(x) {
  return x && typeof x === "object" && "parents" in x;
}
function haveParentsChanged(child) {
  for (let i = 0, n = child.parents.length; i < n; i++) {
    child.parents[i].__unsafe__getWithoutCapture(true);
    if (child.parents[i].lastChangedEpoch !== child.parentEpochs[i]) {
      return true;
    }
  }
  return false;
}
function detach(parent, child) {
  if (!parent.children.remove(child)) {
    return;
  }
  if (parent.children.isEmpty && isChild(parent)) {
    for (let i = 0, n = parent.parents.length; i < n; i++) {
      detach(parent.parents[i], parent);
    }
  }
}
function attach(parent, child) {
  if (!parent.children.add(child)) {
    return;
  }
  if (isChild(parent)) {
    for (let i = 0, n = parent.parents.length; i < n; i++) {
      attach(parent.parents[i], parent);
    }
  }
}
function equals(a, b) {
  const shallowEquals = a === b || Object.is(a, b) || Boolean(a && b && typeof a.equals === "function" && a.equals(b));
  return shallowEquals;
}
function singleton(key, init2) {
  const symbol = Symbol.for(`com.tldraw.state/${key}`);
  const global2 = globalThis;
  global2[symbol] ?? (global2[symbol] = init2());
  return global2[symbol];
}
var EMPTY_ARRAY = singleton("empty_array", () => Object.freeze([]));

// ../node_modules/@tldraw/state/dist-esm/lib/ArraySet.mjs
var ARRAY_SIZE_THRESHOLD = 8;
var ArraySet = class {
  constructor() {
    __publicField(this, "arraySize", 0);
    __publicField(this, "array", Array(ARRAY_SIZE_THRESHOLD));
    __publicField(this, "set", null);
  }
  /**
   * Get whether this ArraySet has any elements.
   *
   * @returns True if this ArraySet has any elements, false otherwise.
   */
  // eslint-disable-next-line no-restricted-syntax
  get isEmpty() {
    if (this.array) {
      return this.arraySize === 0;
    }
    if (this.set) {
      return this.set.size === 0;
    }
    throw new Error("no set or array");
  }
  /**
   * Add an element to the ArraySet if it is not already present.
   *
   * @param elem - The element to add to the set
   * @returns `true` if the element was added, `false` if it was already present
   * @example
   * ```ts
   * const arraySet = new ArraySet<string>()
   *
   * console.log(arraySet.add('hello')) // true
   * console.log(arraySet.add('hello')) // false (already exists)
   * ```
   */
  add(elem) {
    if (this.array) {
      const idx = this.array.indexOf(elem);
      if (idx !== -1) {
        return false;
      }
      if (this.arraySize < ARRAY_SIZE_THRESHOLD) {
        this.array[this.arraySize] = elem;
        this.arraySize++;
        return true;
      } else {
        this.set = new Set(this.array);
        this.array = null;
        this.set.add(elem);
        return true;
      }
    }
    if (this.set) {
      if (this.set.has(elem)) {
        return false;
      }
      this.set.add(elem);
      return true;
    }
    throw new Error("no set or array");
  }
  /**
   * Remove an element from the ArraySet if it is present.
   *
   * @param elem - The element to remove from the set
   * @returns `true` if the element was removed, `false` if it was not present
   * @example
   * ```ts
   * const arraySet = new ArraySet<string>()
   * arraySet.add('hello')
   *
   * console.log(arraySet.remove('hello')) // true
   * console.log(arraySet.remove('hello')) // false (not present)
   * ```
   */
  remove(elem) {
    if (this.array) {
      const idx = this.array.indexOf(elem);
      if (idx === -1) {
        return false;
      }
      this.array[idx] = void 0;
      this.arraySize--;
      if (idx !== this.arraySize) {
        this.array[idx] = this.array[this.arraySize];
        this.array[this.arraySize] = void 0;
      }
      return true;
    }
    if (this.set) {
      if (!this.set.has(elem)) {
        return false;
      }
      this.set.delete(elem);
      return true;
    }
    throw new Error("no set or array");
  }
  /**
   * Execute a callback function for each element in the ArraySet.
   *
   * @param visitor - A function to call for each element in the set
   * @example
   * ```ts
   * const arraySet = new ArraySet<string>()
   * arraySet.add('hello')
   * arraySet.add('world')
   *
   * arraySet.visit((item) => {
   *   console.log(item) // 'hello', 'world'
   * })
   * ```
   */
  visit(visitor) {
    if (this.array) {
      for (let i = 0; i < this.arraySize; i++) {
        const elem = this.array[i];
        if (typeof elem !== "undefined") {
          visitor(elem);
        }
      }
      return;
    }
    if (this.set) {
      this.set.forEach(visitor);
      return;
    }
    throw new Error("no set or array");
  }
  /**
   * Make the ArraySet iterable, allowing it to be used in for...of loops and with spread syntax.
   *
   * @returns An iterator that yields each element in the set
   * @example
   * ```ts
   * const arraySet = new ArraySet<number>()
   * arraySet.add(1)
   * arraySet.add(2)
   *
   * for (const item of arraySet) {
   *   console.log(item) // 1, 2
   * }
   *
   * const items = [...arraySet] // [1, 2]
   * ```
   */
  *[Symbol.iterator]() {
    if (this.array) {
      for (let i = 0; i < this.arraySize; i++) {
        const elem = this.array[i];
        if (typeof elem !== "undefined") {
          yield elem;
        }
      }
    } else if (this.set) {
      yield* this.set;
    } else {
      throw new Error("no set or array");
    }
  }
  /**
   * Check whether an element is present in the ArraySet.
   *
   * @param elem - The element to check for
   * @returns `true` if the element is present, `false` otherwise
   * @example
   * ```ts
   * const arraySet = new ArraySet<string>()
   * arraySet.add('hello')
   *
   * console.log(arraySet.has('hello')) // true
   * console.log(arraySet.has('world')) // false
   * ```
   */
  has(elem) {
    if (this.array) {
      return this.array.indexOf(elem) !== -1;
    } else {
      return this.set.has(elem);
    }
  }
  /**
   * Remove all elements from the ArraySet.
   *
   * @example
   * ```ts
   * const arraySet = new ArraySet<string>()
   * arraySet.add('hello')
   * arraySet.add('world')
   *
   * arraySet.clear()
   * console.log(arraySet.size()) // 0
   * ```
   */
  clear() {
    if (this.set) {
      this.set.clear();
    } else {
      this.arraySize = 0;
      this.array = [];
    }
  }
  /**
   * Get the number of elements in the ArraySet.
   *
   * @returns The number of elements in the set
   * @example
   * ```ts
   * const arraySet = new ArraySet<string>()
   * console.log(arraySet.size()) // 0
   *
   * arraySet.add('hello')
   * console.log(arraySet.size()) // 1
   * ```
   */
  size() {
    if (this.set) {
      return this.set.size;
    } else {
      return this.arraySize;
    }
  }
};

// ../node_modules/@tldraw/state/dist-esm/lib/types.mjs
var RESET_VALUE = Symbol.for("com.tldraw.state/RESET_VALUE");

// ../node_modules/@tldraw/state/dist-esm/lib/HistoryBuffer.mjs
var HistoryBuffer = class {
  /**
   * Creates a new HistoryBuffer with the specified capacity.
   *
   * capacity - Maximum number of diffs to store in the buffer
   * @example
   * ```ts
   * const buffer = new HistoryBuffer<number>(10) // Store up to 10 diffs
   * ```
   */
  constructor(capacity) {
    /**
     * Current write position in the circular buffer.
     * @internal
     */
    __publicField(this, "index", 0);
    /**
     * Circular buffer storing range tuples. Uses undefined to represent empty slots.
     * @internal
     */
    __publicField(this, "buffer");
    this.capacity = capacity;
    this.buffer = new Array(capacity);
  }
  /**
   * Adds a diff entry to the history buffer, representing a change between two epochs.
   *
   * If the diff is undefined, the operation is ignored. If the diff is RESET_VALUE,
   * the entire buffer is cleared to indicate that historical tracking should restart.
   *
   * @param lastComputedEpoch - The epoch when the previous value was computed
   * @param currentEpoch - The epoch when the current value was computed
   * @param diff - The diff representing the change, or RESET_VALUE to clear history
   * @example
   * ```ts
   * const buffer = new HistoryBuffer<string>(5)
   * buffer.pushEntry(0, 1, 'added text')
   * buffer.pushEntry(1, 2, RESET_VALUE) // Clears the buffer
   * ```
   */
  pushEntry(lastComputedEpoch, currentEpoch, diff) {
    if (diff === void 0) {
      return;
    }
    if (diff === RESET_VALUE) {
      this.clear();
      return;
    }
    this.buffer[this.index] = [lastComputedEpoch, currentEpoch, diff];
    this.index = (this.index + 1) % this.capacity;
  }
  /**
   * Clears all entries from the history buffer and resets the write position.
   * This is called when a RESET_VALUE diff is encountered.
   *
   * @example
   * ```ts
   * const buffer = new HistoryBuffer<string>(5)
   * buffer.pushEntry(0, 1, 'change')
   * buffer.clear()
   * console.log(buffer.getChangesSince(0)) // RESET_VALUE
   * ```
   */
  clear() {
    this.index = 0;
    this.buffer.fill(void 0);
  }
  /**
   * Retrieves all diffs that occurred since the specified epoch.
   *
   * The method searches backwards through the circular buffer to find changes
   * that occurred after the given epoch. If insufficient history is available
   * or the requested epoch is too old, returns RESET_VALUE indicating that
   * a complete state rebuild is required.
   *
   * @param sinceEpoch - The epoch from which to retrieve changes
   * @returns Array of diffs since the epoch, or RESET_VALUE if history is insufficient
   * @example
   * ```ts
   * const buffer = new HistoryBuffer<string>(5)
   * buffer.pushEntry(0, 1, 'first')
   * buffer.pushEntry(1, 2, 'second')
   * const changes = buffer.getChangesSince(0) // ['first', 'second']
   * const recentChanges = buffer.getChangesSince(1) // ['second']
   * const tooOld = buffer.getChangesSince(-100) // RESET_VALUE
   * ```
   */
  getChangesSince(sinceEpoch) {
    const { index: index2, capacity, buffer } = this;
    for (let i = 0; i < capacity; i++) {
      const offset4 = (index2 - 1 + capacity - i) % capacity;
      const elem = buffer[offset4];
      if (!elem) {
        return RESET_VALUE;
      }
      const [fromEpoch, toEpoch] = elem;
      if (i === 0 && sinceEpoch >= toEpoch) {
        return [];
      }
      if (fromEpoch <= sinceEpoch && sinceEpoch < toEpoch) {
        const len = i + 1;
        const result = new Array(len);
        for (let j = 0; j < len; j++) {
          result[j] = buffer[(offset4 + j) % capacity][2];
        }
        return result;
      }
    }
    return RESET_VALUE;
  }
};

// ../node_modules/@tldraw/state/dist-esm/lib/constants.mjs
var GLOBAL_START_EPOCH = -1;

// ../node_modules/@tldraw/state/dist-esm/lib/EffectScheduler.mjs
var __EffectScheduler__ = class {
  constructor(name, runEffect, options2) {
    /** @internal */
    __publicField(this, "_isActivelyListening", false);
    /** @internal */
    __publicField(this, "lastTraversedEpoch", GLOBAL_START_EPOCH);
    /** @internal */
    __publicField(this, "lastReactedEpoch", GLOBAL_START_EPOCH);
    /** @internal */
    __publicField(this, "_scheduleCount", 0);
    /** @internal */
    __publicField(this, "__debug_ancestor_epochs__", null);
    /** @internal */
    __publicField(this, "parentSet", new ArraySet());
    /** @internal */
    __publicField(this, "parentEpochs", []);
    /** @internal */
    __publicField(this, "parents", []);
    /** @internal */
    __publicField(this, "_scheduleEffect");
    /** @internal */
    // eslint-disable-next-line local/prefer-class-methods
    __publicField(this, "maybeExecute", () => {
      if (!this._isActivelyListening) return;
      this.execute();
    });
    this.name = name;
    this.runEffect = runEffect;
    this._scheduleEffect = options2 == null ? void 0 : options2.scheduleEffect;
  }
  /**
   * Whether this scheduler is attached and actively listening to its parents.
   * @public
   */
  // eslint-disable-next-line no-restricted-syntax
  get isActivelyListening() {
    return this._isActivelyListening;
  }
  /**
   * The number of times this effect has been scheduled.
   * @public
   */
  // eslint-disable-next-line no-restricted-syntax
  get scheduleCount() {
    return this._scheduleCount;
  }
  /** @internal */
  maybeScheduleEffect() {
    if (!this._isActivelyListening) return;
    if (this.lastReactedEpoch === getGlobalEpoch()) return;
    if (this.parents.length && !haveParentsChanged(this)) {
      this.lastReactedEpoch = getGlobalEpoch();
      return;
    }
    this.scheduleEffect();
  }
  /** @internal */
  scheduleEffect() {
    this._scheduleCount++;
    if (this._scheduleEffect) {
      this._scheduleEffect(this.maybeExecute);
    } else {
      this.execute();
    }
  }
  /**
   * Makes this scheduler become 'actively listening' to its parents.
   * If it has been executed before it will immediately become eligible to receive 'maybeScheduleEffect' calls.
   * If it has not executed before it will need to be manually executed once to become eligible for scheduling, i.e. by calling `EffectScheduler.execute`.
   * @public
   */
  attach() {
    this._isActivelyListening = true;
    for (let i = 0, n = this.parents.length; i < n; i++) {
      attach(this.parents[i], this);
    }
  }
  /**
   * Makes this scheduler stop 'actively listening' to its parents.
   * It will no longer be eligible to receive 'maybeScheduleEffect' calls until `EffectScheduler.attach` is called again.
   * @public
   */
  detach() {
    this._isActivelyListening = false;
    for (let i = 0, n = this.parents.length; i < n; i++) {
      detach(this.parents[i], this);
    }
  }
  /**
   * Executes the effect immediately and returns the result.
   * @returns The result of the effect.
   * @public
   */
  execute() {
    try {
      startCapturingParents(this);
      const currentEpoch = getGlobalEpoch();
      const result = this.runEffect(this.lastReactedEpoch);
      this.lastReactedEpoch = currentEpoch;
      return result;
    } finally {
      stopCapturingParents();
    }
  }
};
var EffectScheduler = singleton(
  "EffectScheduler",
  () => __EffectScheduler__
);
function react(name, fn, options2) {
  const scheduler = new EffectScheduler(name, fn, options2);
  scheduler.attach();
  scheduler.scheduleEffect();
  return () => {
    scheduler.detach();
  };
}
function reactor(name, fn, options2) {
  const scheduler = new EffectScheduler(name, fn, options2);
  return {
    scheduler,
    start: (options22) => {
      const force = (options22 == null ? void 0 : options22.force) ?? false;
      scheduler.attach();
      if (force) {
        scheduler.scheduleEffect();
      } else {
        scheduler.maybeScheduleEffect();
      }
    },
    stop: () => {
      scheduler.detach();
    }
  };
}

// ../node_modules/@tldraw/state/dist-esm/lib/transactions.mjs
var Transaction = class {
  constructor(parent, isSync) {
    __publicField(this, "asyncProcessCount", 0);
    __publicField(this, "initialAtomValues", /* @__PURE__ */ new Map());
    this.parent = parent;
    this.isSync = isSync;
  }
  /**
   * Get whether this transaction is a root (no parents).
   *
   * @public
   */
  // eslint-disable-next-line no-restricted-syntax
  get isRoot() {
    return this.parent === null;
  }
  /**
   * Commit the transaction's changes.
   *
   * @public
   */
  commit() {
    if (inst.globalIsReacting) {
      for (const atom2 of this.initialAtomValues.keys()) {
        traverseAtomForCleanup(atom2);
      }
    } else if (this.isRoot) {
      flushChanges(this.initialAtomValues.keys());
    } else {
      this.initialAtomValues.forEach((value, atom2) => {
        if (!this.parent.initialAtomValues.has(atom2)) {
          this.parent.initialAtomValues.set(atom2, value);
        }
      });
    }
  }
  /**
   * Abort the transaction.
   *
   * @public
   */
  abort() {
    inst.globalEpoch++;
    this.initialAtomValues.forEach((value, atom2) => {
      var _a6;
      atom2.set(value);
      (_a6 = atom2.historyBuffer) == null ? void 0 : _a6.clear();
    });
    this.commit();
  }
};
var inst = singleton("transactions", () => ({
  // The current epoch (global to all atoms).
  globalEpoch: GLOBAL_START_EPOCH + 1,
  // Whether any transaction is reacting.
  globalIsReacting: false,
  currentTransaction: null,
  cleanupReactors: null,
  reactionEpoch: GLOBAL_START_EPOCH + 1
}));
function getReactionEpoch() {
  return inst.reactionEpoch;
}
function getGlobalEpoch() {
  return inst.globalEpoch;
}
function getIsReacting() {
  return inst.globalIsReacting;
}
var traverseReactors;
function traverseChild(child) {
  if (child.lastTraversedEpoch === inst.globalEpoch) {
    return;
  }
  child.lastTraversedEpoch = inst.globalEpoch;
  if (child instanceof EffectScheduler) {
    traverseReactors.add(child);
  } else {
    ;
    child.children.visit(traverseChild);
  }
}
function traverse(reactors, child) {
  traverseReactors = reactors;
  traverseChild(child);
}
function flushChanges(atoms) {
  var _a6;
  if (inst.globalIsReacting) {
    throw new Error("flushChanges cannot be called during a reaction");
  }
  const outerTxn = inst.currentTransaction;
  try {
    inst.currentTransaction = null;
    inst.globalIsReacting = true;
    inst.reactionEpoch = inst.globalEpoch;
    const reactors = /* @__PURE__ */ new Set();
    for (const atom2 of atoms) {
      atom2.children.visit((child) => traverse(reactors, child));
    }
    for (const r of reactors) {
      r.maybeScheduleEffect();
    }
    let updateDepth = 0;
    while ((_a6 = inst.cleanupReactors) == null ? void 0 : _a6.size) {
      if (updateDepth++ > 1e3) {
        throw new Error("Reaction update depth limit exceeded");
      }
      const reactors2 = inst.cleanupReactors;
      inst.cleanupReactors = null;
      for (const r of reactors2) {
        r.maybeScheduleEffect();
      }
    }
  } finally {
    inst.cleanupReactors = null;
    inst.globalIsReacting = false;
    inst.currentTransaction = outerTxn;
    traverseReactors = void 0;
  }
}
function atomDidChange(atom2, previousValue) {
  if (inst.currentTransaction) {
    if (!inst.currentTransaction.initialAtomValues.has(atom2)) {
      inst.currentTransaction.initialAtomValues.set(atom2, previousValue);
    }
  } else if (inst.globalIsReacting) {
    traverseAtomForCleanup(atom2);
  } else {
    flushChanges([atom2]);
  }
}
function traverseAtomForCleanup(atom2) {
  const rs = inst.cleanupReactors ?? (inst.cleanupReactors = /* @__PURE__ */ new Set());
  atom2.children.visit((child) => traverse(rs, child));
}
function advanceGlobalEpoch() {
  inst.globalEpoch++;
}
function transaction(fn) {
  const txn = new Transaction(inst.currentTransaction, true);
  inst.currentTransaction = txn;
  try {
    let result = void 0;
    let rollback = false;
    try {
      result = fn(() => rollback = true);
    } catch (e) {
      txn.abort();
      throw e;
    }
    if (inst.currentTransaction !== txn) {
      throw new Error("Transaction boundaries overlap");
    }
    if (rollback) {
      txn.abort();
    } else {
      txn.commit();
    }
    return result;
  } finally {
    inst.currentTransaction = txn.parent;
  }
}
function transact(fn) {
  if (inst.currentTransaction) {
    return fn();
  }
  return transaction(fn);
}
async function deferAsyncEffects(fn) {
  var _a6;
  if ((_a6 = inst.currentTransaction) == null ? void 0 : _a6.isSync) {
    throw new Error("deferAsyncEffects cannot be called during a sync transaction");
  }
  while (inst.globalIsReacting) {
    await new Promise((r) => queueMicrotask(() => r(null)));
  }
  const txn = inst.currentTransaction ?? new Transaction(null, false);
  if (txn.isSync) throw new Error("deferAsyncEffects cannot be called during a sync transaction");
  inst.currentTransaction = txn;
  txn.asyncProcessCount++;
  let result = void 0;
  let error = void 0;
  try {
    result = await fn();
  } catch (e) {
    error = e ?? null;
  }
  if (--txn.asyncProcessCount > 0) {
    if (typeof error !== "undefined") {
      throw error;
    } else {
      return result;
    }
  }
  inst.currentTransaction = null;
  if (typeof error !== "undefined") {
    txn.abort();
    throw error;
  } else {
    txn.commit();
    return result;
  }
}

// ../node_modules/@tldraw/state/dist-esm/lib/warnings.mjs
var didWarnComputedGetter = false;
function logComputedGetterWarning() {
  if (didWarnComputedGetter) return;
  didWarnComputedGetter = true;
  console.warn(
    `Using \`@computed\` as a decorator for getters is deprecated and will be removed in the near future. Please refactor to use \`@computed\` as a decorator for methods.

// Before
@computed
get foo() {
	return 'foo'
}

// After
@computed
getFoo() {
	return 'foo'
}
`
  );
}

// ../node_modules/@tldraw/state/dist-esm/lib/Computed.mjs
var UNINITIALIZED = Symbol.for("com.tldraw.state/UNINITIALIZED");
function isUninitialized(value) {
  return value === UNINITIALIZED;
}
var WithDiff = singleton(
  "WithDiff",
  () => class WithDiff {
    constructor(value, diff) {
      this.value = value;
      this.diff = diff;
    }
  }
);
function withDiff(value, diff) {
  return new WithDiff(value, diff);
}
var __UNSAFE__Computed = class {
  constructor(name, derive, options2) {
    __publicField(this, "lastChangedEpoch", GLOBAL_START_EPOCH);
    __publicField(this, "lastTraversedEpoch", GLOBAL_START_EPOCH);
    __publicField(this, "__debug_ancestor_epochs__", null);
    /**
     * The epoch when the reactor was last checked.
     */
    __publicField(this, "lastCheckedEpoch", GLOBAL_START_EPOCH);
    __publicField(this, "parentSet", new ArraySet());
    __publicField(this, "parents", []);
    __publicField(this, "parentEpochs", []);
    __publicField(this, "children", new ArraySet());
    __publicField(this, "historyBuffer");
    // The last-computed value of this signal.
    __publicField(this, "state", UNINITIALIZED);
    // If the signal throws an error we stash it so we can rethrow it on the next get()
    __publicField(this, "error", null);
    __publicField(this, "computeDiff");
    __publicField(this, "isEqual");
    this.name = name;
    this.derive = derive;
    if (options2 == null ? void 0 : options2.historyLength) {
      this.historyBuffer = new HistoryBuffer(options2.historyLength);
    }
    this.computeDiff = options2 == null ? void 0 : options2.computeDiff;
    this.isEqual = (options2 == null ? void 0 : options2.isEqual) ?? equals;
  }
  // eslint-disable-next-line no-restricted-syntax
  get isActivelyListening() {
    return !this.children.isEmpty;
  }
  __unsafe__getWithoutCapture(ignoreErrors) {
    var _a6;
    const isNew = this.lastChangedEpoch === GLOBAL_START_EPOCH;
    const globalEpoch = getGlobalEpoch();
    if (!isNew && (this.lastCheckedEpoch === globalEpoch || this.isActivelyListening && getIsReacting() && this.lastTraversedEpoch < getReactionEpoch() || !haveParentsChanged(this))) {
      this.lastCheckedEpoch = globalEpoch;
      if (this.error) {
        if (!ignoreErrors) {
          throw this.error.thrownValue;
        } else {
          return this.state;
        }
      } else {
        return this.state;
      }
    }
    try {
      startCapturingParents(this);
      const result = this.derive(this.state, this.lastCheckedEpoch);
      const newState = result instanceof WithDiff ? result.value : result;
      const isUninitialized2 = this.state === UNINITIALIZED;
      if (isUninitialized2 || !this.isEqual(newState, this.state)) {
        if (this.historyBuffer && !isUninitialized2) {
          const diff = result instanceof WithDiff ? result.diff : void 0;
          this.historyBuffer.pushEntry(
            this.lastChangedEpoch,
            getGlobalEpoch(),
            diff ?? ((_a6 = this.computeDiff) == null ? void 0 : _a6.call(this, this.state, newState, this.lastCheckedEpoch, getGlobalEpoch())) ?? RESET_VALUE
          );
        }
        this.lastChangedEpoch = getGlobalEpoch();
        this.state = newState;
      }
      this.error = null;
      this.lastCheckedEpoch = getGlobalEpoch();
      return this.state;
    } catch (e) {
      if (this.state !== UNINITIALIZED) {
        this.state = UNINITIALIZED;
        this.lastChangedEpoch = getGlobalEpoch();
      }
      this.lastCheckedEpoch = getGlobalEpoch();
      if (this.historyBuffer) {
        this.historyBuffer.clear();
      }
      this.error = { thrownValue: e };
      if (!ignoreErrors) throw e;
      return this.state;
    } finally {
      stopCapturingParents();
    }
  }
  get() {
    try {
      return this.__unsafe__getWithoutCapture();
    } finally {
      maybeCaptureParent(this);
    }
  }
  getDiffSince(epoch) {
    var _a6;
    this.__unsafe__getWithoutCapture(true);
    maybeCaptureParent(this);
    if (epoch >= this.lastChangedEpoch) {
      return EMPTY_ARRAY;
    }
    return ((_a6 = this.historyBuffer) == null ? void 0 : _a6.getChangesSince(epoch)) ?? RESET_VALUE;
  }
};
var _Computed = singleton("Computed", () => __UNSAFE__Computed);
function computedMethodLegacyDecorator(options2 = {}, _target, key, descriptor) {
  const originalMethod = descriptor.value;
  const derivationKey = Symbol.for("__@tldraw/state__computed__" + key);
  descriptor.value = function() {
    let d = this[derivationKey];
    if (!d) {
      d = new _Computed(key, originalMethod.bind(this), options2);
      Object.defineProperty(this, derivationKey, {
        enumerable: false,
        configurable: false,
        writable: false,
        value: d
      });
    }
    return d.get();
  };
  descriptor.value[isComputedMethodKey] = true;
  return descriptor;
}
function computedGetterLegacyDecorator(options2 = {}, _target, key, descriptor) {
  const originalMethod = descriptor.get;
  const derivationKey = Symbol.for("__@tldraw/state__computed__" + key);
  descriptor.get = function() {
    let d = this[derivationKey];
    if (!d) {
      d = new _Computed(key, originalMethod.bind(this), options2);
      Object.defineProperty(this, derivationKey, {
        enumerable: false,
        configurable: false,
        writable: false,
        value: d
      });
    }
    return d.get();
  };
  return descriptor;
}
function computedMethodTc39Decorator(options2, compute, context) {
  assert(context.kind === "method", "@computed can only be used on methods");
  const derivationKey = Symbol.for("__@tldraw/state__computed__" + String(context.name));
  const fn = function() {
    let d = this[derivationKey];
    if (!d) {
      d = new _Computed(String(context.name), compute.bind(this), options2);
      Object.defineProperty(this, derivationKey, {
        enumerable: false,
        configurable: false,
        writable: false,
        value: d
      });
    }
    return d.get();
  };
  fn[isComputedMethodKey] = true;
  return fn;
}
function computedDecorator(options2 = {}, args) {
  if (args.length === 2) {
    const [originalMethod, context] = args;
    return computedMethodTc39Decorator(options2, originalMethod, context);
  } else {
    const [_target, key, descriptor] = args;
    if (descriptor.get) {
      logComputedGetterWarning();
      return computedGetterLegacyDecorator(options2, _target, key, descriptor);
    } else {
      return computedMethodLegacyDecorator(options2, _target, key, descriptor);
    }
  }
}
var isComputedMethodKey = "@@__isComputedMethod__@@";
function getComputedInstance(obj, propertyName) {
  const key = Symbol.for("__@tldraw/state__computed__" + propertyName.toString());
  let inst3 = obj[key];
  if (!inst3) {
    const val = obj[propertyName];
    if (typeof val === "function" && val[isComputedMethodKey]) {
      val.call(obj);
    }
    inst3 = obj[key];
  }
  return inst3;
}
function computed() {
  if (arguments.length === 1) {
    const options2 = arguments[0];
    return (...args) => computedDecorator(options2, args);
  } else if (typeof arguments[0] === "string") {
    return new _Computed(arguments[0], arguments[1], arguments[2]);
  } else {
    return computedDecorator(void 0, arguments);
  }
}
function isComputed(value) {
  return !!(value && value instanceof _Computed);
}

// ../node_modules/@tldraw/state/dist-esm/lib/capture.mjs
var CaptureStackFrame = class {
  constructor(below, child) {
    __publicField(this, "offset", 0);
    __publicField(this, "maybeRemoved");
    this.below = below;
    this.child = child;
  }
};
var inst2 = singleton("capture", () => ({ stack: null }));
function unsafe__withoutCapture(fn) {
  const oldStack = inst2.stack;
  inst2.stack = null;
  try {
    return fn();
  } finally {
    inst2.stack = oldStack;
  }
}
function startCapturingParents(child) {
  inst2.stack = new CaptureStackFrame(inst2.stack, child);
  if (child.__debug_ancestor_epochs__) {
    const previousAncestorEpochs = child.__debug_ancestor_epochs__;
    child.__debug_ancestor_epochs__ = null;
    for (const p of child.parents) {
      p.__unsafe__getWithoutCapture(true);
    }
    logChangedAncestors(child, previousAncestorEpochs);
  }
  child.parentSet.clear();
}
function stopCapturingParents() {
  const frame = inst2.stack;
  inst2.stack = frame.below;
  if (frame.offset < frame.child.parents.length) {
    for (let i = frame.offset; i < frame.child.parents.length; i++) {
      const maybeRemovedParent = frame.child.parents[i];
      if (!frame.child.parentSet.has(maybeRemovedParent)) {
        detach(maybeRemovedParent, frame.child);
      }
    }
    frame.child.parents.length = frame.offset;
    frame.child.parentEpochs.length = frame.offset;
  }
  if (frame.maybeRemoved) {
    for (let i = 0; i < frame.maybeRemoved.length; i++) {
      const maybeRemovedParent = frame.maybeRemoved[i];
      if (!frame.child.parentSet.has(maybeRemovedParent)) {
        detach(maybeRemovedParent, frame.child);
      }
    }
  }
  if (frame.child.__debug_ancestor_epochs__) {
    captureAncestorEpochs(frame.child, frame.child.__debug_ancestor_epochs__);
  }
}
function maybeCaptureParent(p) {
  if (inst2.stack) {
    const wasCapturedAlready = inst2.stack.child.parentSet.has(p);
    if (wasCapturedAlready) {
      return;
    }
    inst2.stack.child.parentSet.add(p);
    if (inst2.stack.child.isActivelyListening) {
      attach(p, inst2.stack.child);
    }
    if (inst2.stack.offset < inst2.stack.child.parents.length) {
      const maybeRemovedParent = inst2.stack.child.parents[inst2.stack.offset];
      if (maybeRemovedParent !== p) {
        if (!inst2.stack.maybeRemoved) {
          inst2.stack.maybeRemoved = [maybeRemovedParent];
        } else {
          inst2.stack.maybeRemoved.push(maybeRemovedParent);
        }
      }
    }
    inst2.stack.child.parents[inst2.stack.offset] = p;
    inst2.stack.child.parentEpochs[inst2.stack.offset] = p.lastChangedEpoch;
    inst2.stack.offset++;
  }
}
function whyAmIRunning() {
  var _a6;
  const child = (_a6 = inst2.stack) == null ? void 0 : _a6.child;
  if (!child) {
    throw new Error("whyAmIRunning() called outside of a reactive context");
  }
  child.__debug_ancestor_epochs__ = /* @__PURE__ */ new Map();
}
function captureAncestorEpochs(child, ancestorEpochs) {
  for (let i = 0; i < child.parents.length; i++) {
    const parent = child.parents[i];
    const epoch = child.parentEpochs[i];
    ancestorEpochs.set(parent, epoch);
    if (isComputed(parent)) {
      captureAncestorEpochs(parent, ancestorEpochs);
    }
  }
  return ancestorEpochs;
}
function collectChangedAncestors(child, ancestorEpochs) {
  const changeTree = {};
  for (let i = 0; i < child.parents.length; i++) {
    const parent = child.parents[i];
    if (!ancestorEpochs.has(parent)) {
      continue;
    }
    const prevEpoch = ancestorEpochs.get(parent);
    const currentEpoch = parent.lastChangedEpoch;
    if (currentEpoch !== prevEpoch) {
      if (isComputed(parent)) {
        changeTree[parent.name] = collectChangedAncestors(parent, ancestorEpochs);
      } else {
        changeTree[parent.name] = null;
      }
    }
  }
  return changeTree;
}
function logChangedAncestors(child, ancestorEpochs) {
  const changeTree = collectChangedAncestors(child, ancestorEpochs);
  if (Object.keys(changeTree).length === 0) {
    console.log(`Effect(${child.name}) was executed manually.`);
    return;
  }
  let str = isComputed(child) ? `Computed(${child.name}) is recomputing because:` : `Effect(${child.name}) is executing because:`;
  function logParent(tree, indent) {
    const indentStr = "\n" + " ".repeat(indent) + "↳ ";
    for (const [name, val] of Object.entries(tree)) {
      if (val) {
        str += `${indentStr}Computed(${name}) changed`;
        logParent(val, indent + 2);
      } else {
        str += `${indentStr}Atom(${name}) changed`;
      }
    }
  }
  logParent(changeTree, 1);
  console.log(str);
}

// ../node_modules/@tldraw/state/dist-esm/lib/Atom.mjs
var __Atom__ = class {
  constructor(name, current, options2) {
    /**
     * Custom equality function for comparing values, or null to use default equality.
     * @internal
     */
    __publicField(this, "isEqual");
    /**
     * Optional function to compute diffs between old and new values.
     * @internal
     */
    __publicField(this, "computeDiff");
    /**
     * The global epoch when this atom was last changed.
     * @internal
     */
    __publicField(this, "lastChangedEpoch", getGlobalEpoch());
    /**
     * Set of child signals that depend on this atom.
     * @internal
     */
    __publicField(this, "children", new ArraySet());
    /**
     * Optional history buffer for tracking changes over time.
     * @internal
     */
    __publicField(this, "historyBuffer");
    this.name = name;
    this.current = current;
    this.isEqual = (options2 == null ? void 0 : options2.isEqual) ?? null;
    if (!options2) return;
    if (options2.historyLength) {
      this.historyBuffer = new HistoryBuffer(options2.historyLength);
    }
    this.computeDiff = options2.computeDiff;
  }
  /**
   * Gets the current value without capturing it as a dependency in the current reactive context.
   * This is unsafe because it breaks the reactivity chain - use with caution.
   *
   * @param _ignoreErrors - Unused parameter for API compatibility
   * @returns The current value
   * @internal
   */
  __unsafe__getWithoutCapture(_ignoreErrors) {
    return this.current;
  }
  /**
   * Gets the current value of this atom. When called within a computed signal or reaction,
   * this atom will be automatically captured as a dependency.
   *
   * @returns The current value
   * @example
   * ```ts
   * const count = atom('count', 5)
   * console.log(count.get()) // 5
   * ```
   */
  get() {
    maybeCaptureParent(this);
    return this.current;
  }
  /**
   * Sets the value of this atom to the given value. If the value is the same as the current value, this is a no-op.
   *
   * @param value - The new value to set
   * @param diff - The diff to use for the update. If not provided, the diff will be computed using {@link AtomOptions.computeDiff}
   * @returns The new value
   * @example
   * ```ts
   * const count = atom('count', 0)
   * count.set(5) // count.get() is now 5
   * ```
   */
  set(value, diff) {
    var _a6, _b3;
    if (((_a6 = this.isEqual) == null ? void 0 : _a6.call(this, this.current, value)) ?? equals(this.current, value)) {
      return this.current;
    }
    advanceGlobalEpoch();
    if (this.historyBuffer) {
      this.historyBuffer.pushEntry(
        this.lastChangedEpoch,
        getGlobalEpoch(),
        diff ?? ((_b3 = this.computeDiff) == null ? void 0 : _b3.call(this, this.current, value, this.lastChangedEpoch, getGlobalEpoch())) ?? RESET_VALUE
      );
    }
    this.lastChangedEpoch = getGlobalEpoch();
    const oldValue = this.current;
    this.current = value;
    atomDidChange(this, oldValue);
    return value;
  }
  /**
   * Updates the value of this atom using the given updater function. If the returned value is the same as the current value, this is a no-op.
   *
   * @param updater - A function that takes the current value and returns the new value
   * @returns The new value
   * @example
   * ```ts
   * const count = atom('count', 5)
   * count.update(n => n + 1) // count.get() is now 6
   * ```
   */
  update(updater) {
    return this.set(updater(this.current));
  }
  /**
   * Gets all the diffs that have occurred since the given epoch. When called within a computed
   * signal or reaction, this atom will be automatically captured as a dependency.
   *
   * @param epoch - The epoch to get changes since
   * @returns An array of diffs, or RESET_VALUE if history is insufficient
   * @internal
   */
  getDiffSince(epoch) {
    var _a6;
    maybeCaptureParent(this);
    if (epoch >= this.lastChangedEpoch) {
      return EMPTY_ARRAY;
    }
    return ((_a6 = this.historyBuffer) == null ? void 0 : _a6.getChangesSince(epoch)) ?? RESET_VALUE;
  }
};
var _Atom = singleton("Atom", () => __Atom__);
function atom(name, initialValue, options2) {
  return new _Atom(name, initialValue, options2);
}
function isAtom(value) {
  return value instanceof _Atom;
}

// ../node_modules/@tldraw/state/dist-esm/lib/isSignal.mjs
function isSignal(value) {
  return value instanceof _Atom || value instanceof _Computed;
}

// ../node_modules/@tldraw/state/dist-esm/lib/localStorageAtom.mjs
function localStorageAtom(name, initialValue, options2) {
  let _initialValue = initialValue;
  try {
    const value = getFromLocalStorage(name);
    if (value) {
      _initialValue = JSON.parse(value);
    }
  } catch {
    deleteFromLocalStorage(name);
  }
  const outAtom = atom(name, _initialValue, options2);
  const reactCleanup = react(`save ${name} to localStorage`, () => {
    setInLocalStorage(name, JSON.stringify(outAtom.get()));
  });
  const handleStorageEvent = (event) => {
    if (event.key !== name) return;
    if (event.newValue === null) {
      outAtom.set(initialValue);
      return;
    }
    try {
      const newValue = JSON.parse(event.newValue);
      outAtom.set(newValue);
    } catch {
    }
  };
  window.addEventListener("storage", handleStorageEvent);
  const cleanup = () => {
    reactCleanup();
    window.removeEventListener("storage", handleStorageEvent);
  };
  return [outAtom, cleanup];
}

// ../node_modules/@tldraw/state/dist-esm/index.mjs
var currentApiVersion = 1;
var actualApiVersion = singleton("apiVersion", () => currentApiVersion);
if (actualApiVersion !== currentApiVersion) {
  throw new Error(
    `You have multiple incompatible versions of @tldraw/state in your app. Please deduplicate the package.`
  );
}
registerTldrawLibraryVersion(
  "@tldraw/state",
  "4.3.1",
  "esm"
);

// ../node_modules/@tldraw/state-react/dist-esm/lib/track.mjs
var import_react2 = __toESM(require_react(), 1);

// ../node_modules/@tldraw/state-react/dist-esm/lib/useStateTracking.mjs
var import_react = __toESM(require_react(), 1);
function useStateTracking(name, render, deps = []) {
  const renderRef = import_react.default.useRef(render);
  renderRef.current = render;
  const [scheduler, subscribe2, getSnapshot2] = import_react.default.useMemo(() => {
    let scheduleUpdate = null;
    const subscribe22 = (cb) => {
      scheduleUpdate = cb;
      return () => {
        scheduleUpdate = null;
      };
    };
    const scheduler2 = new EffectScheduler(
      `useStateTracking(${name})`,
      // this is what `scheduler.execute()` will call
      () => {
        var _a6;
        return (_a6 = renderRef.current) == null ? void 0 : _a6.call(renderRef);
      },
      // this is what will be invoked when @tldraw/state detects a change in an upstream reactive value
      {
        scheduleEffect() {
          scheduleUpdate == null ? void 0 : scheduleUpdate();
        }
      }
    );
    const getSnapshot22 = () => scheduler2.scheduleCount;
    return [scheduler2, subscribe22, getSnapshot22];
  }, [name, ...deps]);
  import_react.default.useSyncExternalStore(subscribe2, getSnapshot2, getSnapshot2);
  import_react.default.useEffect(() => {
    scheduler.attach();
    scheduler.maybeScheduleEffect();
    return () => {
      scheduler.detach();
    };
  }, [scheduler]);
  return scheduler.execute();
}

// ../node_modules/@tldraw/state-react/dist-esm/lib/track.mjs
var ProxyHandlers = {
  /**
   * This is a function call trap for functional components. When this is called, we know it means
   * React did run 'Component()', that means we can use any hooks here to setup our effect and
   * store.
   *
   * With the native Proxy, all other calls such as access/setting to/of properties will be
   * forwarded to the target Component, so we don't need to copy the Component's own or inherited
   * properties.
   *
   * @see https://github.com/facebook/react/blob/2d80a0cd690bb5650b6c8a6c079a87b5dc42bd15/packages/react-reconciler/src/ReactFiberHooks.old.js#L460
   */
  apply(Component2, thisArg, argumentsList) {
    return useStateTracking(
      Component2.displayName ?? Component2.name ?? "tracked(???)",
      () => Component2.apply(thisArg, argumentsList)
    );
  }
};
var ReactMemoSymbol = Symbol.for("react.memo");
var ReactForwardRefSymbol = Symbol.for("react.forward_ref");
function track(baseComponent) {
  let compare = null;
  const $$typeof = baseComponent["$$typeof"];
  if ($$typeof === ReactMemoSymbol) {
    baseComponent = baseComponent.type;
    compare = baseComponent.compare;
  }
  if ($$typeof === ReactForwardRefSymbol) {
    return (0, import_react2.memo)((0, import_react2.forwardRef)(new Proxy(baseComponent.render, ProxyHandlers)));
  }
  return (0, import_react2.memo)(new Proxy(baseComponent, ProxyHandlers), compare);
}

// ../node_modules/@tldraw/state-react/dist-esm/lib/useAtom.mjs
var import_react3 = __toESM(require_react(), 1);
function useAtom(name, valueOrInitialiser, options2) {
  return (0, import_react3.useState)(() => {
    const initialValue = typeof valueOrInitialiser === "function" ? valueOrInitialiser() : valueOrInitialiser;
    return atom(`useAtom(${name})`, initialValue, options2);
  })[0];
}

// ../node_modules/@tldraw/state-react/dist-esm/lib/useComputed.mjs
var import_react4 = __toESM(require_react(), 1);
function useComputed() {
  const name = arguments[0];
  const compute = arguments[1];
  const opts = arguments.length === 3 ? void 0 : arguments[2];
  const deps = arguments.length === 3 ? arguments[2] : arguments[3];
  return (0, import_react4.useMemo)(() => computed(`useComputed(${name})`, compute, opts), deps);
}

// ../node_modules/@tldraw/state-react/dist-esm/lib/useQuickReactor.mjs
var import_react5 = __toESM(require_react(), 1);
function useQuickReactor(name, reactFn, deps = EMPTY_ARRAY) {
  (0, import_react5.useEffect)(() => {
    const scheduler = new EffectScheduler(name, reactFn);
    scheduler.attach();
    scheduler.execute();
    return () => {
      scheduler.detach();
    };
  }, deps);
}

// ../node_modules/@tldraw/state-react/dist-esm/lib/useReactor.mjs
var import_react6 = __toESM(require_react(), 1);
function useReactor(name, reactFn, deps = []) {
  (0, import_react6.useEffect)(() => {
    let cancelFn;
    const scheduler = new EffectScheduler(name, reactFn, {
      scheduleEffect: (cb) => {
        cancelFn = throttleToNextFrame(cb);
      }
    });
    scheduler.attach();
    scheduler.execute();
    return () => {
      scheduler.detach();
      cancelFn == null ? void 0 : cancelFn();
    };
  }, deps);
}

// ../node_modules/@tldraw/state-react/dist-esm/lib/useValue.mjs
var import_react7 = __toESM(require_react(), 1);
function useValue() {
  const args = arguments;
  const deps = args.length === 3 ? args[2] : [args[0]];
  const name = args.length === 3 ? args[0] : `useValue(${args[0].name})`;
  const { $val, subscribe: subscribe2, getSnapshot: getSnapshot2 } = (0, import_react7.useMemo)(() => {
    const $val2 = args.length === 1 ? args[0] : computed(name, args[1]);
    return {
      $val: $val2,
      subscribe: (notify) => {
        return react(`useValue(${name})`, () => {
          try {
            $val2.get();
          } catch {
          }
          notify();
        });
      },
      getSnapshot: () => $val2.lastChangedEpoch
    };
  }, deps);
  (0, import_react7.useSyncExternalStore)(subscribe2, getSnapshot2, getSnapshot2);
  return $val.__unsafe__getWithoutCapture();
}

// ../node_modules/@tldraw/state-react/dist-esm/index.mjs
registerTldrawLibraryVersion(
  "@tldraw/state-react",
  "4.3.1",
  "esm"
);

// ../node_modules/@tldraw/store/dist-esm/lib/ImmutableMap.mjs
function smi(i32) {
  return i32 >>> 1 & 1073741824 | i32 & 3221225471;
}
var defaultValueOf = Object.prototype.valueOf;
function hash(o) {
  if (o == null) {
    return hashNullish(o);
  }
  if (typeof o.hashCode === "function") {
    return smi(o.hashCode(o));
  }
  const v = valueOf(o);
  if (v == null) {
    return hashNullish(v);
  }
  switch (typeof v) {
    case "boolean":
      return v ? 1108378657 : 1108378656;
    case "number":
      return hashNumber(v);
    case "string":
      return v.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(v) : hashString(v);
    case "object":
    case "function":
      return hashJSObj(v);
    case "symbol":
      return hashSymbol(v);
    default:
      if (typeof v.toString === "function") {
        return hashString(v.toString());
      }
      throw new Error("Value type " + typeof v + " cannot be hashed.");
  }
}
function hashNullish(nullish) {
  return nullish === null ? 1108378658 : (
    /* undefined */
    1108378659
  );
}
function hashNumber(n) {
  if (n !== n || n === Infinity) {
    return 0;
  }
  let hash2 = n | 0;
  if (hash2 !== n) {
    hash2 ^= n * 4294967295;
  }
  while (n > 4294967295) {
    n /= 4294967295;
    hash2 ^= n;
  }
  return smi(hash2);
}
function cachedHashString(string) {
  let hashed = stringHashCache[string];
  if (hashed === void 0) {
    hashed = hashString(string);
    if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
      STRING_HASH_CACHE_SIZE = 0;
      stringHashCache = {};
    }
    STRING_HASH_CACHE_SIZE++;
    stringHashCache[string] = hashed;
  }
  return hashed;
}
function hashString(string) {
  let hashed = 0;
  for (let ii = 0; ii < string.length; ii++) {
    hashed = 31 * hashed + string.charCodeAt(ii) | 0;
  }
  return smi(hashed);
}
function hashSymbol(sym) {
  let hashed = symbolMap[sym];
  if (hashed !== void 0) {
    return hashed;
  }
  hashed = nextHash();
  symbolMap[sym] = hashed;
  return hashed;
}
function hashJSObj(obj) {
  let hashed = weakMap.get(obj);
  if (hashed !== void 0) {
    return hashed;
  }
  hashed = nextHash();
  weakMap.set(obj, hashed);
  return hashed;
}
function valueOf(obj) {
  return obj.valueOf !== defaultValueOf && typeof obj.valueOf === "function" ? obj.valueOf(obj) : obj;
}
function nextHash() {
  const nextHash2 = ++_objHashUID;
  if (_objHashUID & 1073741824) {
    _objHashUID = 0;
  }
  return nextHash2;
}
var weakMap = /* @__PURE__ */ new WeakMap();
var symbolMap = /* @__PURE__ */ Object.create(null);
var _objHashUID = 0;
var STRING_HASH_CACHE_MIN_STRLEN = 16;
var STRING_HASH_CACHE_MAX_SIZE = 255;
var STRING_HASH_CACHE_SIZE = 0;
var stringHashCache = {};
var SHIFT = 5;
var SIZE = 1 << SHIFT;
var MASK = SIZE - 1;
var NOT_SET = {};
function MakeRef() {
  return { value: false };
}
function SetRef(ref) {
  if (ref) {
    ref.value = true;
  }
}
function arrCopy(arr, offset4 = 0) {
  return arr.slice(offset4);
}
var OwnerID = class {
};
var ImmutableMap = class _ImmutableMap {
  /**
   * Creates a new ImmutableMap instance.
   *
   * @param value - An iterable of key-value pairs to populate the map, or null/undefined for an empty map
   * @example
   * ```ts
   * // Create from array of pairs
   * const map1 = new ImmutableMap([['a', 1], ['b', 2]])
   *
   * // Create empty map
   * const map2 = new ImmutableMap()
   *
   * // Create from another map
   * const map3 = new ImmutableMap(map1)
   * ```
   */
  constructor(value) {
    // @pragma Construction
    // @ts-ignore
    __publicField(this, "_root");
    // @ts-ignore
    __publicField(this, "size");
    // @ts-ignore
    __publicField(this, "__ownerID");
    // @ts-ignore
    __publicField(this, "__hash");
    // @ts-ignore
    __publicField(this, "__altered");
    return value === void 0 || value === null ? emptyMap() : value instanceof _ImmutableMap ? value : emptyMap().withMutations((map2) => {
      for (const [k, v] of value) {
        map2.set(k, v);
      }
    });
  }
  /**
   * Gets the value associated with the specified key, with a fallback value.
   *
   * @param k - The key to look up
   * @param notSetValue - The value to return if the key is not found
   * @returns The value associated with the key, or the fallback value if not found
   * @example
   * ```ts
   * const map = new ImmutableMap([['key1', 'value1']])
   * console.log(map.get('key1', 'default')) // 'value1'
   * console.log(map.get('missing', 'default')) // 'default'
   * ```
   */
  get(k, notSetValue) {
    return this._root ? this._root.get(0, void 0, k, notSetValue) : notSetValue;
  }
  /**
   * Returns a new ImmutableMap with the specified key-value pair added or updated.
   * If the key already exists, its value is replaced. Otherwise, a new entry is created.
   *
   * @param k - The key to set
   * @param v - The value to associate with the key
   * @returns A new ImmutableMap with the key-value pair set
   * @example
   * ```ts
   * const map = new ImmutableMap([['a', 1]])
   * const updated = map.set('b', 2) // New map with both 'a' and 'b'
   * const replaced = map.set('a', 10) // New map with 'a' updated to 10
   * ```
   */
  set(k, v) {
    return updateMap(this, k, v);
  }
  /**
   * Returns a new ImmutableMap with the specified key removed.
   * If the key doesn't exist, returns the same map instance.
   *
   * @param k - The key to remove
   * @returns A new ImmutableMap with the key removed, or the same instance if key not found
   * @example
   * ```ts
   * const map = new ImmutableMap([['a', 1], ['b', 2]])
   * const smaller = map.delete('a') // New map with only 'b'
   * const same = map.delete('missing') // Returns original map
   * ```
   */
  delete(k) {
    return updateMap(this, k, NOT_SET);
  }
  /**
   * Returns a new ImmutableMap with all specified keys removed.
   * This is more efficient than calling delete() multiple times.
   *
   * @param keys - An iterable of keys to remove
   * @returns A new ImmutableMap with all specified keys removed
   * @example
   * ```ts
   * const map = new ImmutableMap([['a', 1], ['b', 2], ['c', 3]])
   * const smaller = map.deleteAll(['a', 'c']) // New map with only 'b'
   * ```
   */
  deleteAll(keys3) {
    return this.withMutations((map2) => {
      for (const key of keys3) {
        map2.delete(key);
      }
    });
  }
  __ensureOwner(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      if (this.size === 0) {
        return emptyMap();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }
    return makeMap(this.size, this._root, ownerID, this.__hash);
  }
  /**
   * Applies multiple mutations efficiently by creating a mutable copy,
   * applying all changes, then returning an immutable result.
   * This is more efficient than chaining multiple set/delete operations.
   *
   * @param fn - Function that receives a mutable copy and applies changes
   * @returns A new ImmutableMap with all mutations applied, or the same instance if no changes
   * @example
   * ```ts
   * const map = new ImmutableMap([['a', 1]])
   * const updated = map.withMutations(mutable => {
   *   mutable.set('b', 2)
   *   mutable.set('c', 3)
   *   mutable.delete('a')
   * }) // Efficiently applies all changes at once
   * ```
   */
  withMutations(fn) {
    const mutable = this.asMutable();
    fn(mutable);
    return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
  }
  /**
   * Checks if this map instance has been altered during a mutation operation.
   * This is used internally to optimize mutations.
   *
   * @returns True if the map was altered, false otherwise
   * @internal
   */
  wasAltered() {
    return this.__altered;
  }
  /**
   * Returns a mutable copy of this map that can be efficiently modified.
   * Multiple changes to the mutable copy are batched together.
   *
   * @returns A mutable copy of this map
   * @internal
   */
  asMutable() {
    return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
  }
  /**
   * Makes the map iterable, yielding key-value pairs.
   *
   * @returns An iterator over [key, value] pairs
   * @example
   * ```ts
   * const map = new ImmutableMap([['a', 1], ['b', 2]])
   * for (const [key, value] of map) {
   *   console.log(key, value) // 'a' 1, then 'b' 2
   * }
   * ```
   */
  [Symbol.iterator]() {
    return this.entries()[Symbol.iterator]();
  }
  /**
   * Returns an iterable of key-value pairs.
   *
   * @returns An iterable over [key, value] pairs
   * @example
   * ```ts
   * const map = new ImmutableMap([['a', 1], ['b', 2]])
   * const entries = Array.from(map.entries()) // [['a', 1], ['b', 2]]
   * ```
   */
  entries() {
    return new MapIterator(this, ITERATE_ENTRIES, false);
  }
  /**
   * Returns an iterable of keys.
   *
   * @returns An iterable over keys
   * @example
   * ```ts
   * const map = new ImmutableMap([['a', 1], ['b', 2]])
   * const keys = Array.from(map.keys()) // ['a', 'b']
   * ```
   */
  keys() {
    return new MapIterator(this, ITERATE_KEYS, false);
  }
  /**
   * Returns an iterable of values.
   *
   * @returns An iterable over values
   * @example
   * ```ts
   * const map = new ImmutableMap([['a', 1], ['b', 2]])
   * const values = Array.from(map.values()) // [1, 2]
   * ```
   */
  values() {
    return new MapIterator(this, ITERATE_VALUES, false);
  }
};
var ArrayMapNode = class _ArrayMapNode {
  constructor(ownerID, entries) {
    this.ownerID = ownerID;
    this.entries = entries;
  }
  get(_shift, _keyHash, key, notSetValue) {
    const entries = this.entries;
    for (let ii = 0, len = entries.length; ii < len; ii++) {
      if (Object.is(key, entries[ii][0])) {
        return entries[ii][1];
      }
    }
    return notSetValue;
  }
  update(ownerID, _shift, _keyHash, key, value, didChangeSize, didAlter) {
    const removed = value === NOT_SET;
    const entries = this.entries;
    let idx = 0;
    const len = entries.length;
    for (; idx < len; idx++) {
      if (Object.is(key, entries[idx][0])) {
        break;
      }
    }
    const exists = idx < len;
    if (exists ? entries[idx][1] === value : removed) {
      return this;
    }
    SetRef(didAlter);
    if (removed || !exists) SetRef(didChangeSize);
    if (removed && entries.length === 1) {
      return;
    }
    if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
      return createNodes(ownerID, entries, key, value);
    }
    const isEditable = ownerID && ownerID === this.ownerID;
    const newEntries = isEditable ? entries : arrCopy(entries);
    if (exists) {
      if (removed) {
        if (idx === len - 1) {
          newEntries.pop();
        } else {
          newEntries[idx] = newEntries.pop();
        }
      } else {
        newEntries[idx] = [key, value];
      }
    } else {
      newEntries.push([key, value]);
    }
    if (isEditable) {
      this.entries = newEntries;
      return this;
    }
    return new _ArrayMapNode(ownerID, newEntries);
  }
};
var BitmapIndexedNode = class _BitmapIndexedNode {
  constructor(ownerID, bitmap, nodes) {
    this.ownerID = ownerID;
    this.bitmap = bitmap;
    this.nodes = nodes;
  }
  get(shift5, keyHash, key, notSetValue) {
    if (keyHash === void 0) {
      keyHash = hash(key);
    }
    const bit = 1 << ((shift5 === 0 ? keyHash : keyHash >>> shift5) & MASK);
    const bitmap = this.bitmap;
    return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(shift5 + SHIFT, keyHash, key, notSetValue);
  }
  update(ownerID, shift5, keyHash, key, value, didChangeSize, didAlter) {
    if (keyHash === void 0) {
      keyHash = hash(key);
    }
    const keyHashFrag = (shift5 === 0 ? keyHash : keyHash >>> shift5) & MASK;
    const bit = 1 << keyHashFrag;
    const bitmap = this.bitmap;
    const exists = (bitmap & bit) !== 0;
    if (!exists && value === NOT_SET) {
      return this;
    }
    const idx = popCount(bitmap & bit - 1);
    const nodes = this.nodes;
    const node = exists ? nodes[idx] : void 0;
    const newNode = updateNode(
      node,
      ownerID,
      shift5 + SHIFT,
      keyHash,
      key,
      value,
      didChangeSize,
      didAlter
    );
    if (newNode === node) {
      return this;
    }
    if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
      return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
    }
    if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
      return nodes[idx ^ 1];
    }
    if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
      return newNode;
    }
    const isEditable = ownerID && ownerID === this.ownerID;
    const newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
    const newNodes = exists ? newNode ? setAt(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);
    if (isEditable) {
      this.bitmap = newBitmap;
      this.nodes = newNodes;
      return this;
    }
    return new _BitmapIndexedNode(ownerID, newBitmap, newNodes);
  }
};
var HashArrayMapNode = class _HashArrayMapNode {
  constructor(ownerID, count3, nodes) {
    this.ownerID = ownerID;
    this.count = count3;
    this.nodes = nodes;
  }
  get(shift5, keyHash, key, notSetValue) {
    if (keyHash === void 0) {
      keyHash = hash(key);
    }
    const idx = (shift5 === 0 ? keyHash : keyHash >>> shift5) & MASK;
    const node = this.nodes[idx];
    return node ? node.get(shift5 + SHIFT, keyHash, key, notSetValue) : notSetValue;
  }
  update(ownerID, shift5, keyHash, key, value, didChangeSize, didAlter) {
    if (keyHash === void 0) {
      keyHash = hash(key);
    }
    const idx = (shift5 === 0 ? keyHash : keyHash >>> shift5) & MASK;
    const removed = value === NOT_SET;
    const nodes = this.nodes;
    const node = nodes[idx];
    if (removed && !node) {
      return this;
    }
    const newNode = updateNode(
      node,
      ownerID,
      shift5 + SHIFT,
      keyHash,
      key,
      value,
      didChangeSize,
      didAlter
    );
    if (newNode === node) {
      return this;
    }
    let newCount = this.count;
    if (!node) {
      newCount++;
    } else if (!newNode) {
      newCount--;
      if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
        return packNodes(ownerID, nodes, newCount, idx);
      }
    }
    const isEditable = ownerID && ownerID === this.ownerID;
    const newNodes = setAt(nodes, idx, newNode, isEditable);
    if (isEditable) {
      this.count = newCount;
      this.nodes = newNodes;
      return this;
    }
    return new _HashArrayMapNode(ownerID, newCount, newNodes);
  }
};
var HashCollisionNode = class _HashCollisionNode {
  constructor(ownerID, keyHash, entries) {
    this.ownerID = ownerID;
    this.keyHash = keyHash;
    this.entries = entries;
  }
  get(shift5, keyHash, key, notSetValue) {
    const entries = this.entries;
    for (let ii = 0, len = entries.length; ii < len; ii++) {
      if (Object.is(key, entries[ii][0])) {
        return entries[ii][1];
      }
    }
    return notSetValue;
  }
  update(ownerID, shift5, keyHash, key, value, didChangeSize, didAlter) {
    if (keyHash === void 0) {
      keyHash = hash(key);
    }
    const removed = value === NOT_SET;
    if (keyHash !== this.keyHash) {
      if (removed) {
        return this;
      }
      SetRef(didAlter);
      SetRef(didChangeSize);
      return mergeIntoNode(this, ownerID, shift5, keyHash, [key, value]);
    }
    const entries = this.entries;
    let idx = 0;
    const len = entries.length;
    for (; idx < len; idx++) {
      if (Object.is(key, entries[idx][0])) {
        break;
      }
    }
    const exists = idx < len;
    if (exists ? entries[idx][1] === value : removed) {
      return this;
    }
    SetRef(didAlter);
    if (removed || !exists) SetRef(didChangeSize);
    if (removed && len === 2) {
      return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
    }
    const isEditable = ownerID && ownerID === this.ownerID;
    const newEntries = isEditable ? entries : arrCopy(entries);
    if (exists) {
      if (removed) {
        if (idx === len - 1) {
          newEntries.pop();
        } else {
          newEntries[idx] = newEntries.pop();
        }
      } else {
        newEntries[idx] = [key, value];
      }
    } else {
      newEntries.push([key, value]);
    }
    if (isEditable) {
      this.entries = newEntries;
      return this;
    }
    return new _HashCollisionNode(ownerID, this.keyHash, newEntries);
  }
};
var ValueNode = class _ValueNode {
  constructor(ownerID, keyHash, entry) {
    this.ownerID = ownerID;
    this.keyHash = keyHash;
    this.entry = entry;
  }
  get(shift5, keyHash, key, notSetValue) {
    return Object.is(key, this.entry[0]) ? this.entry[1] : notSetValue;
  }
  update(ownerID, shift5, keyHash, key, value, didChangeSize, didAlter) {
    const removed = value === NOT_SET;
    const keyMatch = Object.is(key, this.entry[0]);
    if (keyMatch ? value === this.entry[1] : removed) {
      return this;
    }
    SetRef(didAlter);
    if (removed) {
      SetRef(didChangeSize);
      return;
    }
    if (keyMatch) {
      if (ownerID && ownerID === this.ownerID) {
        this.entry[1] = value;
        return this;
      }
      return new _ValueNode(ownerID, this.keyHash, [key, value]);
    }
    SetRef(didChangeSize);
    return mergeIntoNode(this, ownerID, shift5, hash(key), [key, value]);
  }
};
var MapIterator = class {
  constructor(map2, _type, _reverse) {
    __publicField(this, "_stack");
    this._type = _type;
    this._reverse = _reverse;
    this._stack = map2._root && mapIteratorFrame(map2._root);
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const type = this._type;
    let stack2 = this._stack;
    while (stack2) {
      const node = stack2.node;
      const index2 = stack2.index++;
      let maxIndex;
      if (node.entry) {
        if (index2 === 0) {
          return mapIteratorValue(type, node.entry);
        }
      } else if ("entries" in node && node.entries) {
        maxIndex = node.entries.length - 1;
        if (index2 <= maxIndex) {
          return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index2 : index2]);
        }
      } else {
        maxIndex = node.nodes.length - 1;
        if (index2 <= maxIndex) {
          const subNode = node.nodes[this._reverse ? maxIndex - index2 : index2];
          if (subNode) {
            if (subNode.entry) {
              return mapIteratorValue(type, subNode.entry);
            }
            stack2 = this._stack = mapIteratorFrame(subNode, stack2);
          }
          continue;
        }
      }
      stack2 = this._stack = this._stack.__prev;
    }
    return iteratorDone();
  }
};
function mapIteratorValue(type, entry) {
  return iteratorValue(type, entry[0], entry[1]);
}
function mapIteratorFrame(node, prev) {
  return {
    node,
    index: 0,
    __prev: prev
  };
}
var ITERATE_KEYS = 0;
var ITERATE_VALUES = 1;
var ITERATE_ENTRIES = 2;
function iteratorValue(type, k, v, iteratorResult) {
  const value = type === ITERATE_KEYS ? k : type === ITERATE_VALUES ? v : [k, v];
  if (iteratorResult) {
    iteratorResult.value = value;
  } else {
    iteratorResult = { value, done: false };
  }
  return iteratorResult;
}
function iteratorDone() {
  return { value: void 0, done: true };
}
function makeMap(size4, root, ownerID, hash2) {
  const map2 = Object.create(ImmutableMap.prototype);
  map2.size = size4;
  map2._root = root;
  map2.__ownerID = ownerID;
  map2.__hash = hash2;
  map2.__altered = false;
  return map2;
}
var EMPTY_MAP;
function emptyMap() {
  return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
}
function updateMap(map2, k, v) {
  let newRoot;
  let newSize;
  if (!map2._root) {
    if (v === NOT_SET) {
      return map2;
    }
    newSize = 1;
    newRoot = new ArrayMapNode(map2.__ownerID, [[k, v]]);
  } else {
    const didChangeSize = MakeRef();
    const didAlter = MakeRef();
    newRoot = updateNode(map2._root, map2.__ownerID, 0, void 0, k, v, didChangeSize, didAlter);
    if (!didAlter.value) {
      return map2;
    }
    newSize = map2.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
  }
  if (map2.__ownerID) {
    map2.size = newSize;
    map2._root = newRoot;
    map2.__hash = void 0;
    map2.__altered = true;
    return map2;
  }
  return newRoot ? makeMap(newSize, newRoot) : emptyMap();
}
function updateNode(node, ownerID, shift5, keyHash, key, value, didChangeSize, didAlter) {
  if (!node) {
    if (value === NOT_SET) {
      return node;
    }
    SetRef(didAlter);
    SetRef(didChangeSize);
    return new ValueNode(ownerID, keyHash, [key, value]);
  }
  return node.update(ownerID, shift5, keyHash, key, value, didChangeSize, didAlter);
}
function isLeafNode(node) {
  return node.constructor === ValueNode || node.constructor === HashCollisionNode;
}
function mergeIntoNode(node, ownerID, shift5, keyHash, entry) {
  if (node.keyHash === keyHash) {
    return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
  }
  const idx1 = (shift5 === 0 ? node.keyHash : node.keyHash >>> shift5) & MASK;
  const idx2 = (shift5 === 0 ? keyHash : keyHash >>> shift5) & MASK;
  let newNode;
  const nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift5 + SHIFT, keyHash, entry)] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [node, newNode] : [newNode, node]);
  return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);
}
function createNodes(ownerID, entries, key, value) {
  if (!ownerID) {
    ownerID = new OwnerID();
  }
  let node = new ValueNode(ownerID, hash(key), [key, value]);
  for (let ii = 0; ii < entries.length; ii++) {
    const entry = entries[ii];
    node = node.update(ownerID, 0, void 0, entry[0], entry[1]);
  }
  return node;
}
function packNodes(ownerID, nodes, count3, excluding) {
  let bitmap = 0;
  let packedII = 0;
  const packedNodes = new Array(count3);
  for (let ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
    const node = nodes[ii];
    if (node !== void 0 && ii !== excluding) {
      bitmap |= bit;
      packedNodes[packedII++] = node;
    }
  }
  return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
}
function expandNodes(ownerID, nodes, bitmap, including, node) {
  let count3 = 0;
  const expandedNodes = new Array(SIZE);
  for (let ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
    expandedNodes[ii] = bitmap & 1 ? nodes[count3++] : void 0;
  }
  expandedNodes[including] = node;
  return new HashArrayMapNode(ownerID, count3 + 1, expandedNodes);
}
function popCount(x) {
  x -= x >> 1 & 1431655765;
  x = (x & 858993459) + (x >> 2 & 858993459);
  x = x + (x >> 4) & 252645135;
  x += x >> 8;
  x += x >> 16;
  return x & 127;
}
function setAt(array, idx, val, canEdit) {
  const newArray = canEdit ? array : arrCopy(array);
  newArray[idx] = val;
  return newArray;
}
function spliceIn(array, idx, val, canEdit) {
  const newLen = array.length + 1;
  if (canEdit && idx + 1 === newLen) {
    array[idx] = val;
    return array;
  }
  const newArray = new Array(newLen);
  let after = 0;
  for (let ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      newArray[ii] = val;
      after = -1;
    } else {
      newArray[ii] = array[ii + after];
    }
  }
  return newArray;
}
function spliceOut(array, idx, canEdit) {
  const newLen = array.length - 1;
  if (canEdit && idx === newLen) {
    array.pop();
    return array;
  }
  const newArray = new Array(newLen);
  let after = 0;
  for (let ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      after = 1;
    }
    newArray[ii] = array[ii + after];
  }
  return newArray;
}
var MAX_ARRAY_MAP_SIZE = SIZE / 4;
var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

// ../node_modules/@tldraw/store/dist-esm/lib/AtomMap.mjs
var _a, _b;
var AtomMap = class {
  /**
   * Creates a new AtomMap instance.
   *
   * name - A unique name for this map, used for atom identification
   * entries - Optional initial entries to populate the map with
   * @example
   * ```ts
   * // Create an empty map
   * const map = new AtomMap('userMap')
   *
   * // Create a map with initial data
   * const initialData: [string, number][] = [['a', 1], ['b', 2]]
   * const mapWithData = new AtomMap('numbersMap', initialData)
   * ```
   */
  constructor(name, entries) {
    __publicField(this, "atoms");
    /**
     * The string tag used by Object.prototype.toString for this class.
     *
     * @example
     * ```ts
     * const map = new AtomMap('myMap')
     * console.log(Object.prototype.toString.call(map)) // '[object AtomMap]'
     * ```
     */
    __publicField(this, _a, "AtomMap");
    this.name = name;
    let atoms = emptyMap();
    if (entries) {
      atoms = atoms.withMutations((atoms2) => {
        for (const [k, v] of entries) {
          atoms2.set(k, atom(`${name}:${String(k)}`, v));
        }
      });
    }
    this.atoms = atom(`${name}:atoms`, atoms);
  }
  /**
   * Retrieves the underlying atom for a given key.
   *
   * @param key - The key to retrieve the atom for
   * @returns The atom containing the value, or undefined if the key doesn't exist
   * @internal
   */
  getAtom(key) {
    const valueAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
    if (!valueAtom) {
      this.atoms.get();
      return void 0;
    }
    return valueAtom;
  }
  /**
   * Gets the value associated with a key. Returns undefined if the key doesn't exist.
   * This method is reactive and will cause reactive contexts to update when the value changes.
   *
   * @param key - The key to retrieve the value for
   * @returns The value associated with the key, or undefined if not found
   * @example
   * ```ts
   * const map = new AtomMap('myMap')
   * map.set('name', 'Alice')
   * console.log(map.get('name')) // 'Alice'
   * console.log(map.get('missing')) // undefined
   * ```
   */
  get(key) {
    var _a6;
    const value = (_a6 = this.getAtom(key)) == null ? void 0 : _a6.get();
    assert(value !== UNINITIALIZED);
    return value;
  }
  /**
   * Gets the value associated with a key without creating reactive dependencies.
   * This method will not cause reactive contexts to update when the value changes.
   *
   * @param key - The key to retrieve the value for
   * @returns The value associated with the key, or undefined if not found
   * @example
   * ```ts
   * const map = new AtomMap('myMap')
   * map.set('count', 42)
   * const value = map.__unsafe__getWithoutCapture('count') // No reactive subscription
   * ```
   */
  __unsafe__getWithoutCapture(key) {
    const valueAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
    if (!valueAtom) return void 0;
    const value = valueAtom.__unsafe__getWithoutCapture();
    assert(value !== UNINITIALIZED);
    return value;
  }
  /**
   * Checks whether a key exists in the map.
   * This method is reactive and will cause reactive contexts to update when keys are added or removed.
   *
   * @param key - The key to check for
   * @returns True if the key exists in the map, false otherwise
   * @example
   * ```ts
   * const map = new AtomMap('myMap')
   * console.log(map.has('name')) // false
   * map.set('name', 'Alice')
   * console.log(map.has('name')) // true
   * ```
   */
  has(key) {
    const valueAtom = this.getAtom(key);
    if (!valueAtom) {
      return false;
    }
    return valueAtom.get() !== UNINITIALIZED;
  }
  /**
   * Checks whether a key exists in the map without creating reactive dependencies.
   * This method will not cause reactive contexts to update when keys are added or removed.
   *
   * @param key - The key to check for
   * @returns True if the key exists in the map, false otherwise
   * @example
   * ```ts
   * const map = new AtomMap('myMap')
   * map.set('active', true)
   * const exists = map.__unsafe__hasWithoutCapture('active') // No reactive subscription
   * ```
   */
  __unsafe__hasWithoutCapture(key) {
    const valueAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
    if (!valueAtom) return false;
    assert(valueAtom.__unsafe__getWithoutCapture() !== UNINITIALIZED);
    return true;
  }
  /**
   * Sets a value for the given key. If the key already exists, its value is updated.
   * If the key doesn't exist, a new entry is created.
   *
   * @param key - The key to set the value for
   * @param value - The value to associate with the key
   * @returns This AtomMap instance for method chaining
   * @example
   * ```ts
   * const map = new AtomMap('myMap')
   * map.set('name', 'Alice').set('age', 30)
   * ```
   */
  set(key, value) {
    const existingAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
    if (existingAtom) {
      existingAtom.set(value);
    } else {
      this.atoms.update((atoms) => {
        return atoms.set(key, atom(`${this.name}:${String(key)}`, value));
      });
    }
    return this;
  }
  /**
   * Updates an existing value using an updater function.
   *
   * @param key - The key of the value to update
   * @param updater - A function that receives the current value and returns the new value
   * @throws Error if the key doesn't exist in the map
   * @example
   * ```ts
   * const map = new AtomMap('myMap')
   * map.set('count', 5)
   * map.update('count', count => count + 1) // count is now 6
   * ```
   */
  update(key, updater) {
    const valueAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
    if (!valueAtom) {
      throw new Error(`AtomMap: key ${key} not found`);
    }
    const value = valueAtom.__unsafe__getWithoutCapture();
    assert(value !== UNINITIALIZED);
    valueAtom.set(updater(value));
  }
  /**
   * Removes a key-value pair from the map.
   *
   * @param key - The key to remove
   * @returns True if the key existed and was removed, false if it didn't exist
   * @example
   * ```ts
   * const map = new AtomMap('myMap')
   * map.set('temp', 'value')
   * console.log(map.delete('temp')) // true
   * console.log(map.delete('missing')) // false
   * ```
   */
  delete(key) {
    const valueAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
    if (!valueAtom) {
      return false;
    }
    transact(() => {
      valueAtom.set(UNINITIALIZED);
      this.atoms.update((atoms) => {
        return atoms.delete(key);
      });
    });
    return true;
  }
  /**
   * Removes multiple key-value pairs from the map in a single transaction.
   *
   * @param keys - An iterable of keys to remove
   * @returns An array of [key, value] pairs that were actually deleted
   * @example
   * ```ts
   * const map = new AtomMap('myMap')
   * map.set('a', 1).set('b', 2).set('c', 3)
   * const deleted = map.deleteMany(['a', 'c', 'missing'])
   * console.log(deleted) // [['a', 1], ['c', 3]]
   * ```
   */
  deleteMany(keys3) {
    return transact(() => {
      const deleted = [];
      const newAtoms = this.atoms.get().withMutations((atoms) => {
        for (const key of keys3) {
          const valueAtom = atoms.get(key);
          if (!valueAtom) continue;
          const oldValue = valueAtom.get();
          assert(oldValue !== UNINITIALIZED);
          deleted.push([key, oldValue]);
          atoms.delete(key);
          valueAtom.set(UNINITIALIZED);
        }
      });
      if (deleted.length) {
        this.atoms.set(newAtoms);
      }
      return deleted;
    });
  }
  /**
   * Removes all key-value pairs from the map.
   *
   * @example
   * ```ts
   * const map = new AtomMap('myMap')
   * map.set('a', 1).set('b', 2)
   * map.clear()
   * console.log(map.size) // 0
   * ```
   */
  clear() {
    return transact(() => {
      for (const valueAtom of this.atoms.__unsafe__getWithoutCapture().values()) {
        valueAtom.set(UNINITIALIZED);
      }
      this.atoms.set(emptyMap());
    });
  }
  /**
   * Returns an iterator that yields [key, value] pairs for each entry in the map.
   * This method is reactive and will cause reactive contexts to update when entries change.
   *
   * @returns A generator that yields [key, value] tuples
   * @example
   * ```ts
   * const map = new AtomMap('myMap')
   * map.set('a', 1).set('b', 2)
   * for (const [key, value] of map.entries()) {
   *   console.log(`${key}: ${value}`)
   * }
   * ```
   */
  *entries() {
    for (const [key, valueAtom] of this.atoms.get()) {
      const value = valueAtom.get();
      assert(value !== UNINITIALIZED);
      yield [key, value];
    }
  }
  /**
   * Returns an iterator that yields all keys in the map.
   * This method is reactive and will cause reactive contexts to update when keys change.
   *
   * @returns A generator that yields keys
   * @example
   * ```ts
   * const map = new AtomMap('myMap')
   * map.set('name', 'Alice').set('age', 30)
   * for (const key of map.keys()) {
   *   console.log(key) // 'name', 'age'
   * }
   * ```
   */
  *keys() {
    for (const key of this.atoms.get().keys()) {
      yield key;
    }
  }
  /**
   * Returns an iterator that yields all values in the map.
   * This method is reactive and will cause reactive contexts to update when values change.
   *
   * @returns A generator that yields values
   * @example
   * ```ts
   * const map = new AtomMap('myMap')
   * map.set('name', 'Alice').set('age', 30)
   * for (const value of map.values()) {
   *   console.log(value) // 'Alice', 30
   * }
   * ```
   */
  *values() {
    for (const valueAtom of this.atoms.get().values()) {
      const value = valueAtom.get();
      assert(value !== UNINITIALIZED);
      yield value;
    }
  }
  /**
   * The number of key-value pairs in the map.
   * This property is reactive and will cause reactive contexts to update when the size changes.
   *
   * @returns The number of entries in the map
   * @example
   * ```ts
   * const map = new AtomMap('myMap')
   * console.log(map.size) // 0
   * map.set('a', 1)
   * console.log(map.size) // 1
   * ```
   */
  // eslint-disable-next-line no-restricted-syntax
  get size() {
    return this.atoms.get().size;
  }
  /**
   * Executes a provided function once for each key-value pair in the map.
   * This method is reactive and will cause reactive contexts to update when entries change.
   *
   * @param callbackfn - Function to execute for each entry
   *   - value - The value of the current entry
   *   - key - The key of the current entry
   *   - map - The AtomMap being traversed
   * @param thisArg - Value to use as `this` when executing the callback
   * @example
   * ```ts
   * const map = new AtomMap('myMap')
   * map.set('a', 1).set('b', 2)
   * map.forEach((value, key) => {
   *   console.log(`${key} = ${value}`)
   * })
   * ```
   */
  forEach(callbackfn, thisArg) {
    for (const [key, value] of this.entries()) {
      callbackfn.call(thisArg, value, key, this);
    }
  }
  /**
   * Returns the default iterator for the map, which is the same as entries().
   * This allows the map to be used in for...of loops and other iterable contexts.
   *
   * @returns The same iterator as entries()
   * @example
   * ```ts
   * const map = new AtomMap('myMap')
   * map.set('a', 1).set('b', 2)
   *
   * // These are equivalent:
   * for (const [key, value] of map) {
   *   console.log(`${key}: ${value}`)
   * }
   *
   * for (const [key, value] of map.entries()) {
   *   console.log(`${key}: ${value}`)
   * }
   * ```
   */
  [(_b = Symbol.iterator, _a = Symbol.toStringTag, _b)]() {
    return this.entries();
  }
};

// ../node_modules/@tldraw/store/dist-esm/lib/AtomSet.mjs
var _a2, _b2;
var AtomSet = class {
  constructor(name, keys3) {
    __publicField(this, "map");
    __publicField(this, _a2, "AtomSet");
    this.name = name;
    const entries = keys3 ? Array.from(keys3, (k) => [k, k]) : void 0;
    this.map = new AtomMap(name, entries);
  }
  add(value) {
    this.map.set(value, value);
    return this;
  }
  clear() {
    this.map.clear();
  }
  delete(value) {
    return this.map.delete(value);
  }
  forEach(callbackfn, thisArg) {
    for (const value of this) {
      callbackfn.call(thisArg, value, value, this);
    }
  }
  has(value) {
    return this.map.has(value);
  }
  // eslint-disable-next-line no-restricted-syntax
  get size() {
    return this.map.size;
  }
  entries() {
    return this.map.entries();
  }
  keys() {
    return this.map.keys();
  }
  values() {
    return this.map.keys();
  }
  [(_b2 = Symbol.iterator, _a2 = Symbol.toStringTag, _b2)]() {
    return this.map.keys();
  }
};

// ../node_modules/@tldraw/store/dist-esm/lib/isDev.mjs
var _isDev = false;
try {
  _isDev = true;
} catch (_e) {
}
try {
  _isDev = _isDev || import.meta.env.DEV || import.meta.env.TEST || import.meta.env.MODE === "development" || import.meta.env.MODE === "test";
} catch (_e) {
}
function isDev() {
  return _isDev;
}

// ../node_modules/@tldraw/store/dist-esm/lib/devFreeze.mjs
function devFreeze(object) {
  if (!isDev()) return object;
  const proto = Object.getPrototypeOf(object);
  if (proto && !(Array.isArray(object) || proto === Object.prototype || proto === null || proto === STRUCTURED_CLONE_OBJECT_PROTOTYPE)) {
    console.error("cannot include non-js data in a record", object);
    throw new Error("cannot include non-js data in a record");
  }
  if (Object.isFrozen(object)) {
    return object;
  }
  const propNames = Object.getOwnPropertyNames(object);
  for (const name of propNames) {
    const value = object[name];
    if (value && typeof value === "object") {
      devFreeze(value);
    }
  }
  return Object.freeze(object);
}

// ../node_modules/@tldraw/store/dist-esm/lib/IncrementalSetConstructor.mjs
var IncrementalSetConstructor = class {
  constructor(previousValue) {
    /**
     * The next value of the set.
     *
     * @internal
     */
    __publicField(this, "nextValue");
    /**
     * The diff of the set.
     *
     * @internal
     */
    __publicField(this, "diff");
    this.previousValue = previousValue;
  }
  /**
   * Gets the result of the incremental set construction if any changes were made.
   * Returns undefined if no additions or removals occurred.
   *
   * @returns An object containing the final set value and the diff of changes,
   * or undefined if no changes were made
   *
   * @example
   * ```ts
   * const constructor = new IncrementalSetConstructor(new Set(['a', 'b']))
   * constructor.add('c')
   *
   * const result = constructor.get()
   * // result = {
   * //   value: Set(['a', 'b', 'c']),
   * //   diff: { added: Set(['c']) }
   * // }
   * ```
   *
   * @public
   */
  get() {
    var _a6, _b3, _c, _d;
    const numRemoved = ((_b3 = (_a6 = this.diff) == null ? void 0 : _a6.removed) == null ? void 0 : _b3.size) ?? 0;
    const numAdded = ((_d = (_c = this.diff) == null ? void 0 : _c.added) == null ? void 0 : _d.size) ?? 0;
    if (numRemoved === 0 && numAdded === 0) {
      return void 0;
    }
    return { value: this.nextValue, diff: this.diff };
  }
  /**
   * Add an item to the set.
   *
   * @param item - The item to add.
   * @param wasAlreadyPresent - Whether the item was already present in the set.
   * @internal
   */
  _add(item, wasAlreadyPresent) {
    var _a6, _b3;
    this.nextValue ?? (this.nextValue = new Set(this.previousValue));
    this.nextValue.add(item);
    this.diff ?? (this.diff = {});
    if (wasAlreadyPresent) {
      (_a6 = this.diff.removed) == null ? void 0 : _a6.delete(item);
    } else {
      (_b3 = this.diff).added ?? (_b3.added = /* @__PURE__ */ new Set());
      this.diff.added.add(item);
    }
  }
  /**
   * Adds an item to the set. If the item was already present in the original set
   * and was previously removed during this construction, it will be restored.
   * If the item is already present and wasn't removed, this is a no-op.
   *
   * @param item - The item to add to the set
   *
   * @example
   * ```ts
   * const constructor = new IncrementalSetConstructor(new Set(['a', 'b']))
   * constructor.add('c') // Adds new item
   * constructor.add('a') // No-op, already present
   * constructor.remove('b')
   * constructor.add('b') // Restores previously removed item
   * ```
   *
   * @public
   */
  add(item) {
    var _a6, _b3, _c;
    const wasAlreadyPresent = this.previousValue.has(item);
    if (wasAlreadyPresent) {
      const wasRemoved = (_b3 = (_a6 = this.diff) == null ? void 0 : _a6.removed) == null ? void 0 : _b3.has(item);
      if (!wasRemoved) return;
      return this._add(item, wasAlreadyPresent);
    }
    const isCurrentlyPresent = (_c = this.nextValue) == null ? void 0 : _c.has(item);
    if (isCurrentlyPresent) return;
    this._add(item, wasAlreadyPresent);
  }
  /**
   * Remove an item from the set.
   *
   * @param item - The item to remove.
   * @param wasAlreadyPresent - Whether the item was already present in the set.
   * @internal
   */
  _remove(item, wasAlreadyPresent) {
    var _a6, _b3;
    this.nextValue ?? (this.nextValue = new Set(this.previousValue));
    this.nextValue.delete(item);
    this.diff ?? (this.diff = {});
    if (wasAlreadyPresent) {
      (_a6 = this.diff).removed ?? (_a6.removed = /* @__PURE__ */ new Set());
      this.diff.removed.add(item);
    } else {
      (_b3 = this.diff.added) == null ? void 0 : _b3.delete(item);
    }
  }
  /**
   * Removes an item from the set. If the item wasn't present in the original set
   * and was added during this construction, it will be removed from the added diff.
   * If the item is not present at all, this is a no-op.
   *
   * @param item - The item to remove from the set
   *
   * @example
   * ```ts
   * const constructor = new IncrementalSetConstructor(new Set(['a', 'b']))
   * constructor.remove('a') // Removes existing item
   * constructor.remove('c') // No-op, not present
   * constructor.add('d')
   * constructor.remove('d') // Removes recently added item
   * ```
   *
   * @public
   */
  remove(item) {
    var _a6, _b3, _c, _d;
    const wasAlreadyPresent = this.previousValue.has(item);
    if (!wasAlreadyPresent) {
      const wasAdded = (_b3 = (_a6 = this.diff) == null ? void 0 : _a6.added) == null ? void 0 : _b3.has(item);
      if (!wasAdded) return;
      return this._remove(item, wasAlreadyPresent);
    }
    const hasAlreadyBeenRemoved = (_d = (_c = this.diff) == null ? void 0 : _c.removed) == null ? void 0 : _d.has(item);
    if (hasAlreadyBeenRemoved) return;
    this._remove(item, wasAlreadyPresent);
  }
};

// ../node_modules/@tldraw/store/dist-esm/lib/migrate.mjs
function squashDependsOn(sequence) {
  const result = [];
  for (let i = sequence.length - 1; i >= 0; i--) {
    const elem = sequence[i];
    if (!("id" in elem)) {
      const dependsOn = elem.dependsOn;
      const prev = result[0];
      if (prev) {
        result[0] = {
          ...prev,
          dependsOn: dependsOn.concat(prev.dependsOn ?? [])
        };
      }
    } else {
      result.unshift(elem);
    }
  }
  return result;
}
function createMigrationSequence({
  sequence,
  sequenceId,
  retroactive = true
}) {
  const migrations = {
    sequenceId,
    retroactive,
    sequence: squashDependsOn(sequence)
  };
  validateMigrations(migrations);
  return migrations;
}
function createMigrationIds(sequenceId, versions) {
  return Object.fromEntries(
    objectMapEntries(versions).map(([key, version2]) => [key, `${sequenceId}/${version2}`])
  );
}
function createRecordMigrationSequence(opts) {
  const sequenceId = opts.sequenceId;
  return createMigrationSequence({
    sequenceId,
    retroactive: opts.retroactive ?? true,
    sequence: opts.sequence.map(
      (m) => "id" in m ? {
        ...m,
        scope: "record",
        filter: (r) => {
          var _a6, _b3;
          return r.typeName === opts.recordType && (((_a6 = m.filter) == null ? void 0 : _a6.call(m, r)) ?? true) && (((_b3 = opts.filter) == null ? void 0 : _b3.call(opts, r)) ?? true);
        }
      } : m
    )
  });
}
function sortMigrations(migrations) {
  if (migrations.length === 0) return [];
  const byId = new Map(migrations.map((m) => [m.id, m]));
  const dependents = /* @__PURE__ */ new Map();
  const inDegree = /* @__PURE__ */ new Map();
  const explicitDeps = /* @__PURE__ */ new Map();
  for (const m of migrations) {
    inDegree.set(m.id, 0);
    dependents.set(m.id, /* @__PURE__ */ new Set());
    explicitDeps.set(m.id, /* @__PURE__ */ new Set());
  }
  for (const m of migrations) {
    const { version: version2, sequenceId } = parseMigrationId(m.id);
    const prevId = `${sequenceId}/${version2 - 1}`;
    if (byId.has(prevId)) {
      dependents.get(prevId).add(m.id);
      inDegree.set(m.id, inDegree.get(m.id) + 1);
    }
    if (m.dependsOn) {
      for (const depId of m.dependsOn) {
        if (byId.has(depId)) {
          dependents.get(depId).add(m.id);
          explicitDeps.get(m.id).add(depId);
          inDegree.set(m.id, inDegree.get(m.id) + 1);
        }
      }
    }
  }
  const ready = migrations.filter((m) => inDegree.get(m.id) === 0);
  const result = [];
  const processed = /* @__PURE__ */ new Set();
  while (ready.length > 0) {
    let bestCandidate;
    let bestCandidateScore = -Infinity;
    for (const m of ready) {
      let urgencyScore = 0;
      for (const depId of dependents.get(m.id) || []) {
        if (!processed.has(depId)) {
          urgencyScore += 1;
          if (explicitDeps.get(depId).has(m.id)) {
            urgencyScore += 100;
          }
        }
      }
      if (urgencyScore > bestCandidateScore || // Tiebreaker: prefer lower sequence/version
      urgencyScore === bestCandidateScore && m.id.localeCompare((bestCandidate == null ? void 0 : bestCandidate.id) ?? "") < 0) {
        bestCandidate = m;
        bestCandidateScore = urgencyScore;
      }
    }
    const nextMigration = bestCandidate;
    ready.splice(ready.indexOf(nextMigration), 1);
    result.push(nextMigration);
    processed.add(nextMigration.id);
    for (const depId of dependents.get(nextMigration.id) || []) {
      if (!processed.has(depId)) {
        inDegree.set(depId, inDegree.get(depId) - 1);
        if (inDegree.get(depId) === 0) {
          ready.push(byId.get(depId));
        }
      }
    }
  }
  if (result.length !== migrations.length) {
    const unprocessed = migrations.filter((m) => !processed.has(m.id));
    assert(false, `Circular dependency in migrations: ${unprocessed[0].id}`);
  }
  return result;
}
function parseMigrationId(id) {
  const [sequenceId, version2] = id.split("/");
  return { sequenceId, version: parseInt(version2) };
}
function validateMigrationId(id, expectedSequenceId) {
  if (expectedSequenceId) {
    assert(
      id.startsWith(expectedSequenceId + "/"),
      `Every migration in sequence '${expectedSequenceId}' must have an id starting with '${expectedSequenceId}/'. Got invalid id: '${id}'`
    );
  }
  assert(id.match(/^(.*?)\/(0|[1-9]\d*)$/), `Invalid migration id: '${id}'`);
}
function validateMigrations(migrations) {
  assert(
    !migrations.sequenceId.includes("/"),
    `sequenceId cannot contain a '/', got ${migrations.sequenceId}`
  );
  assert(migrations.sequenceId.length, "sequenceId must be a non-empty string");
  if (migrations.sequence.length === 0) {
    return;
  }
  validateMigrationId(migrations.sequence[0].id, migrations.sequenceId);
  let n = parseMigrationId(migrations.sequence[0].id).version;
  assert(
    n === 1,
    `Expected the first migrationId to be '${migrations.sequenceId}/1' but got '${migrations.sequence[0].id}'`
  );
  for (let i = 1; i < migrations.sequence.length; i++) {
    const id = migrations.sequence[i].id;
    validateMigrationId(id, migrations.sequenceId);
    const m = parseMigrationId(id).version;
    assert(
      m === n + 1,
      `Migration id numbers must increase in increments of 1, expected ${migrations.sequenceId}/${n + 1} but got '${migrations.sequence[i].id}'`
    );
    n = m;
  }
}
var MigrationFailureReason = ((MigrationFailureReason2) => {
  MigrationFailureReason2["IncompatibleSubtype"] = "incompatible-subtype";
  MigrationFailureReason2["UnknownType"] = "unknown-type";
  MigrationFailureReason2["TargetVersionTooNew"] = "target-version-too-new";
  MigrationFailureReason2["TargetVersionTooOld"] = "target-version-too-old";
  MigrationFailureReason2["MigrationError"] = "migration-error";
  MigrationFailureReason2["UnrecognizedSubtype"] = "unrecognized-subtype";
  return MigrationFailureReason2;
})(MigrationFailureReason || {});

// ../node_modules/@tldraw/store/dist-esm/lib/RecordsDiff.mjs
function createEmptyRecordsDiff() {
  return { added: {}, updated: {}, removed: {} };
}
function reverseRecordsDiff(diff) {
  const result = { added: diff.removed, removed: diff.added, updated: {} };
  for (const [from2, to] of Object.values(diff.updated)) {
    result.updated[from2.id] = [to, from2];
  }
  return result;
}
function isRecordsDiffEmpty(diff) {
  return Object.keys(diff.added).length === 0 && Object.keys(diff.updated).length === 0 && Object.keys(diff.removed).length === 0;
}
function squashRecordDiffs(diffs, options2) {
  const result = (options2 == null ? void 0 : options2.mutateFirstDiff) ? diffs[0] : { added: {}, removed: {}, updated: {} };
  squashRecordDiffsMutable(result, (options2 == null ? void 0 : options2.mutateFirstDiff) ? diffs.slice(1) : diffs);
  return result;
}
function squashRecordDiffsMutable(target, diffs) {
  for (const diff of diffs) {
    for (const [id, value] of objectMapEntries(diff.added)) {
      if (target.removed[id]) {
        const original = target.removed[id];
        delete target.removed[id];
        if (original !== value) {
          target.updated[id] = [original, value];
        }
      } else {
        target.added[id] = value;
      }
    }
    for (const [id, [_from, to]] of objectMapEntries(diff.updated)) {
      if (target.added[id]) {
        target.added[id] = to;
        delete target.updated[id];
        delete target.removed[id];
        continue;
      }
      if (target.updated[id]) {
        target.updated[id] = [target.updated[id][0], to];
        delete target.removed[id];
        continue;
      }
      target.updated[id] = diff.updated[id];
      delete target.removed[id];
    }
    for (const [id, value] of objectMapEntries(diff.removed)) {
      if (target.added[id]) {
        delete target.added[id];
      } else if (target.updated[id]) {
        target.removed[id] = target.updated[id][0];
        delete target.updated[id];
      } else {
        target.removed[id] = value;
      }
    }
  }
}

// ../node_modules/@tldraw/store/dist-esm/lib/RecordType.mjs
var RecordType = class _RecordType {
  /**
   * Creates a new RecordType instance.
   *
   * typeName - The unique type name for records created by this RecordType
   * config - Configuration object for the RecordType
   *   - createDefaultProperties - Function that returns default properties for new records
   *   - validator - Optional validator function for record validation
   *   - scope - Optional scope determining persistence behavior (defaults to 'document')
   *   - ephemeralKeys - Optional mapping of property names to ephemeral status
   * @public
   */
  constructor(typeName, config) {
    /**
     * Factory function that creates default properties for new records.
     * @public
     */
    __publicField(this, "createDefaultProperties");
    /**
     * Validator function used to validate records of this type.
     * @public
     */
    __publicField(this, "validator");
    /**
     * Optional configuration specifying which record properties are ephemeral.
     * Ephemeral properties are not included in snapshots or synchronization.
     * @public
     */
    __publicField(this, "ephemeralKeys");
    /**
     * Set of property names that are marked as ephemeral for efficient lookup.
     * @public
     */
    __publicField(this, "ephemeralKeySet");
    /**
     * The scope that determines how records of this type are persisted and synchronized.
     * @public
     */
    __publicField(this, "scope");
    this.typeName = typeName;
    this.createDefaultProperties = config.createDefaultProperties;
    this.validator = config.validator ?? { validate: (r) => r };
    this.scope = config.scope ?? "document";
    this.ephemeralKeys = config.ephemeralKeys;
    const ephemeralKeySet = /* @__PURE__ */ new Set();
    if (config.ephemeralKeys) {
      for (const [key, isEphemeral] of objectMapEntries(config.ephemeralKeys)) {
        if (isEphemeral) ephemeralKeySet.add(key);
      }
    }
    this.ephemeralKeySet = ephemeralKeySet;
  }
  /**
   * Creates a new record of this type with the given properties.
   *
   * Properties are merged with default properties from the RecordType configuration.
   * If no id is provided, a unique id will be generated automatically.
   *
   * @example
   * ```ts
   * const book = Book.create({
   *   title: 'The Great Gatsby',
   *   author: 'F. Scott Fitzgerald'
   * })
   * // Result: { id: 'book:abc123', typeName: 'book', title: 'The Great Gatsby', author: 'F. Scott Fitzgerald', inStock: true }
   * ```
   *
   * @param properties - The properties for the new record, including both required and optional fields
   * @returns The newly created record with generated id and typeName
   * @public
   */
  create(properties) {
    const result = {
      ...this.createDefaultProperties(),
      id: "id" in properties ? properties.id : this.createId()
    };
    for (const [k, v] of Object.entries(properties)) {
      if (v !== void 0) {
        result[k] = v;
      }
    }
    result.typeName = this.typeName;
    return result;
  }
  /**
   * Creates a deep copy of an existing record with a new unique id.
   *
   * This method performs a deep clone of all properties while generating a fresh id,
   * making it useful for duplicating records without id conflicts.
   *
   * @example
   * ```ts
   * const originalBook = Book.create({ title: '1984', author: 'George Orwell' })
   * const duplicatedBook = Book.clone(originalBook)
   * // duplicatedBook has same properties but different id
   * ```
   *
   * @param record - The record to clone
   * @returns A new record with the same properties but a different id
   * @public
   */
  clone(record) {
    return { ...structuredClone(record), id: this.createId() };
  }
  /**
   * Create a new ID for this record type.
   *
   * @example
   *
   * ```ts
   * const id = recordType.createId()
   * ```
   *
   * @returns The new ID.
   * @public
   */
  createId(customUniquePart) {
    return this.typeName + ":" + (customUniquePart ?? uniqueId());
  }
  /**
   * Extracts the unique identifier part from a full record id.
   *
   * Record ids have the format `typeName:uniquePart`. This method returns just the unique part.
   *
   * @example
   * ```ts
   * const bookId = Book.createId() // 'book:abc123'
   * const uniquePart = Book.parseId(bookId) // 'abc123'
   * ```
   *
   * @param id - The full record id to parse
   * @returns The unique identifier portion after the colon
   * @throws Error if the id is not valid for this record type
   * @public
   */
  parseId(id) {
    if (!this.isId(id)) {
      throw new Error(`ID "${id}" is not a valid ID for type "${this.typeName}"`);
    }
    return id.slice(this.typeName.length + 1);
  }
  /**
   * Type guard that checks whether a record belongs to this RecordType.
   *
   * This method performs a runtime check by comparing the record's typeName
   * against this RecordType's typeName.
   *
   * @example
   * ```ts
   * if (Book.isInstance(someRecord)) {
   *   // someRecord is now typed as a book record
   *   console.log(someRecord.title)
   * }
   * ```
   *
   * @param record - The record to check, may be undefined
   * @returns True if the record is an instance of this record type
   * @public
   */
  isInstance(record) {
    return (record == null ? void 0 : record.typeName) === this.typeName;
  }
  /**
   * Type guard that checks whether an id string belongs to this RecordType.
   *
   * Validates that the id starts with this RecordType's typeName followed by a colon.
   * This is more efficient than parsing the full id when you only need to verify the type.
   *
   * @example
   * ```ts
   * if (Book.isId(someId)) {
   *   // someId is now typed as IdOf<BookRecord>
   *   const book = store.get(someId)
   * }
   * ```
   *
   * @param id - The id string to check, may be undefined
   * @returns True if the id belongs to this record type
   * @public
   */
  isId(id) {
    if (!id) return false;
    for (let i = 0; i < this.typeName.length; i++) {
      if (id[i] !== this.typeName[i]) return false;
    }
    return id[this.typeName.length] === ":";
  }
  /**
   * Create a new RecordType that has the same type name as this RecordType and includes the given
   * default properties.
   *
   * @example
   *
   * ```ts
   * const authorType = createRecordType('author', () => ({ living: true }))
   * const deadAuthorType = authorType.withDefaultProperties({ living: false })
   * ```
   *
   * @param createDefaultProperties - A function that returns the default properties of the new RecordType.
   * @returns The new RecordType.
   */
  withDefaultProperties(createDefaultProperties) {
    return new _RecordType(this.typeName, {
      createDefaultProperties,
      validator: this.validator,
      scope: this.scope,
      ephemeralKeys: this.ephemeralKeys
    });
  }
  /**
   * Validates a record against this RecordType's validator and returns it with proper typing.
   *
   * This method runs the configured validator function and throws an error if validation fails.
   * If a previous version of the record is provided, it may use optimized validation.
   *
   * @example
   * ```ts
   * try {
   *   const validBook = Book.validate(untrustedData)
   *   // validBook is now properly typed and validated
   * } catch (error) {
   *   console.log('Validation failed:', error.message)
   * }
   * ```
   *
   * @param record - The unknown record data to validate
   * @param recordBefore - Optional previous version for optimized validation
   * @returns The validated and properly typed record
   * @throws Error if validation fails
   * @public
   */
  validate(record, recordBefore) {
    if (recordBefore && this.validator.validateUsingKnownGoodVersion) {
      return this.validator.validateUsingKnownGoodVersion(recordBefore, record);
    }
    return this.validator.validate(record);
  }
};
function createRecordType(typeName, config) {
  return new RecordType(typeName, {
    createDefaultProperties: () => ({}),
    validator: config.validator,
    scope: config.scope,
    ephemeralKeys: config.ephemeralKeys
  });
}
function assertIdType(id, type) {
  if (!id || !type.isId(id)) {
    throw new Error(`string ${JSON.stringify(id)} is not a valid ${type.typeName} id`);
  }
}

// ../node_modules/@tldraw/store/dist-esm/lib/setUtils.mjs
function intersectSets(sets) {
  if (sets.length === 0) return /* @__PURE__ */ new Set();
  const first2 = sets[0];
  const rest = sets.slice(1);
  const result = /* @__PURE__ */ new Set();
  for (const val of first2) {
    if (rest.every((set) => set.has(val))) {
      result.add(val);
    }
  }
  return result;
}
function diffSets(prev, next) {
  const result = {};
  for (const val of next) {
    if (!prev.has(val)) {
      result.added ?? (result.added = /* @__PURE__ */ new Set());
      result.added.add(val);
    }
  }
  for (const val of prev) {
    if (!next.has(val)) {
      result.removed ?? (result.removed = /* @__PURE__ */ new Set());
      result.removed.add(val);
    }
  }
  return result.added || result.removed ? result : void 0;
}

// ../node_modules/@tldraw/store/dist-esm/lib/executeQuery.mjs
function isQueryValueMatcher(value) {
  if (typeof value !== "object" || value === null) return false;
  return "eq" in value || "neq" in value || "gt" in value;
}
function extractMatcherPaths(query, prefix = "") {
  const paths = [];
  for (const [key, value] of Object.entries(query)) {
    const currentPath = prefix ? `${prefix}\\${key}` : key;
    if (isQueryValueMatcher(value)) {
      paths.push({ path: currentPath, matcher: value });
    } else if (typeof value === "object" && value !== null) {
      paths.push(...extractMatcherPaths(value, currentPath));
    }
  }
  return paths;
}
function objectMatchesQuery(query, object) {
  for (const [key, matcher] of Object.entries(query)) {
    const value = object[key];
    if (isQueryValueMatcher(matcher)) {
      if ("eq" in matcher && value !== matcher.eq) return false;
      if ("neq" in matcher && value === matcher.neq) return false;
      if ("gt" in matcher && (typeof value !== "number" || value <= matcher.gt)) return false;
      continue;
    }
    if (typeof value !== "object" || value === null) return false;
    if (!objectMatchesQuery(matcher, value)) {
      return false;
    }
  }
  return true;
}
function executeQuery(store, typeName, query) {
  const matcherPaths = extractMatcherPaths(query);
  const matchIds = Object.fromEntries(matcherPaths.map(({ path }) => [path, /* @__PURE__ */ new Set()]));
  for (const { path, matcher } of matcherPaths) {
    const index2 = store.index(typeName, path);
    if ("eq" in matcher) {
      const ids = index2.get().get(matcher.eq);
      if (ids) {
        for (const id of ids) {
          matchIds[path].add(id);
        }
      }
    } else if ("neq" in matcher) {
      for (const [value, ids] of index2.get()) {
        if (value !== matcher.neq) {
          for (const id of ids) {
            matchIds[path].add(id);
          }
        }
      }
    } else if ("gt" in matcher) {
      for (const [value, ids] of index2.get()) {
        if (typeof value === "number" && value > matcher.gt) {
          for (const id of ids) {
            matchIds[path].add(id);
          }
        }
      }
    }
    if (matchIds[path].size === 0) {
      return /* @__PURE__ */ new Set();
    }
  }
  return intersectSets(Object.values(matchIds));
}

// ../node_modules/@tldraw/store/dist-esm/lib/StoreQueries.mjs
var StoreQueries = class {
  /**
   * Creates a new StoreQueries instance.
   *
   * recordMap - The atom map containing all records in the store
   * history - The atom tracking the store's change history with diffs
   *
   * @internal
   */
  constructor(recordMap, history2) {
    /**
     * A cache of derivations (indexes).
     *
     * @internal
     */
    __publicField(this, "indexCache", /* @__PURE__ */ new Map());
    /**
     * A cache of derivations (filtered histories).
     *
     * @internal
     */
    __publicField(this, "historyCache", /* @__PURE__ */ new Map());
    this.recordMap = recordMap;
    this.history = history2;
  }
  /**
   * @internal
   */
  getAllIdsForType(typeName) {
    const ids = /* @__PURE__ */ new Set();
    for (const record of this.recordMap.values()) {
      if (record.typeName === typeName) {
        ids.add(record.id);
      }
    }
    return ids;
  }
  /**
   * @internal
   */
  getRecordById(typeName, id) {
    const record = this.recordMap.get(id);
    if (record && record.typeName === typeName) {
      return record;
    }
    return void 0;
  }
  /**
   * Helper to extract nested property value using pre-split path parts.
   * @internal
   */
  getNestedValue(obj, pathParts) {
    let current = obj;
    for (const part of pathParts) {
      if (current == null || typeof current !== "object") return void 0;
      current = current[part];
    }
    return current;
  }
  /**
   * Creates a reactive computed that tracks the change history for records of a specific type.
   * The returned computed provides incremental diffs showing what records of the given type
   * have been added, updated, or removed.
   *
   * @param typeName - The type name to filter the history by
   * @returns A computed value containing the current epoch and diffs of changes for the specified type
   *
   * @example
   * ```ts
   * // Track changes to book records only
   * const bookHistory = store.query.filterHistory('book')
   *
   * // React to book changes
   * react('book-changes', () => {
   *   const currentEpoch = bookHistory.get()
   *   console.log('Books updated at epoch:', currentEpoch)
   * })
   * ```
   *
   * @public
   */
  filterHistory(typeName) {
    if (this.historyCache.has(typeName)) {
      return this.historyCache.get(typeName);
    }
    const filtered = computed(
      "filterHistory:" + typeName,
      (lastValue, lastComputedEpoch) => {
        if (isUninitialized(lastValue)) {
          return this.history.get();
        }
        const diff = this.history.getDiffSince(lastComputedEpoch);
        if (diff === RESET_VALUE) return this.history.get();
        const res = { added: {}, removed: {}, updated: {} };
        let numAdded = 0;
        let numRemoved = 0;
        let numUpdated = 0;
        for (const changes of diff) {
          for (const added of objectMapValues(changes.added)) {
            if (added.typeName === typeName) {
              if (res.removed[added.id]) {
                const original = res.removed[added.id];
                delete res.removed[added.id];
                numRemoved--;
                if (original !== added) {
                  res.updated[added.id] = [original, added];
                  numUpdated++;
                }
              } else {
                res.added[added.id] = added;
                numAdded++;
              }
            }
          }
          for (const [from2, to] of objectMapValues(changes.updated)) {
            if (to.typeName === typeName) {
              if (res.added[to.id]) {
                res.added[to.id] = to;
              } else if (res.updated[to.id]) {
                res.updated[to.id] = [res.updated[to.id][0], to];
              } else {
                res.updated[to.id] = [from2, to];
                numUpdated++;
              }
            }
          }
          for (const removed of objectMapValues(changes.removed)) {
            if (removed.typeName === typeName) {
              if (res.added[removed.id]) {
                delete res.added[removed.id];
                numAdded--;
              } else if (res.updated[removed.id]) {
                res.removed[removed.id] = res.updated[removed.id][0];
                delete res.updated[removed.id];
                numUpdated--;
                numRemoved++;
              } else {
                res.removed[removed.id] = removed;
                numRemoved++;
              }
            }
          }
        }
        if (numAdded || numRemoved || numUpdated) {
          return withDiff(this.history.get(), res);
        } else {
          return lastValue;
        }
      },
      { historyLength: 100 }
    );
    this.historyCache.set(typeName, filtered);
    return filtered;
  }
  /**
   * Creates a reactive index that maps property values to sets of record IDs for efficient lookups.
   * The index automatically updates when records are added, updated, or removed, and results are cached
   * for performance.
   *
   * Supports nested property paths using backslash separator (e.g., 'metadata\\sessionId').
   *
   * @param typeName - The type name of records to index
   * @param path - The property name or backslash-delimited path to index by
   * @returns A reactive computed containing the index map with change diffs
   *
   * @example
   * ```ts
   * // Create an index of books by author ID
   * const booksByAuthor = store.query.index('book', 'authorId')
   *
   * // Get all books by a specific author
   * const authorBooks = booksByAuthor.get().get('author:leguin')
   * console.log(authorBooks) // Set<RecordId<Book>>
   *
   * // Index by nested property using backslash separator
   * const booksBySession = store.query.index('book', 'metadata\\sessionId')
   * const sessionBooks = booksBySession.get().get('session:alpha')
   * ```
   *
   * @public
   */
  index(typeName, path) {
    const cacheKey = typeName + ":" + path;
    if (this.indexCache.has(cacheKey)) {
      return this.indexCache.get(cacheKey);
    }
    const index2 = this.__uncached_createIndex(typeName, path);
    this.indexCache.set(cacheKey, index2);
    return index2;
  }
  /**
   * Creates a new index without checking the cache. This method performs the actual work
   * of building the reactive index computation that tracks property values to record ID sets.
   *
   * Supports nested property paths using backslash separator.
   *
   * @param typeName - The type name of records to index
   * @param path - The property name or backslash-delimited path to index by
   * @returns A reactive computed containing the index map with change diffs
   *
   * @internal
   */
  __uncached_createIndex(typeName, path) {
    const typeHistory = this.filterHistory(typeName);
    const pathParts = path.split("\\");
    const getPropertyValue = pathParts.length > 1 ? (obj) => this.getNestedValue(obj, pathParts) : (obj) => obj[path];
    const fromScratch3 = () => {
      typeHistory.get();
      const res = /* @__PURE__ */ new Map();
      for (const record of this.recordMap.values()) {
        if (record.typeName === typeName) {
          const value = getPropertyValue(record);
          if (value !== void 0) {
            if (!res.has(value)) {
              res.set(value, /* @__PURE__ */ new Set());
            }
            res.get(value).add(record.id);
          }
        }
      }
      return res;
    };
    return computed(
      "index:" + typeName + ":" + path,
      (prevValue, lastComputedEpoch) => {
        if (isUninitialized(prevValue)) return fromScratch3();
        const history2 = typeHistory.getDiffSince(lastComputedEpoch);
        if (history2 === RESET_VALUE) {
          return fromScratch3();
        }
        const setConstructors = /* @__PURE__ */ new Map();
        const add = (value, id) => {
          let setConstructor = setConstructors.get(value);
          if (!setConstructor)
            setConstructor = new IncrementalSetConstructor(
              prevValue.get(value) ?? /* @__PURE__ */ new Set()
            );
          setConstructor.add(id);
          setConstructors.set(value, setConstructor);
        };
        const remove2 = (value, id) => {
          let set = setConstructors.get(value);
          if (!set) set = new IncrementalSetConstructor(prevValue.get(value) ?? /* @__PURE__ */ new Set());
          set.remove(id);
          setConstructors.set(value, set);
        };
        for (const changes of history2) {
          for (const record of objectMapValues(changes.added)) {
            if (record.typeName === typeName) {
              const value = getPropertyValue(record);
              if (value !== void 0) {
                add(value, record.id);
              }
            }
          }
          for (const [from2, to] of objectMapValues(changes.updated)) {
            if (to.typeName === typeName) {
              const prev = getPropertyValue(from2);
              const next = getPropertyValue(to);
              if (prev !== next) {
                if (prev !== void 0) {
                  remove2(prev, to.id);
                }
                if (next !== void 0) {
                  add(next, to.id);
                }
              }
            }
          }
          for (const record of objectMapValues(changes.removed)) {
            if (record.typeName === typeName) {
              const value = getPropertyValue(record);
              if (value !== void 0) {
                remove2(value, record.id);
              }
            }
          }
        }
        let nextValue = void 0;
        let nextDiff = void 0;
        for (const [value, setConstructor] of setConstructors) {
          const result = setConstructor.get();
          if (!result) continue;
          if (!nextValue) nextValue = new Map(prevValue);
          if (!nextDiff) nextDiff = /* @__PURE__ */ new Map();
          if (result.value.size === 0) {
            nextValue.delete(value);
          } else {
            nextValue.set(value, result.value);
          }
          nextDiff.set(value, result.diff);
        }
        if (nextValue && nextDiff) {
          return withDiff(nextValue, nextDiff);
        }
        return prevValue;
      },
      { historyLength: 100 }
    );
  }
  /**
   * Creates a reactive query that returns the first record matching the given query criteria.
   * Returns undefined if no matching record is found. The query automatically updates
   * when records change.
   *
   * @param typeName - The type name of records to query
   * @param queryCreator - Function that returns the query expression object to match against
   * @param name - Optional name for the query computation (used for debugging)
   * @returns A computed value containing the first matching record or undefined
   *
   * @example
   * ```ts
   * // Find the first book with a specific title
   * const bookLatheOfHeaven = store.query.record('book', () => ({ title: { eq: 'The Lathe of Heaven' } }))
   * console.log(bookLatheOfHeaven.get()?.title) // 'The Lathe of Heaven' or undefined
   *
   * // Find any book in stock
   * const anyInStockBook = store.query.record('book', () => ({ inStock: { eq: true } }))
   * ```
   *
   * @public
   */
  record(typeName, queryCreator = () => ({}), name = "record:" + typeName + (queryCreator ? ":" + queryCreator.toString() : "")) {
    const ids = this.ids(typeName, queryCreator, name);
    return computed(name, () => {
      for (const id of ids.get()) {
        return this.recordMap.get(id);
      }
      return void 0;
    });
  }
  /**
   * Creates a reactive query that returns an array of all records matching the given query criteria.
   * The array automatically updates when records are added, updated, or removed.
   *
   * @param typeName - The type name of records to query
   * @param queryCreator - Function that returns the query expression object to match against
   * @param name - Optional name for the query computation (used for debugging)
   * @returns A computed value containing an array of all matching records
   *
   * @example
   * ```ts
   * // Get all books in stock
   * const inStockBooks = store.query.records('book', () => ({ inStock: { eq: true } }))
   * console.log(inStockBooks.get()) // Book[]
   *
   * // Get all books by a specific author
   * const leguinBooks = store.query.records('book', () => ({ authorId: { eq: 'author:leguin' } }))
   *
   * // Get all books (no filter)
   * const allBooks = store.query.records('book')
   * ```
   *
   * @public
   */
  records(typeName, queryCreator = () => ({}), name = "records:" + typeName + (queryCreator ? ":" + queryCreator.toString() : "")) {
    const ids = this.ids(typeName, queryCreator, "ids:" + name);
    return computed(
      name,
      () => {
        return Array.from(ids.get(), (id) => this.recordMap.get(id));
      },
      {
        isEqual: areArraysShallowEqual
      }
    );
  }
  /**
   * Creates a reactive query that returns a set of record IDs matching the given query criteria.
   * This is more efficient than `records()` when you only need the IDs and not the full record objects.
   * The set automatically updates with collection diffs when records change.
   *
   * @param typeName - The type name of records to query
   * @param queryCreator - Function that returns the query expression object to match against
   * @param name - Optional name for the query computation (used for debugging)
   * @returns A computed value containing a set of matching record IDs with collection diffs
   *
   * @example
   * ```ts
   * // Get IDs of all books in stock
   * const inStockBookIds = store.query.ids('book', () => ({ inStock: { eq: true } }))
   * console.log(inStockBookIds.get()) // Set<RecordId<Book>>
   *
   * // Get all book IDs (no filter)
   * const allBookIds = store.query.ids('book')
   *
   * // Use with other queries for efficient lookups
   * const authorBookIds = store.query.ids('book', () => ({ authorId: { eq: 'author:leguin' } }))
   * ```
   *
   * @public
   */
  ids(typeName, queryCreator = () => ({}), name = "ids:" + typeName + (queryCreator ? ":" + queryCreator.toString() : "")) {
    const typeHistory = this.filterHistory(typeName);
    const fromScratch3 = () => {
      typeHistory.get();
      const query = queryCreator();
      if (Object.keys(query).length === 0) {
        return this.getAllIdsForType(typeName);
      }
      return executeQuery(this, typeName, query);
    };
    const fromScratchWithDiff = (prevValue) => {
      const nextValue = fromScratch3();
      const diff = diffSets(prevValue, nextValue);
      if (diff) {
        return withDiff(nextValue, diff);
      } else {
        return prevValue;
      }
    };
    const cachedQuery = computed("ids_query:" + name, queryCreator, {
      isEqual: import_lodash.default
    });
    return computed(
      "query:" + name,
      (prevValue, lastComputedEpoch) => {
        const query = cachedQuery.get();
        if (isUninitialized(prevValue)) {
          return fromScratch3();
        }
        if (lastComputedEpoch < cachedQuery.lastChangedEpoch) {
          return fromScratchWithDiff(prevValue);
        }
        const history2 = typeHistory.getDiffSince(lastComputedEpoch);
        if (history2 === RESET_VALUE) {
          return fromScratchWithDiff(prevValue);
        }
        const setConstructor = new IncrementalSetConstructor(
          prevValue
        );
        for (const changes of history2) {
          for (const added of objectMapValues(changes.added)) {
            if (added.typeName === typeName && objectMatchesQuery(query, added)) {
              setConstructor.add(added.id);
            }
          }
          for (const [_, updated] of objectMapValues(changes.updated)) {
            if (updated.typeName === typeName) {
              if (objectMatchesQuery(query, updated)) {
                setConstructor.add(updated.id);
              } else {
                setConstructor.remove(updated.id);
              }
            }
          }
          for (const removed of objectMapValues(changes.removed)) {
            if (removed.typeName === typeName) {
              setConstructor.remove(removed.id);
            }
          }
        }
        const result = setConstructor.get();
        if (!result) {
          return prevValue;
        }
        return withDiff(result.value, result.diff);
      },
      { historyLength: 50 }
    );
  }
  /**
   * Executes a one-time query against the current store state and returns matching records.
   * This is a non-reactive query that returns results immediately without creating a computed value.
   * Use this when you need a snapshot of data at a specific point in time.
   *
   * @param typeName - The type name of records to query
   * @param query - The query expression object to match against
   * @returns An array of records that match the query at the current moment
   *
   * @example
   * ```ts
   * // Get current in-stock books (non-reactive)
   * const currentInStockBooks = store.query.exec('book', { inStock: { eq: true } })
   * console.log(currentInStockBooks) // Book[]
   *
   * // Unlike records(), this won't update when the data changes
   * const staticBookList = store.query.exec('book', { authorId: { eq: 'author:leguin' } })
   * ```
   *
   * @public
   */
  exec(typeName, query) {
    const ids = executeQuery(this, typeName, query);
    if (ids.size === 0) {
      return EMPTY_ARRAY;
    }
    return Array.from(ids, (id) => this.recordMap.get(id));
  }
};

// ../node_modules/@tldraw/store/dist-esm/lib/StoreSideEffects.mjs
var StoreSideEffects = class {
  /**
   * Creates a new side effects manager for the given store.
   *
   * store - The store instance to manage side effects for
   */
  constructor(store) {
    __publicField(this, "_beforeCreateHandlers", {});
    __publicField(this, "_afterCreateHandlers", {});
    __publicField(this, "_beforeChangeHandlers", {});
    __publicField(this, "_afterChangeHandlers", {});
    __publicField(this, "_beforeDeleteHandlers", {});
    __publicField(this, "_afterDeleteHandlers", {});
    __publicField(this, "_operationCompleteHandlers", []);
    __publicField(this, "_isEnabled", true);
    this.store = store;
  }
  /**
   * Checks whether side effects are currently enabled.
   * When disabled, all side effect handlers are bypassed.
   *
   * @returns `true` if side effects are enabled, `false` otherwise
   * @internal
   */
  isEnabled() {
    return this._isEnabled;
  }
  /**
   * Enables or disables side effects processing.
   * When disabled, no side effect handlers will be called.
   *
   * @param enabled - Whether to enable or disable side effects
   * @internal
   */
  setIsEnabled(enabled) {
    this._isEnabled = enabled;
  }
  /**
   * Processes all registered 'before create' handlers for a record.
   * Handlers are called in registration order and can transform the record.
   *
   * @param record - The record about to be created
   * @param source - Whether the change originated from 'user' or 'remote'
   * @returns The potentially modified record to actually create
   * @internal
   */
  handleBeforeCreate(record, source) {
    if (!this._isEnabled) return record;
    const handlers2 = this._beforeCreateHandlers[record.typeName];
    if (handlers2) {
      let r = record;
      for (const handler of handlers2) {
        r = handler(r, source);
      }
      return r;
    }
    return record;
  }
  /**
   * Processes all registered 'after create' handlers for a record.
   * Handlers are called in registration order after the record is created.
   *
   * @param record - The record that was created
   * @param source - Whether the change originated from 'user' or 'remote'
   * @internal
   */
  handleAfterCreate(record, source) {
    if (!this._isEnabled) return;
    const handlers2 = this._afterCreateHandlers[record.typeName];
    if (handlers2) {
      for (const handler of handlers2) {
        handler(record, source);
      }
    }
  }
  /**
   * Processes all registered 'before change' handlers for a record.
   * Handlers are called in registration order and can modify or block the change.
   *
   * @param prev - The current version of the record
   * @param next - The proposed new version of the record
   * @param source - Whether the change originated from 'user' or 'remote'
   * @returns The potentially modified record to actually store
   * @internal
   */
  handleBeforeChange(prev, next, source) {
    if (!this._isEnabled) return next;
    const handlers2 = this._beforeChangeHandlers[next.typeName];
    if (handlers2) {
      let r = next;
      for (const handler of handlers2) {
        r = handler(prev, r, source);
      }
      return r;
    }
    return next;
  }
  /**
   * Processes all registered 'after change' handlers for a record.
   * Handlers are called in registration order after the record is updated.
   *
   * @param prev - The previous version of the record
   * @param next - The new version of the record that was stored
   * @param source - Whether the change originated from 'user' or 'remote'
   * @internal
   */
  handleAfterChange(prev, next, source) {
    if (!this._isEnabled) return;
    const handlers2 = this._afterChangeHandlers[next.typeName];
    if (handlers2) {
      for (const handler of handlers2) {
        handler(prev, next, source);
      }
    }
  }
  /**
   * Processes all registered 'before delete' handlers for a record.
   * If any handler returns `false`, the deletion is prevented.
   *
   * @param record - The record about to be deleted
   * @param source - Whether the change originated from 'user' or 'remote'
   * @returns `true` to allow deletion, `false` to prevent it
   * @internal
   */
  handleBeforeDelete(record, source) {
    if (!this._isEnabled) return true;
    const handlers2 = this._beforeDeleteHandlers[record.typeName];
    if (handlers2) {
      for (const handler of handlers2) {
        if (handler(record, source) === false) {
          return false;
        }
      }
    }
    return true;
  }
  /**
   * Processes all registered 'after delete' handlers for a record.
   * Handlers are called in registration order after the record is deleted.
   *
   * @param record - The record that was deleted
   * @param source - Whether the change originated from 'user' or 'remote'
   * @internal
   */
  handleAfterDelete(record, source) {
    if (!this._isEnabled) return;
    const handlers2 = this._afterDeleteHandlers[record.typeName];
    if (handlers2) {
      for (const handler of handlers2) {
        handler(record, source);
      }
    }
  }
  /**
   * Processes all registered operation complete handlers.
   * Called after an atomic store operation finishes.
   *
   * @param source - Whether the operation originated from 'user' or 'remote'
   * @internal
   */
  handleOperationComplete(source) {
    if (!this._isEnabled) return;
    for (const handler of this._operationCompleteHandlers) {
      handler(source);
    }
  }
  /**
   * Internal helper for registering multiple side effect handlers at once and keeping them organized.
   * This provides a convenient way to register handlers for multiple record types and lifecycle events
   * in a single call, returning a single cleanup function.
   *
   * @param handlersByType - An object mapping record type names to their respective handlers
   * @returns A function that removes all registered handlers when called
   *
   * @example
   * ```ts
   * const cleanup = sideEffects.register({
   *   shape: {
   *     afterDelete: (shape) => console.log('Shape deleted:', shape.id),
   *     beforeChange: (prev, next) => ({ ...next, lastModified: Date.now() })
   *   },
   *   arrow: {
   *     afterCreate: (arrow) => updateConnectedShapes(arrow)
   *   }
   * })
   *
   * // Later, remove all handlers
   * cleanup()
   * ```
   *
   * @internal
   */
  register(handlersByType) {
    const disposes = [];
    for (const [type, handlers2] of Object.entries(handlersByType)) {
      if (handlers2 == null ? void 0 : handlers2.beforeCreate) {
        disposes.push(this.registerBeforeCreateHandler(type, handlers2.beforeCreate));
      }
      if (handlers2 == null ? void 0 : handlers2.afterCreate) {
        disposes.push(this.registerAfterCreateHandler(type, handlers2.afterCreate));
      }
      if (handlers2 == null ? void 0 : handlers2.beforeChange) {
        disposes.push(this.registerBeforeChangeHandler(type, handlers2.beforeChange));
      }
      if (handlers2 == null ? void 0 : handlers2.afterChange) {
        disposes.push(this.registerAfterChangeHandler(type, handlers2.afterChange));
      }
      if (handlers2 == null ? void 0 : handlers2.beforeDelete) {
        disposes.push(this.registerBeforeDeleteHandler(type, handlers2.beforeDelete));
      }
      if (handlers2 == null ? void 0 : handlers2.afterDelete) {
        disposes.push(this.registerAfterDeleteHandler(type, handlers2.afterDelete));
      }
    }
    return () => {
      for (const dispose of disposes) dispose();
    };
  }
  /**
   * Register a handler to be called before a record of a certain type is created. Return a
   * modified record from the handler to change the record that will be created.
   *
   * Use this handle only to modify the creation of the record itself. If you want to trigger a
   * side-effect on a different record (for example, moving one shape when another is created),
   * use {@link StoreSideEffects.registerAfterCreateHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerBeforeCreateHandler('shape', (shape, source) => {
   *     // only modify shapes created by the user
   *     if (source !== 'user') return shape
   *
   *     //by default, arrow shapes have no label. Let's make sure they always have a label.
   *     if (shape.type === 'arrow') {
   *         return {...shape, props: {...shape.props, text: 'an arrow'}}
   *     }
   *
   *     // other shapes get returned unmodified
   *     return shape
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerBeforeCreateHandler(typeName, handler) {
    const handlers2 = this._beforeCreateHandlers[typeName];
    if (!handlers2) this._beforeCreateHandlers[typeName] = [];
    this._beforeCreateHandlers[typeName].push(handler);
    return () => remove(this._beforeCreateHandlers[typeName], handler);
  }
  /**
   * Register a handler to be called after a record is created. This is useful for side-effects
   * that would update _other_ records. If you want to modify the record being created use
   * {@link StoreSideEffects.registerBeforeCreateHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerAfterCreateHandler('page', (page, source) => {
   *     // Automatically create a shape when a page is created
   *     editor.createShape({
   *         id: createShapeId(),
   *         type: 'text',
   *         props: { richText: toRichText(page.name) },
   *     })
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerAfterCreateHandler(typeName, handler) {
    const handlers2 = this._afterCreateHandlers[typeName];
    if (!handlers2) this._afterCreateHandlers[typeName] = [];
    this._afterCreateHandlers[typeName].push(handler);
    return () => remove(this._afterCreateHandlers[typeName], handler);
  }
  /**
   * Register a handler to be called before a record is changed. The handler is given the old and
   * new record - you can return a modified record to apply a different update, or the old record
   * to block the update entirely.
   *
   * Use this handler only for intercepting updates to the record itself. If you want to update
   * other records in response to a change, use
   * {@link StoreSideEffects.registerAfterChangeHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerBeforeChangeHandler('shape', (prev, next, source) => {
   *     if (next.isLocked && !prev.isLocked) {
   *         // prevent shapes from ever being locked:
   *         return prev
   *     }
   *     // other types of change are allowed
   *     return next
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerBeforeChangeHandler(typeName, handler) {
    const handlers2 = this._beforeChangeHandlers[typeName];
    if (!handlers2) this._beforeChangeHandlers[typeName] = [];
    this._beforeChangeHandlers[typeName].push(handler);
    return () => remove(this._beforeChangeHandlers[typeName], handler);
  }
  /**
   * Register a handler to be called after a record is changed. This is useful for side-effects
   * that would update _other_ records - if you want to modify the record being changed, use
   * {@link StoreSideEffects.registerBeforeChangeHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerAfterChangeHandler('shape', (prev, next, source) => {
   *     if (next.props.color === 'red') {
   *         // there can only be one red shape at a time:
   *         const otherRedShapes = editor.getCurrentPageShapes().filter(s => s.props.color === 'red' && s.id !== next.id)
   *         editor.updateShapes(otherRedShapes.map(s => ({...s, props: {...s.props, color: 'blue'}})))
   *     }
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerAfterChangeHandler(typeName, handler) {
    const handlers2 = this._afterChangeHandlers[typeName];
    if (!handlers2) this._afterChangeHandlers[typeName] = [];
    this._afterChangeHandlers[typeName].push(handler);
    return () => remove(this._afterChangeHandlers[typeName], handler);
  }
  /**
   * Register a handler to be called before a record is deleted. The handler can return `false` to
   * prevent the deletion.
   *
   * Use this handler only for intercepting deletions of the record itself. If you want to do
   * something to other records in response to a deletion, use
   * {@link StoreSideEffects.registerAfterDeleteHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerBeforeDeleteHandler('shape', (shape, source) => {
   *     if (shape.props.color === 'red') {
   *         // prevent red shapes from being deleted
   * 	       return false
   *     }
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerBeforeDeleteHandler(typeName, handler) {
    const handlers2 = this._beforeDeleteHandlers[typeName];
    if (!handlers2) this._beforeDeleteHandlers[typeName] = [];
    this._beforeDeleteHandlers[typeName].push(handler);
    return () => remove(this._beforeDeleteHandlers[typeName], handler);
  }
  /**
   * Register a handler to be called after a record is deleted. This is useful for side-effects
   * that would update _other_ records - if you want to block the deletion of the record itself,
   * use {@link StoreSideEffects.registerBeforeDeleteHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerAfterDeleteHandler('shape', (shape, source) => {
   *     // if the last shape in a frame is deleted, delete the frame too:
   *     const parentFrame = editor.getShape(shape.parentId)
   *     if (!parentFrame || parentFrame.type !== 'frame') return
   *
   *     const siblings = editor.getSortedChildIdsForParent(parentFrame)
   *     if (siblings.length === 0) {
   *         editor.deleteShape(parentFrame.id)
   *     }
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerAfterDeleteHandler(typeName, handler) {
    const handlers2 = this._afterDeleteHandlers[typeName];
    if (!handlers2) this._afterDeleteHandlers[typeName] = [];
    this._afterDeleteHandlers[typeName].push(handler);
    return () => remove(this._afterDeleteHandlers[typeName], handler);
  }
  /**
   * Register a handler to be called when a store completes an atomic operation.
   *
   * @example
   * ```ts
   * let count = 0
   *
   * editor.sideEffects.registerOperationCompleteHandler(() => count++)
   *
   * editor.selectAll()
   * expect(count).toBe(1)
   *
   * editor.store.atomic(() => {
   *	editor.selectNone()
   * 	editor.selectAll()
   * })
   *
   * expect(count).toBe(2)
   * ```
   *
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   *
   * @public
   */
  registerOperationCompleteHandler(handler) {
    this._operationCompleteHandlers.push(handler);
    return () => remove(this._operationCompleteHandlers, handler);
  }
};
function remove(array, item) {
  const index2 = array.indexOf(item);
  if (index2 >= 0) {
    array.splice(index2, 1);
  }
}

// ../node_modules/@tldraw/store/dist-esm/lib/Store.mjs
var Store = class {
  /**
   * Creates a new Store instance.
   *
   * @example
   * ```ts
   * const store = new Store({
   *   schema: StoreSchema.create({ book: Book }),
   *   props: { appName: 'MyLibrary' },
   *   initialData: savedData
   * })
   * ```
   *
   * @param config - Configuration object for the store
   */
  constructor(config) {
    /**
     * The unique identifier of the store instance.
     *
     * @public
     */
    __publicField(this, "id");
    /**
     * An AtomMap containing the stores records.
     *
     * @internal
     * @readonly
     */
    __publicField(this, "records");
    /**
     * An atom containing the store's history.
     *
     * @public
     * @readonly
     */
    __publicField(this, "history", atom("history", 0, {
      historyLength: 1e3
    }));
    /**
     * Reactive queries and indexes for efficiently accessing store data.
     * Provides methods for filtering, indexing, and subscribing to subsets of records.
     *
     * @example
     * ```ts
     * // Create an index by a property
     * const booksByAuthor = store.query.index('book', 'author')
     *
     * // Get records matching criteria
     * const inStockBooks = store.query.records('book', () => ({
     *   inStock: { eq: true }
     * }))
     * ```
     *
     * @public
     * @readonly
     */
    __publicField(this, "query");
    /**
     * A set containing listeners that have been added to this store.
     *
     * @internal
     */
    __publicField(this, "listeners", /* @__PURE__ */ new Set());
    /**
     * An array of history entries that have not yet been flushed.
     *
     * @internal
     */
    __publicField(this, "historyAccumulator", new HistoryAccumulator());
    /**
     * A reactor that responds to changes to the history by squashing the accumulated history and
     * notifying listeners of the changes.
     *
     * @internal
     */
    __publicField(this, "historyReactor");
    /**
     * The schema that defines the structure and validation rules for records in this store.
     *
     * @public
     */
    __publicField(this, "schema");
    /**
     * Custom properties associated with this store instance.
     *
     * @public
     */
    __publicField(this, "props");
    /**
     * A mapping of record scopes to the set of record type names that belong to each scope.
     * Used to filter records by their persistence and synchronization behavior.
     *
     * @public
     */
    __publicField(this, "scopedTypes");
    /**
     * Side effects manager that handles lifecycle events for record operations.
     * Allows registration of callbacks for create, update, delete, and validation events.
     *
     * @example
     * ```ts
     * store.sideEffects.registerAfterCreateHandler('book', (book) => {
     *   console.log('Book created:', book.title)
     * })
     * ```
     *
     * @public
     */
    __publicField(this, "sideEffects", new StoreSideEffects(this));
    __publicField(this, "isMergingRemoteChanges", false);
    __publicField(this, "_integrityChecker");
    __publicField(this, "_isPossiblyCorrupted", false);
    __publicField(this, "pendingAfterEvents", null);
    __publicField(this, "_isInAtomicOp", false);
    const { initialData, schema, id } = config;
    this.id = id ?? uniqueId();
    this.schema = schema;
    this.props = config.props;
    if (initialData) {
      this.records = new AtomMap(
        "store",
        objectMapEntries(initialData).map(([id2, record]) => [
          id2,
          devFreeze(this.schema.validateRecord(this, record, "initialize", null))
        ])
      );
    } else {
      this.records = new AtomMap("store");
    }
    this.query = new StoreQueries(this.records, this.history);
    this.historyReactor = reactor(
      "Store.historyReactor",
      () => {
        this.history.get();
        this._flushHistory();
      },
      { scheduleEffect: (cb) => this.cancelHistoryReactor = throttleToNextFrame(cb) }
    );
    this.scopedTypes = {
      document: new Set(
        objectMapValues(this.schema.types).filter((t2) => t2.scope === "document").map((t2) => t2.typeName)
      ),
      session: new Set(
        objectMapValues(this.schema.types).filter((t2) => t2.scope === "session").map((t2) => t2.typeName)
      ),
      presence: new Set(
        objectMapValues(this.schema.types).filter((t2) => t2.scope === "presence").map((t2) => t2.typeName)
      )
    };
  }
  /**
   * Function to dispose of any in-flight timeouts.
   *
   * @internal
   */
  cancelHistoryReactor() {
  }
  _flushHistory() {
    if (this.historyAccumulator.hasChanges()) {
      const entries = this.historyAccumulator.flush();
      for (const { changes, source } of entries) {
        let instanceChanges = null;
        let documentChanges = null;
        let presenceChanges = null;
        for (const { onHistory, filters } of this.listeners) {
          if (filters.source !== "all" && filters.source !== source) {
            continue;
          }
          if (filters.scope !== "all") {
            if (filters.scope === "document") {
              documentChanges ?? (documentChanges = this.filterChangesByScope(changes, "document"));
              if (!documentChanges) continue;
              onHistory({ changes: documentChanges, source });
            } else if (filters.scope === "session") {
              instanceChanges ?? (instanceChanges = this.filterChangesByScope(changes, "session"));
              if (!instanceChanges) continue;
              onHistory({ changes: instanceChanges, source });
            } else {
              presenceChanges ?? (presenceChanges = this.filterChangesByScope(changes, "presence"));
              if (!presenceChanges) continue;
              onHistory({ changes: presenceChanges, source });
            }
          } else {
            onHistory({ changes, source });
          }
        }
      }
    }
  }
  dispose() {
    this.cancelHistoryReactor();
  }
  /**
   * Filters out non-document changes from a diff. Returns null if there are no changes left.
   * @param change - the records diff
   * @param scope - the records scope
   * @returns
   */
  filterChangesByScope(change, scope) {
    const result = {
      added: filterEntries(change.added, (_, r) => this.scopedTypes[scope].has(r.typeName)),
      updated: filterEntries(change.updated, (_, r) => this.scopedTypes[scope].has(r[1].typeName)),
      removed: filterEntries(change.removed, (_, r) => this.scopedTypes[scope].has(r.typeName))
    };
    if (Object.keys(result.added).length === 0 && Object.keys(result.updated).length === 0 && Object.keys(result.removed).length === 0) {
      return null;
    }
    return result;
  }
  /**
   * Update the history with a diff of changes.
   *
   * @param changes - The changes to add to the history.
   */
  updateHistory(changes) {
    this.historyAccumulator.add({
      changes,
      source: this.isMergingRemoteChanges ? "remote" : "user"
    });
    if (this.listeners.size === 0) {
      this.historyAccumulator.clear();
    }
    this.history.set(this.history.get() + 1, changes);
  }
  validate(phase) {
    this.allRecords().forEach((record) => this.schema.validateRecord(this, record, phase, null));
  }
  /**
   * Add or update records in the store. If a record with the same ID already exists, it will be updated.
   * Otherwise, a new record will be created.
   *
   * @example
   * ```ts
   * // Add new records
   * const book = Book.create({ title: 'Lathe Of Heaven', author: 'Le Guin' })
   * store.put([book])
   *
   * // Update existing record
   * store.put([{ ...book, title: 'The Lathe of Heaven' }])
   * ```
   *
   * @param records - The records to add or update
   * @param phaseOverride - Override the validation phase (used internally)
   * @public
   */
  put(records, phaseOverride) {
    this.atomic(() => {
      const updates = {};
      const additions = {};
      let record;
      let didChange = false;
      const source = this.isMergingRemoteChanges ? "remote" : "user";
      for (let i = 0, n = records.length; i < n; i++) {
        record = records[i];
        const initialValue = this.records.__unsafe__getWithoutCapture(record.id);
        if (initialValue) {
          record = this.sideEffects.handleBeforeChange(initialValue, record, source);
          const validated = this.schema.validateRecord(
            this,
            record,
            phaseOverride ?? "updateRecord",
            initialValue
          );
          if (validated === initialValue) continue;
          record = devFreeze(record);
          this.records.set(record.id, record);
          didChange = true;
          updates[record.id] = [initialValue, record];
          this.addDiffForAfterEvent(initialValue, record);
        } else {
          record = this.sideEffects.handleBeforeCreate(record, source);
          didChange = true;
          record = this.schema.validateRecord(
            this,
            record,
            phaseOverride ?? "createRecord",
            null
          );
          record = devFreeze(record);
          additions[record.id] = record;
          this.addDiffForAfterEvent(null, record);
          this.records.set(record.id, record);
        }
      }
      if (!didChange) return;
      this.updateHistory({
        added: additions,
        updated: updates,
        removed: {}
      });
    });
  }
  /**
   * Remove records from the store by their IDs.
   *
   * @example
   * ```ts
   * // Remove a single record
   * store.remove([book.id])
   *
   * // Remove multiple records
   * store.remove([book1.id, book2.id, book3.id])
   * ```
   *
   * @param ids - The IDs of the records to remove
   * @public
   */
  remove(ids) {
    this.atomic(() => {
      const toDelete = new Set(ids);
      const source = this.isMergingRemoteChanges ? "remote" : "user";
      if (this.sideEffects.isEnabled()) {
        for (const id of ids) {
          const record = this.records.__unsafe__getWithoutCapture(id);
          if (!record) continue;
          if (this.sideEffects.handleBeforeDelete(record, source) === false) {
            toDelete.delete(id);
          }
        }
      }
      const actuallyDeleted = this.records.deleteMany(toDelete);
      if (actuallyDeleted.length === 0) return;
      const removed = {};
      for (const [id, record] of actuallyDeleted) {
        removed[id] = record;
        this.addDiffForAfterEvent(record, null);
      }
      this.updateHistory({ added: {}, updated: {}, removed });
    });
  }
  /**
   * Get a record by its ID. This creates a reactive subscription to the record.
   *
   * @example
   * ```ts
   * const book = store.get(bookId)
   * if (book) {
   *   console.log(book.title)
   * }
   * ```
   *
   * @param id - The ID of the record to get
   * @returns The record if it exists, undefined otherwise
   * @public
   */
  get(id) {
    return this.records.get(id);
  }
  /**
   * Get a record by its ID without creating a reactive subscription.
   * Use this when you need to access a record but don't want reactive updates.
   *
   * @example
   * ```ts
   * // Won't trigger reactive updates when this record changes
   * const book = store.unsafeGetWithoutCapture(bookId)
   * ```
   *
   * @param id - The ID of the record to get
   * @returns The record if it exists, undefined otherwise
   * @public
   */
  unsafeGetWithoutCapture(id) {
    return this.records.__unsafe__getWithoutCapture(id);
  }
  /**
   * Serialize the store's records to a plain JavaScript object.
   * Only includes records matching the specified scope.
   *
   * @example
   * ```ts
   * // Serialize only document records (default)
   * const documentData = store.serialize('document')
   *
   * // Serialize all records
   * const allData = store.serialize('all')
   * ```
   *
   * @param scope - The scope of records to serialize. Defaults to 'document'
   * @returns The serialized store data
   * @public
   */
  serialize(scope = "document") {
    const result = {};
    for (const [id, record] of this.records) {
      if (scope === "all" || this.scopedTypes[scope].has(record.typeName)) {
        result[id] = record;
      }
    }
    return result;
  }
  /**
   * Get a serialized snapshot of the store and its schema.
   * This includes both the data and schema information needed for proper migration.
   *
   * @example
   * ```ts
   * const snapshot = store.getStoreSnapshot()
   * localStorage.setItem('myApp', JSON.stringify(snapshot))
   *
   * // Later...
   * const saved = JSON.parse(localStorage.getItem('myApp'))
   * store.loadStoreSnapshot(saved)
   * ```
   *
   * @param scope - The scope of records to serialize. Defaults to 'document'
   * @returns A snapshot containing both store data and schema information
   * @public
   */
  getStoreSnapshot(scope = "document") {
    return {
      store: this.serialize(scope),
      schema: this.schema.serialize()
    };
  }
  /**
   * Migrate a serialized snapshot to the current schema version.
   * This applies any necessary migrations to bring old data up to date.
   *
   * @example
   * ```ts
   * const oldSnapshot = JSON.parse(localStorage.getItem('myApp'))
   * const migratedSnapshot = store.migrateSnapshot(oldSnapshot)
   * ```
   *
   * @param snapshot - The snapshot to migrate
   * @returns The migrated snapshot with current schema version
   * @throws Error if migration fails
   * @public
   */
  migrateSnapshot(snapshot) {
    const migrationResult = this.schema.migrateStoreSnapshot(snapshot);
    if (migrationResult.type === "error") {
      throw new Error(`Failed to migrate snapshot: ${migrationResult.reason}`);
    }
    return {
      store: migrationResult.value,
      schema: this.schema.serialize()
    };
  }
  /**
   * Load a serialized snapshot into the store, replacing all current data.
   * The snapshot will be automatically migrated to the current schema version if needed.
   *
   * @example
   * ```ts
   * const snapshot = JSON.parse(localStorage.getItem('myApp'))
   * store.loadStoreSnapshot(snapshot)
   * ```
   *
   * @param snapshot - The snapshot to load
   * @throws Error if migration fails or snapshot is invalid
   * @public
   */
  loadStoreSnapshot(snapshot) {
    const migrationResult = this.schema.migrateStoreSnapshot(snapshot);
    if (migrationResult.type === "error") {
      throw new Error(`Failed to migrate snapshot: ${migrationResult.reason}`);
    }
    const prevSideEffectsEnabled = this.sideEffects.isEnabled();
    try {
      this.sideEffects.setIsEnabled(false);
      this.atomic(() => {
        this.clear();
        this.put(Object.values(migrationResult.value));
        this.ensureStoreIsUsable();
      });
    } finally {
      this.sideEffects.setIsEnabled(prevSideEffectsEnabled);
    }
  }
  /**
   * Get an array of all records in the store.
   *
   * @example
   * ```ts
   * const allRecords = store.allRecords()
   * const books = allRecords.filter(r => r.typeName === 'book')
   * ```
   *
   * @returns An array containing all records in the store
   * @public
   */
  allRecords() {
    return Array.from(this.records.values());
  }
  /**
   * Remove all records from the store.
   *
   * @example
   * ```ts
   * store.clear()
   * console.log(store.allRecords().length) // 0
   * ```
   *
   * @public
   */
  clear() {
    this.remove(Array.from(this.records.keys()));
  }
  /**
   * Update a single record using an updater function. To update multiple records at once,
   * use the `update` method of the `TypedStore` class.
   *
   * @example
   * ```ts
   * store.update(book.id, (book) => ({
   *   ...book,
   *   title: 'Updated Title'
   * }))
   * ```
   *
   * @param id - The ID of the record to update
   * @param updater - A function that receives the current record and returns the updated record
   * @public
   */
  update(id, updater) {
    const existing = this.unsafeGetWithoutCapture(id);
    if (!existing) {
      console.error(`Record ${id} not found. This is probably an error`);
      return;
    }
    this.put([updater(existing)]);
  }
  /**
   * Check whether a record with the given ID exists in the store.
   *
   * @example
   * ```ts
   * if (store.has(bookId)) {
   *   console.log('Book exists!')
   * }
   * ```
   *
   * @param id - The ID of the record to check
   * @returns True if the record exists, false otherwise
   * @public
   */
  has(id) {
    return this.records.has(id);
  }
  /**
   * Add a listener that will be called when the store changes.
   * Returns a function to remove the listener.
   *
   * @example
   * ```ts
   * const removeListener = store.listen((entry) => {
   *   console.log('Changes:', entry.changes)
   *   console.log('Source:', entry.source)
   * })
   *
   * // Listen only to user changes to document records
   * const removeDocumentListener = store.listen(
   *   (entry) => console.log('Document changed:', entry),
   *   { source: 'user', scope: 'document' }
   * )
   *
   * // Later, remove the listener
   * removeListener()
   * ```
   *
   * @param onHistory - The listener function to call when changes occur
   * @param filters - Optional filters to control when the listener is called
   * @returns A function that removes the listener when called
   * @public
   */
  listen(onHistory, filters) {
    this._flushHistory();
    const listener = {
      onHistory,
      filters: {
        source: (filters == null ? void 0 : filters.source) ?? "all",
        scope: (filters == null ? void 0 : filters.scope) ?? "all"
      }
    };
    if (!this.historyReactor.scheduler.isActivelyListening) {
      this.historyReactor.start();
      this.historyReactor.scheduler.execute();
    }
    this.listeners.add(listener);
    return () => {
      this.listeners.delete(listener);
      if (this.listeners.size === 0) {
        this.historyReactor.stop();
      }
    };
  }
  /**
   * Merge changes from a remote source. Changes made within the provided function
   * will be marked with source 'remote' instead of 'user'.
   *
   * @example
   * ```ts
   * // Changes from sync/collaboration
   * store.mergeRemoteChanges(() => {
   *   store.put(remoteRecords)
   *   store.remove(deletedIds)
   * })
   * ```
   *
   * @param fn - A function that applies the remote changes
   * @public
   */
  mergeRemoteChanges(fn) {
    if (this.isMergingRemoteChanges) {
      return fn();
    }
    if (this._isInAtomicOp) {
      throw new Error("Cannot merge remote changes while in atomic operation");
    }
    try {
      this.atomic(fn, true, true);
    } finally {
      this.ensureStoreIsUsable();
    }
  }
  /**
   * Run `fn` and return a {@link RecordsDiff} of the changes that occurred as a result.
   */
  extractingChanges(fn) {
    const changes = [];
    const dispose = this.historyAccumulator.addInterceptor((entry) => changes.push(entry.changes));
    try {
      transact(fn);
      return squashRecordDiffs(changes);
    } finally {
      dispose();
    }
  }
  applyDiff(diff, {
    runCallbacks = true,
    ignoreEphemeralKeys = false
  } = {}) {
    this.atomic(() => {
      const toPut = objectMapValues(diff.added);
      for (const [_from, to] of objectMapValues(diff.updated)) {
        const type = this.schema.getType(to.typeName);
        if (ignoreEphemeralKeys && type.ephemeralKeySet.size) {
          const existing = this.get(to.id);
          if (!existing) {
            toPut.push(to);
            continue;
          }
          let changed = null;
          for (const [key, value] of Object.entries(to)) {
            if (type.ephemeralKeySet.has(key) || Object.is(value, getOwnProperty(existing, key))) {
              continue;
            }
            if (!changed) changed = { ...existing };
            changed[key] = value;
          }
          if (changed) toPut.push(changed);
        } else {
          toPut.push(to);
        }
      }
      const toRemove = objectMapKeys(diff.removed);
      if (toPut.length) {
        this.put(toPut);
      }
      if (toRemove.length) {
        this.remove(toRemove);
      }
    }, runCallbacks);
  }
  /**
   * Create a cache based on values in the store. Pass in a function that takes and ID and a
   * signal for the underlying record. Return a signal (usually a computed) for the cached value.
   * For simple derivations, use {@link Store.createComputedCache}. This function is useful if you
   * need more precise control over intermediate values.
   */
  createCache(create) {
    const cache = new WeakCache();
    return {
      get: (id) => {
        const atom2 = this.records.getAtom(id);
        if (!atom2) return void 0;
        return cache.get(atom2, () => create(id, atom2)).get();
      }
    };
  }
  /**
   * Create a computed cache.
   *
   * @param name - The name of the derivation cache.
   * @param derive - A function used to derive the value of the cache.
   * @param opts - Options for the computed cache.
   * @public
   */
  createComputedCache(name, derive, opts) {
    return this.createCache((id, record) => {
      const recordSignal = (opts == null ? void 0 : opts.areRecordsEqual) ? computed(`${name}:${id}:isEqual`, () => record.get(), { isEqual: opts.areRecordsEqual }) : record;
      return computed(
        name + ":" + id,
        () => {
          return derive(recordSignal.get());
        },
        {
          isEqual: opts == null ? void 0 : opts.areResultsEqual
        }
      );
    });
  }
  /** @internal */
  ensureStoreIsUsable() {
    this.atomic(() => {
      var _a6;
      this._integrityChecker ?? (this._integrityChecker = this.schema.createIntegrityChecker(this));
      (_a6 = this._integrityChecker) == null ? void 0 : _a6.call(this);
    });
  }
  /** @internal */
  markAsPossiblyCorrupted() {
    this._isPossiblyCorrupted = true;
  }
  /** @internal */
  isPossiblyCorrupted() {
    return this._isPossiblyCorrupted;
  }
  addDiffForAfterEvent(before, after) {
    assert(this.pendingAfterEvents, "must be in event operation");
    if (before === after) return;
    if (before && after) assert(before.id === after.id);
    if (!before && !after) return;
    const id = (before || after).id;
    const existing = this.pendingAfterEvents.get(id);
    if (existing) {
      existing.after = after;
    } else {
      this.pendingAfterEvents.set(id, { before, after });
    }
  }
  flushAtomicCallbacks(isMergingRemoteChanges) {
    let updateDepth = 0;
    let source = isMergingRemoteChanges ? "remote" : "user";
    while (this.pendingAfterEvents) {
      const events = this.pendingAfterEvents;
      this.pendingAfterEvents = null;
      if (!this.sideEffects.isEnabled()) continue;
      updateDepth++;
      if (updateDepth > 100) {
        throw new Error("Maximum store update depth exceeded, bailing out");
      }
      for (const { before, after } of events.values()) {
        if (before && after && before !== after && !(0, import_lodash.default)(before, after)) {
          this.sideEffects.handleAfterChange(before, after, source);
        } else if (before && !after) {
          this.sideEffects.handleAfterDelete(before, source);
        } else if (!before && after) {
          this.sideEffects.handleAfterCreate(after, source);
        }
      }
      if (!this.pendingAfterEvents) {
        this.sideEffects.handleOperationComplete(source);
      } else {
        source = "user";
      }
    }
  }
  /** @internal */
  atomic(fn, runCallbacks = true, isMergingRemoteChanges = false) {
    return transact(() => {
      if (this._isInAtomicOp) {
        if (!this.pendingAfterEvents) this.pendingAfterEvents = /* @__PURE__ */ new Map();
        const prevSideEffectsEnabled2 = this.sideEffects.isEnabled();
        assert(!isMergingRemoteChanges, "cannot call mergeRemoteChanges while in atomic operation");
        try {
          if (prevSideEffectsEnabled2 && !runCallbacks) {
            this.sideEffects.setIsEnabled(false);
          }
          return fn();
        } finally {
          this.sideEffects.setIsEnabled(prevSideEffectsEnabled2);
        }
      }
      this.pendingAfterEvents = /* @__PURE__ */ new Map();
      const prevSideEffectsEnabled = this.sideEffects.isEnabled();
      this.sideEffects.setIsEnabled(runCallbacks ?? prevSideEffectsEnabled);
      this._isInAtomicOp = true;
      if (isMergingRemoteChanges) {
        this.isMergingRemoteChanges = true;
      }
      try {
        const result = fn();
        this.isMergingRemoteChanges = false;
        this.flushAtomicCallbacks(isMergingRemoteChanges);
        return result;
      } finally {
        this.pendingAfterEvents = null;
        this.sideEffects.setIsEnabled(prevSideEffectsEnabled);
        this._isInAtomicOp = false;
        this.isMergingRemoteChanges = false;
      }
    });
  }
  /** @internal */
  addHistoryInterceptor(fn) {
    return this.historyAccumulator.addInterceptor(
      (entry) => fn(entry, this.isMergingRemoteChanges ? "remote" : "user")
    );
  }
};
function squashHistoryEntries(entries) {
  if (entries.length === 0) return [];
  const chunked = [];
  let chunk = [entries[0]];
  let entry;
  for (let i = 1, n = entries.length; i < n; i++) {
    entry = entries[i];
    if (chunk[0].source !== entry.source) {
      chunked.push(chunk);
      chunk = [];
    }
    chunk.push(entry);
  }
  chunked.push(chunk);
  return devFreeze(
    chunked.map((chunk2) => ({
      source: chunk2[0].source,
      changes: squashRecordDiffs(chunk2.map((e) => e.changes))
    }))
  );
}
var HistoryAccumulator = class {
  constructor() {
    __publicField(this, "_history", []);
    __publicField(this, "_interceptors", /* @__PURE__ */ new Set());
  }
  /**
   * Add an interceptor that will be called for each history entry.
   * Returns a function to remove the interceptor.
   */
  addInterceptor(fn) {
    this._interceptors.add(fn);
    return () => {
      this._interceptors.delete(fn);
    };
  }
  /**
   * Add a history entry to the accumulator.
   * Calls all registered interceptors with the entry.
   */
  add(entry) {
    this._history.push(entry);
    for (const interceptor of this._interceptors) {
      interceptor(entry);
    }
  }
  /**
   * Flush all accumulated history entries, squashing adjacent entries from the same source.
   * Clears the internal history buffer.
   */
  flush() {
    const history2 = squashHistoryEntries(this._history);
    this._history = [];
    return history2;
  }
  /**
   * Clear all accumulated history entries without flushing.
   */
  clear() {
    this._history = [];
  }
  /**
   * Check if there are any accumulated history entries.
   */
  hasChanges() {
    return this._history.length > 0;
  }
};
function createComputedCache(name, derive, opts) {
  const cache = new WeakCache();
  return {
    get(context, id) {
      const computedCache = cache.get(context, () => {
        const store = context instanceof Store ? context : context.store;
        return store.createComputedCache(name, (record) => derive(context, record), opts);
      });
      return computedCache.get(id);
    }
  };
}

// ../node_modules/@tldraw/store/dist-esm/lib/StoreSchema.mjs
function upgradeSchema(schema) {
  if (schema.schemaVersion > 2 || schema.schemaVersion < 1) return Result.err("Bad schema version");
  if (schema.schemaVersion === 2) return Result.ok(schema);
  const result = {
    schemaVersion: 2,
    sequences: {
      "com.tldraw.store": schema.storeVersion
    }
  };
  for (const [typeName, recordVersion] of Object.entries(schema.recordVersions)) {
    result.sequences[`com.tldraw.${typeName}`] = recordVersion.version;
    if ("subTypeKey" in recordVersion) {
      for (const [subType, version2] of Object.entries(recordVersion.subTypeVersions)) {
        result.sequences[`com.tldraw.${typeName}.${subType}`] = version2;
      }
    }
  }
  return Result.ok(result);
}
var StoreSchema = class _StoreSchema {
  constructor(types, options2) {
    __publicField(this, "migrations", {});
    __publicField(this, "sortedMigrations");
    __publicField(this, "migrationCache", /* @__PURE__ */ new WeakMap());
    var _a6;
    this.types = types;
    this.options = options2;
    for (const m of options2.migrations ?? []) {
      assert(!this.migrations[m.sequenceId], `Duplicate migration sequenceId ${m.sequenceId}`);
      validateMigrations(m);
      this.migrations[m.sequenceId] = m;
    }
    const allMigrations = Object.values(this.migrations).flatMap((m) => m.sequence);
    this.sortedMigrations = sortMigrations(allMigrations);
    for (const migration of this.sortedMigrations) {
      if (!((_a6 = migration.dependsOn) == null ? void 0 : _a6.length)) continue;
      for (const dep of migration.dependsOn) {
        const depMigration = allMigrations.find((m) => m.id === dep);
        assert(depMigration, `Migration '${migration.id}' depends on missing migration '${dep}'`);
      }
    }
  }
  /**
   * Creates a new StoreSchema with the given record types and options.
   *
   * This static factory method is the recommended way to create a StoreSchema.
   * It ensures type safety while providing a clean API for schema definition.
   *
   * @param types - Object mapping type names to their RecordType definitions
   * @param options - Optional configuration for migrations, validation, and integrity checking
   * @returns A new StoreSchema instance
   *
   * @example
   * ```ts
   * const Book = createRecordType<Book>('book', { scope: 'document' })
   * const Author = createRecordType<Author>('author', { scope: 'document' })
   *
   * const schema = StoreSchema.create(
   *   {
   *     book: Book,
   *     author: Author
   *   },
   *   {
   *     migrations: [bookMigrations],
   *     onValidationFailure: (failure) => failure.record
   *   }
   * )
   * ```
   *
   * @public
   */
  static create(types, options2) {
    return new _StoreSchema(types, options2 ?? {});
  }
  /**
   * Validates a record using its corresponding RecordType validator.
   *
   * This method ensures that records conform to their type definitions before
   * being stored. If validation fails and an onValidationFailure handler is
   * provided, it will be called to potentially recover from the error.
   *
   * @param store - The store instance where validation is occurring
   * @param record - The record to validate
   * @param phase - The lifecycle phase where validation is happening
   * @param recordBefore - The previous version of the record (for updates)
   * @returns The validated record, potentially modified by validation failure handler
   *
   * @example
   * ```ts
   * try {
   *   const validatedBook = schema.validateRecord(
   *     store,
   *     { id: 'book:1', typeName: 'book', title: '', author: 'Jane Doe' },
   *     'createRecord',
   *     null
   *   )
   * } catch (error) {
   *   console.error('Record validation failed:', error)
   * }
   * ```
   *
   * @public
   */
  validateRecord(store, record, phase, recordBefore) {
    try {
      const recordType = getOwnProperty(this.types, record.typeName);
      if (!recordType) {
        throw new Error(`Missing definition for record type ${record.typeName}`);
      }
      return recordType.validate(record, recordBefore ?? void 0);
    } catch (error) {
      if (this.options.onValidationFailure) {
        return this.options.onValidationFailure({
          store,
          record,
          phase,
          recordBefore,
          error
        });
      } else {
        throw error;
      }
    }
  }
  /**
   * Gets all migrations that need to be applied to upgrade from a persisted schema
   * to the current schema version.
   *
   * This method compares the persisted schema with the current schema and determines
   * which migrations need to be applied to bring the data up to date. It handles
   * both regular migrations and retroactive migrations, and caches results for
   * performance.
   *
   * @param persistedSchema - The schema version that was previously persisted
   * @returns A Result containing the list of migrations to apply, or an error message
   *
   * @example
   * ```ts
   * const persistedSchema = {
   *   schemaVersion: 2,
   *   sequences: { 'com.tldraw.book': 1, 'com.tldraw.author': 0 }
   * }
   *
   * const migrationsResult = schema.getMigrationsSince(persistedSchema)
   * if (migrationsResult.ok) {
   *   console.log('Migrations to apply:', migrationsResult.value.length)
   *   // Apply each migration to bring data up to date
   * }
   * ```
   *
   * @public
   */
  getMigrationsSince(persistedSchema) {
    const cached = this.migrationCache.get(persistedSchema);
    if (cached) {
      return cached;
    }
    const upgradeResult = upgradeSchema(persistedSchema);
    if (!upgradeResult.ok) {
      this.migrationCache.set(persistedSchema, upgradeResult);
      return upgradeResult;
    }
    const schema = upgradeResult.value;
    const sequenceIdsToInclude = new Set(
      // start with any shared sequences
      Object.keys(schema.sequences).filter((sequenceId) => this.migrations[sequenceId])
    );
    for (const sequenceId in this.migrations) {
      if (schema.sequences[sequenceId] === void 0 && this.migrations[sequenceId].retroactive) {
        sequenceIdsToInclude.add(sequenceId);
      }
    }
    if (sequenceIdsToInclude.size === 0) {
      const result2 = Result.ok([]);
      this.migrationCache.set(persistedSchema, result2);
      return result2;
    }
    const allMigrationsToInclude = /* @__PURE__ */ new Set();
    for (const sequenceId of sequenceIdsToInclude) {
      const theirVersion = schema.sequences[sequenceId];
      if (typeof theirVersion !== "number" && this.migrations[sequenceId].retroactive || theirVersion === 0) {
        for (const migration of this.migrations[sequenceId].sequence) {
          allMigrationsToInclude.add(migration.id);
        }
        continue;
      }
      const theirVersionId = `${sequenceId}/${theirVersion}`;
      const idx = this.migrations[sequenceId].sequence.findIndex((m) => m.id === theirVersionId);
      if (idx === -1) {
        const result2 = Result.err("Incompatible schema?");
        this.migrationCache.set(persistedSchema, result2);
        return result2;
      }
      for (const migration of this.migrations[sequenceId].sequence.slice(idx + 1)) {
        allMigrationsToInclude.add(migration.id);
      }
    }
    const result = Result.ok(
      this.sortedMigrations.filter(({ id }) => allMigrationsToInclude.has(id))
    );
    this.migrationCache.set(persistedSchema, result);
    return result;
  }
  /**
   * Migrates a single persisted record to match the current schema version.
   *
   * This method applies the necessary migrations to transform a record from an
   * older (or newer) schema version to the current version. It supports both
   * forward ('up') and backward ('down') migrations.
   *
   * @param record - The record to migrate
   * @param persistedSchema - The schema version the record was persisted with
   * @param direction - Direction to migrate ('up' for newer, 'down' for older)
   * @returns A MigrationResult containing the migrated record or an error
   *
   * @example
   * ```ts
   * const oldRecord = { id: 'book:1', typeName: 'book', title: 'Old Title', publishDate: '2020-01-01' }
   * const oldSchema = { schemaVersion: 2, sequences: { 'com.tldraw.book': 1 } }
   *
   * const result = schema.migratePersistedRecord(oldRecord, oldSchema, 'up')
   * if (result.type === 'success') {
   *   console.log('Migrated record:', result.value)
   *   // Record now has publishedYear instead of publishDate
   * } else {
   *   console.error('Migration failed:', result.reason)
   * }
   * ```
   *
   * @public
   */
  migratePersistedRecord(record, persistedSchema, direction = "up") {
    const migrations = this.getMigrationsSince(persistedSchema);
    if (!migrations.ok) {
      console.error("Error migrating record", migrations.error);
      return { type: "error", reason: MigrationFailureReason.MigrationError };
    }
    let migrationsToApply = migrations.value;
    if (migrationsToApply.length === 0) {
      return { type: "success", value: record };
    }
    if (!migrationsToApply.every((m) => m.scope === "record")) {
      return {
        type: "error",
        reason: direction === "down" ? MigrationFailureReason.TargetVersionTooOld : MigrationFailureReason.TargetVersionTooNew
      };
    }
    if (direction === "down") {
      if (!migrationsToApply.every((m) => m.scope === "record" && m.down)) {
        return {
          type: "error",
          reason: MigrationFailureReason.TargetVersionTooOld
        };
      }
      migrationsToApply = migrationsToApply.slice().reverse();
    }
    record = structuredClone(record);
    try {
      for (const migration of migrationsToApply) {
        if (migration.scope === "store") throw new Error(
          /* won't happen, just for TS */
        );
        if (migration.scope === "storage") throw new Error(
          /* won't happen, just for TS */
        );
        const shouldApply = migration.filter ? migration.filter(record) : true;
        if (!shouldApply) continue;
        const result = migration[direction](record);
        if (result) {
          record = structuredClone(result);
        }
      }
    } catch (e) {
      console.error("Error migrating record", e);
      return { type: "error", reason: MigrationFailureReason.MigrationError };
    }
    return { type: "success", value: record };
  }
  migrateStorage(storage) {
    const schema = storage.getSchema();
    assert(schema, "Schema is missing.");
    const migrations = this.getMigrationsSince(schema);
    if (!migrations.ok) {
      console.error("Error migrating store", migrations.error);
      throw new Error(migrations.error);
    }
    const migrationsToApply = migrations.value;
    if (migrationsToApply.length === 0) {
      return;
    }
    storage.setSchema(this.serialize());
    for (const migration of migrationsToApply) {
      if (migration.scope === "record") {
        const updates = [];
        for (const [id, state] of storage.entries()) {
          const shouldApply = migration.filter ? migration.filter(state) : true;
          if (!shouldApply) continue;
          const record = structuredClone(state);
          const result = migration.up(record) ?? record;
          if (!(0, import_lodash.default)(result, state)) {
            updates.push([id, result]);
          }
        }
        for (const [id, record] of updates) {
          storage.set(id, record);
        }
      } else if (migration.scope === "store") {
        const prevStore = Object.fromEntries(storage.entries());
        let nextStore = structuredClone(prevStore);
        nextStore = migration.up(nextStore) ?? nextStore;
        for (const [id, state] of Object.entries(nextStore)) {
          if (!state) continue;
          if (!(0, import_lodash.default)(state, prevStore[id])) {
            storage.set(id, state);
          }
        }
        for (const id of Object.keys(prevStore)) {
          if (!nextStore[id]) {
            storage.delete(id);
          }
        }
      } else if (migration.scope === "storage") {
        migration.up(storage);
      } else {
        exhaustiveSwitchError(migration);
      }
    }
    for (const [id, state] of storage.entries()) {
      if (this.getType(state.typeName).scope !== "document") {
        storage.delete(id);
      }
    }
  }
  /**
   * Migrates an entire store snapshot to match the current schema version.
   *
   * This method applies all necessary migrations to bring a persisted store
   * snapshot up to the current schema version. It handles both record-level
   * and store-level migrations, and can optionally mutate the input store
   * for performance.
   *
   * @param snapshot - The store snapshot containing data and schema information
   * @param opts - Options controlling migration behavior
   *   - mutateInputStore - Whether to modify the input store directly (default: false)
   * @returns A MigrationResult containing the migrated store or an error
   *
   * @example
   * ```ts
   * const snapshot = {
   *   schema: { schemaVersion: 2, sequences: { 'com.tldraw.book': 1 } },
   *   store: {
   *     'book:1': { id: 'book:1', typeName: 'book', title: 'Old Book', publishDate: '2020-01-01' }
   *   }
   * }
   *
   * const result = schema.migrateStoreSnapshot(snapshot)
   * if (result.type === 'success') {
   *   console.log('Migrated store:', result.value)
   *   // All records are now at current schema version
   * }
   * ```
   *
   * @public
   */
  migrateStoreSnapshot(snapshot, opts) {
    const migrations = this.getMigrationsSince(snapshot.schema);
    if (!migrations.ok) {
      console.error("Error migrating store", migrations.error);
      return { type: "error", reason: MigrationFailureReason.MigrationError };
    }
    const migrationsToApply = migrations.value;
    if (migrationsToApply.length === 0) {
      return { type: "success", value: snapshot.store };
    }
    const store = Object.assign(
      new Map(objectMapEntries(snapshot.store).map(devFreeze)),
      {
        getSchema: () => snapshot.schema,
        setSchema: (_) => {
        }
      }
    );
    try {
      this.migrateStorage(store);
      if (opts == null ? void 0 : opts.mutateInputStore) {
        for (const [id, record] of store.entries()) {
          snapshot.store[id] = record;
        }
        for (const id of Object.keys(snapshot.store)) {
          if (!store.has(id)) {
            delete snapshot.store[id];
          }
        }
        return { type: "success", value: snapshot.store };
      } else {
        return {
          type: "success",
          value: Object.fromEntries(store.entries())
        };
      }
    } catch (e) {
      console.error("Error migrating store", e);
      return { type: "error", reason: MigrationFailureReason.MigrationError };
    }
  }
  /**
   * Creates an integrity checker function for the given store.
   *
   * This method calls the createIntegrityChecker option if provided, allowing
   * custom integrity checking logic to be set up for the store. The integrity
   * checker is used to validate store consistency and catch data corruption.
   *
   * @param store - The store instance to create an integrity checker for
   * @returns An integrity checker function, or undefined if none is configured
   *
   * @internal
   */
  createIntegrityChecker(store) {
    var _a6, _b3;
    return ((_b3 = (_a6 = this.options).createIntegrityChecker) == null ? void 0 : _b3.call(_a6, store)) ?? void 0;
  }
  /**
   * Serializes the current schema to a SerializedSchemaV2 format.
   *
   * This method creates a serialized representation of the current schema,
   * capturing the latest version number for each migration sequence.
   * The result can be persisted and later used to determine what migrations
   * need to be applied when loading data.
   *
   * @returns A SerializedSchemaV2 object representing the current schema state
   *
   * @example
   * ```ts
   * const serialized = schema.serialize()
   * console.log(serialized)
   * // {
   * //   schemaVersion: 2,
   * //   sequences: {
   * //     'com.tldraw.book': 3,
   * //     'com.tldraw.author': 2
   * //   }
   * // }
   *
   * // Store this with your data for future migrations
   * localStorage.setItem('schema', JSON.stringify(serialized))
   * ```
   *
   * @public
   */
  serialize() {
    return {
      schemaVersion: 2,
      sequences: Object.fromEntries(
        Object.values(this.migrations).map(({ sequenceId, sequence }) => [
          sequenceId,
          sequence.length ? parseMigrationId(sequence.at(-1).id).version : 0
        ])
      )
    };
  }
  /**
   * Serializes a schema representing the earliest possible version.
   *
   * This method creates a serialized schema where all migration sequences
   * are set to version 0, representing the state before any migrations
   * have been applied. This is used in specific legacy scenarios.
   *
   * @returns A SerializedSchema with all sequences set to version 0
   *
   * @deprecated This is only here for legacy reasons, don't use it unless you have david's blessing!
   * @internal
   */
  serializeEarliestVersion() {
    return {
      schemaVersion: 2,
      sequences: Object.fromEntries(
        Object.values(this.migrations).map(({ sequenceId }) => [sequenceId, 0])
      )
    };
  }
  /**
   * Gets the RecordType definition for a given type name.
   *
   * This method retrieves the RecordType associated with the specified
   * type name, which contains the record's validation, creation, and
   * other behavioral logic.
   *
   * @param typeName - The name of the record type to retrieve
   * @returns The RecordType definition for the specified type
   *
   * @throws Will throw an error if the record type does not exist
   *
   * @internal
   */
  getType(typeName) {
    const type = getOwnProperty(this.types, typeName);
    assert(type, "record type does not exists");
    return type;
  }
};

// ../node_modules/@tldraw/store/dist-esm/index.mjs
registerTldrawLibraryVersion(
  "@tldraw/store",
  "4.3.1",
  "esm"
);

// ../node_modules/@tldraw/tlschema/dist-esm/misc/id-validator.mjs
function idValidator(prefix) {
  return validation_exports.string.refine((id) => {
    if (!id.startsWith(`${prefix}:`)) {
      throw new Error(`${prefix} ID must start with "${prefix}:"`);
    }
    return id;
  });
}

// ../node_modules/@tldraw/tlschema/dist-esm/assets/TLBaseAsset.mjs
var assetIdValidator = idValidator("asset");
function createAssetValidator(type, props) {
  return validation_exports.object({
    id: assetIdValidator,
    typeName: validation_exports.literal("asset"),
    type: validation_exports.literal(type),
    props,
    meta: validation_exports.jsonValue
  });
}

// ../node_modules/@tldraw/tlschema/dist-esm/misc/geometry-types.mjs
var vecModelValidator = validation_exports.object({
  x: validation_exports.number,
  y: validation_exports.number,
  z: validation_exports.number.optional()
});
var boxModelValidator = validation_exports.object({
  x: validation_exports.number,
  y: validation_exports.number,
  w: validation_exports.number,
  h: validation_exports.number
});

// ../node_modules/@tldraw/tlschema/dist-esm/misc/TLOpacity.mjs
var opacityValidator = validation_exports.unitInterval;

// ../node_modules/@tldraw/tlschema/dist-esm/shapes/TLBaseShape.mjs
var parentIdValidator = validation_exports.string.refine((id) => {
  if (!id.startsWith("page:") && !id.startsWith("shape:")) {
    throw new Error('Parent ID must start with "page:" or "shape:"');
  }
  return id;
});
var shapeIdValidator = idValidator("shape");
function createShapeValidator(type, props, meta) {
  return validation_exports.object({
    id: shapeIdValidator,
    typeName: validation_exports.literal("shape"),
    x: validation_exports.number,
    y: validation_exports.number,
    rotation: validation_exports.number,
    index: validation_exports.indexKey,
    parentId: parentIdValidator,
    type: validation_exports.literal(type),
    isLocked: validation_exports.boolean,
    opacity: opacityValidator,
    props: props ? validation_exports.object(props) : validation_exports.jsonValue,
    meta: meta ? validation_exports.object(meta) : validation_exports.jsonValue
  });
}

// ../node_modules/@tldraw/tlschema/dist-esm/bindings/TLBaseBinding.mjs
var bindingIdValidator = idValidator("binding");
function createBindingValidator(type, props, meta) {
  return validation_exports.object({
    id: bindingIdValidator,
    typeName: validation_exports.literal("binding"),
    type: validation_exports.literal(type),
    fromId: shapeIdValidator,
    toId: shapeIdValidator,
    props: props ? validation_exports.object(props) : validation_exports.jsonValue,
    meta: meta ? validation_exports.object(meta) : validation_exports.jsonValue
  });
}

// ../node_modules/@tldraw/tlschema/dist-esm/records/TLBinding.mjs
var rootBindingVersions = createMigrationIds("com.tldraw.binding", {});
var rootBindingMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.binding",
  recordType: "binding",
  sequence: []
});
function isBinding(record) {
  if (!record) return false;
  return record.typeName === "binding";
}
function isBindingId(id) {
  if (!id) return false;
  return id.startsWith("binding:");
}
function createBindingId(id) {
  return `binding:${id ?? uniqueId()}`;
}
function createBindingPropsMigrationSequence(migrations) {
  return migrations;
}
function createBindingPropsMigrationIds(bindingType, ids) {
  return mapObjectMapValues(ids, (_k, v) => `com.tldraw.binding.${bindingType}/${v}`);
}
function createBindingRecordType(bindings) {
  return createRecordType("binding", {
    scope: "document",
    validator: validation_exports.model(
      "binding",
      validation_exports.union(
        "type",
        mapObjectMapValues(
          bindings,
          (type, { props, meta }) => createBindingValidator(type, props, meta)
        )
      )
    )
  }).withDefaultProperties(() => ({
    meta: {}
  }));
}

// ../node_modules/@tldraw/tlschema/dist-esm/misc/TLRichText.mjs
var richTextValidator = validation_exports.object({
  type: validation_exports.string,
  content: validation_exports.arrayOf(validation_exports.unknown),
  attrs: validation_exports.any.optional()
});
function toRichText(text) {
  const lines = text.split("\n");
  const content = lines.map((text2) => {
    if (!text2) {
      return {
        type: "paragraph"
      };
    }
    return {
      type: "paragraph",
      content: [{ type: "text", text: text2 }]
    };
  });
  return {
    type: "doc",
    content
  };
}

// ../node_modules/@tldraw/tlschema/dist-esm/styles/StyleProp.mjs
var StyleProp = class _StyleProp {
  /** @internal */
  constructor(id, defaultValue, type) {
    this.id = id;
    this.defaultValue = defaultValue;
    this.type = type;
  }
  /**
   * Define a new {@link StyleProp}.
   *
   * @param uniqueId - Each StyleProp must have a unique ID. We recommend you prefix this with
   * your app/library name.
   * @param options -
   * - `defaultValue`: The default value for this style prop.
   *
   * - `type`: Optionally, describe what type of data you expect for this style prop.
   *
   * @example
   * ```ts
   * import {T} from '@tldraw/validate'
   * import {StyleProp} from '@tldraw/tlschema'
   *
   * const MyLineWidthProp = StyleProp.define('myApp:lineWidth', {
   *   defaultValue: 1,
   *   type: T.number,
   * })
   * ```
   * @public
   */
  static define(uniqueId2, options2) {
    const { defaultValue, type = validation_exports.any } = options2;
    return new _StyleProp(uniqueId2, defaultValue, type);
  }
  /**
   * Define a new {@link StyleProp} as a list of possible values.
   *
   * @param uniqueId - Each StyleProp must have a unique ID. We recommend you prefix this with
   * your app/library name.
   * @param options -
   * - `defaultValue`: The default value for this style prop.
   *
   * - `values`: An array of possible values of this style prop.
   *
   * @example
   * ```ts
   * import {StyleProp} from '@tldraw/tlschema'
   *
   * const MySizeProp = StyleProp.defineEnum('myApp:size', {
   *   defaultValue: 'medium',
   *   values: ['small', 'medium', 'large'],
   * })
   * ```
   */
  static defineEnum(uniqueId2, options2) {
    const { defaultValue, values } = options2;
    return new EnumStyleProp(uniqueId2, defaultValue, values);
  }
  setDefaultValue(value) {
    this.defaultValue = value;
  }
  validate(value) {
    return this.type.validate(value);
  }
  validateUsingKnownGoodVersion(prevValue, newValue) {
    if (this.type.validateUsingKnownGoodVersion) {
      return this.type.validateUsingKnownGoodVersion(prevValue, newValue);
    } else {
      return this.validate(newValue);
    }
  }
};
var EnumStyleProp = class extends StyleProp {
  /** @internal */
  constructor(id, defaultValue, values) {
    super(id, defaultValue, validation_exports.literalEnum(...values));
    this.values = values;
  }
};

// ../node_modules/@tldraw/tlschema/dist-esm/records/TLShape.mjs
var rootShapeVersions = createMigrationIds("com.tldraw.shape", {
  AddIsLocked: 1,
  HoistOpacity: 2,
  AddMeta: 3,
  AddWhite: 4
});
var rootShapeMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.shape",
  recordType: "shape",
  sequence: [
    {
      id: rootShapeVersions.AddIsLocked,
      up: (record) => {
        record.isLocked = false;
      },
      down: (record) => {
        delete record.isLocked;
      }
    },
    {
      id: rootShapeVersions.HoistOpacity,
      up: (record) => {
        record.opacity = Number(record.props.opacity ?? "1");
        delete record.props.opacity;
      },
      down: (record) => {
        const opacity = record.opacity;
        delete record.opacity;
        record.props.opacity = opacity < 0.175 ? "0.1" : opacity < 0.375 ? "0.25" : opacity < 0.625 ? "0.5" : opacity < 0.875 ? "0.75" : "1";
      }
    },
    {
      id: rootShapeVersions.AddMeta,
      up: (record) => {
        record.meta = {};
      }
    },
    {
      id: rootShapeVersions.AddWhite,
      up: (_record) => {
      },
      down: (record) => {
        if (record.props.color === "white") {
          record.props.color = "black";
        }
      }
    }
  ]
});
function isShape(record) {
  if (!record) return false;
  return record.typeName === "shape";
}
function isShapeId(id) {
  if (!id) return false;
  return id.startsWith("shape:");
}
function createShapeId(id) {
  return `shape:${id ?? uniqueId()}`;
}
function getShapePropKeysByStyle(props) {
  const propKeysByStyle = /* @__PURE__ */ new Map();
  for (const [key, prop] of Object.entries(props)) {
    if (prop instanceof StyleProp) {
      if (propKeysByStyle.has(prop)) {
        throw new Error(
          `Duplicate style prop ${prop.id}. Each style prop can only be used once within a shape.`
        );
      }
      propKeysByStyle.set(prop, key);
    }
  }
  return propKeysByStyle;
}
function createShapePropsMigrationSequence(migrations) {
  return migrations;
}
function createShapePropsMigrationIds(shapeType, ids) {
  return mapObjectMapValues(ids, (_k, v) => `com.tldraw.shape.${shapeType}/${v}`);
}
function createShapeRecordType(shapes) {
  return createRecordType("shape", {
    scope: "document",
    validator: validation_exports.model(
      "shape",
      validation_exports.union(
        "type",
        mapObjectMapValues(
          shapes,
          (type, { props, meta }) => createShapeValidator(type, props, meta)
        )
      )
    )
  }).withDefaultProperties(() => ({
    x: 0,
    y: 0,
    rotation: 0,
    isLocked: false,
    opacity: 1,
    meta: {}
  }));
}

// ../node_modules/@tldraw/tlschema/dist-esm/recordsWithProps.mjs
function processPropsMigrations(typeName, records) {
  const result = [];
  for (const [subType, { migrations }] of Object.entries(records)) {
    const sequenceId = `com.tldraw.${typeName}.${subType}`;
    if (!migrations) {
      result.push(
        createMigrationSequence({
          sequenceId,
          retroactive: true,
          sequence: []
        })
      );
    } else if ("sequenceId" in migrations) {
      assert(
        sequenceId === migrations.sequenceId,
        `sequenceId mismatch for ${subType} ${RecordType} migrations. Expected '${sequenceId}', got '${migrations.sequenceId}'`
      );
      result.push(migrations);
    } else if ("sequence" in migrations) {
      result.push(
        createMigrationSequence({
          sequenceId,
          retroactive: true,
          sequence: migrations.sequence.map(
            (m) => "id" in m ? createPropsMigration(typeName, subType, m) : m
          )
        })
      );
    } else {
      result.push(
        createMigrationSequence({
          sequenceId,
          retroactive: true,
          sequence: Object.keys(migrations.migrators).map((k) => Number(k)).sort((a, b) => a - b).map(
            (version2) => ({
              id: `${sequenceId}/${version2}`,
              scope: "record",
              filter: (r) => r.typeName === typeName && r.type === subType,
              up: (record) => {
                const result2 = migrations.migrators[version2].up(record);
                if (result2) {
                  return result2;
                }
              },
              down: (record) => {
                const result2 = migrations.migrators[version2].down(record);
                if (result2) {
                  return result2;
                }
              }
            })
          )
        })
      );
    }
  }
  return result;
}
function createPropsMigration(typeName, subType, m) {
  return {
    id: m.id,
    dependsOn: m.dependsOn,
    scope: "record",
    filter: (r) => r.typeName === typeName && r.type === subType,
    up: (record) => {
      const result = m.up(record.props);
      if (result) {
        record.props = result;
      }
    },
    down: typeof m.down === "function" ? (record) => {
      const result = m.down(record.props);
      if (result) {
        record.props = result;
      }
    } : void 0
  };
}

// ../node_modules/@tldraw/tlschema/dist-esm/styles/TLColorStyle.mjs
var defaultColorNames = [
  "black",
  "grey",
  "light-violet",
  "violet",
  "blue",
  "light-blue",
  "yellow",
  "orange",
  "green",
  "light-green",
  "light-red",
  "red",
  "white"
];
var DefaultColorThemePalette = {
  lightMode: {
    id: "light",
    text: "#000000",
    background: "#f9fafb",
    solid: "#fcfffe",
    black: {
      solid: "#1d1d1d",
      fill: "#1d1d1d",
      linedFill: "#363636",
      frameHeadingStroke: "#717171",
      frameHeadingFill: "#ffffff",
      frameStroke: "#717171",
      frameFill: "#ffffff",
      frameText: "#000000",
      noteFill: "#FCE19C",
      noteText: "#000000",
      semi: "#e8e8e8",
      pattern: "#494949",
      highlightSrgb: "#fddd00",
      highlightP3: "color(display-p3 0.972 0.8205 0.05)"
    },
    blue: {
      solid: "#4465e9",
      fill: "#4465e9",
      linedFill: "#6580ec",
      frameHeadingStroke: "#6681ec",
      frameHeadingFill: "#f9fafe",
      frameStroke: "#6681ec",
      frameFill: "#f9fafe",
      frameText: "#000000",
      noteFill: "#8AA3FF",
      noteText: "#000000",
      semi: "#dce1f8",
      pattern: "#6681ee",
      highlightSrgb: "#10acff",
      highlightP3: "color(display-p3 0.308 0.6632 0.9996)"
    },
    green: {
      solid: "#099268",
      fill: "#099268",
      linedFill: "#0bad7c",
      frameHeadingStroke: "#37a684",
      frameHeadingFill: "#f8fcfa",
      frameStroke: "#37a684",
      frameFill: "#f8fcfa",
      frameText: "#000000",
      noteFill: "#6FC896",
      noteText: "#000000",
      semi: "#d3e9e3",
      pattern: "#39a785",
      highlightSrgb: "#00ffc8",
      highlightP3: "color(display-p3 0.2536 0.984 0.7981)"
    },
    grey: {
      solid: "#9fa8b2",
      fill: "#9fa8b2",
      linedFill: "#bbc1c9",
      frameHeadingStroke: "#aaaaab",
      frameHeadingFill: "#fbfcfc",
      frameStroke: "#aaaaab",
      frameFill: "#fcfcfd",
      frameText: "#000000",
      noteFill: "#C0CAD3",
      noteText: "#000000",
      semi: "#eceef0",
      pattern: "#bcc3c9",
      highlightSrgb: "#cbe7f1",
      highlightP3: "color(display-p3 0.8163 0.9023 0.9416)"
    },
    "light-blue": {
      solid: "#4ba1f1",
      fill: "#4ba1f1",
      linedFill: "#7abaf5",
      frameHeadingStroke: "#6cb2f3",
      frameHeadingFill: "#f8fbfe",
      frameStroke: "#6cb2f3",
      frameFill: "#fafcff",
      frameText: "#000000",
      noteFill: "#9BC4FD",
      noteText: "#000000",
      semi: "#ddedfa",
      pattern: "#6fbbf8",
      highlightSrgb: "#00f4ff",
      highlightP3: "color(display-p3 0.1512 0.9414 0.9996)"
    },
    "light-green": {
      solid: "#4cb05e",
      fill: "#4cb05e",
      linedFill: "#7ec88c",
      frameHeadingStroke: "#6dbe7c",
      frameHeadingFill: "#f8fcf9",
      frameStroke: "#6dbe7c",
      frameFill: "#fafdfa",
      frameText: "#000000",
      noteFill: "#98D08A",
      noteText: "#000000",
      semi: "#dbf0e0",
      pattern: "#65cb78",
      highlightSrgb: "#65f641",
      highlightP3: "color(display-p3 0.563 0.9495 0.3857)"
    },
    "light-red": {
      solid: "#f87777",
      fill: "#f87777",
      linedFill: "#f99a9a",
      frameHeadingStroke: "#f89090",
      frameHeadingFill: "#fffafa",
      frameStroke: "#f89090",
      frameFill: "#fffbfb",
      frameText: "#000000",
      noteFill: "#F7A5A1",
      noteText: "#000000",
      semi: "#f4dadb",
      pattern: "#fe9e9e",
      highlightSrgb: "#ff7fa3",
      highlightP3: "color(display-p3 0.9988 0.5301 0.6397)"
    },
    "light-violet": {
      solid: "#e085f4",
      fill: "#e085f4",
      linedFill: "#e9abf7",
      frameHeadingStroke: "#e59bf5",
      frameHeadingFill: "#fefaff",
      frameStroke: "#e59bf5",
      frameFill: "#fefbff",
      frameText: "#000000",
      noteFill: "#DFB0F9",
      noteText: "#000000",
      semi: "#f5eafa",
      pattern: "#e9acf8",
      highlightSrgb: "#ff88ff",
      highlightP3: "color(display-p3 0.9676 0.5652 0.9999)"
    },
    orange: {
      solid: "#e16919",
      fill: "#e16919",
      linedFill: "#ea8643",
      frameHeadingStroke: "#e68544",
      frameHeadingFill: "#fef9f6",
      frameStroke: "#e68544",
      frameFill: "#fef9f6",
      frameText: "#000000",
      noteFill: "#FAA475",
      noteText: "#000000",
      semi: "#f8e2d4",
      pattern: "#f78438",
      highlightSrgb: "#ffa500",
      highlightP3: "color(display-p3 0.9988 0.6905 0.266)"
    },
    red: {
      solid: "#e03131",
      fill: "#e03131",
      linedFill: "#e75f5f",
      frameHeadingStroke: "#e55757",
      frameHeadingFill: "#fef7f7",
      frameStroke: "#e55757",
      frameFill: "#fef9f9",
      frameText: "#000000",
      noteFill: "#FC8282",
      noteText: "#000000",
      semi: "#f4dadb",
      pattern: "#e55959",
      highlightSrgb: "#ff636e",
      highlightP3: "color(display-p3 0.9992 0.4376 0.45)"
    },
    violet: {
      solid: "#ae3ec9",
      fill: "#ae3ec9",
      linedFill: "#be68d4",
      frameHeadingStroke: "#bc62d3",
      frameHeadingFill: "#fcf7fd",
      frameStroke: "#bc62d3",
      frameFill: "#fdf9fd",
      frameText: "#000000",
      noteFill: "#DB91FD",
      noteText: "#000000",
      semi: "#ecdcf2",
      pattern: "#bd63d3",
      highlightSrgb: "#c77cff",
      highlightP3: "color(display-p3 0.7469 0.5089 0.9995)"
    },
    yellow: {
      solid: "#f1ac4b",
      fill: "#f1ac4b",
      linedFill: "#f5c27a",
      frameHeadingStroke: "#f3bb6c",
      frameHeadingFill: "#fefcf8",
      frameStroke: "#f3bb6c",
      frameFill: "#fffdfa",
      frameText: "#000000",
      noteFill: "#FED49A",
      noteText: "#000000",
      semi: "#f9f0e6",
      pattern: "#fecb92",
      highlightSrgb: "#fddd00",
      highlightP3: "color(display-p3 0.972 0.8705 0.05)"
    },
    white: {
      solid: "#FFFFFF",
      fill: "#FFFFFF",
      linedFill: "#ffffff",
      semi: "#f5f5f5",
      pattern: "#f9f9f9",
      frameHeadingStroke: "#7d7d7d",
      frameHeadingFill: "#ffffff",
      frameStroke: "#7d7d7d",
      frameFill: "#ffffff",
      frameText: "#000000",
      noteFill: "#FFFFFF",
      noteText: "#000000",
      highlightSrgb: "#ffffff",
      highlightP3: "color(display-p3 1 1 1)"
    }
  },
  darkMode: {
    id: "dark",
    text: "hsl(210, 17%, 98%)",
    background: "hsl(240, 5%, 6.5%)",
    solid: "#010403",
    black: {
      solid: "#f2f2f2",
      fill: "#f2f2f2",
      linedFill: "#ffffff",
      frameHeadingStroke: "#5c5c5c",
      frameHeadingFill: "#252525",
      frameStroke: "#5c5c5c",
      frameFill: "#0c0c0c",
      frameText: "#f2f2f2",
      noteFill: "#2c2c2c",
      noteText: "#f2f2f2",
      semi: "#2c3036",
      pattern: "#989898",
      highlightSrgb: "#d2b700",
      highlightP3: "color(display-p3 0.8078 0.6225 0.0312)"
    },
    blue: {
      solid: "#4f72fc",
      // 3c60f0
      fill: "#4f72fc",
      linedFill: "#3c5cdd",
      frameHeadingStroke: "#384994",
      frameHeadingFill: "#1C2036",
      frameStroke: "#384994",
      frameFill: "#11141f",
      frameText: "#f2f2f2",
      noteFill: "#2A3F98",
      noteText: "#f2f2f2",
      semi: "#262d40",
      pattern: "#3a4b9e",
      highlightSrgb: "#0079d2",
      highlightP3: "color(display-p3 0.0032 0.4655 0.7991)"
    },
    green: {
      solid: "#099268",
      fill: "#099268",
      linedFill: "#087856",
      frameHeadingStroke: "#10513C",
      frameHeadingFill: "#14241f",
      frameStroke: "#10513C",
      frameFill: "#0E1614",
      frameText: "#f2f2f2",
      noteFill: "#014429",
      noteText: "#f2f2f2",
      semi: "#253231",
      pattern: "#366a53",
      highlightSrgb: "#009774",
      highlightP3: "color(display-p3 0.0085 0.582 0.4604)"
    },
    grey: {
      solid: "#9398b0",
      fill: "#9398b0",
      linedFill: "#8388a5",
      frameHeadingStroke: "#42474D",
      frameHeadingFill: "#23262A",
      frameStroke: "#42474D",
      frameFill: "#151719",
      frameText: "#f2f2f2",
      noteFill: "#56595F",
      noteText: "#f2f2f2",
      semi: "#33373c",
      pattern: "#7c8187",
      highlightSrgb: "#9cb4cb",
      highlightP3: "color(display-p3 0.6299 0.7012 0.7856)"
    },
    "light-blue": {
      solid: "#4dabf7",
      fill: "#4dabf7",
      linedFill: "#2793ec",
      frameHeadingStroke: "#075797",
      frameHeadingFill: "#142839",
      frameStroke: "#075797",
      frameFill: "#0B1823",
      frameText: "#f2f2f2",
      noteFill: "#1F5495",
      noteText: "#f2f2f2",
      semi: "#2a3642",
      pattern: "#4d7aa9",
      highlightSrgb: "#00bdc8",
      highlightP3: "color(display-p3 0.0023 0.7259 0.7735)"
    },
    "light-green": {
      solid: "#40c057",
      fill: "#40c057",
      linedFill: "#37a44b",
      frameHeadingStroke: "#1C5427",
      frameHeadingFill: "#18251A",
      frameStroke: "#1C5427",
      frameFill: "#0F1911",
      frameText: "#f2f2f2",
      noteFill: "#21581D",
      noteText: "#f2f2f2",
      semi: "#2a3830",
      pattern: "#4e874e",
      highlightSrgb: "#00a000",
      highlightP3: "color(display-p3 0.2711 0.6172 0.0195)"
    },
    "light-red": {
      solid: "#ff8787",
      fill: "#ff8787",
      linedFill: "#ff6666",
      frameHeadingStroke: "#6f3232",
      // Darker and desaturated variant of solid
      frameHeadingFill: "#341818",
      // Deep, muted dark red
      frameStroke: "#6f3232",
      // Matches headingStroke
      frameFill: "#181212",
      // Darker, muted background shade
      frameText: "#f2f2f2",
      // Consistent bright text color
      noteFill: "#7a3333",
      // Medium-dark, muted variant of solid
      noteText: "#f2f2f2",
      semi: "#3c2b2b",
      // Subdued, darker neutral-red tone
      pattern: "#a56767",
      // Existing pattern shade retained
      highlightSrgb: "#db005b",
      highlightP3: "color(display-p3 0.7849 0.0585 0.3589)"
    },
    "light-violet": {
      solid: "#e599f7",
      fill: "#e599f7",
      linedFill: "#dc71f4",
      frameHeadingStroke: "#6c367a",
      frameHeadingFill: "#2D2230",
      frameStroke: "#6c367a",
      frameFill: "#1C151E",
      frameText: "#f2f2f2",
      noteFill: "#762F8E",
      noteText: "#f2f2f2",
      semi: "#383442",
      pattern: "#9770a9",
      highlightSrgb: "#c400c7",
      highlightP3: "color(display-p3 0.7024 0.0403 0.753)"
    },
    orange: {
      solid: "#f76707",
      fill: "#f76707",
      linedFill: "#f54900",
      frameHeadingStroke: "#773a0e",
      // Darker, muted version of solid
      frameHeadingFill: "#2f1d13",
      // Deep, warm, muted background
      frameStroke: "#773a0e",
      // Matches headingStroke
      frameFill: "#1c1512",
      // Darker, richer muted background
      frameText: "#f2f2f2",
      // Bright text for contrast
      noteFill: "#7c3905",
      // Muted dark variant for note fill
      noteText: "#f2f2f2",
      semi: "#3b2e27",
      // Muted neutral-orange tone
      pattern: "#9f552d",
      // Retained existing shade
      highlightSrgb: "#d07a00",
      highlightP3: "color(display-p3 0.7699 0.4937 0.0085)"
    },
    red: {
      solid: "#e03131",
      fill: "#e03131",
      linedFill: "#c31d1d",
      frameHeadingStroke: "#701e1e",
      // Darker, muted variation of solid
      frameHeadingFill: "#301616",
      // Deep, muted reddish backdrop
      frameStroke: "#701e1e",
      // Matches headingStroke
      frameFill: "#1b1313",
      // Rich, dark muted background
      frameText: "#f2f2f2",
      // Bright text for readability
      noteFill: "#7e201f",
      // Muted dark variant for note fill
      noteText: "#f2f2f2",
      semi: "#382726",
      // Dark neutral-red tone
      pattern: "#8f3734",
      // Existing pattern color retained
      highlightSrgb: "#de002c",
      highlightP3: "color(display-p3 0.7978 0.0509 0.2035)"
    },
    violet: {
      solid: "#ae3ec9",
      fill: "#ae3ec9",
      linedFill: "#8f2fa7",
      frameHeadingStroke: "#6d1583",
      // Darker, muted variation of solid
      frameHeadingFill: "#27152e",
      // Deep, rich muted violet backdrop
      frameStroke: "#6d1583",
      // Matches headingStroke
      frameFill: "#1b0f21",
      // Darker muted violet background
      frameText: "#f2f2f2",
      // Consistent bright text color
      noteFill: "#5f1c70",
      // Muted dark variant for note fill
      noteText: "#f2f2f2",
      semi: "#342938",
      // Dark neutral-violet tone
      pattern: "#763a8b",
      // Retained existing pattern color
      highlightSrgb: "#9e00ee",
      highlightP3: "color(display-p3 0.5651 0.0079 0.8986)"
    },
    yellow: {
      solid: "#ffc034",
      fill: "#ffc034",
      linedFill: "#ffae00",
      frameHeadingStroke: "#684e12",
      // Darker, muted variant of solid
      frameHeadingFill: "#2a2113",
      // Rich, muted dark-yellow background
      frameStroke: "#684e12",
      // Matches headingStroke
      frameFill: "#1e1911",
      // Darker muted shade for background fill
      frameText: "#f2f2f2",
      // Bright text color for readability
      noteFill: "#8a5e1c",
      // Muted, dark complementary variant
      noteText: "#f2f2f2",
      semi: "#3b352b",
      // Dark muted neutral-yellow tone
      pattern: "#fecb92",
      // Existing shade retained
      highlightSrgb: "#d2b700",
      highlightP3: "color(display-p3 0.8078 0.7225 0.0312)"
    },
    white: {
      solid: "#f3f3f3",
      fill: "#f3f3f3",
      linedFill: "#f3f3f3",
      semi: "#f5f5f5",
      pattern: "#f9f9f9",
      frameHeadingStroke: "#ffffff",
      frameHeadingFill: "#ffffff",
      frameStroke: "#ffffff",
      frameFill: "#ffffff",
      frameText: "#000000",
      noteFill: "#eaeaea",
      noteText: "#1d1d1d",
      highlightSrgb: "#ffffff",
      highlightP3: "color(display-p3 1 1 1)"
    }
  }
};
function getDefaultColorTheme(opts) {
  return opts.isDarkMode ? DefaultColorThemePalette.darkMode : DefaultColorThemePalette.lightMode;
}
var DefaultColorStyle = StyleProp.defineEnum("tldraw:color", {
  defaultValue: "black",
  values: defaultColorNames
});
var DefaultLabelColorStyle = StyleProp.defineEnum("tldraw:labelColor", {
  defaultValue: "black",
  values: defaultColorNames
});
var defaultColorNamesSet = new Set(defaultColorNames);
function isDefaultThemeColor(color) {
  return defaultColorNamesSet.has(color);
}
function getColorValue(theme, color, variant) {
  if (!isDefaultThemeColor(color)) {
    return color;
  }
  return theme[color][variant];
}

// ../node_modules/@tldraw/tlschema/dist-esm/styles/TLDashStyle.mjs
var DefaultDashStyle = StyleProp.defineEnum("tldraw:dash", {
  defaultValue: "draw",
  values: ["draw", "solid", "dashed", "dotted"]
});

// ../node_modules/@tldraw/tlschema/dist-esm/styles/TLFillStyle.mjs
var DefaultFillStyle = StyleProp.defineEnum("tldraw:fill", {
  defaultValue: "none",
  values: ["none", "semi", "solid", "pattern", "fill", "lined-fill"]
});

// ../node_modules/@tldraw/tlschema/dist-esm/styles/TLFontStyle.mjs
var DefaultFontStyle = StyleProp.defineEnum("tldraw:font", {
  defaultValue: "draw",
  values: ["draw", "sans", "serif", "mono"]
});
var DefaultFontFamilies = {
  draw: "'tldraw_draw', sans-serif",
  sans: "'tldraw_sans', sans-serif",
  serif: "'tldraw_serif', serif",
  mono: "'tldraw_mono', monospace"
};

// ../node_modules/@tldraw/tlschema/dist-esm/styles/TLSizeStyle.mjs
var DefaultSizeStyle = StyleProp.defineEnum("tldraw:size", {
  defaultValue: "m",
  values: ["s", "m", "l", "xl"]
});

// ../node_modules/@tldraw/tlschema/dist-esm/shapes/TLArrowShape.mjs
var arrowKinds = ["arc", "elbow"];
var ArrowShapeKindStyle = StyleProp.defineEnum("tldraw:arrowKind", {
  defaultValue: "arc",
  values: arrowKinds
});
var arrowheadTypes = [
  "arrow",
  "triangle",
  "square",
  "dot",
  "pipe",
  "diamond",
  "inverted",
  "bar",
  "none"
];
var ArrowShapeArrowheadStartStyle = StyleProp.defineEnum("tldraw:arrowheadStart", {
  defaultValue: "none",
  values: arrowheadTypes
});
var ArrowShapeArrowheadEndStyle = StyleProp.defineEnum("tldraw:arrowheadEnd", {
  defaultValue: "arrow",
  values: arrowheadTypes
});
var arrowShapeProps = {
  kind: ArrowShapeKindStyle,
  labelColor: DefaultLabelColorStyle,
  color: DefaultColorStyle,
  fill: DefaultFillStyle,
  dash: DefaultDashStyle,
  size: DefaultSizeStyle,
  arrowheadStart: ArrowShapeArrowheadStartStyle,
  arrowheadEnd: ArrowShapeArrowheadEndStyle,
  font: DefaultFontStyle,
  start: vecModelValidator,
  end: vecModelValidator,
  bend: validation_exports.number,
  richText: richTextValidator,
  labelPosition: validation_exports.number,
  scale: validation_exports.nonZeroNumber,
  elbowMidPoint: validation_exports.number
};
var arrowShapeVersions = createShapePropsMigrationIds("arrow", {
  AddLabelColor: 1,
  AddIsPrecise: 2,
  AddLabelPosition: 3,
  ExtractBindings: 4,
  AddScale: 5,
  AddElbow: 6,
  AddRichText: 7,
  AddRichTextAttrs: 8
});
function propsMigration(migration) {
  return createPropsMigration("shape", "arrow", migration);
}
var arrowShapeMigrations = createMigrationSequence({
  sequenceId: "com.tldraw.shape.arrow",
  retroactive: false,
  sequence: [
    propsMigration({
      id: arrowShapeVersions.AddLabelColor,
      up: (props) => {
        props.labelColor = "black";
      },
      down: "retired"
    }),
    propsMigration({
      id: arrowShapeVersions.AddIsPrecise,
      up: ({ start, end }) => {
        if (start.type === "binding") {
          start.isPrecise = !(start.normalizedAnchor.x === 0.5 && start.normalizedAnchor.y === 0.5);
        }
        if (end.type === "binding") {
          end.isPrecise = !(end.normalizedAnchor.x === 0.5 && end.normalizedAnchor.y === 0.5);
        }
      },
      down: ({ start, end }) => {
        if (start.type === "binding") {
          if (!start.isPrecise) {
            start.normalizedAnchor = { x: 0.5, y: 0.5 };
          }
          delete start.isPrecise;
        }
        if (end.type === "binding") {
          if (!end.isPrecise) {
            end.normalizedAnchor = { x: 0.5, y: 0.5 };
          }
          delete end.isPrecise;
        }
      }
    }),
    propsMigration({
      id: arrowShapeVersions.AddLabelPosition,
      up: (props) => {
        props.labelPosition = 0.5;
      },
      down: (props) => {
        delete props.labelPosition;
      }
    }),
    {
      id: arrowShapeVersions.ExtractBindings,
      scope: "storage",
      up: (storage) => {
        const updates = [];
        for (const record of storage.values()) {
          if (record.typeName !== "shape" || record.type !== "arrow") continue;
          const arrow5 = record;
          const newArrow = structuredClone(arrow5);
          const { start, end } = arrow5.props;
          if (start.type === "binding") {
            const id = createBindingId();
            const binding = {
              typeName: "binding",
              id,
              type: "arrow",
              fromId: arrow5.id,
              toId: start.boundShapeId,
              meta: {},
              props: {
                terminal: "start",
                normalizedAnchor: start.normalizedAnchor,
                isExact: start.isExact,
                isPrecise: start.isPrecise
              }
            };
            updates.push([id, binding]);
            newArrow.props.start = { x: 0, y: 0 };
          } else {
            delete newArrow.props.start.type;
          }
          if (end.type === "binding") {
            const id = createBindingId();
            const binding = {
              typeName: "binding",
              id,
              type: "arrow",
              fromId: arrow5.id,
              toId: end.boundShapeId,
              meta: {},
              props: {
                terminal: "end",
                normalizedAnchor: end.normalizedAnchor,
                isExact: end.isExact,
                isPrecise: end.isPrecise
              }
            };
            updates.push([id, binding]);
            newArrow.props.end = { x: 0, y: 0 };
          } else {
            delete newArrow.props.end.type;
          }
          updates.push([arrow5.id, newArrow]);
        }
        for (const [id, record] of updates) {
          storage.set(id, record);
        }
      }
    },
    propsMigration({
      id: arrowShapeVersions.AddScale,
      up: (props) => {
        props.scale = 1;
      },
      down: (props) => {
        delete props.scale;
      }
    }),
    propsMigration({
      id: arrowShapeVersions.AddElbow,
      up: (props) => {
        props.kind = "arc";
        props.elbowMidPoint = 0.5;
      },
      down: (props) => {
        delete props.kind;
        delete props.elbowMidPoint;
      }
    }),
    propsMigration({
      id: arrowShapeVersions.AddRichText,
      up: (props) => {
        props.richText = toRichText(props.text);
        delete props.text;
      }
      // N.B. Explicitly no down state so that we force clients to update.
      // down: (props) => {
      // 	delete props.richText
      // },
    }),
    propsMigration({
      id: arrowShapeVersions.AddRichTextAttrs,
      up: (_props) => {
      },
      down: (props) => {
        if (props.richText && "attrs" in props.richText) {
          delete props.richText.attrs;
        }
      }
    })
  ]
});

// ../node_modules/@tldraw/tlschema/dist-esm/bindings/TLArrowBinding.mjs
var ElbowArrowSnap = validation_exports.literalEnum("center", "edge-point", "edge", "none");
var arrowBindingProps = {
  terminal: validation_exports.literalEnum("start", "end"),
  normalizedAnchor: vecModelValidator,
  isExact: validation_exports.boolean,
  isPrecise: validation_exports.boolean,
  snap: ElbowArrowSnap
};
var arrowBindingVersions = createBindingPropsMigrationIds("arrow", {
  AddSnap: 1
});
var arrowBindingMigrations = createBindingPropsMigrationSequence({
  sequence: [
    { dependsOn: [arrowShapeVersions.ExtractBindings] },
    {
      id: arrowBindingVersions.AddSnap,
      up: (props) => {
        props.snap = "none";
      },
      down: (props) => {
        delete props.snap;
      }
    }
  ]
});

// ../node_modules/@tldraw/tlschema/dist-esm/records/TLCamera.mjs
var cameraValidator = validation_exports.model(
  "camera",
  validation_exports.object({
    typeName: validation_exports.literal("camera"),
    id: idValidator("camera"),
    x: validation_exports.number,
    y: validation_exports.number,
    z: validation_exports.number,
    meta: validation_exports.jsonValue
  })
);
var cameraVersions = createMigrationIds("com.tldraw.camera", {
  AddMeta: 1
});
var cameraMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.camera",
  recordType: "camera",
  sequence: [
    {
      id: cameraVersions.AddMeta,
      up: (record) => {
        ;
        record.meta = {};
      }
    }
  ]
});
var CameraRecordType = createRecordType("camera", {
  validator: cameraValidator,
  scope: "session"
}).withDefaultProperties(
  () => ({
    x: 0,
    y: 0,
    z: 1,
    meta: {}
  })
);

// ../node_modules/@tldraw/tlschema/dist-esm/misc/TLCursor.mjs
var TL_CURSOR_TYPES = /* @__PURE__ */ new Set([
  "none",
  "default",
  "pointer",
  "cross",
  "grab",
  "rotate",
  "grabbing",
  "resize-edge",
  "resize-corner",
  "text",
  "move",
  "ew-resize",
  "ns-resize",
  "nesw-resize",
  "nwse-resize",
  "nesw-rotate",
  "nwse-rotate",
  "swne-rotate",
  "senw-rotate",
  "zoom-in",
  "zoom-out"
]);
var cursorTypeValidator = validation_exports.setEnum(TL_CURSOR_TYPES);
var cursorValidator = validation_exports.object({
  type: cursorTypeValidator,
  rotation: validation_exports.number
});

// ../node_modules/@tldraw/tlschema/dist-esm/misc/TLColor.mjs
var TL_CANVAS_UI_COLOR_TYPES = /* @__PURE__ */ new Set([
  "accent",
  "white",
  "black",
  "selection-stroke",
  "selection-fill",
  "laser",
  "muted-1"
]);
var canvasUiColorTypeValidator = validation_exports.setEnum(TL_CANVAS_UI_COLOR_TYPES);

// ../node_modules/@tldraw/tlschema/dist-esm/misc/TLScribble.mjs
var TL_SCRIBBLE_STATES = /* @__PURE__ */ new Set(["starting", "paused", "active", "stopping"]);
var scribbleValidator = validation_exports.object({
  id: validation_exports.string,
  points: validation_exports.arrayOf(vecModelValidator),
  size: validation_exports.positiveNumber,
  color: canvasUiColorTypeValidator,
  opacity: validation_exports.number,
  state: validation_exports.setEnum(TL_SCRIBBLE_STATES),
  delay: validation_exports.number,
  shrink: validation_exports.number,
  taper: validation_exports.boolean
});

// ../node_modules/@tldraw/tlschema/dist-esm/records/TLPage.mjs
var pageIdValidator = idValidator("page");
var pageValidator = validation_exports.model(
  "page",
  validation_exports.object({
    typeName: validation_exports.literal("page"),
    id: pageIdValidator,
    name: validation_exports.string,
    index: validation_exports.indexKey,
    meta: validation_exports.jsonValue
  })
);
var pageVersions = createMigrationIds("com.tldraw.page", {
  AddMeta: 1
});
var pageMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.page",
  recordType: "page",
  sequence: [
    {
      id: pageVersions.AddMeta,
      up: (record) => {
        record.meta = {};
      }
    }
  ]
});
var PageRecordType = createRecordType("page", {
  validator: pageValidator,
  scope: "document"
}).withDefaultProperties(() => ({
  meta: {}
}));
function isPageId(id) {
  return PageRecordType.isId(id);
}

// ../node_modules/@tldraw/tlschema/dist-esm/records/TLInstance.mjs
var shouldKeyBePreservedBetweenSessions = {
  // This object defines keys that should be preserved across calls to loadSnapshot()
  id: false,
  // meta
  typeName: false,
  // meta
  currentPageId: false,
  // does not preserve because who knows if the page still exists
  opacityForNextShape: false,
  // does not preserve because it's a temporary state
  stylesForNextShape: false,
  // does not preserve because it's a temporary state
  followingUserId: false,
  // does not preserve because it's a temporary state
  highlightedUserIds: false,
  // does not preserve because it's a temporary state
  brush: false,
  // does not preserve because it's a temporary state
  cursor: false,
  // does not preserve because it's a temporary state
  scribbles: false,
  // does not preserve because it's a temporary state
  isFocusMode: true,
  // preserves because it's a user preference
  isDebugMode: true,
  // preserves because it's a user preference
  isToolLocked: true,
  // preserves because it's a user preference
  exportBackground: true,
  // preserves because it's a user preference
  screenBounds: true,
  // preserves because it's capturing the user's screen state
  insets: true,
  // preserves because it's capturing the user's screen state
  zoomBrush: false,
  // does not preserve because it's a temporary state
  chatMessage: false,
  // does not preserve because it's a temporary state
  isChatting: false,
  // does not preserve because it's a temporary state
  isPenMode: false,
  // does not preserve because it's a temporary state
  isGridMode: true,
  // preserves because it's a user preference
  isFocused: true,
  // preserves because obviously
  devicePixelRatio: true,
  // preserves because it captures the user's screen state
  isCoarsePointer: true,
  // preserves because it captures the user's screen state
  isHoveringCanvas: false,
  // does not preserve because it's a temporary state
  openMenus: false,
  // does not preserve because it's a temporary state
  isChangingStyle: false,
  // does not preserve because it's a temporary state
  isReadonly: true,
  // preserves because it's a config option
  meta: false,
  // does not preserve because who knows what's in there, leave it up to sdk users to save and reinstate
  duplicateProps: false
  //
};
function pluckPreservingValues(val) {
  return val ? filterEntries(val, (key) => {
    return shouldKeyBePreservedBetweenSessions[key];
  }) : null;
}
var instanceIdValidator = idValidator("instance");
function createInstanceRecordType(stylesById) {
  const stylesForNextShapeValidators = {};
  for (const [id, style2] of stylesById) {
    stylesForNextShapeValidators[id] = validation_exports.optional(style2);
  }
  const instanceTypeValidator = validation_exports.model(
    "instance",
    validation_exports.object({
      typeName: validation_exports.literal("instance"),
      id: idValidator("instance"),
      currentPageId: pageIdValidator,
      followingUserId: validation_exports.string.nullable(),
      brush: boxModelValidator.nullable(),
      opacityForNextShape: opacityValidator,
      stylesForNextShape: validation_exports.object(stylesForNextShapeValidators),
      cursor: cursorValidator,
      scribbles: validation_exports.arrayOf(scribbleValidator),
      isFocusMode: validation_exports.boolean,
      isDebugMode: validation_exports.boolean,
      isToolLocked: validation_exports.boolean,
      exportBackground: validation_exports.boolean,
      screenBounds: boxModelValidator,
      insets: validation_exports.arrayOf(validation_exports.boolean),
      zoomBrush: boxModelValidator.nullable(),
      isPenMode: validation_exports.boolean,
      isGridMode: validation_exports.boolean,
      chatMessage: validation_exports.string,
      isChatting: validation_exports.boolean,
      highlightedUserIds: validation_exports.arrayOf(validation_exports.string),
      isFocused: validation_exports.boolean,
      devicePixelRatio: validation_exports.number,
      isCoarsePointer: validation_exports.boolean,
      isHoveringCanvas: validation_exports.boolean.nullable(),
      openMenus: validation_exports.arrayOf(validation_exports.string),
      isChangingStyle: validation_exports.boolean,
      isReadonly: validation_exports.boolean,
      meta: validation_exports.jsonValue,
      duplicateProps: validation_exports.object({
        shapeIds: validation_exports.arrayOf(idValidator("shape")),
        offset: validation_exports.object({
          x: validation_exports.number,
          y: validation_exports.number
        })
      }).nullable()
    })
  );
  return createRecordType("instance", {
    validator: instanceTypeValidator,
    scope: "session",
    ephemeralKeys: {
      currentPageId: false,
      meta: false,
      followingUserId: true,
      opacityForNextShape: true,
      stylesForNextShape: true,
      brush: true,
      cursor: true,
      scribbles: true,
      isFocusMode: true,
      isDebugMode: true,
      isToolLocked: true,
      exportBackground: true,
      screenBounds: true,
      insets: true,
      zoomBrush: true,
      isPenMode: true,
      isGridMode: true,
      chatMessage: true,
      isChatting: true,
      highlightedUserIds: true,
      isFocused: true,
      devicePixelRatio: true,
      isCoarsePointer: true,
      isHoveringCanvas: true,
      openMenus: true,
      isChangingStyle: true,
      isReadonly: true,
      duplicateProps: true
    }
  }).withDefaultProperties(
    () => ({
      followingUserId: null,
      opacityForNextShape: 1,
      stylesForNextShape: {},
      brush: null,
      scribbles: [],
      cursor: {
        type: "default",
        rotation: 0
      },
      isFocusMode: false,
      exportBackground: false,
      isDebugMode: false,
      isToolLocked: false,
      screenBounds: { x: 0, y: 0, w: 1080, h: 720 },
      insets: [false, false, false, false],
      zoomBrush: null,
      isGridMode: false,
      isPenMode: false,
      chatMessage: "",
      isChatting: false,
      highlightedUserIds: [],
      isFocused: false,
      devicePixelRatio: typeof window === "undefined" ? 1 : window.devicePixelRatio,
      isCoarsePointer: false,
      isHoveringCanvas: null,
      openMenus: [],
      isChangingStyle: false,
      isReadonly: false,
      meta: {},
      duplicateProps: null
    })
  );
}
var instanceVersions = createMigrationIds("com.tldraw.instance", {
  AddTransparentExportBgs: 1,
  RemoveDialog: 2,
  AddToolLockMode: 3,
  RemoveExtraPropsForNextShape: 4,
  AddLabelColor: 5,
  AddFollowingUserId: 6,
  RemoveAlignJustify: 7,
  AddZoom: 8,
  AddVerticalAlign: 9,
  AddScribbleDelay: 10,
  RemoveUserId: 11,
  AddIsPenModeAndIsGridMode: 12,
  HoistOpacity: 13,
  AddChat: 14,
  AddHighlightedUserIds: 15,
  ReplacePropsForNextShapeWithStylesForNextShape: 16,
  AddMeta: 17,
  RemoveCursorColor: 18,
  AddLonelyProperties: 19,
  ReadOnlyReadonly: 20,
  AddHoveringCanvas: 21,
  AddScribbles: 22,
  AddInset: 23,
  AddDuplicateProps: 24,
  RemoveCanMoveCamera: 25
});
var instanceMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.instance",
  recordType: "instance",
  sequence: [
    {
      id: instanceVersions.AddTransparentExportBgs,
      up: (instance) => {
        return { ...instance, exportBackground: true };
      }
    },
    {
      id: instanceVersions.RemoveDialog,
      up: ({ dialog: _, ...instance }) => {
        return instance;
      }
    },
    {
      id: instanceVersions.AddToolLockMode,
      up: (instance) => {
        return { ...instance, isToolLocked: false };
      }
    },
    {
      id: instanceVersions.RemoveExtraPropsForNextShape,
      up: ({ propsForNextShape, ...instance }) => {
        return {
          ...instance,
          propsForNextShape: Object.fromEntries(
            Object.entries(propsForNextShape).filter(
              ([key]) => [
                "color",
                "labelColor",
                "dash",
                "fill",
                "size",
                "font",
                "align",
                "verticalAlign",
                "icon",
                "geo",
                "arrowheadStart",
                "arrowheadEnd",
                "spline"
              ].includes(key)
            )
          )
        };
      }
    },
    {
      id: instanceVersions.AddLabelColor,
      up: ({ propsForNextShape, ...instance }) => {
        return {
          ...instance,
          propsForNextShape: {
            ...propsForNextShape,
            labelColor: "black"
          }
        };
      }
    },
    {
      id: instanceVersions.AddFollowingUserId,
      up: (instance) => {
        return { ...instance, followingUserId: null };
      }
    },
    {
      id: instanceVersions.RemoveAlignJustify,
      up: (instance) => {
        let newAlign = instance.propsForNextShape.align;
        if (newAlign === "justify") {
          newAlign = "start";
        }
        return {
          ...instance,
          propsForNextShape: {
            ...instance.propsForNextShape,
            align: newAlign
          }
        };
      }
    },
    {
      id: instanceVersions.AddZoom,
      up: (instance) => {
        return { ...instance, zoomBrush: null };
      }
    },
    {
      id: instanceVersions.AddVerticalAlign,
      up: (instance) => {
        return {
          ...instance,
          propsForNextShape: {
            ...instance.propsForNextShape,
            verticalAlign: "middle"
          }
        };
      }
    },
    {
      id: instanceVersions.AddScribbleDelay,
      up: (instance) => {
        if (instance.scribble !== null) {
          return { ...instance, scribble: { ...instance.scribble, delay: 0 } };
        }
        return { ...instance };
      }
    },
    {
      id: instanceVersions.RemoveUserId,
      up: ({ userId: _, ...instance }) => {
        return instance;
      }
    },
    {
      id: instanceVersions.AddIsPenModeAndIsGridMode,
      up: (instance) => {
        return { ...instance, isPenMode: false, isGridMode: false };
      }
    },
    {
      id: instanceVersions.HoistOpacity,
      up: ({ propsForNextShape: { opacity, ...propsForNextShape }, ...instance }) => {
        return { ...instance, opacityForNextShape: Number(opacity ?? "1"), propsForNextShape };
      }
    },
    {
      id: instanceVersions.AddChat,
      up: (instance) => {
        return { ...instance, chatMessage: "", isChatting: false };
      }
    },
    {
      id: instanceVersions.AddHighlightedUserIds,
      up: (instance) => {
        return { ...instance, highlightedUserIds: [] };
      }
    },
    {
      id: instanceVersions.ReplacePropsForNextShapeWithStylesForNextShape,
      up: ({ propsForNextShape: _, ...instance }) => {
        return { ...instance, stylesForNextShape: {} };
      }
    },
    {
      id: instanceVersions.AddMeta,
      up: (record) => {
        return {
          ...record,
          meta: {}
        };
      }
    },
    {
      id: instanceVersions.RemoveCursorColor,
      up: (record) => {
        const { color: _, ...cursor } = record.cursor;
        return {
          ...record,
          cursor
        };
      }
    },
    {
      id: instanceVersions.AddLonelyProperties,
      up: (record) => {
        return {
          ...record,
          canMoveCamera: true,
          isFocused: false,
          devicePixelRatio: 1,
          isCoarsePointer: false,
          openMenus: [],
          isChangingStyle: false,
          isReadOnly: false
        };
      }
    },
    {
      id: instanceVersions.ReadOnlyReadonly,
      up: ({ isReadOnly: _isReadOnly, ...record }) => {
        return {
          ...record,
          isReadonly: _isReadOnly
        };
      }
    },
    {
      id: instanceVersions.AddHoveringCanvas,
      up: (record) => {
        return {
          ...record,
          isHoveringCanvas: null
        };
      }
    },
    {
      id: instanceVersions.AddScribbles,
      up: ({ scribble: _, ...record }) => {
        return {
          ...record,
          scribbles: []
        };
      }
    },
    {
      id: instanceVersions.AddInset,
      up: (record) => {
        return {
          ...record,
          insets: [false, false, false, false]
        };
      },
      down: ({ insets: _, ...record }) => {
        return {
          ...record
        };
      }
    },
    {
      id: instanceVersions.AddDuplicateProps,
      up: (record) => {
        return {
          ...record,
          duplicateProps: null
        };
      },
      down: ({ duplicateProps: _, ...record }) => {
        return {
          ...record
        };
      }
    },
    {
      id: instanceVersions.RemoveCanMoveCamera,
      up: ({ canMoveCamera: _, ...record }) => {
        return {
          ...record
        };
      },
      down: (instance) => {
        return { ...instance, canMoveCamera: true };
      }
    }
  ]
});
var TLINSTANCE_ID = "instance:instance";

// ../node_modules/@tldraw/tlschema/dist-esm/records/TLPageState.mjs
var instancePageStateValidator = validation_exports.model(
  "instance_page_state",
  validation_exports.object({
    typeName: validation_exports.literal("instance_page_state"),
    id: idValidator("instance_page_state"),
    pageId: pageIdValidator,
    selectedShapeIds: validation_exports.arrayOf(shapeIdValidator),
    hintingShapeIds: validation_exports.arrayOf(shapeIdValidator),
    erasingShapeIds: validation_exports.arrayOf(shapeIdValidator),
    hoveredShapeId: shapeIdValidator.nullable(),
    editingShapeId: shapeIdValidator.nullable(),
    croppingShapeId: shapeIdValidator.nullable(),
    focusedGroupId: shapeIdValidator.nullable(),
    meta: validation_exports.jsonValue
  })
);
var instancePageStateVersions = createMigrationIds("com.tldraw.instance_page_state", {
  AddCroppingId: 1,
  RemoveInstanceIdAndCameraId: 2,
  AddMeta: 3,
  RenameProperties: 4,
  RenamePropertiesAgain: 5
});
var instancePageStateMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.instance_page_state",
  recordType: "instance_page_state",
  sequence: [
    {
      id: instancePageStateVersions.AddCroppingId,
      up(instance) {
        instance.croppingShapeId = null;
      }
    },
    {
      id: instancePageStateVersions.RemoveInstanceIdAndCameraId,
      up(instance) {
        delete instance.instanceId;
        delete instance.cameraId;
      }
    },
    {
      id: instancePageStateVersions.AddMeta,
      up: (record) => {
        record.meta = {};
      }
    },
    {
      id: instancePageStateVersions.RenameProperties,
      // this migration is cursed: it was written wrong and doesn't do anything.
      // rather than replace it, I've added another migration below that fixes it.
      up: (_record) => {
      },
      down: (_record) => {
      }
    },
    {
      id: instancePageStateVersions.RenamePropertiesAgain,
      up: (record) => {
        record.selectedShapeIds = record.selectedIds;
        delete record.selectedIds;
        record.hintingShapeIds = record.hintingIds;
        delete record.hintingIds;
        record.erasingShapeIds = record.erasingIds;
        delete record.erasingIds;
        record.hoveredShapeId = record.hoveredId;
        delete record.hoveredId;
        record.editingShapeId = record.editingId;
        delete record.editingId;
        record.croppingShapeId = record.croppingShapeId ?? record.croppingId ?? null;
        delete record.croppingId;
        record.focusedGroupId = record.focusLayerId;
        delete record.focusLayerId;
      },
      down: (record) => {
        record.selectedIds = record.selectedShapeIds;
        delete record.selectedShapeIds;
        record.hintingIds = record.hintingShapeIds;
        delete record.hintingShapeIds;
        record.erasingIds = record.erasingShapeIds;
        delete record.erasingShapeIds;
        record.hoveredId = record.hoveredShapeId;
        delete record.hoveredShapeId;
        record.editingId = record.editingShapeId;
        delete record.editingShapeId;
        record.croppingId = record.croppingShapeId;
        delete record.croppingShapeId;
        record.focusLayerId = record.focusedGroupId;
        delete record.focusedGroupId;
      }
    }
  ]
});
var InstancePageStateRecordType = createRecordType(
  "instance_page_state",
  {
    validator: instancePageStateValidator,
    scope: "session",
    ephemeralKeys: {
      pageId: false,
      selectedShapeIds: false,
      editingShapeId: false,
      croppingShapeId: false,
      meta: false,
      hintingShapeIds: true,
      erasingShapeIds: true,
      hoveredShapeId: true,
      focusedGroupId: true
    }
  }
).withDefaultProperties(
  () => ({
    editingShapeId: null,
    croppingShapeId: null,
    selectedShapeIds: [],
    hoveredShapeId: null,
    erasingShapeIds: [],
    hintingShapeIds: [],
    focusedGroupId: null,
    meta: {}
  })
);

// ../node_modules/@tldraw/tlschema/dist-esm/records/TLPointer.mjs
var pointerValidator = validation_exports.model(
  "pointer",
  validation_exports.object({
    typeName: validation_exports.literal("pointer"),
    id: idValidator("pointer"),
    x: validation_exports.number,
    y: validation_exports.number,
    lastActivityTimestamp: validation_exports.number,
    meta: validation_exports.jsonValue
  })
);
var pointerVersions = createMigrationIds("com.tldraw.pointer", {
  AddMeta: 1
});
var pointerMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.pointer",
  recordType: "pointer",
  sequence: [
    {
      id: pointerVersions.AddMeta,
      up: (record) => {
        record.meta = {};
      }
    }
  ]
});
var PointerRecordType = createRecordType("pointer", {
  validator: pointerValidator,
  scope: "session"
}).withDefaultProperties(
  () => ({
    x: 0,
    y: 0,
    lastActivityTimestamp: 0,
    meta: {}
  })
);
var TLPOINTER_ID = PointerRecordType.createId("pointer");

// ../node_modules/@tldraw/tlschema/dist-esm/records/TLPresence.mjs
var instancePresenceValidator = validation_exports.model(
  "instance_presence",
  validation_exports.object({
    typeName: validation_exports.literal("instance_presence"),
    id: idValidator("instance_presence"),
    userId: validation_exports.string,
    userName: validation_exports.string,
    lastActivityTimestamp: validation_exports.number.nullable(),
    followingUserId: validation_exports.string.nullable(),
    cursor: validation_exports.object({
      x: validation_exports.number,
      y: validation_exports.number,
      type: cursorTypeValidator,
      rotation: validation_exports.number
    }).nullable(),
    color: validation_exports.string,
    camera: validation_exports.object({
      x: validation_exports.number,
      y: validation_exports.number,
      z: validation_exports.number
    }).nullable(),
    screenBounds: boxModelValidator.nullable(),
    selectedShapeIds: validation_exports.arrayOf(idValidator("shape")),
    currentPageId: idValidator("page"),
    brush: boxModelValidator.nullable(),
    scribbles: validation_exports.arrayOf(scribbleValidator),
    chatMessage: validation_exports.string,
    meta: validation_exports.jsonValue
  })
);
var instancePresenceVersions = createMigrationIds("com.tldraw.instance_presence", {
  AddScribbleDelay: 1,
  RemoveInstanceId: 2,
  AddChatMessage: 3,
  AddMeta: 4,
  RenameSelectedShapeIds: 5,
  NullableCameraCursor: 6
});
var instancePresenceMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.instance_presence",
  recordType: "instance_presence",
  sequence: [
    {
      id: instancePresenceVersions.AddScribbleDelay,
      up: (instance) => {
        if (instance.scribble !== null) {
          instance.scribble.delay = 0;
        }
      }
    },
    {
      id: instancePresenceVersions.RemoveInstanceId,
      up: (instance) => {
        delete instance.instanceId;
      }
    },
    {
      id: instancePresenceVersions.AddChatMessage,
      up: (instance) => {
        instance.chatMessage = "";
      }
    },
    {
      id: instancePresenceVersions.AddMeta,
      up: (record) => {
        record.meta = {};
      }
    },
    {
      id: instancePresenceVersions.RenameSelectedShapeIds,
      up: (_record) => {
      }
    },
    {
      id: instancePresenceVersions.NullableCameraCursor,
      up: (_record) => {
      },
      down: (record) => {
        if (record.camera === null) {
          record.camera = { x: 0, y: 0, z: 1 };
        }
        if (record.lastActivityTimestamp === null) {
          record.lastActivityTimestamp = 0;
        }
        if (record.cursor === null) {
          record.cursor = { type: "default", x: 0, y: 0, rotation: 0 };
        }
        if (record.screenBounds === null) {
          record.screenBounds = { x: 0, y: 0, w: 1, h: 1 };
        }
      }
    }
  ]
});
var InstancePresenceRecordType = createRecordType(
  "instance_presence",
  {
    validator: instancePresenceValidator,
    scope: "presence"
  }
).withDefaultProperties(() => ({
  lastActivityTimestamp: null,
  followingUserId: null,
  color: "#FF0000",
  camera: null,
  cursor: null,
  screenBounds: null,
  selectedShapeIds: [],
  brush: null,
  scribbles: [],
  chatMessage: "",
  meta: {}
}));

// ../node_modules/@tldraw/tlschema/dist-esm/createPresenceStateDerivation.mjs
function createPresenceStateDerivation($user, instanceId) {
  return (store) => {
    return computed("instancePresence", () => {
      const user = $user.get();
      if (!user) return null;
      const state = getDefaultUserPresence(store, user);
      if (!state) return null;
      return InstancePresenceRecordType.create({
        ...state,
        id: instanceId ?? InstancePresenceRecordType.createId(store.id)
      });
    });
  };
}
function getDefaultUserPresence(store, user) {
  const instance = store.get(TLINSTANCE_ID);
  const pageState = store.get(InstancePageStateRecordType.createId(instance == null ? void 0 : instance.currentPageId));
  const camera = store.get(CameraRecordType.createId(instance == null ? void 0 : instance.currentPageId));
  const pointer = store.get(TLPOINTER_ID);
  if (!pageState || !instance || !camera || !pointer) {
    return null;
  }
  return {
    selectedShapeIds: pageState.selectedShapeIds,
    brush: instance.brush,
    scribbles: instance.scribbles,
    userId: user.id,
    userName: user.name ?? "",
    followingUserId: instance.followingUserId,
    camera: {
      x: camera.x,
      y: camera.y,
      z: camera.z
    },
    color: user.color ?? "#FF0000",
    currentPageId: instance.currentPageId,
    cursor: {
      x: pointer.x,
      y: pointer.y,
      rotation: instance.cursor.rotation,
      type: instance.cursor.type
    },
    lastActivityTimestamp: pointer.lastActivityTimestamp,
    screenBounds: instance.screenBounds,
    chatMessage: instance.chatMessage,
    meta: {}
  };
}

// ../node_modules/@tldraw/tlschema/dist-esm/records/TLDocument.mjs
var documentValidator = validation_exports.model(
  "document",
  validation_exports.object({
    typeName: validation_exports.literal("document"),
    id: validation_exports.literal("document:document"),
    gridSize: validation_exports.number,
    name: validation_exports.string,
    meta: validation_exports.jsonValue
  })
);
function isDocument(record) {
  if (!record) return false;
  return record.typeName === "document";
}
var documentVersions = createMigrationIds("com.tldraw.document", {
  AddName: 1,
  AddMeta: 2
});
var documentMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.document",
  recordType: "document",
  sequence: [
    {
      id: documentVersions.AddName,
      up: (document2) => {
        ;
        document2.name = "";
      },
      down: (document2) => {
        delete document2.name;
      }
    },
    {
      id: documentVersions.AddMeta,
      up: (record) => {
        ;
        record.meta = {};
      }
    }
  ]
});
var DocumentRecordType = createRecordType("document", {
  validator: documentValidator,
  scope: "document"
}).withDefaultProperties(
  () => ({
    gridSize: 10,
    name: "",
    meta: {}
  })
);
var TLDOCUMENT_ID = DocumentRecordType.createId("document");

// ../node_modules/@tldraw/tlschema/dist-esm/TLStore.mjs
function redactRecordForErrorReporting(record) {
  if (record.typeName === "asset") {
    if ("src" in record) {
      record.src = "<redacted>";
    }
    if ("src" in record.props) {
      record.props.src = "<redacted>";
    }
  }
}
function onValidationFailure({
  error,
  phase,
  record,
  recordBefore
}) {
  const isExistingValidationIssue = (
    // if we're initializing the store for the first time, we should
    // allow invalid records so people can load old buggy data:
    phase === "initialize"
  );
  annotateError(error, {
    tags: {
      origin: "store.validateRecord",
      storePhase: phase,
      isExistingValidationIssue
    },
    extras: {
      recordBefore: recordBefore ? redactRecordForErrorReporting(structuredClone(recordBefore)) : void 0,
      recordAfter: redactRecordForErrorReporting(structuredClone(record))
    }
  });
  throw error;
}
function getDefaultPages() {
  return [
    PageRecordType.create({
      id: "page:page",
      name: "Page 1",
      index: "a1",
      meta: {}
    })
  ];
}
function createIntegrityChecker(store) {
  const $pageIds = store.query.ids("page");
  const $pageStates = store.query.records("instance_page_state");
  const ensureStoreIsUsable = () => {
    if (!store.has(TLDOCUMENT_ID)) {
      store.put([DocumentRecordType.create({ id: TLDOCUMENT_ID, name: store.props.defaultName })]);
      return ensureStoreIsUsable();
    }
    if (!store.has(TLPOINTER_ID)) {
      store.put([PointerRecordType.create({ id: TLPOINTER_ID })]);
      return ensureStoreIsUsable();
    }
    const pageIds = $pageIds.get();
    if (pageIds.size === 0) {
      store.put(getDefaultPages());
      return ensureStoreIsUsable();
    }
    const getFirstPageId = () => [...pageIds].map((id) => store.get(id)).sort(sortByIndex)[0].id;
    const instanceState = store.get(TLINSTANCE_ID);
    if (!instanceState) {
      store.put([
        store.schema.types.instance.create({
          id: TLINSTANCE_ID,
          currentPageId: getFirstPageId(),
          exportBackground: true
        })
      ]);
      return ensureStoreIsUsable();
    } else if (!pageIds.has(instanceState.currentPageId)) {
      store.put([{ ...instanceState, currentPageId: getFirstPageId() }]);
      return ensureStoreIsUsable();
    }
    const missingPageStateIds = /* @__PURE__ */ new Set();
    const missingCameraIds = /* @__PURE__ */ new Set();
    for (const id of pageIds) {
      const pageStateId = InstancePageStateRecordType.createId(id);
      const pageState = store.get(pageStateId);
      if (!pageState) {
        missingPageStateIds.add(pageStateId);
      }
      const cameraId = CameraRecordType.createId(id);
      if (!store.has(cameraId)) {
        missingCameraIds.add(cameraId);
      }
    }
    if (missingPageStateIds.size > 0) {
      store.put(
        [...missingPageStateIds].map(
          (id) => InstancePageStateRecordType.create({
            id,
            pageId: InstancePageStateRecordType.parseId(id)
          })
        )
      );
    }
    if (missingCameraIds.size > 0) {
      store.put([...missingCameraIds].map((id) => CameraRecordType.create({ id })));
    }
    const pageStates = $pageStates.get();
    for (const pageState of pageStates) {
      if (!pageIds.has(pageState.pageId)) {
        store.remove([pageState.id]);
        continue;
      }
      if (pageState.croppingShapeId && !store.has(pageState.croppingShapeId)) {
        store.put([{ ...pageState, croppingShapeId: null }]);
        return ensureStoreIsUsable();
      }
      if (pageState.focusedGroupId && !store.has(pageState.focusedGroupId)) {
        store.put([{ ...pageState, focusedGroupId: null }]);
        return ensureStoreIsUsable();
      }
      if (pageState.hoveredShapeId && !store.has(pageState.hoveredShapeId)) {
        store.put([{ ...pageState, hoveredShapeId: null }]);
        return ensureStoreIsUsable();
      }
      const filteredSelectedIds = pageState.selectedShapeIds.filter((id) => store.has(id));
      if (filteredSelectedIds.length !== pageState.selectedShapeIds.length) {
        store.put([{ ...pageState, selectedShapeIds: filteredSelectedIds }]);
        return ensureStoreIsUsable();
      }
      const filteredHintingIds = pageState.hintingShapeIds.filter((id) => store.has(id));
      if (filteredHintingIds.length !== pageState.hintingShapeIds.length) {
        store.put([{ ...pageState, hintingShapeIds: filteredHintingIds }]);
        return ensureStoreIsUsable();
      }
      const filteredErasingIds = pageState.erasingShapeIds.filter((id) => store.has(id));
      if (filteredErasingIds.length !== pageState.erasingShapeIds.length) {
        store.put([{ ...pageState, erasingShapeIds: filteredErasingIds }]);
        return ensureStoreIsUsable();
      }
    }
  };
  return ensureStoreIsUsable;
}

// ../node_modules/@tldraw/tlschema/dist-esm/assets/TLBookmarkAsset.mjs
var bookmarkAssetValidator = createAssetValidator(
  "bookmark",
  validation_exports.object({
    title: validation_exports.string,
    description: validation_exports.string,
    image: validation_exports.string,
    favicon: validation_exports.string,
    src: validation_exports.srcUrl.nullable()
  })
);
var Versions = createMigrationIds("com.tldraw.asset.bookmark", {
  MakeUrlsValid: 1,
  AddFavicon: 2
});
var bookmarkAssetMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.asset.bookmark",
  recordType: "asset",
  filter: (asset) => asset.type === "bookmark",
  sequence: [
    {
      id: Versions.MakeUrlsValid,
      up: (asset) => {
        if (!validation_exports.srcUrl.isValid(asset.props.src)) {
          asset.props.src = "";
        }
      },
      down: (_asset) => {
      }
    },
    {
      id: Versions.AddFavicon,
      up: (asset) => {
        if (!validation_exports.srcUrl.isValid(asset.props.favicon)) {
          asset.props.favicon = "";
        }
      },
      down: (asset) => {
        delete asset.props.favicon;
      }
    }
  ]
});

// ../node_modules/@tldraw/tlschema/dist-esm/assets/TLImageAsset.mjs
var imageAssetValidator = createAssetValidator(
  "image",
  validation_exports.object({
    w: validation_exports.number,
    h: validation_exports.number,
    name: validation_exports.string,
    isAnimated: validation_exports.boolean,
    mimeType: validation_exports.string.nullable(),
    src: validation_exports.srcUrl.nullable(),
    fileSize: validation_exports.nonZeroNumber.optional()
  })
);
var Versions2 = createMigrationIds("com.tldraw.asset.image", {
  AddIsAnimated: 1,
  RenameWidthHeight: 2,
  MakeUrlsValid: 3,
  AddFileSize: 4,
  MakeFileSizeOptional: 5
});
var imageAssetMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.asset.image",
  recordType: "asset",
  filter: (asset) => asset.type === "image",
  sequence: [
    {
      id: Versions2.AddIsAnimated,
      up: (asset) => {
        asset.props.isAnimated = false;
      },
      down: (asset) => {
        delete asset.props.isAnimated;
      }
    },
    {
      id: Versions2.RenameWidthHeight,
      up: (asset) => {
        asset.props.w = asset.props.width;
        asset.props.h = asset.props.height;
        delete asset.props.width;
        delete asset.props.height;
      },
      down: (asset) => {
        asset.props.width = asset.props.w;
        asset.props.height = asset.props.h;
        delete asset.props.w;
        delete asset.props.h;
      }
    },
    {
      id: Versions2.MakeUrlsValid,
      up: (asset) => {
        if (!validation_exports.srcUrl.isValid(asset.props.src)) {
          asset.props.src = "";
        }
      },
      down: (_asset) => {
      }
    },
    {
      id: Versions2.AddFileSize,
      up: (asset) => {
        asset.props.fileSize = -1;
      },
      down: (asset) => {
        delete asset.props.fileSize;
      }
    },
    {
      id: Versions2.MakeFileSizeOptional,
      up: (asset) => {
        if (asset.props.fileSize === -1) {
          asset.props.fileSize = void 0;
        }
      },
      down: (asset) => {
        if (asset.props.fileSize === void 0) {
          asset.props.fileSize = -1;
        }
      }
    }
  ]
});

// ../node_modules/@tldraw/tlschema/dist-esm/assets/TLVideoAsset.mjs
var videoAssetValidator = createAssetValidator(
  "video",
  validation_exports.object({
    w: validation_exports.number,
    h: validation_exports.number,
    name: validation_exports.string,
    isAnimated: validation_exports.boolean,
    mimeType: validation_exports.string.nullable(),
    src: validation_exports.srcUrl.nullable(),
    fileSize: validation_exports.number.optional()
  })
);
var Versions3 = createMigrationIds("com.tldraw.asset.video", {
  AddIsAnimated: 1,
  RenameWidthHeight: 2,
  MakeUrlsValid: 3,
  AddFileSize: 4,
  MakeFileSizeOptional: 5
});
var videoAssetMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.asset.video",
  recordType: "asset",
  filter: (asset) => asset.type === "video",
  sequence: [
    {
      id: Versions3.AddIsAnimated,
      up: (asset) => {
        asset.props.isAnimated = false;
      },
      down: (asset) => {
        delete asset.props.isAnimated;
      }
    },
    {
      id: Versions3.RenameWidthHeight,
      up: (asset) => {
        asset.props.w = asset.props.width;
        asset.props.h = asset.props.height;
        delete asset.props.width;
        delete asset.props.height;
      },
      down: (asset) => {
        asset.props.width = asset.props.w;
        asset.props.height = asset.props.h;
        delete asset.props.w;
        delete asset.props.h;
      }
    },
    {
      id: Versions3.MakeUrlsValid,
      up: (asset) => {
        if (!validation_exports.srcUrl.isValid(asset.props.src)) {
          asset.props.src = "";
        }
      },
      down: (_asset) => {
      }
    },
    {
      id: Versions3.AddFileSize,
      up: (asset) => {
        asset.props.fileSize = -1;
      },
      down: (asset) => {
        delete asset.props.fileSize;
      }
    },
    {
      id: Versions3.MakeFileSizeOptional,
      up: (asset) => {
        if (asset.props.fileSize === -1) {
          asset.props.fileSize = void 0;
        }
      },
      down: (asset) => {
        if (asset.props.fileSize === void 0) {
          asset.props.fileSize = -1;
        }
      }
    }
  ]
});

// ../node_modules/@tldraw/tlschema/dist-esm/records/TLAsset.mjs
var assetValidator = validation_exports.model(
  "asset",
  validation_exports.union("type", {
    image: imageAssetValidator,
    video: videoAssetValidator,
    bookmark: bookmarkAssetValidator
  })
);
var assetVersions = createMigrationIds("com.tldraw.asset", {
  AddMeta: 1
});
var assetMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.asset",
  recordType: "asset",
  sequence: [
    {
      id: assetVersions.AddMeta,
      up: (record) => {
        ;
        record.meta = {};
      }
    }
  ]
});
var AssetRecordType = createRecordType("asset", {
  validator: assetValidator,
  scope: "document"
}).withDefaultProperties(() => ({
  meta: {}
}));

// ../node_modules/@tldraw/tlschema/dist-esm/shapes/TLBookmarkShape.mjs
var bookmarkShapeProps = {
  w: validation_exports.nonZeroNumber,
  h: validation_exports.nonZeroNumber,
  assetId: assetIdValidator.nullable(),
  url: validation_exports.linkUrl
};
var Versions4 = createShapePropsMigrationIds("bookmark", {
  NullAssetId: 1,
  MakeUrlsValid: 2
});
var bookmarkShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions4.NullAssetId,
      up: (props) => {
        if (props.assetId === void 0) {
          props.assetId = null;
        }
      },
      down: "retired"
    },
    {
      id: Versions4.MakeUrlsValid,
      up: (props) => {
        if (!validation_exports.linkUrl.isValid(props.url)) {
          props.url = "";
        }
      },
      down: (_props) => {
      }
    }
  ]
});

// ../node_modules/@tldraw/tlschema/dist-esm/misc/b64Vecs.mjs
var FIRST_POINT_B64_LENGTH = 16;
var BASE64_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var B64_LOOKUP = new Uint8Array(128);
for (let i = 0; i < 64; i++) {
  B64_LOOKUP[BASE64_CHARS.charCodeAt(i)] = i;
}
var POW2 = new Float64Array(31);
for (let i = 0; i < 31; i++) {
  POW2[i] = Math.pow(2, i - 15);
}
var POW2_SUBNORMAL = Math.pow(2, -14) / 1024;
var MANTISSA = new Float64Array(1024);
for (let i = 0; i < 1024; i++) {
  MANTISSA[i] = 1 + i / 1024;
}
function nativeGetFloat16(dataView, offset4) {
  return dataView.getFloat16(offset4, true);
}
function fallbackGetFloat16(dataView, offset4) {
  return float16BitsToNumber(dataView.getUint16(offset4, true));
}
var getFloat16 = typeof DataView.prototype.getFloat16 === "function" ? nativeGetFloat16 : fallbackGetFloat16;
function nativeSetFloat16(dataView, offset4, value) {
  ;
  dataView.setFloat16(offset4, value, true);
}
function fallbackSetFloat16(dataView, offset4, value) {
  dataView.setUint16(offset4, numberToFloat16Bits(value), true);
}
var setFloat16 = typeof DataView.prototype.setFloat16 === "function" ? nativeSetFloat16 : fallbackSetFloat16;
function nativeBase64ToUint8Array(base64) {
  return Uint8Array.fromBase64(base64);
}
function fallbackBase64ToUint8Array(base64) {
  const numBytes = Math.floor(base64.length * 3 / 4);
  const bytes = new Uint8Array(numBytes);
  let byteIndex = 0;
  for (let i = 0; i < base64.length; i += 4) {
    const c0 = B64_LOOKUP[base64.charCodeAt(i)];
    const c1 = B64_LOOKUP[base64.charCodeAt(i + 1)];
    const c2 = B64_LOOKUP[base64.charCodeAt(i + 2)];
    const c3 = B64_LOOKUP[base64.charCodeAt(i + 3)];
    const bitmap = c0 << 18 | c1 << 12 | c2 << 6 | c3;
    bytes[byteIndex++] = bitmap >> 16 & 255;
    bytes[byteIndex++] = bitmap >> 8 & 255;
    bytes[byteIndex++] = bitmap & 255;
  }
  return bytes;
}
function nativeUint8ArrayToBase64(uint8Array) {
  return uint8Array.toBase64();
}
function fallbackUint8ArrayToBase64(uint8Array) {
  assert(uint8Array.length % 3 === 0, "Uint8Array length must be a multiple of 3");
  let result = "";
  for (let i = 0; i < uint8Array.length; i += 3) {
    const byte1 = uint8Array[i];
    const byte2 = uint8Array[i + 1];
    const byte3 = uint8Array[i + 2];
    const bitmap = byte1 << 16 | byte2 << 8 | byte3;
    result += BASE64_CHARS[bitmap >> 18 & 63] + BASE64_CHARS[bitmap >> 12 & 63] + BASE64_CHARS[bitmap >> 6 & 63] + BASE64_CHARS[bitmap & 63];
  }
  return result;
}
var uint8ArrayToBase64 = typeof Uint8Array.prototype.toBase64 === "function" ? nativeUint8ArrayToBase64 : fallbackUint8ArrayToBase64;
var base64ToUint8Array = typeof Uint8Array.fromBase64 === "function" ? nativeBase64ToUint8Array : fallbackBase64ToUint8Array;
function float16BitsToNumber(bits) {
  const sign = bits >> 15;
  const exp = bits >> 10 & 31;
  const frac = bits & 1023;
  if (exp === 0) {
    return sign ? -frac * POW2_SUBNORMAL : frac * POW2_SUBNORMAL;
  }
  if (exp === 31) {
    return frac ? NaN : sign ? -Infinity : Infinity;
  }
  const magnitude = POW2[exp] * MANTISSA[frac];
  return sign ? -magnitude : magnitude;
}
function numberToFloat16Bits(value) {
  if (value === 0) return Object.is(value, -0) ? 32768 : 0;
  if (!Number.isFinite(value)) {
    if (Number.isNaN(value)) return 32256;
    return value > 0 ? 31744 : 64512;
  }
  const sign = value < 0 ? 1 : 0;
  value = Math.abs(value);
  const exp = Math.floor(Math.log2(value));
  let expBiased = exp + 15;
  if (expBiased >= 31) {
    return sign << 15 | 31744;
  }
  if (expBiased <= 0) {
    const frac2 = Math.round(value * Math.pow(2, 14) * 1024);
    return sign << 15 | frac2 & 1023;
  }
  const mantissa = value / Math.pow(2, exp) - 1;
  let frac = Math.round(mantissa * 1024);
  if (frac >= 1024) {
    frac = 0;
    expBiased++;
    if (expBiased >= 31) {
      return sign << 15 | 31744;
    }
  }
  return sign << 15 | expBiased << 10 | frac;
}
var b64Vecs = class {
  /**
   * Encode a single point (x, y, z) to 8 base64 characters using legacy Float16 encoding.
   * Each coordinate is encoded as a Float16 value, resulting in 6 bytes total.
   *
   * @param x - The x coordinate
   * @param y - The y coordinate
   * @param z - The z coordinate
   * @returns An 8-character base64 string representing the point
   * @internal
   */
  static _legacyEncodePoint(x, y, z) {
    const buffer = new Uint8Array(6);
    const dataView = new DataView(buffer.buffer);
    setFloat16(dataView, 0, x);
    setFloat16(dataView, 2, y);
    setFloat16(dataView, 4, z);
    return uint8ArrayToBase64(buffer);
  }
  /**
   * Convert an array of VecModels to a base64 string using legacy Float16 encoding.
   * Uses Float16 encoding for each coordinate (x, y, z). If a point's z value is
   * undefined, it defaults to 0.5.
   *
   * @param points - An array of VecModel objects to encode
   * @returns A base64-encoded string containing all points
   * @internal Used only for migrations from legacy format
   */
  static _legacyEncodePoints(points) {
    if (points.length === 0) return "";
    const buffer = new Uint8Array(points.length * 6);
    const dataView = new DataView(buffer.buffer);
    for (let i = 0; i < points.length; i++) {
      const p = points[i];
      const offset4 = i * 6;
      setFloat16(dataView, offset4, p.x);
      setFloat16(dataView, offset4 + 2, p.y);
      setFloat16(dataView, offset4 + 4, p.z ?? 0.5);
    }
    return uint8ArrayToBase64(buffer);
  }
  /**
   * Convert a legacy base64 string back to an array of VecModels.
   * Decodes Float16-encoded coordinates (x, y, z) from the base64 string.
   *
   * @param base64 - The base64-encoded string containing point data
   * @returns An array of VecModel objects decoded from the string
   * @internal Used only for migrations from legacy format
   */
  static _legacyDecodePoints(base64) {
    const bytes = base64ToUint8Array(base64);
    const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    const result = [];
    for (let offset4 = 0; offset4 < bytes.length; offset4 += 6) {
      result.push({
        x: getFloat16(dataView, offset4),
        y: getFloat16(dataView, offset4 + 2),
        z: getFloat16(dataView, offset4 + 4)
      });
    }
    return result;
  }
  /**
   * Encode an array of VecModels using delta encoding for improved precision.
   * The first point is stored as Float32 (high precision for absolute position),
   * subsequent points are stored as Float16 deltas from the previous point.
   * This provides full precision for the starting position and excellent precision
   * for deltas between consecutive points (which are typically small values).
   *
   * Format:
   * - First point: 3 Float32 values = 12 bytes = 16 base64 chars
   * - Delta points: 3 Float16 values each = 6 bytes = 8 base64 chars each
   *
   * @param points - An array of VecModel objects to encode
   * @returns A base64-encoded string containing delta-encoded points
   * @public
   */
  static encodePoints(points) {
    if (points.length === 0) return "";
    const firstPointBytes = 12;
    const deltaBytes = (points.length - 1) * 6;
    const totalBytes = firstPointBytes + deltaBytes;
    const buffer = new Uint8Array(totalBytes);
    const dataView = new DataView(buffer.buffer);
    const first2 = points[0];
    dataView.setFloat32(0, first2.x, true);
    dataView.setFloat32(4, first2.y, true);
    dataView.setFloat32(8, first2.z ?? 0.5, true);
    let prevX = first2.x;
    let prevY = first2.y;
    let prevZ = first2.z ?? 0.5;
    for (let i = 1; i < points.length; i++) {
      const p = points[i];
      const z = p.z ?? 0.5;
      const offset4 = firstPointBytes + (i - 1) * 6;
      setFloat16(dataView, offset4, p.x - prevX);
      setFloat16(dataView, offset4 + 2, p.y - prevY);
      setFloat16(dataView, offset4 + 4, z - prevZ);
      prevX = p.x;
      prevY = p.y;
      prevZ = z;
    }
    return uint8ArrayToBase64(buffer);
  }
  /**
   * Decode a delta-encoded base64 string back to an array of absolute VecModels.
   * The first point is stored as Float32 (high precision), subsequent points are
   * Float16 deltas that are accumulated to reconstruct absolute positions.
   *
   * @param base64 - The base64-encoded string containing delta-encoded point data
   * @returns An array of VecModel objects with absolute coordinates
   * @public
   */
  static decodePoints(base64) {
    if (base64.length === 0) return [];
    const bytes = base64ToUint8Array(base64);
    const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    const result = [];
    let x = dataView.getFloat32(0, true);
    let y = dataView.getFloat32(4, true);
    let z = dataView.getFloat32(8, true);
    result.push({ x, y, z });
    const firstPointBytes = 12;
    for (let offset4 = firstPointBytes; offset4 < bytes.length; offset4 += 6) {
      x += getFloat16(dataView, offset4);
      y += getFloat16(dataView, offset4 + 2);
      z += getFloat16(dataView, offset4 + 4);
      result.push({ x, y, z });
    }
    return result;
  }
  /**
   * Get the first point from a delta-encoded base64 string.
   * The first point is stored as Float32 for full precision.
   *
   * @param b64Points - The delta-encoded base64 string
   * @returns The first point as a VecModel, or null if the string is too short
   * @public
   */
  static decodeFirstPoint(b64Points) {
    if (b64Points.length < FIRST_POINT_B64_LENGTH) return null;
    const bytes = base64ToUint8Array(b64Points.slice(0, FIRST_POINT_B64_LENGTH));
    const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    return {
      x: dataView.getFloat32(0, true),
      y: dataView.getFloat32(4, true),
      z: dataView.getFloat32(8, true)
    };
  }
  /**
   * Get the last point from a delta-encoded base64 string.
   * Requires decoding all points to accumulate deltas.
   *
   * @param b64Points - The delta-encoded base64 string
   * @returns The last point as a VecModel, or null if the string is too short
   * @public
   */
  static decodeLastPoint(b64Points) {
    if (b64Points.length < FIRST_POINT_B64_LENGTH) return null;
    const bytes = base64ToUint8Array(b64Points);
    const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    let x = dataView.getFloat32(0, true);
    let y = dataView.getFloat32(4, true);
    let z = dataView.getFloat32(8, true);
    const firstPointBytes = 12;
    for (let offset4 = firstPointBytes; offset4 < bytes.length; offset4 += 6) {
      x += getFloat16(dataView, offset4);
      y += getFloat16(dataView, offset4 + 2);
      z += getFloat16(dataView, offset4 + 4);
    }
    return { x, y, z };
  }
};

// ../node_modules/@tldraw/tlschema/dist-esm/shapes/TLDrawShape.mjs
var DrawShapeSegment = validation_exports.object({
  type: validation_exports.literalEnum("free", "straight"),
  path: validation_exports.string
});
var drawShapeProps = {
  color: DefaultColorStyle,
  fill: DefaultFillStyle,
  dash: DefaultDashStyle,
  size: DefaultSizeStyle,
  segments: validation_exports.arrayOf(DrawShapeSegment),
  isComplete: validation_exports.boolean,
  isClosed: validation_exports.boolean,
  isPen: validation_exports.boolean,
  scale: validation_exports.nonZeroNumber,
  scaleX: validation_exports.nonZeroFiniteNumber,
  scaleY: validation_exports.nonZeroFiniteNumber
};
var Versions5 = createShapePropsMigrationIds("draw", {
  AddInPen: 1,
  AddScale: 2,
  Base64: 3,
  LegacyPointsConversion: 4
});
var drawShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions5.AddInPen,
      up: (props) => {
        const { points } = props.segments[0];
        if (points.length === 0) {
          props.isPen = false;
          return;
        }
        let isPen = !(points[0].z === 0 || points[0].z === 0.5);
        if (points[1]) {
          isPen = isPen && !(points[1].z === 0 || points[1].z === 0.5);
        }
        props.isPen = isPen;
      },
      down: "retired"
    },
    {
      id: Versions5.AddScale,
      up: (props) => {
        props.scale = 1;
      },
      down: (props) => {
        delete props.scale;
      }
    },
    {
      id: Versions5.Base64,
      up: (props) => {
        props.segments = props.segments.map((segment) => {
          if (segment.path !== void 0) return segment;
          const { points, ...rest } = segment;
          const vecModels = Array.isArray(points) ? points : b64Vecs._legacyDecodePoints(points);
          return {
            ...rest,
            path: b64Vecs.encodePoints(vecModels)
          };
        });
        props.scaleX = props.scaleX ?? 1;
        props.scaleY = props.scaleY ?? 1;
      },
      down: (props) => {
        props.segments = props.segments.map((segment) => {
          const { path, ...rest } = segment;
          return {
            ...rest,
            points: b64Vecs.decodePoints(path)
          };
        });
        delete props.scaleX;
        delete props.scaleY;
      }
    },
    {
      id: Versions5.LegacyPointsConversion,
      up: (props) => {
        props.segments = props.segments.map((segment) => {
          if (segment.path !== void 0) return segment;
          const { points, ...rest } = segment;
          const vecModels = Array.isArray(points) ? points : b64Vecs._legacyDecodePoints(points);
          return {
            ...rest,
            path: b64Vecs.encodePoints(vecModels)
          };
        });
      },
      down: (_props) => {
      }
    }
  ]
});
function compressLegacySegments(segments) {
  return segments.map((segment) => ({
    type: segment.type,
    path: b64Vecs.encodePoints(segment.points)
  }));
}

// ../node_modules/@tldraw/tlschema/dist-esm/shapes/TLEmbedShape.mjs
var TLDRAW_APP_RE = /(^\/r\/[^/]+\/?$)/;
var EMBED_DEFINITIONS = [
  {
    hostnames: ["beta.tldraw.com", "tldraw.com", "localhost:3000"],
    canEditWhileLocked: true,
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(TLDRAW_APP_RE)) {
        return url;
      }
      return;
    }
  },
  {
    hostnames: ["figma.com"],
    canEditWhileLocked: true,
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/embed\/?$/)) {
        const outUrl = urlObj.searchParams.get("url");
        if (outUrl) {
          return outUrl;
        }
      }
      return;
    }
  },
  {
    hostnames: ["google.*"],
    canEditWhileLocked: true,
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (!urlObj) return;
      const matches2 = urlObj.pathname.match(/^\/maps\/embed\/v1\/view\/?$/);
      if (matches2 && urlObj.searchParams.has("center") && urlObj.searchParams.get("zoom")) {
        const zoom = urlObj.searchParams.get("zoom");
        const [lat, lon] = urlObj.searchParams.get("center").split(",");
        return `https://www.google.com/maps/@${lat},${lon},${zoom}z`;
      }
      return;
    }
  },
  {
    hostnames: ["val.town"],
    canEditWhileLocked: true,
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const matches2 = urlObj && urlObj.pathname.match(/\/embed\/(.+)\/?/);
      if (matches2) {
        return `https://www.val.town/v/${matches2[1]}`;
      }
      return;
    }
  },
  {
    hostnames: ["codesandbox.io"],
    canEditWhileLocked: true,
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const matches2 = urlObj && urlObj.pathname.match(/\/embed\/([^/]+)\/?/);
      if (matches2) {
        return `https://codesandbox.io/s/${matches2[1]}`;
      }
      return;
    }
  },
  {
    hostnames: ["codepen.io"],
    canEditWhileLocked: true,
    fromEmbedUrl: (url) => {
      const CODEPEN_EMBED_REGEXP = /https:\/\/codepen.io\/([^/]+)\/embed\/([^/]+)/;
      const matches2 = url.match(CODEPEN_EMBED_REGEXP);
      if (matches2) {
        const [_, user, id] = matches2;
        return `https://codepen.io/${user}/pen/${id}`;
      }
      return;
    }
  },
  {
    hostnames: ["scratch.mit.edu"],
    canEditWhileLocked: true,
    fromEmbedUrl: (url) => {
      const SCRATCH_EMBED_REGEXP = /https:\/\/scratch.mit.edu\/projects\/embed\/([^/]+)/;
      const matches2 = url.match(SCRATCH_EMBED_REGEXP);
      if (matches2) {
        const [_, id] = matches2;
        return `https://scratch.mit.edu/projects/${id}`;
      }
      return;
    }
  },
  {
    hostnames: ["*.youtube.com", "youtube.com", "youtu.be"],
    canEditWhileLocked: true,
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (!urlObj) return;
      const hostname = urlObj.hostname.replace(/^www./, "");
      if (hostname === "youtube.com") {
        const matches2 = urlObj.pathname.match(/^\/embed\/([^/]+)\/?/);
        if (matches2) {
          return `https://www.youtube.com/watch?v=${matches2[1]}`;
        }
      }
      return;
    }
  },
  {
    hostnames: ["calendar.google.*"],
    canEditWhileLocked: true,
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const srcQs = urlObj == null ? void 0 : urlObj.searchParams.get("src");
      if ((urlObj == null ? void 0 : urlObj.pathname.match(/\/calendar\/embed/)) && srcQs) {
        urlObj.pathname = "/calendar/u/0";
        const keys3 = Array.from(urlObj.searchParams.keys());
        for (const key of keys3) {
          urlObj.searchParams.delete(key);
        }
        urlObj.searchParams.set("cid", srcQs);
        return urlObj.href;
      }
      return;
    }
  },
  {
    hostnames: ["docs.google.*"],
    canEditWhileLocked: true,
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if ((urlObj == null ? void 0 : urlObj.pathname.match(/^\/presentation/)) && (urlObj == null ? void 0 : urlObj.pathname.match(/\/embed\/?$/))) {
        urlObj.pathname = urlObj.pathname.replace(/\/embed$/, "/pub");
        const keys3 = Array.from(urlObj.searchParams.keys());
        for (const key of keys3) {
          urlObj.searchParams.delete(key);
        }
        return urlObj.href;
      }
      return;
    }
  },
  {
    hostnames: ["gist.github.com"],
    canEditWhileLocked: true,
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/\/([^/]+)\/([^/]+)/)) {
        if (!url.split("/").pop()) return;
        return url;
      }
      return;
    }
  },
  {
    hostnames: ["replit.com"],
    canEditWhileLocked: true,
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/\/@([^/]+)\/([^/]+)/) && urlObj.searchParams.has("embed")) {
        urlObj.searchParams.delete("embed");
        return urlObj.href;
      }
      return;
    }
  },
  {
    hostnames: ["felt.com"],
    canEditWhileLocked: true,
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/embed\/map\//)) {
        urlObj.pathname = urlObj.pathname.replace(/^\/embed/, "");
        return urlObj.href;
      }
      return;
    }
  },
  {
    hostnames: ["open.spotify.com"],
    canEditWhileLocked: true,
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/embed\/(artist|album)\//)) {
        return urlObj.origin + urlObj.pathname.replace(/^\/embed/, "");
      }
      return;
    }
  },
  {
    hostnames: ["vimeo.com", "player.vimeo.com"],
    canEditWhileLocked: true,
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.hostname === "player.vimeo.com") {
        const matches2 = urlObj.pathname.match(/^\/video\/([^/]+)\/?$/);
        if (matches2) {
          return "https://vimeo.com/" + matches2[1];
        }
      }
      return;
    }
  },
  {
    hostnames: ["observablehq.com"],
    canEditWhileLocked: true,
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/embed\/@([^/]+)\/([^/]+)\/?$/)) {
        return `${urlObj.origin}${urlObj.pathname.replace("/embed", "")}#cell-*`;
      }
      if (urlObj && urlObj.pathname.match(/^\/embed\/([^/]+)\/?$/)) {
        return `${urlObj.origin}${urlObj.pathname.replace("/embed", "/d")}#cell-*`;
      }
      return;
    }
  },
  {
    hostnames: ["desmos.com"],
    canEditWhileLocked: true,
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.hostname === "www.desmos.com" && urlObj.pathname.match(/^\/calculator\/([^/]+)\/?$/) && urlObj.search === "?embed" && urlObj.hash === "") {
        return url.replace("?embed", "");
      }
      return;
    }
  }
];
var embedShapeProps = {
  w: validation_exports.nonZeroNumber,
  h: validation_exports.nonZeroNumber,
  url: validation_exports.string
};
var Versions6 = createShapePropsMigrationIds("embed", {
  GenOriginalUrlInEmbed: 1,
  RemoveDoesResize: 2,
  RemoveTmpOldUrl: 3,
  RemovePermissionOverrides: 4
});
var embedShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions6.GenOriginalUrlInEmbed,
      // add tmpOldUrl property
      up: (props) => {
        try {
          const url = props.url;
          const host = new URL(url).host.replace("www.", "");
          let originalUrl;
          for (const localEmbedDef of EMBED_DEFINITIONS) {
            if (localEmbedDef.hostnames.includes(host)) {
              try {
                originalUrl = localEmbedDef.fromEmbedUrl(url);
              } catch (err) {
                console.warn(err);
              }
            }
          }
          props.tmpOldUrl = props.url;
          props.url = originalUrl ?? "";
        } catch {
          props.url = "";
          props.tmpOldUrl = props.url;
        }
      },
      down: "retired"
    },
    {
      id: Versions6.RemoveDoesResize,
      up: (props) => {
        delete props.doesResize;
      },
      down: "retired"
    },
    {
      id: Versions6.RemoveTmpOldUrl,
      up: (props) => {
        delete props.tmpOldUrl;
      },
      down: "retired"
    },
    {
      id: Versions6.RemovePermissionOverrides,
      up: (props) => {
        delete props.overridePermissions;
      },
      down: "retired"
    }
  ]
});

// ../node_modules/@tldraw/tlschema/dist-esm/shapes/TLFrameShape.mjs
var frameShapeProps = {
  w: validation_exports.nonZeroNumber,
  h: validation_exports.nonZeroNumber,
  name: validation_exports.string,
  // because shape colors are an option, we don't want them to be picked up by the editor as a
  // style prop by default, so instead of a proper style we just supply an equivalent validator.
  // Check `FrameShapeUtil.configure` for how we replace this with the original
  // `DefaultColorStyle` style when the option is turned on.
  color: validation_exports.literalEnum(...DefaultColorStyle.values)
};
var Versions7 = createShapePropsMigrationIds("frame", {
  AddColorProp: 1
});
var frameShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions7.AddColorProp,
      up: (props) => {
        props.color = "black";
      },
      down: (props) => {
        delete props.color;
      }
    }
  ]
});

// ../node_modules/@tldraw/tlschema/dist-esm/styles/TLHorizontalAlignStyle.mjs
var DefaultHorizontalAlignStyle = StyleProp.defineEnum("tldraw:horizontalAlign", {
  defaultValue: "middle",
  values: ["start", "middle", "end", "start-legacy", "end-legacy", "middle-legacy"]
});

// ../node_modules/@tldraw/tlschema/dist-esm/styles/TLVerticalAlignStyle.mjs
var DefaultVerticalAlignStyle = StyleProp.defineEnum("tldraw:verticalAlign", {
  defaultValue: "middle",
  values: ["start", "middle", "end"]
});

// ../node_modules/@tldraw/tlschema/dist-esm/shapes/TLGeoShape.mjs
var GeoShapeGeoStyle = StyleProp.defineEnum("tldraw:geo", {
  defaultValue: "rectangle",
  values: [
    "cloud",
    "rectangle",
    "ellipse",
    "triangle",
    "diamond",
    "pentagon",
    "hexagon",
    "octagon",
    "star",
    "rhombus",
    "rhombus-2",
    "oval",
    "trapezoid",
    "arrow-right",
    "arrow-left",
    "arrow-up",
    "arrow-down",
    "x-box",
    "check-box",
    "heart"
  ]
});
var geoShapeProps = {
  geo: GeoShapeGeoStyle,
  dash: DefaultDashStyle,
  url: validation_exports.linkUrl,
  w: validation_exports.nonZeroNumber,
  h: validation_exports.nonZeroNumber,
  growY: validation_exports.positiveNumber,
  scale: validation_exports.nonZeroNumber,
  // Text properties
  labelColor: DefaultLabelColorStyle,
  color: DefaultColorStyle,
  fill: DefaultFillStyle,
  size: DefaultSizeStyle,
  font: DefaultFontStyle,
  align: DefaultHorizontalAlignStyle,
  verticalAlign: DefaultVerticalAlignStyle,
  richText: richTextValidator
};
var geoShapeVersions = createShapePropsMigrationIds("geo", {
  AddUrlProp: 1,
  AddLabelColor: 2,
  RemoveJustify: 3,
  AddCheckBox: 4,
  AddVerticalAlign: 5,
  MigrateLegacyAlign: 6,
  AddCloud: 7,
  MakeUrlsValid: 8,
  AddScale: 9,
  AddRichText: 10,
  AddRichTextAttrs: 11
});
var geoShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: geoShapeVersions.AddUrlProp,
      up: (props) => {
        props.url = "";
      },
      down: "retired"
    },
    {
      id: geoShapeVersions.AddLabelColor,
      up: (props) => {
        props.labelColor = "black";
      },
      down: "retired"
    },
    {
      id: geoShapeVersions.RemoveJustify,
      up: (props) => {
        if (props.align === "justify") {
          props.align = "start";
        }
      },
      down: "retired"
    },
    {
      id: geoShapeVersions.AddCheckBox,
      up: (_props) => {
      },
      down: "retired"
    },
    {
      id: geoShapeVersions.AddVerticalAlign,
      up: (props) => {
        props.verticalAlign = "middle";
      },
      down: "retired"
    },
    {
      id: geoShapeVersions.MigrateLegacyAlign,
      up: (props) => {
        let newAlign;
        switch (props.align) {
          case "start":
            newAlign = "start-legacy";
            break;
          case "end":
            newAlign = "end-legacy";
            break;
          default:
            newAlign = "middle-legacy";
            break;
        }
        props.align = newAlign;
      },
      down: "retired"
    },
    {
      id: geoShapeVersions.AddCloud,
      up: (_props) => {
      },
      down: "retired"
    },
    {
      id: geoShapeVersions.MakeUrlsValid,
      up: (props) => {
        if (!validation_exports.linkUrl.isValid(props.url)) {
          props.url = "";
        }
      },
      down: (_props) => {
      }
    },
    {
      id: geoShapeVersions.AddScale,
      up: (props) => {
        props.scale = 1;
      },
      down: (props) => {
        delete props.scale;
      }
    },
    {
      id: geoShapeVersions.AddRichText,
      up: (props) => {
        props.richText = toRichText(props.text);
        delete props.text;
      }
      // N.B. Explicitly no down state so that we force clients to update.
      // down: (props) => {
      // 	delete props.richText
      // },
    },
    {
      id: geoShapeVersions.AddRichTextAttrs,
      up: (_props) => {
      },
      down: (props) => {
        if (props.richText && "attrs" in props.richText) {
          delete props.richText.attrs;
        }
      }
    }
  ]
});

// ../node_modules/@tldraw/tlschema/dist-esm/shapes/TLGroupShape.mjs
var groupShapeProps = {};
var groupShapeMigrations = createShapePropsMigrationSequence({ sequence: [] });

// ../node_modules/@tldraw/tlschema/dist-esm/shapes/TLHighlightShape.mjs
var highlightShapeProps = {
  color: DefaultColorStyle,
  size: DefaultSizeStyle,
  segments: validation_exports.arrayOf(DrawShapeSegment),
  isComplete: validation_exports.boolean,
  isPen: validation_exports.boolean,
  scale: validation_exports.nonZeroNumber,
  scaleX: validation_exports.nonZeroFiniteNumber,
  scaleY: validation_exports.nonZeroFiniteNumber
};
var Versions8 = createShapePropsMigrationIds("highlight", {
  AddScale: 1,
  Base64: 2,
  LegacyPointsConversion: 3
});
var highlightShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions8.AddScale,
      up: (props) => {
        props.scale = 1;
      },
      down: (props) => {
        delete props.scale;
      }
    },
    {
      id: Versions8.Base64,
      up: (props) => {
        props.segments = props.segments.map((segment) => {
          if (segment.path !== void 0) return segment;
          const { points, ...rest } = segment;
          const vecModels = Array.isArray(points) ? points : b64Vecs._legacyDecodePoints(points);
          return {
            ...rest,
            path: b64Vecs.encodePoints(vecModels)
          };
        });
        props.scaleX = props.scaleX ?? 1;
        props.scaleY = props.scaleY ?? 1;
      },
      down: (props) => {
        props.segments = props.segments.map((segment) => {
          const { path, ...rest } = segment;
          return {
            ...rest,
            points: b64Vecs.decodePoints(path)
          };
        });
        delete props.scaleX;
        delete props.scaleY;
      }
    },
    {
      id: Versions8.LegacyPointsConversion,
      up: (props) => {
        props.segments = props.segments.map((segment) => {
          if (segment.path !== void 0) return segment;
          const { points, ...rest } = segment;
          const vecModels = Array.isArray(points) ? points : b64Vecs._legacyDecodePoints(points);
          return {
            ...rest,
            path: b64Vecs.encodePoints(vecModels)
          };
        });
      },
      down: (_props) => {
      }
    }
  ]
});

// ../node_modules/@tldraw/tlschema/dist-esm/shapes/TLImageShape.mjs
var ImageShapeCrop = validation_exports.object({
  topLeft: vecModelValidator,
  bottomRight: vecModelValidator,
  isCircle: validation_exports.boolean.optional()
});
var imageShapeProps = {
  w: validation_exports.nonZeroNumber,
  h: validation_exports.nonZeroNumber,
  playing: validation_exports.boolean,
  url: validation_exports.linkUrl,
  assetId: assetIdValidator.nullable(),
  crop: ImageShapeCrop.nullable(),
  flipX: validation_exports.boolean,
  flipY: validation_exports.boolean,
  altText: validation_exports.string
};
var Versions9 = createShapePropsMigrationIds("image", {
  AddUrlProp: 1,
  AddCropProp: 2,
  MakeUrlsValid: 3,
  AddFlipProps: 4,
  AddAltText: 5
});
var imageShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions9.AddUrlProp,
      up: (props) => {
        props.url = "";
      },
      down: "retired"
    },
    {
      id: Versions9.AddCropProp,
      up: (props) => {
        props.crop = null;
      },
      down: (props) => {
        delete props.crop;
      }
    },
    {
      id: Versions9.MakeUrlsValid,
      up: (props) => {
        if (!validation_exports.linkUrl.isValid(props.url)) {
          props.url = "";
        }
      },
      down: (_props) => {
      }
    },
    {
      id: Versions9.AddFlipProps,
      up: (props) => {
        props.flipX = false;
        props.flipY = false;
      },
      down: (props) => {
        delete props.flipX;
        delete props.flipY;
      }
    },
    {
      id: Versions9.AddAltText,
      up: (props) => {
        props.altText = "";
      },
      down: (props) => {
        delete props.altText;
      }
    }
  ]
});

// ../node_modules/@tldraw/tlschema/dist-esm/shapes/TLLineShape.mjs
var LineShapeSplineStyle = StyleProp.defineEnum("tldraw:spline", {
  defaultValue: "line",
  values: ["cubic", "line"]
});
var lineShapePointValidator = validation_exports.object({
  id: validation_exports.string,
  index: validation_exports.indexKey,
  x: validation_exports.number,
  y: validation_exports.number
});
var lineShapeProps = {
  color: DefaultColorStyle,
  dash: DefaultDashStyle,
  size: DefaultSizeStyle,
  spline: LineShapeSplineStyle,
  points: validation_exports.dict(validation_exports.string, lineShapePointValidator),
  scale: validation_exports.nonZeroNumber
};
var lineShapeVersions = createShapePropsMigrationIds("line", {
  AddSnapHandles: 1,
  RemoveExtraHandleProps: 2,
  HandlesToPoints: 3,
  PointIndexIds: 4,
  AddScale: 5
});
var lineShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: lineShapeVersions.AddSnapHandles,
      up: (props) => {
        for (const handle of Object.values(props.handles)) {
          ;
          handle.canSnap = true;
        }
      },
      down: "retired"
    },
    {
      id: lineShapeVersions.RemoveExtraHandleProps,
      up: (props) => {
        props.handles = objectMapFromEntries(
          Object.values(props.handles).map((handle) => [
            handle.index,
            {
              x: handle.x,
              y: handle.y
            }
          ])
        );
      },
      down: (props) => {
        const handles = Object.entries(props.handles).map(([index2, handle]) => ({ index: index2, ...handle })).sort(sortByIndex);
        props.handles = Object.fromEntries(
          handles.map((handle, i) => {
            const id = i === 0 ? "start" : i === handles.length - 1 ? "end" : `handle:${handle.index}`;
            return [
              id,
              {
                id,
                type: "vertex",
                canBind: false,
                canSnap: true,
                index: handle.index,
                x: handle.x,
                y: handle.y
              }
            ];
          })
        );
      }
    },
    {
      id: lineShapeVersions.HandlesToPoints,
      up: (props) => {
        const sortedHandles = Object.entries(props.handles).map(([index2, { x, y }]) => ({ x, y, index: index2 })).sort(sortByIndex);
        props.points = sortedHandles.map(({ x, y }) => ({ x, y }));
        delete props.handles;
      },
      down: (props) => {
        const indices = getIndices(props.points.length);
        props.handles = Object.fromEntries(
          props.points.map((handle, i) => {
            const index2 = indices[i];
            return [
              index2,
              {
                x: handle.x,
                y: handle.y
              }
            ];
          })
        );
        delete props.points;
      }
    },
    {
      id: lineShapeVersions.PointIndexIds,
      up: (props) => {
        const indices = getIndices(props.points.length);
        props.points = Object.fromEntries(
          props.points.map((point, i) => {
            const id = indices[i];
            return [
              id,
              {
                id,
                index: id,
                x: point.x,
                y: point.y
              }
            ];
          })
        );
      },
      down: (props) => {
        const sortedHandles = Object.values(props.points).sort(sortByIndex);
        props.points = sortedHandles.map(({ x, y }) => ({ x, y }));
      }
    },
    {
      id: lineShapeVersions.AddScale,
      up: (props) => {
        props.scale = 1;
      },
      down: (props) => {
        delete props.scale;
      }
    }
  ]
});

// ../node_modules/@tldraw/tlschema/dist-esm/shapes/TLNoteShape.mjs
var noteShapeProps = {
  color: DefaultColorStyle,
  labelColor: DefaultLabelColorStyle,
  size: DefaultSizeStyle,
  font: DefaultFontStyle,
  fontSizeAdjustment: validation_exports.positiveNumber,
  align: DefaultHorizontalAlignStyle,
  verticalAlign: DefaultVerticalAlignStyle,
  growY: validation_exports.positiveNumber,
  url: validation_exports.linkUrl,
  richText: richTextValidator,
  scale: validation_exports.nonZeroNumber
};
var Versions10 = createShapePropsMigrationIds("note", {
  AddUrlProp: 1,
  RemoveJustify: 2,
  MigrateLegacyAlign: 3,
  AddVerticalAlign: 4,
  MakeUrlsValid: 5,
  AddFontSizeAdjustment: 6,
  AddScale: 7,
  AddLabelColor: 8,
  AddRichText: 9,
  AddRichTextAttrs: 10
});
var noteShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions10.AddUrlProp,
      up: (props) => {
        props.url = "";
      },
      down: "retired"
    },
    {
      id: Versions10.RemoveJustify,
      up: (props) => {
        if (props.align === "justify") {
          props.align = "start";
        }
      },
      down: "retired"
    },
    {
      id: Versions10.MigrateLegacyAlign,
      up: (props) => {
        switch (props.align) {
          case "start":
            props.align = "start-legacy";
            return;
          case "end":
            props.align = "end-legacy";
            return;
          default:
            props.align = "middle-legacy";
            return;
        }
      },
      down: "retired"
    },
    {
      id: Versions10.AddVerticalAlign,
      up: (props) => {
        props.verticalAlign = "middle";
      },
      down: "retired"
    },
    {
      id: Versions10.MakeUrlsValid,
      up: (props) => {
        if (!validation_exports.linkUrl.isValid(props.url)) {
          props.url = "";
        }
      },
      down: (_props) => {
      }
    },
    {
      id: Versions10.AddFontSizeAdjustment,
      up: (props) => {
        props.fontSizeAdjustment = 0;
      },
      down: (props) => {
        delete props.fontSizeAdjustment;
      }
    },
    {
      id: Versions10.AddScale,
      up: (props) => {
        props.scale = 1;
      },
      down: (props) => {
        delete props.scale;
      }
    },
    {
      id: Versions10.AddLabelColor,
      up: (props) => {
        props.labelColor = "black";
      },
      down: (props) => {
        delete props.labelColor;
      }
    },
    {
      id: Versions10.AddRichText,
      up: (props) => {
        props.richText = toRichText(props.text);
        delete props.text;
      }
      // N.B. Explicitly no down state so that we force clients to update.
      // down: (props) => {
      // 	delete props.richText
      // },
    },
    {
      id: Versions10.AddRichTextAttrs,
      up: (_props) => {
      },
      down: (props) => {
        if (props.richText && "attrs" in props.richText) {
          delete props.richText.attrs;
        }
      }
    }
  ]
});

// ../node_modules/@tldraw/tlschema/dist-esm/styles/TLTextAlignStyle.mjs
var DefaultTextAlignStyle = StyleProp.defineEnum("tldraw:textAlign", {
  defaultValue: "start",
  values: ["start", "middle", "end"]
});

// ../node_modules/@tldraw/tlschema/dist-esm/shapes/TLTextShape.mjs
var textShapeProps = {
  color: DefaultColorStyle,
  size: DefaultSizeStyle,
  font: DefaultFontStyle,
  textAlign: DefaultTextAlignStyle,
  w: validation_exports.nonZeroNumber,
  richText: richTextValidator,
  scale: validation_exports.nonZeroNumber,
  autoSize: validation_exports.boolean
};
var Versions11 = createShapePropsMigrationIds("text", {
  RemoveJustify: 1,
  AddTextAlign: 2,
  AddRichText: 3,
  AddRichTextAttrs: 4
});
var textShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions11.RemoveJustify,
      up: (props) => {
        if (props.align === "justify") {
          props.align = "start";
        }
      },
      down: "retired"
    },
    {
      id: Versions11.AddTextAlign,
      up: (props) => {
        props.textAlign = props.align;
        delete props.align;
      },
      down: (props) => {
        props.align = props.textAlign;
        delete props.textAlign;
      }
    },
    {
      id: Versions11.AddRichText,
      up: (props) => {
        props.richText = toRichText(props.text);
        delete props.text;
      }
      // N.B. Explicitly no down state so that we force clients to update.
      // down: (props) => {
      // 	delete props.richText
      // },
    },
    {
      id: Versions11.AddRichTextAttrs,
      up: (_props) => {
      },
      down: (props) => {
        if (props.richText && "attrs" in props.richText) {
          delete props.richText.attrs;
        }
      }
    }
  ]
});

// ../node_modules/@tldraw/tlschema/dist-esm/shapes/TLVideoShape.mjs
var videoShapeProps = {
  w: validation_exports.nonZeroNumber,
  h: validation_exports.nonZeroNumber,
  time: validation_exports.number,
  playing: validation_exports.boolean,
  autoplay: validation_exports.boolean,
  url: validation_exports.linkUrl,
  assetId: assetIdValidator.nullable(),
  altText: validation_exports.string
};
var Versions12 = createShapePropsMigrationIds("video", {
  AddUrlProp: 1,
  MakeUrlsValid: 2,
  AddAltText: 3,
  AddAutoplay: 4
});
var videoShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions12.AddUrlProp,
      up: (props) => {
        props.url = "";
      },
      down: "retired"
    },
    {
      id: Versions12.MakeUrlsValid,
      up: (props) => {
        if (!validation_exports.linkUrl.isValid(props.url)) {
          props.url = "";
        }
      },
      down: (_props) => {
      }
    },
    {
      id: Versions12.AddAltText,
      up: (props) => {
        props.altText = "";
      },
      down: (props) => {
        delete props.altText;
      }
    },
    {
      id: Versions12.AddAutoplay,
      up: (props) => {
        props.autoplay = true;
      },
      down: (props) => {
        delete props.autoplay;
      }
    }
  ]
});

// ../node_modules/@tldraw/tlschema/dist-esm/store-migrations.mjs
var Versions13 = createMigrationIds("com.tldraw.store", {
  RemoveCodeAndIconShapeTypes: 1,
  AddInstancePresenceType: 2,
  RemoveTLUserAndPresenceAndAddPointer: 3,
  RemoveUserDocument: 4,
  FixIndexKeys: 5
});
var storeMigrations = createMigrationSequence({
  sequenceId: "com.tldraw.store",
  retroactive: false,
  sequence: [
    {
      id: Versions13.RemoveCodeAndIconShapeTypes,
      scope: "storage",
      up: (storage) => {
        for (const [id, record] of storage.entries()) {
          if (record.typeName === "shape" && "type" in record && (record.type === "icon" || record.type === "code")) {
            storage.delete(id);
          }
        }
      }
    },
    {
      id: Versions13.AddInstancePresenceType,
      scope: "storage",
      up(_storage) {
      }
    },
    {
      // remove user and presence records and add pointer records
      id: Versions13.RemoveTLUserAndPresenceAndAddPointer,
      scope: "storage",
      up: (storage) => {
        for (const [id, record] of storage.entries()) {
          if (record.typeName.match(/^(user|user_presence)$/)) {
            storage.delete(id);
          }
        }
      }
    },
    {
      // remove user document records
      id: Versions13.RemoveUserDocument,
      scope: "storage",
      up: (storage) => {
        for (const [id, record] of storage.entries()) {
          if (record.typeName.match("user_document")) {
            storage.delete(id);
          }
        }
      }
    },
    {
      id: Versions13.FixIndexKeys,
      scope: "record",
      up: (record) => {
        if (["shape", "page"].includes(record.typeName) && "index" in record) {
          const recordWithIndex = record;
          if (recordWithIndex.index.endsWith("0") && recordWithIndex.index !== "a0") {
            recordWithIndex.index = recordWithIndex.index.slice(0, -1) + getNRandomBase62Digits(3);
          }
          if (record.typeName === "shape" && recordWithIndex.type === "line") {
            const lineShape = recordWithIndex;
            for (const [_, point] of objectMapEntries(lineShape.props.points)) {
              if (point.index.endsWith("0") && point.index !== "a0") {
                point.index = point.index.slice(0, -1) + getNRandomBase62Digits(3);
              }
            }
          }
        }
      },
      down: () => {
      }
    }
  ]
});
var BASE_62_DIGITS_WITHOUT_ZERO = "123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
var getRandomBase62Digit = () => {
  return BASE_62_DIGITS_WITHOUT_ZERO.charAt(
    Math.floor(Math.random() * BASE_62_DIGITS_WITHOUT_ZERO.length)
  );
};
var getNRandomBase62Digits = (n) => {
  return Array.from({ length: n }, getRandomBase62Digit).join("");
};

// ../node_modules/@tldraw/tlschema/dist-esm/createTLSchema.mjs
var defaultShapeSchemas = {
  arrow: { migrations: arrowShapeMigrations, props: arrowShapeProps },
  bookmark: { migrations: bookmarkShapeMigrations, props: bookmarkShapeProps },
  draw: { migrations: drawShapeMigrations, props: drawShapeProps },
  embed: { migrations: embedShapeMigrations, props: embedShapeProps },
  frame: { migrations: frameShapeMigrations, props: frameShapeProps },
  geo: { migrations: geoShapeMigrations, props: geoShapeProps },
  group: { migrations: groupShapeMigrations, props: groupShapeProps },
  highlight: { migrations: highlightShapeMigrations, props: highlightShapeProps },
  image: { migrations: imageShapeMigrations, props: imageShapeProps },
  line: { migrations: lineShapeMigrations, props: lineShapeProps },
  note: { migrations: noteShapeMigrations, props: noteShapeProps },
  text: { migrations: textShapeMigrations, props: textShapeProps },
  video: { migrations: videoShapeMigrations, props: videoShapeProps }
};
var defaultBindingSchemas = {
  arrow: { migrations: arrowBindingMigrations, props: arrowBindingProps }
};
function createTLSchema({
  shapes = defaultShapeSchemas,
  bindings = defaultBindingSchemas,
  migrations
} = {}) {
  const stylesById = /* @__PURE__ */ new Map();
  for (const shape of objectMapValues(shapes)) {
    for (const style2 of getShapePropKeysByStyle(shape.props ?? {}).keys()) {
      if (stylesById.has(style2.id) && stylesById.get(style2.id) !== style2) {
        throw new Error(`Multiple StyleProp instances with the same id: ${style2.id}`);
      }
      stylesById.set(style2.id, style2);
    }
  }
  const ShapeRecordType = createShapeRecordType(shapes);
  const BindingRecordType = createBindingRecordType(bindings);
  const InstanceRecordType = createInstanceRecordType(stylesById);
  return StoreSchema.create(
    {
      asset: AssetRecordType,
      binding: BindingRecordType,
      camera: CameraRecordType,
      document: DocumentRecordType,
      instance: InstanceRecordType,
      instance_page_state: InstancePageStateRecordType,
      page: PageRecordType,
      instance_presence: InstancePresenceRecordType,
      pointer: PointerRecordType,
      shape: ShapeRecordType
    },
    {
      migrations: [
        storeMigrations,
        assetMigrations,
        cameraMigrations,
        documentMigrations,
        instanceMigrations,
        instancePageStateMigrations,
        pageMigrations,
        instancePresenceMigrations,
        pointerMigrations,
        rootShapeMigrations,
        bookmarkAssetMigrations,
        imageAssetMigrations,
        videoAssetMigrations,
        ...processPropsMigrations("shape", shapes),
        ...processPropsMigrations("binding", bindings),
        ...migrations ?? []
      ],
      onValidationFailure,
      createIntegrityChecker
    }
  );
}

// ../node_modules/@tldraw/tlschema/dist-esm/misc/TLHandle.mjs
var TL_HANDLE_TYPES = /* @__PURE__ */ new Set(["vertex", "virtual", "create", "clone"]);

// ../node_modules/@tldraw/tlschema/dist-esm/translations/languages.mjs
var LANGUAGES = [
  { locale: "id", label: "Bahasa Indonesia" },
  { locale: "ms", label: "Bahasa Melayu" },
  { locale: "ca", label: "Català" },
  { locale: "cs", label: "Čeština" },
  { locale: "da", label: "Danish" },
  { locale: "de", label: "Deutsch" },
  { locale: "en", label: "English" },
  { locale: "es", label: "Español" },
  { locale: "tl", label: "Filipino" },
  { locale: "fr", label: "Français" },
  { locale: "gl", label: "Galego" },
  { locale: "hr", label: "Hrvatski" },
  { locale: "it", label: "Italiano" },
  { locale: "hu", label: "Magyar" },
  { locale: "nl", label: "Nederlands" },
  { locale: "no", label: "Norwegian" },
  { locale: "pl", label: "Polski" },
  { locale: "pt-br", label: "Português - Brasil" },
  { locale: "pt-pt", label: "Português - Europeu" },
  { locale: "ro", label: "Română" },
  { locale: "sl", label: "Slovenščina" },
  { locale: "so", label: "Somali" },
  { locale: "fi", label: "Suomi" },
  { locale: "sv", label: "Svenska" },
  { locale: "vi", label: "Tiếng Việt" },
  { locale: "tr", label: "Türkçe" },
  { locale: "el", label: "Ελληνικά" },
  { locale: "ru", label: "Русский" },
  { locale: "uk", label: "Українська" },
  { locale: "he", label: "עברית" },
  { locale: "ur", label: "اردو" },
  { locale: "ar", label: "عربي" },
  { locale: "fa", label: "فارسی" },
  { locale: "ne", label: "नेपाली" },
  { locale: "mr", label: "मराठी" },
  { locale: "hi-in", label: "हिन्दी" },
  { locale: "bn", label: "বাংলা" },
  { locale: "pa", label: "ਪੰਜਾਬੀ" },
  { locale: "gu-in", label: "ગુજરાતી" },
  { locale: "ta", label: "தமிழ்" },
  { locale: "te", label: "తెలుగు" },
  { locale: "kn", label: "ಕನ್ನಡ" },
  { locale: "ml", label: "മലയാളം" },
  { locale: "th", label: "ภาษาไทย" },
  { locale: "km-kh", label: "ភាសាខ្មែរ" },
  { locale: "ko-kr", label: "한국어" },
  { locale: "ja", label: "日本語" },
  { locale: "zh-cn", label: "简体中文" },
  { locale: "zh-tw", label: "繁體中文 (台灣)" }
];

// ../node_modules/@tldraw/tlschema/dist-esm/translations/translations.mjs
function getDefaultTranslationLocale() {
  const locales = typeof window !== "undefined" && window.navigator ? window.navigator.languages ?? ["en"] : ["en"];
  return _getDefaultTranslationLocale(locales);
}
function _getDefaultTranslationLocale(locales) {
  for (const locale of locales) {
    const supportedLocale = getSupportedLocale(locale);
    if (supportedLocale) {
      return supportedLocale;
    }
  }
  return "en";
}
var DEFAULT_LOCALE_REGIONS = {
  zh: "zh-cn",
  pt: "pt-br",
  ko: "ko-kr",
  hi: "hi-in"
};
function getSupportedLocale(locale) {
  const exactMatch = LANGUAGES.find((t2) => t2.locale === locale.toLowerCase());
  if (exactMatch) {
    return exactMatch.locale;
  }
  const [language, region] = locale.split(/[-_]/).map((s) => s.toLowerCase());
  if (region) {
    const languageMatch = LANGUAGES.find((t2) => t2.locale === language);
    if (languageMatch) {
      return languageMatch.locale;
    }
  }
  if (language in DEFAULT_LOCALE_REGIONS) {
    return DEFAULT_LOCALE_REGIONS[language];
  }
  return null;
}

// ../node_modules/@tldraw/tlschema/dist-esm/index.mjs
registerTldrawLibraryVersion(
  "@tldraw/tlschema",
  "4.3.1",
  "esm"
);

// ../node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultBackground.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
function DefaultBackground() {
  return (0, import_jsx_runtime.jsx)("div", { className: "tl-background" });
}

// ../node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultBrush.mjs
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react9 = __toESM(require_react(), 1);

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/useTransform.mjs
var import_react8 = __toESM(require_react(), 1);
function useTransform(ref, x, y, scale, rotate, additionalOffset) {
  (0, import_react8.useLayoutEffect)(() => {
    const elm = ref.current;
    if (!elm) return;
    if (x === void 0) return;
    let trans = `translate(${x}px, ${y}px)`;
    if (scale !== void 0) {
      trans += ` scale(${scale})`;
    }
    if (rotate !== void 0) {
      trans += ` rotate(${rotate}rad)`;
    }
    if (additionalOffset) {
      trans += ` translate(${additionalOffset.x}px, ${additionalOffset.y}px)`;
    }
    elm.style.transform = trans;
  });
}

// ../node_modules/@tldraw/editor/dist-esm/lib/primitives/easings.mjs
var EASINGS = {
  linear: (t2) => t2,
  easeInQuad: (t2) => t2 * t2,
  easeOutQuad: (t2) => t2 * (2 - t2),
  easeInOutQuad: (t2) => t2 < 0.5 ? 2 * t2 * t2 : -1 + (4 - 2 * t2) * t2,
  easeInCubic: (t2) => t2 * t2 * t2,
  easeOutCubic: (t2) => --t2 * t2 * t2 + 1,
  easeInOutCubic: (t2) => t2 < 0.5 ? 4 * t2 * t2 * t2 : (t2 - 1) * (2 * t2 - 2) * (2 * t2 - 2) + 1,
  easeInQuart: (t2) => t2 * t2 * t2 * t2,
  easeOutQuart: (t2) => 1 - --t2 * t2 * t2 * t2,
  easeInOutQuart: (t2) => t2 < 0.5 ? 8 * t2 * t2 * t2 * t2 : 1 - 8 * --t2 * t2 * t2 * t2,
  easeInQuint: (t2) => t2 * t2 * t2 * t2 * t2,
  easeOutQuint: (t2) => 1 + --t2 * t2 * t2 * t2 * t2,
  easeInOutQuint: (t2) => t2 < 0.5 ? 16 * t2 * t2 * t2 * t2 * t2 : 1 + 16 * --t2 * t2 * t2 * t2 * t2,
  easeInSine: (t2) => 1 - Math.cos(t2 * Math.PI / 2),
  easeOutSine: (t2) => Math.sin(t2 * Math.PI / 2),
  easeInOutSine: (t2) => -(Math.cos(Math.PI * t2) - 1) / 2,
  easeInExpo: (t2) => t2 <= 0 ? 0 : Math.pow(2, 10 * t2 - 10),
  easeOutExpo: (t2) => t2 >= 1 ? 1 : 1 - Math.pow(2, -10 * t2),
  easeInOutExpo: (t2) => t2 <= 0 ? 0 : t2 >= 1 ? 1 : t2 < 0.5 ? Math.pow(2, 20 * t2 - 10) / 2 : (2 - Math.pow(2, -20 * t2 + 10)) / 2
};

// ../node_modules/@tldraw/editor/dist-esm/lib/primitives/Vec.mjs
var Vec = class _Vec {
  constructor(x = 0, y = 0, z = 1) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  // eslint-disable-next-line no-restricted-syntax
  get pressure() {
    return this.z;
  }
  set(x = this.x, y = this.y, z = this.z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
  setTo({ x = 0, y = 0, z = 1 }) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
  rot(r) {
    if (r === 0) return this;
    const { x, y } = this;
    const s = Math.sin(r);
    const c = Math.cos(r);
    this.x = x * c - y * s;
    this.y = x * s + y * c;
    return this;
  }
  rotWith(C, r) {
    if (r === 0) return this;
    const x = this.x - C.x;
    const y = this.y - C.y;
    const s = Math.sin(r);
    const c = Math.cos(r);
    this.x = C.x + (x * c - y * s);
    this.y = C.y + (x * s + y * c);
    return this;
  }
  clone() {
    const { x, y, z } = this;
    return new _Vec(x, y, z);
  }
  sub(V2) {
    this.x -= V2.x;
    this.y -= V2.y;
    return this;
  }
  subXY(x, y) {
    this.x -= x;
    this.y -= y;
    return this;
  }
  subScalar(n) {
    this.x -= n;
    this.y -= n;
    return this;
  }
  add(V2) {
    this.x += V2.x;
    this.y += V2.y;
    return this;
  }
  addXY(x, y) {
    this.x += x;
    this.y += y;
    return this;
  }
  addScalar(n) {
    this.x += n;
    this.y += n;
    return this;
  }
  clamp(min3, max2) {
    this.x = Math.max(this.x, min3);
    this.y = Math.max(this.y, min3);
    if (max2 !== void 0) {
      this.x = Math.min(this.x, max2);
      this.y = Math.min(this.y, max2);
    }
    return this;
  }
  div(t2) {
    this.x /= t2;
    this.y /= t2;
    return this;
  }
  divV(V2) {
    this.x /= V2.x;
    this.y /= V2.y;
    return this;
  }
  mul(t2) {
    this.x *= t2;
    this.y *= t2;
    return this;
  }
  mulV(V2) {
    this.x *= V2.x;
    this.y *= V2.y;
    return this;
  }
  abs() {
    this.x = Math.abs(this.x);
    this.y = Math.abs(this.y);
    return this;
  }
  nudge(B, distance) {
    const tan = _Vec.Tan(B, this);
    return this.add(tan.mul(distance));
  }
  neg() {
    this.x *= -1;
    this.y *= -1;
    return this;
  }
  cross(V2) {
    this.x = this.y * V2.z - this.z * V2.y;
    this.y = this.z * V2.x - this.x * V2.z;
    return this;
  }
  dpr(V2) {
    return _Vec.Dpr(this, V2);
  }
  cpr(V2) {
    return _Vec.Cpr(this, V2);
  }
  len2() {
    return _Vec.Len2(this);
  }
  len() {
    return _Vec.Len(this);
  }
  pry(V2) {
    return _Vec.Pry(this, V2);
  }
  per() {
    const { x, y } = this;
    this.x = y;
    this.y = -x;
    return this;
  }
  uni() {
    const l = this.len();
    if (l === 0) return this;
    this.x /= l;
    this.y /= l;
    return this;
  }
  tan(V2) {
    return this.sub(V2).uni();
  }
  dist(V2) {
    return _Vec.Dist(this, V2);
  }
  distanceToLineSegment(A, B) {
    return _Vec.DistanceToLineSegment(A, B, this);
  }
  slope(B) {
    return _Vec.Slope(this, B);
  }
  snapToGrid(gridSize) {
    this.x = Math.round(this.x / gridSize) * gridSize;
    this.y = Math.round(this.y / gridSize) * gridSize;
    return this;
  }
  angle(B) {
    return _Vec.Angle(this, B);
  }
  toAngle() {
    return _Vec.ToAngle(this);
  }
  lrp(B, t2) {
    this.x = this.x + (B.x - this.x) * t2;
    this.y = this.y + (B.y - this.y) * t2;
    return this;
  }
  equals(B) {
    return _Vec.Equals(this, B);
  }
  equalsXY(x, y) {
    return _Vec.EqualsXY(this, x, y);
  }
  toFixed() {
    this.x = toFixed(this.x);
    this.y = toFixed(this.y);
    return this;
  }
  toString() {
    return _Vec.ToString(_Vec.ToFixed(this));
  }
  toJson() {
    return _Vec.ToJson(this);
  }
  toArray() {
    return _Vec.ToArray(this);
  }
  static Add(A, B) {
    return new _Vec(A.x + B.x, A.y + B.y);
  }
  static AddXY(A, x, y) {
    return new _Vec(A.x + x, A.y + y);
  }
  static Sub(A, B) {
    return new _Vec(A.x - B.x, A.y - B.y);
  }
  static SubXY(A, x, y) {
    return new _Vec(A.x - x, A.y - y);
  }
  static AddScalar(A, n) {
    return new _Vec(A.x + n, A.y + n);
  }
  static SubScalar(A, n) {
    return new _Vec(A.x - n, A.y - n);
  }
  static Div(A, t2) {
    return new _Vec(A.x / t2, A.y / t2);
  }
  static Mul(A, t2) {
    return new _Vec(A.x * t2, A.y * t2);
  }
  static DivV(A, B) {
    return new _Vec(A.x / B.x, A.y / B.y);
  }
  static MulV(A, B) {
    return new _Vec(A.x * B.x, A.y * B.y);
  }
  static Neg(A) {
    return new _Vec(-A.x, -A.y);
  }
  /**
   * Get the perpendicular vector to A.
   */
  static Per(A) {
    return new _Vec(A.y, -A.x);
  }
  static Abs(A) {
    return new _Vec(Math.abs(A.x), Math.abs(A.y));
  }
  // Get the distance between two points.
  static Dist(A, B) {
    return ((A.y - B.y) ** 2 + (A.x - B.x) ** 2) ** 0.5;
  }
  // Get the Manhattan distance between two points.
  static ManhattanDist(A, B) {
    return Math.abs(A.x - B.x) + Math.abs(A.y - B.y);
  }
  // Get whether a distance between two points is less than a number. This is faster to calulate than using `Vec.Dist(a, b) < n`.
  static DistMin(A, B, n) {
    return (A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y) < n ** 2;
  }
  // Get the squared distance between two points. This is faster to calculate (no square root) so useful for "minimum distance" checks where the actual measurement does not matter.
  static Dist2(A, B) {
    return (A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y);
  }
  /**
   * Dot product of two vectors which is used to calculate the angle between them.
   */
  static Dpr(A, B) {
    return A.x * B.x + A.y * B.y;
  }
  static Cross(A, V2) {
    return new _Vec(
      A.y * V2.z - A.z * V2.y,
      A.z * V2.x - A.x * V2.z
      // A.z = A.x * V.y - A.y * V.x
    );
  }
  /**
   * Cross product of two vectors which is used to calculate the area of a parallelogram.
   */
  static Cpr(A, B) {
    return A.x * B.y - B.x * A.y;
  }
  static Len2(A) {
    return A.x * A.x + A.y * A.y;
  }
  static Len(A) {
    return (A.x * A.x + A.y * A.y) ** 0.5;
  }
  /**
   * Get the projection of A onto B.
   */
  static Pry(A, B) {
    return _Vec.Dpr(A, B) / _Vec.Len(B);
  }
  /**
   * Get the unit vector of A.
   */
  static Uni(A) {
    const l = _Vec.Len(A);
    return new _Vec(l === 0 ? 0 : A.x / l, l === 0 ? 0 : A.y / l);
  }
  static Tan(A, B) {
    return _Vec.Uni(_Vec.Sub(A, B));
  }
  static Min(A, B) {
    return new _Vec(Math.min(A.x, B.x), Math.min(A.y, B.y));
  }
  static Max(A, B) {
    return new _Vec(Math.max(A.x, B.x), Math.max(A.y, B.y));
  }
  static From({ x, y, z = 1 }) {
    return new _Vec(x, y, z);
  }
  static FromArray(v) {
    return new _Vec(v[0], v[1]);
  }
  static Rot(A, r = 0) {
    const s = Math.sin(r);
    const c = Math.cos(r);
    return new _Vec(A.x * c - A.y * s, A.x * s + A.y * c);
  }
  static RotWith(A, C, r) {
    const x = A.x - C.x;
    const y = A.y - C.y;
    const s = Math.sin(r);
    const c = Math.cos(r);
    return new _Vec(C.x + (x * c - y * s), C.y + (x * s + y * c));
  }
  /**
   * Get the nearest point on a line with a known unit vector that passes through point A
   *
   * ```ts
   * Vec.nearestPointOnLineThroughPoint(A, u, Point)
   * ```
   *
   * @param A - Any point on the line
   * @param u - The unit vector for the line.
   * @param P - A point not on the line to test.
   */
  static NearestPointOnLineThroughPoint(A, u, P) {
    return _Vec.Mul(u, _Vec.Sub(P, A).pry(u)).add(A);
  }
  static NearestPointOnLineSegment(A, B, P, clamp22 = true) {
    if (_Vec.Equals(A, P)) return _Vec.From(P);
    if (_Vec.Equals(B, P)) return _Vec.From(P);
    const u = _Vec.Tan(B, A);
    const C = _Vec.Add(A, _Vec.Mul(u, _Vec.Sub(P, A).pry(u)));
    if (clamp22) {
      if (C.x < Math.min(A.x, B.x)) return _Vec.Cast(A.x < B.x ? A : B);
      if (C.x > Math.max(A.x, B.x)) return _Vec.Cast(A.x > B.x ? A : B);
      if (C.y < Math.min(A.y, B.y)) return _Vec.Cast(A.y < B.y ? A : B);
      if (C.y > Math.max(A.y, B.y)) return _Vec.Cast(A.y > B.y ? A : B);
    }
    return C;
  }
  static DistanceToLineThroughPoint(A, u, P) {
    return _Vec.Dist(P, _Vec.NearestPointOnLineThroughPoint(A, u, P));
  }
  static DistanceToLineSegment(A, B, P, clamp22 = true) {
    return _Vec.Dist(P, _Vec.NearestPointOnLineSegment(A, B, P, clamp22));
  }
  static Snap(A, step = 1) {
    return new _Vec(Math.round(A.x / step) * step, Math.round(A.y / step) * step);
  }
  static Cast(A) {
    if (A instanceof _Vec) return A;
    return _Vec.From(A);
  }
  static Slope(A, B) {
    if (A.x === B.y) return NaN;
    return (A.y - B.y) / (A.x - B.x);
  }
  static IsNaN(A) {
    return isNaN(A.x) || isNaN(A.y);
  }
  /**
   * Get the angle from position A to position B.
   */
  static Angle(A, B) {
    return Math.atan2(B.y - A.y, B.x - A.x);
  }
  /**
   * Get the angle between vector A and vector B. This will return the smallest angle between the
   * two vectors, between -π and π. The sign indicates direction of angle.
   */
  static AngleBetween(A, B) {
    const p = A.x * B.x + A.y * B.y;
    const n = Math.sqrt(
      (Math.pow(A.x, 2) + Math.pow(A.y, 2)) * (Math.pow(B.x, 2) + Math.pow(B.y, 2))
    );
    const sign = A.x * B.y - A.y * B.x < 0 ? -1 : 1;
    const angle = sign * Math.acos(clamp(p / n, -1, 1));
    return angle;
  }
  /**
   * Linearly interpolate between two points.
   * @param A - The first point.
   * @param B - The second point.
   * @param t - The interpolation value between 0 and 1.
   * @returns The interpolated point.
   */
  static Lrp(A, B, t2) {
    return _Vec.Sub(B, A).mul(t2).add(A);
  }
  static Med(A, B) {
    return new _Vec((A.x + B.x) / 2, (A.y + B.y) / 2);
  }
  static Equals(A, B) {
    return Math.abs(A.x - B.x) < 1e-4 && Math.abs(A.y - B.y) < 1e-4;
  }
  static EqualsXY(A, x, y) {
    return A.x === x && A.y === y;
  }
  static Clockwise(A, B, C) {
    return (C.x - A.x) * (B.y - A.y) - (B.x - A.x) * (C.y - A.y) < 0;
  }
  static Rescale(A, n) {
    const l = _Vec.Len(A);
    return new _Vec(n * A.x / l, n * A.y / l);
  }
  static ScaleWithOrigin(A, scale, origin) {
    return _Vec.Sub(A, origin).mul(scale).add(origin);
  }
  static ToFixed(A) {
    return new _Vec(toFixed(A.x), toFixed(A.y));
  }
  static ToInt(A) {
    return new _Vec(
      parseInt(A.x.toFixed(0)),
      parseInt(A.y.toFixed(0)),
      parseInt((A.z ?? 0).toFixed(0))
    );
  }
  static ToCss(A) {
    return `${A.x},${A.y}`;
  }
  static Nudge(A, B, distance) {
    return _Vec.Add(A, _Vec.Tan(B, A).mul(distance));
  }
  static ToString(A) {
    return `${A.x}, ${A.y}`;
  }
  static ToAngle(A) {
    let r = Math.atan2(A.y, A.x);
    if (r < 0) r += Math.PI * 2;
    return r;
  }
  static FromAngle(r, length = 1) {
    return new _Vec(Math.cos(r) * length, Math.sin(r) * length);
  }
  static ToArray(A) {
    return [A.x, A.y, A.z];
  }
  static ToJson(A) {
    const { x, y, z } = A;
    return { x, y, z };
  }
  static Average(arr) {
    const len = arr.length;
    const avg = new _Vec(0, 0);
    if (len === 0) {
      return avg;
    }
    for (let i = 0; i < len; i++) {
      avg.add(arr[i]);
    }
    return avg.div(len);
  }
  static Clamp(A, min3, max2) {
    if (max2 === void 0) {
      return new _Vec(Math.min(Math.max(A.x, min3)), Math.min(Math.max(A.y, min3)));
    }
    return new _Vec(Math.min(Math.max(A.x, min3), max2), Math.min(Math.max(A.y, min3), max2));
  }
  /**
   * Get an array of points (with simulated pressure) between two points.
   *
   * @param A - The first point.
   * @param B - The second point.
   * @param steps - The number of points to return.
   */
  static PointsBetween(A, B, steps = 6) {
    const results = [];
    for (let i = 0; i < steps; i++) {
      const t2 = EASINGS.easeInQuad(i / (steps - 1));
      const point = _Vec.Lrp(A, B, t2);
      point.z = Math.min(1, 0.5 + Math.abs(0.5 - ease(t2)) * 0.65);
      results.push(point);
    }
    return results;
  }
  static SnapToGrid(A, gridSize = 8) {
    return new _Vec(Math.round(A.x / gridSize) * gridSize, Math.round(A.y / gridSize) * gridSize);
  }
};
var ease = (t2) => t2 < 0.5 ? 2 * t2 * t2 : -1 + (4 - 2 * t2) * t2;

// ../node_modules/@tldraw/editor/dist-esm/lib/primitives/utils.mjs
function precise(A) {
  return `${toDomPrecision(A.x)},${toDomPrecision(A.y)} `;
}
function average(A, B) {
  return `${toDomPrecision((A.x + B.x) / 2)},${toDomPrecision((A.y + B.y) / 2)} `;
}
var PI = Math.PI;
var HALF_PI = PI / 2;
var PI2 = PI * 2;
var SIN = Math.sin;
function clamp(n, min3, max2) {
  return Math.max(min3, typeof max2 !== "undefined" ? Math.min(n, max2) : n);
}
function toPrecision(n, precision = 1e10) {
  if (!n) return 0;
  return Math.round(n * precision) / precision;
}
function approximately(a, b, precision = 1e-6) {
  return Math.abs(a - b) <= precision;
}
function approximatelyLte(a, b, precision = 1e-6) {
  return a < b || approximately(a, b, precision);
}
function perimeterOfEllipse(rx, ry) {
  const h2 = Math.pow(rx - ry, 2) / Math.pow(rx + ry, 2);
  return PI * (rx + ry) * (1 + 3 * h2 / (10 + Math.sqrt(4 - 3 * h2)));
}
function canonicalizeRotation(a) {
  a = a % PI2;
  if (a < 0) {
    a = a + PI2;
  } else if (a === 0) {
    a = 0;
  }
  return a;
}
function clockwiseAngleDist(a0, a1) {
  a0 = canonicalizeRotation(a0);
  a1 = canonicalizeRotation(a1);
  if (a0 > a1) {
    a1 += PI2;
  }
  return a1 - a0;
}
function counterClockwiseAngleDist(a0, a1) {
  return PI2 - clockwiseAngleDist(a0, a1);
}
function shortAngleDist(a0, a1) {
  const da = (a1 - a0) % PI2;
  return 2 * da % PI2 - da;
}
function clampRadians(r) {
  return (PI2 + r) % PI2;
}
function snapAngle(r, segments) {
  const seg = PI2 / segments;
  let ang = Math.floor((clampRadians(r) + seg / 2) / seg) * seg % PI2;
  if (ang < PI) ang += PI2;
  if (ang > PI) ang -= PI2;
  return ang;
}
function areAnglesCompatible(a, b) {
  return a === b || approximately(a % (Math.PI / 2) - b % (Math.PI / 2), 0);
}
function degreesToRadians(d) {
  return d * PI / 180;
}
function radiansToDegrees(r) {
  return r * 180 / PI;
}
function getPointOnCircle(center, r, a) {
  return new Vec(center.x, center.y).add(Vec.FromAngle(a, r));
}
function getPolygonVertices(width, height, sides2) {
  const cx = width / 2;
  const cy = height / 2;
  const pointsOnPerimeter = [];
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY = -Infinity;
  for (let i = 0; i < sides2; i++) {
    const step = PI2 / sides2;
    const t2 = -HALF_PI + i * step;
    const x = cx + cx * Math.cos(t2);
    const y = cy + cy * Math.sin(t2);
    if (x < minX) minX = x;
    if (y < minY) minY = y;
    if (x > maxX) maxX = x;
    if (y > maxY) maxY = y;
    pointsOnPerimeter.push(new Vec(x, y));
  }
  const w = maxX - minX;
  const h2 = maxY - minY;
  const dx = width - w;
  const dy = height - h2;
  if (dx !== 0 || dy !== 0) {
    for (let i = 0; i < pointsOnPerimeter.length; i++) {
      const pt = pointsOnPerimeter[i];
      pt.x = (pt.x - minX) / w * width;
      pt.y = (pt.y - minY) / h2 * height;
    }
  }
  return pointsOnPerimeter;
}
function rangesOverlap(a0, a1, b0, b1) {
  return a0 < b1 && b0 < a1;
}
function rangeIntersection(a0, a1, b0, b1) {
  const min3 = Math.max(a0, b0);
  const max2 = Math.min(a1, b1);
  if (min3 <= max2) {
    return [min3, max2];
  }
  return null;
}
function cross(x, y, z) {
  return (y.x - x.x) * (z.y - x.y) - (z.x - x.x) * (y.y - x.y);
}
function pointInPolygon(A, points) {
  let windingNumber = 0;
  let a;
  let b;
  for (let i = 0; i < points.length; i++) {
    a = points[i];
    if (a.x === A.x && a.y === A.y) return true;
    b = points[(i + 1) % points.length];
    if (Vec.Dist(A, a) + Vec.Dist(A, b) === Vec.Dist(a, b)) return true;
    if (a.y <= A.y) {
      if (b.y > A.y && cross(a, b, A) > 0) {
        windingNumber += 1;
      }
    } else if (b.y <= A.y && cross(a, b, A) < 0) {
      windingNumber -= 1;
    }
  }
  return windingNumber !== 0;
}
function toDomPrecision(v) {
  return Math.round(v * 1e4) / 1e4;
}
function toFixed(v) {
  return Math.round(v * 100) / 100;
}
var isSafeFloat = (n) => {
  return Math.abs(n) < Number.MAX_SAFE_INTEGER;
};
function angleDistance(fromAngle, toAngle, direction) {
  const dist = direction < 0 ? clockwiseAngleDist(fromAngle, toAngle) : counterClockwiseAngleDist(fromAngle, toAngle);
  return dist;
}
function getPointInArcT(mAB, A, B, P) {
  let mAP;
  if (Math.abs(mAB) > PI) {
    mAP = shortAngleDist(A, P);
    const mPB = shortAngleDist(P, B);
    if (Math.abs(mAP) < Math.abs(mPB)) {
      return mAP / mAB;
    } else {
      return (mAB - mPB) / mAB;
    }
  } else {
    mAP = shortAngleDist(A, P);
    const t2 = mAP / mAB;
    if (Math.sign(mAP) !== Math.sign(mAB)) {
      return Math.abs(t2) > 0.5 ? 1 : 0;
    }
    return t2;
  }
}
function getArcMeasure(A, B, sweepFlag, largeArcFlag) {
  const m = 2 * ((B - A) % PI2) % PI2 - (B - A) % PI2;
  if (!largeArcFlag) return m;
  return (PI2 - Math.abs(m)) * (sweepFlag ? 1 : -1);
}
function centerOfCircleFromThreePoints(a, b, c) {
  const u = -2 * (a.x * (b.y - c.y) - a.y * (b.x - c.x) + b.x * c.y - c.x * b.y);
  const x = ((a.x * a.x + a.y * a.y) * (c.y - b.y) + (b.x * b.x + b.y * b.y) * (a.y - c.y) + (c.x * c.x + c.y * c.y) * (b.y - a.y)) / u;
  const y = ((a.x * a.x + a.y * a.y) * (b.x - c.x) + (b.x * b.x + b.y * b.y) * (c.x - a.x) + (c.x * c.x + c.y * c.y) * (a.x - b.x)) / u;
  if (!Number.isFinite(x) || !Number.isFinite(y)) {
    return null;
  }
  return new Vec(x, y);
}
function getPointsOnArc(startPoint, endPoint, center, radius, numPoints) {
  if (center === null) {
    return [Vec.From(startPoint), Vec.From(endPoint)];
  }
  const results = [];
  const startAngle = Vec.Angle(center, startPoint);
  const endAngle = Vec.Angle(center, endPoint);
  const l = clockwiseAngleDist(startAngle, endAngle);
  for (let i = 0; i < numPoints; i++) {
    const t2 = i / (numPoints - 1);
    const angle = startAngle + l * t2;
    const point = getPointOnCircle(center, radius, angle);
    results.push(point);
  }
  return results;
}

// ../node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultBrush.mjs
var DefaultBrush = ({ brush, color, opacity, className }) => {
  const rSvg = (0, import_react9.useRef)(null);
  useTransform(rSvg, brush.x, brush.y);
  const w = toDomPrecision(Math.max(1, brush.w));
  const h2 = toDomPrecision(Math.max(1, brush.h));
  return (0, import_jsx_runtime2.jsx)("svg", { className: "tl-overlays__item", ref: rSvg, "aria-hidden": "true", children: color ? (0, import_jsx_runtime2.jsxs)("g", { className: "tl-brush", opacity, children: [
    (0, import_jsx_runtime2.jsx)("rect", { width: w, height: h2, fill: color, opacity: 0.75 }),
    (0, import_jsx_runtime2.jsx)("rect", { width: w, height: h2, fill: "none", stroke: color, opacity: 0.1 })
  ] }) : (0, import_jsx_runtime2.jsx)("rect", { className: `tl-brush tl-brush__default ${className}`, width: w, height: h2 }) });
};

// ../node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultCanvas.mjs
var import_jsx_runtime36 = __toESM(require_jsx_runtime(), 1);
var import_classnames13 = __toESM(require_classnames(), 1);
var import_react45 = __toESM(require_react(), 1);

// ../node_modules/@tldraw/editor/dist-esm/lib/globals/environment.mjs
var tlenv = {
  isSafari: false,
  isIos: false,
  isChromeForIos: false,
  isFirefox: false,
  isAndroid: false,
  isWebview: false,
  isDarwin: false,
  hasCanvasSupport: false
};
var isForcedFinePointer = false;
if (typeof window !== "undefined") {
  if ("navigator" in window) {
    tlenv.isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    tlenv.isIos = !!navigator.userAgent.match(/iPad/i) || !!navigator.userAgent.match(/iPhone/i);
    tlenv.isChromeForIos = /crios.*safari/i.test(navigator.userAgent);
    tlenv.isFirefox = /firefox/i.test(navigator.userAgent);
    tlenv.isAndroid = /android/i.test(navigator.userAgent);
    tlenv.isDarwin = window.navigator.userAgent.toLowerCase().indexOf("mac") > -1;
  }
  tlenv.hasCanvasSupport = "Promise" in window && "HTMLCanvasElement" in window;
  isForcedFinePointer = tlenv.isFirefox && !tlenv.isAndroid && !tlenv.isIos;
}
var tlenvReactive = atom("tlenvReactive", {
  // Whether the user's device has a coarse pointer. This is dynamic on many systems, especially
  // on touch-screen laptops, which will become "coarse" if the user touches the screen.
  // See https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/At-rules/@media/pointer#coarse
  isCoarsePointer: false
});
if (typeof window !== "undefined" && !isForcedFinePointer) {
  const mql = window.matchMedia && window.matchMedia("(any-pointer: coarse)");
  const isCurrentCoarsePointer = () => tlenvReactive.__unsafe__getWithoutCapture().isCoarsePointer;
  if (mql) {
    const updateIsCoarsePointer = () => {
      const isCoarsePointer = mql.matches;
      if (isCoarsePointer !== isCurrentCoarsePointer()) {
        tlenvReactive.update((prev) => ({ ...prev, isCoarsePointer }));
      }
    };
    updateIsCoarsePointer();
    mql.addEventListener("change", updateIsCoarsePointer);
  }
  window.addEventListener(
    "pointerdown",
    (e) => {
      const isCoarseEvent = e.pointerType !== "mouse";
      if (isCoarseEvent !== isCurrentCoarsePointer()) {
        tlenvReactive.update((prev) => ({ ...prev, isCoarsePointer: isCoarseEvent }));
      }
    },
    { capture: true }
  );
}

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/useCanvasEvents.mjs
var import_react12 = __toESM(require_react(), 1);

// ../node_modules/@tldraw/editor/dist-esm/lib/constants.mjs
var DEFAULT_CAMERA_OPTIONS = {
  isLocked: false,
  wheelBehavior: "pan",
  panSpeed: 1,
  zoomSpeed: 1,
  zoomSteps: [0.05, 0.1, 0.25, 0.5, 1, 2, 4, 8]
};
var DEFAULT_ANIMATION_OPTIONS = {
  duration: 0,
  easing: EASINGS.easeInOutCubic
};
var INTERNAL_POINTER_IDS = {
  CAMERA_MOVE: -10
};
var SIDES = ["top", "right", "bottom", "left"];
var LEFT_MOUSE_BUTTON = 0;
var RIGHT_MOUSE_BUTTON = 2;
var MIDDLE_MOUSE_BUTTON = 1;
var STYLUS_ERASER_BUTTON = 5;

// ../node_modules/@tldraw/editor/dist-esm/lib/utils/debug-flags.mjs
var featureFlags = {};
var pointerCaptureTrackingObject = createDebugValue(
  "pointerCaptureTrackingObject",
  // ideally we wouldn't store this mutable value in an atom but it's not
  // a big deal for debug values
  {
    defaults: { all: /* @__PURE__ */ new Map() },
    shouldStoreForSession: false
  }
);
var debugFlags = {
  // --- DEBUG VALUES ---
  logPreventDefaults: createDebugValue("logPreventDefaults", {
    defaults: { all: false }
  }),
  logPointerCaptures: createDebugValue("logPointerCaptures", {
    defaults: { all: false }
  }),
  logElementRemoves: createDebugValue("logElementRemoves", {
    defaults: { all: false }
  }),
  debugSvg: createDebugValue("debugSvg", {
    defaults: { all: false }
  }),
  showFps: createDebugValue("showFps", {
    defaults: { all: false }
  }),
  measurePerformance: createDebugValue("measurePerformance", { defaults: { all: false } }),
  throwToBlob: createDebugValue("throwToBlob", {
    defaults: { all: false }
  }),
  reconnectOnPing: createDebugValue("reconnectOnPing", {
    defaults: { all: false }
  }),
  debugCursors: createDebugValue("debugCursors", {
    defaults: { all: false }
  }),
  forceSrgb: createDebugValue("forceSrgbColors", { defaults: { all: false } }),
  debugGeometry: createDebugValue("debugGeometry", { defaults: { all: false } }),
  hideShapes: createDebugValue("hideShapes", { defaults: { all: false } }),
  editOnType: createDebugValue("editOnType", { defaults: { all: false } }),
  a11y: createDebugValue("a11y", { defaults: { all: false } }),
  debugElbowArrows: createDebugValue("debugElbowArrows", { defaults: { all: false } })
};
if (typeof Element !== "undefined") {
  const nativeElementRemoveChild = Element.prototype.removeChild;
  react("element removal logging", () => {
    if (debugFlags.logElementRemoves.get()) {
      Element.prototype.removeChild = function(child) {
        console.warn("[tldraw] removing child:", child);
        return nativeElementRemoveChild.call(this, child);
      };
    } else {
      Element.prototype.removeChild = nativeElementRemoveChild;
    }
  });
}
function createDebugValue(name, {
  defaults: defaults2,
  shouldStoreForSession = true
}) {
  return createDebugValueBase({
    name,
    defaults: defaults2,
    shouldStoreForSession
  });
}
function createDebugValueBase(def) {
  const defaultValue = getDefaultValue(def);
  const storedValue = def.shouldStoreForSession ? getStoredInitialValue(def.name) : null;
  const valueAtom = atom(`debug:${def.name}`, storedValue ?? defaultValue);
  if (typeof window !== "undefined") {
    if (def.shouldStoreForSession) {
      react(`debug:${def.name}`, () => {
        const currentValue = valueAtom.get();
        if (currentValue === defaultValue) {
          deleteFromSessionStorage(`tldraw_debug:${def.name}`);
        } else {
          setInSessionStorage(`tldraw_debug:${def.name}`, JSON.stringify(currentValue));
        }
      });
    }
    Object.defineProperty(window, `tldraw${def.name.replace(/^[a-z]/, (l) => l.toUpperCase())}`, {
      get() {
        return valueAtom.get();
      },
      set(newValue) {
        valueAtom.set(newValue);
      },
      configurable: true
    });
  }
  return Object.assign(valueAtom, def, {
    reset: () => valueAtom.set(defaultValue)
  });
}
function getStoredInitialValue(name) {
  try {
    return JSON.parse(getFromSessionStorage(`tldraw_debug:${name}`) ?? "null");
  } catch {
    return null;
  }
}
function readEnv(fn) {
  try {
    return fn();
  } catch {
    return null;
  }
}
function getDefaultValue(def) {
  const env2 = readEnv(() => process.env.TLDRAW_ENV) ?? readEnv(() => process.env.VERCEL_PUBLIC_TLDRAW_ENV) ?? readEnv(() => process.env.NEXT_PUBLIC_TLDRAW_ENV) ?? // default to production because if we don't have one of these, this is probably a library use
  "production";
  switch (env2) {
    case "production":
      return def.defaults.production ?? def.defaults.all;
    case "preview":
    case "staging":
      return def.defaults.staging ?? def.defaults.all;
    default:
      return def.defaults.development ?? def.defaults.all;
  }
}

// ../node_modules/@tldraw/editor/dist-esm/lib/utils/dom.mjs
function loopToHtmlElement(elm) {
  if (elm.nodeType === Node.ELEMENT_NODE) return elm;
  if (elm.parentElement) return loopToHtmlElement(elm.parentElement);
  else throw Error("Could not find a parent element of an HTML type!");
}
function preventDefault(event) {
  event.preventDefault();
  if (debugFlags.logPreventDefaults.get()) {
    console.warn("preventDefault called on event:", event);
  }
}
function setPointerCapture(element, event) {
  element.setPointerCapture(event.pointerId);
  if (debugFlags.logPointerCaptures.get()) {
    const trackingObj = pointerCaptureTrackingObject.get();
    trackingObj.set(element, (trackingObj.get(element) ?? 0) + 1);
    console.warn("setPointerCapture called on element:", element, event);
  }
}
function releasePointerCapture(element, event) {
  if (!element.hasPointerCapture(event.pointerId)) {
    return;
  }
  element.releasePointerCapture(event.pointerId);
  if (debugFlags.logPointerCaptures.get()) {
    const trackingObj = pointerCaptureTrackingObject.get();
    if (trackingObj.get(element) === 1) {
      trackingObj.delete(element);
    } else if (trackingObj.has(element)) {
      trackingObj.set(element, trackingObj.get(element) - 1);
    } else {
      console.warn("Release without capture");
    }
    console.warn("releasePointerCapture called on element:", element, event);
  }
}
var stopEventPropagation = (e) => e.stopPropagation();
var setStyleProperty = (elm, property, value) => {
  if (!elm) return;
  elm.style.setProperty(property, value);
};
function activeElementShouldCaptureKeys(allowButtons = false) {
  const { activeElement } = document;
  const elements = allowButtons ? ["input", "textarea"] : ["input", "select", "button", "textarea"];
  return !!(activeElement && (activeElement.isContentEditable || elements.indexOf(activeElement.tagName.toLowerCase()) > -1 || activeElement.classList.contains("tlui-slider__thumb")));
}

// ../node_modules/@tldraw/editor/dist-esm/lib/utils/keyboard.mjs
var isAccelKey = (e) => {
  return tlenv.isDarwin ? e.metaKey : e.ctrlKey || e.metaKey;
};

// ../node_modules/@tldraw/editor/dist-esm/lib/utils/getPointerInfo.mjs
function getPointerInfo(editor, e) {
  editor.markEventAsHandled(e);
  return {
    point: {
      x: e.clientX,
      y: e.clientY,
      z: e.pressure
    },
    shiftKey: e.shiftKey,
    altKey: e.altKey,
    ctrlKey: e.metaKey || e.ctrlKey,
    metaKey: e.metaKey,
    accelKey: isAccelKey(e),
    pointerId: e.pointerId,
    button: e.button,
    isPen: e.pointerType === "pen"
  };
}

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/useEditor.mjs
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react11 = __toESM(require_react(), 1);

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/useSafeId.mjs
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react10 = __toESM(require_react(), 1);
function suffixSafeId(id, suffix) {
  return sanitizeId(`${id}_${suffix}`);
}
function useUniqueSafeId(suffix) {
  return sanitizeId(`${(0, import_react10.useId)()}${suffix ?? ""}`);
}
function useSharedSafeId(id) {
  const idScope = assertExists((0, import_react10.useContext)(IdContext));
  return sanitizeId(`${idScope}_${id}`);
}
function sanitizeId(id) {
  return id.replace(/:/g, "_");
}
var IdContext = (0, import_react10.createContext)(null);
function IdProvider({ children }) {
  const id = useUniqueSafeId();
  return (0, import_jsx_runtime3.jsx)(IdContext.Provider, { value: id, children });
}

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/useEditor.mjs
var EditorContext = (0, import_react11.createContext)(null);
function useEditor() {
  const editor = import_react11.default.useContext(EditorContext);
  if (!editor) {
    throw new Error(
      "useEditor must be used inside of the <Tldraw /> or <TldrawEditor /> components"
    );
  }
  return editor;
}
function useMaybeEditor() {
  return import_react11.default.useContext(EditorContext);
}
function EditorProvider({ editor, children }) {
  return (0, import_jsx_runtime4.jsx)(EditorContext.Provider, { value: editor, children: (0, import_jsx_runtime4.jsx)(IdProvider, { children }) });
}

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/useCanvasEvents.mjs
function useCanvasEvents() {
  const editor = useEditor();
  const ownerDocument = editor.getContainer().ownerDocument;
  const currentTool = useValue("current tool", () => editor.getCurrentTool(), [editor]);
  const events = (0, import_react12.useMemo)(
    function canvasEvents() {
      function onPointerDown(e) {
        if (editor.wasEventAlreadyHandled(e)) return;
        if (e.button === RIGHT_MOUSE_BUTTON) {
          editor.dispatch({
            type: "pointer",
            target: "canvas",
            name: "right_click",
            ...getPointerInfo(editor, e)
          });
          return;
        }
        if (e.button !== 0 && e.button !== 1 && e.button !== 5) return;
        setPointerCapture(e.currentTarget, e);
        editor.dispatch({
          type: "pointer",
          target: "canvas",
          name: "pointer_down",
          ...getPointerInfo(editor, e)
        });
      }
      function onPointerUp(e) {
        if (editor.wasEventAlreadyHandled(e)) return;
        if (e.button !== 0 && e.button !== 1 && e.button !== 2 && e.button !== 5) return;
        releasePointerCapture(e.currentTarget, e);
        editor.dispatch({
          type: "pointer",
          target: "canvas",
          name: "pointer_up",
          ...getPointerInfo(editor, e)
        });
      }
      function onPointerEnter(e) {
        if (editor.wasEventAlreadyHandled(e)) return;
        if (editor.getInstanceState().isPenMode && e.pointerType !== "pen") return;
        const canHover = e.pointerType === "mouse" || e.pointerType === "pen";
        editor.updateInstanceState({ isHoveringCanvas: canHover ? true : null });
      }
      function onPointerLeave(e) {
        if (editor.wasEventAlreadyHandled(e)) return;
        if (editor.getInstanceState().isPenMode && e.pointerType !== "pen") return;
        const canHover = e.pointerType === "mouse" || e.pointerType === "pen";
        editor.updateInstanceState({ isHoveringCanvas: canHover ? false : null });
      }
      function onTouchStart(e) {
        if (editor.wasEventAlreadyHandled(e)) return;
        editor.markEventAsHandled(e);
        preventDefault(e);
      }
      function onTouchEnd(e) {
        var _a6;
        if (editor.wasEventAlreadyHandled(e)) return;
        editor.markEventAsHandled(e);
        if (!(e.target instanceof HTMLElement)) return;
        const editingShapeId = (_a6 = editor.getEditingShape()) == null ? void 0 : _a6.id;
        if (
          // if the target is not inside the editing shape
          !(editingShapeId && e.target.closest(`[data-shape-id="${editingShapeId}"]`)) && // and the target is not an clickable element
          e.target.tagName !== "A" && // or a TextArea.tsx ?
          e.target.tagName !== "TEXTAREA" && !e.target.isContentEditable
        ) {
          preventDefault(e);
        }
      }
      function onDragOver(e) {
        if (editor.wasEventAlreadyHandled(e)) return;
        preventDefault(e);
      }
      async function onDrop(e) {
        var _a6, _b3;
        if (editor.wasEventAlreadyHandled(e)) return;
        preventDefault(e);
        e.stopPropagation();
        if ((_b3 = (_a6 = e.dataTransfer) == null ? void 0 : _a6.files) == null ? void 0 : _b3.length) {
          const files = Array.from(e.dataTransfer.files);
          await editor.putExternalContent({
            type: "files",
            files,
            point: editor.screenToPage({ x: e.clientX, y: e.clientY })
          });
          return;
        }
        const url = e.dataTransfer.getData("url");
        if (url) {
          await editor.putExternalContent({
            type: "url",
            url,
            point: editor.screenToPage({ x: e.clientX, y: e.clientY })
          });
          return;
        }
      }
      function onClick(e) {
        if (editor.wasEventAlreadyHandled(e)) return;
        e.stopPropagation();
      }
      return {
        onPointerDown,
        onPointerUp,
        onPointerEnter,
        onPointerLeave,
        onDragOver,
        onDrop,
        onTouchStart,
        onTouchEnd,
        onClick
      };
    },
    [editor]
  );
  (0, import_react12.useEffect)(() => {
    let lastX, lastY;
    function onPointerMove(e) {
      if (editor.wasEventAlreadyHandled(e)) return;
      editor.markEventAsHandled(e);
      if (e.clientX === lastX && e.clientY === lastY) return;
      lastX = e.clientX;
      lastY = e.clientY;
      const events2 = !tlenv.isIos && currentTool.useCoalescedEvents && e.getCoalescedEvents ? e.getCoalescedEvents() : [e];
      for (const singleEvent of events2) {
        editor.dispatch({
          type: "pointer",
          target: "canvas",
          name: "pointer_move",
          ...getPointerInfo(editor, singleEvent)
        });
      }
    }
    ownerDocument.body.addEventListener("pointermove", onPointerMove);
    return () => {
      ownerDocument.body.removeEventListener("pointermove", onPointerMove);
    };
  }, [editor, currentTool, ownerDocument]);
  return events;
}

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/useCoarsePointer.mjs
function useCoarsePointer() {
  const editor = useEditor();
  useReactor(
    "coarse pointer change",
    () => {
      const isCoarsePointer = tlenvReactive.get().isCoarsePointer;
      const isInstanceStateCoarsePointer = unsafe__withoutCapture(
        () => editor.getInstanceState().isCoarsePointer
      );
      if (isCoarsePointer === isInstanceStateCoarsePointer) return;
      editor.updateInstanceState({ isCoarsePointer });
    },
    [editor]
  );
}

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/useContainer.mjs
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react13 = __toESM(require_react(), 1);
var ContainerContext = (0, import_react13.createContext)(null);
function ContainerProvider({ container, children }) {
  return (0, import_jsx_runtime5.jsx)(ContainerContext.Provider, { value: container, children });
}
function useContainer() {
  return assertExists((0, import_react13.useContext)(ContainerContext), "useContainer used outside of <Tldraw />");
}
function useContainerIfExists() {
  return (0, import_react13.useContext)(ContainerContext);
}

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/useDocumentEvents.mjs
var import_react14 = __toESM(require_react(), 1);
function useDocumentEvents() {
  const editor = useEditor();
  const container = useContainer();
  const isEditing = useValue("isEditing", () => editor.getEditingShapeId(), [editor]);
  const isAppFocused = useValue("isFocused", () => editor.getIsFocused(), [editor]);
  (0, import_react14.useEffect)(() => {
    if (!container) return;
    function onDrop(e) {
      if (e.isSpecialRedispatchedEvent) return;
      preventDefault(e);
      e.stopPropagation();
      const cvs = container.querySelector(".tl-canvas");
      if (!cvs) return;
      const newEvent = new DragEvent(e.type, e);
      newEvent.isSpecialRedispatchedEvent = true;
      cvs.dispatchEvent(newEvent);
    }
    container.addEventListener("dragover", onDrop);
    container.addEventListener("drop", onDrop);
    return () => {
      container.removeEventListener("dragover", onDrop);
      container.removeEventListener("drop", onDrop);
    };
  }, [container]);
  (0, import_react14.useEffect)(() => {
    if (typeof window === "undefined" || !("matchMedia" in window)) return;
    let remove2 = null;
    const updatePixelRatio = () => {
      if (remove2 != null) {
        remove2();
      }
      const mqString = `(resolution: ${window.devicePixelRatio}dppx)`;
      const media = matchMedia(mqString);
      const safariCb = (ev) => {
        if (ev.type === "change") {
          updatePixelRatio();
        }
      };
      if (media.addEventListener) {
        media.addEventListener("change", updatePixelRatio);
      } else if (media.addListener) {
        media.addListener(safariCb);
      }
      remove2 = () => {
        if (media.removeEventListener) {
          media.removeEventListener("change", updatePixelRatio);
        } else if (media.removeListener) {
          media.removeListener(safariCb);
        }
      };
      editor.updateInstanceState({ devicePixelRatio: window.devicePixelRatio });
    };
    updatePixelRatio();
    return () => {
      remove2 == null ? void 0 : remove2();
    };
  }, [editor]);
  (0, import_react14.useEffect)(() => {
    if (!isAppFocused) return;
    const handleKeyDown2 = (e) => {
      if (e.altKey && // todo: When should we allow the alt key to be used? Perhaps states should declare which keys matter to them?
      (editor.isIn("zoom") || !editor.getPath().endsWith(".idle")) && !areShortcutsDisabled(editor)) {
        preventDefault(e);
      }
      if (editor.wasEventAlreadyHandled(e)) return;
      editor.markEventAsHandled(e);
      const hasSelectedShapes = !!editor.getSelectedShapeIds().length;
      switch (e.key) {
        case "=":
        case "-":
        case "0": {
          if (e.metaKey || e.ctrlKey) {
            preventDefault(e);
            return;
          }
          break;
        }
        case "Tab": {
          if (areShortcutsDisabled(editor)) {
            return;
          }
          if (hasSelectedShapes && !isEditing) {
            preventDefault(e);
          }
          break;
        }
        case "ArrowLeft":
        case "ArrowRight":
        case "ArrowUp":
        case "ArrowDown": {
          if (areShortcutsDisabled(editor)) {
            return;
          }
          if (hasSelectedShapes && (e.metaKey || e.ctrlKey)) {
            preventDefault(e);
          }
          break;
        }
        case ",": {
          return;
        }
        case "Escape": {
          if (editor.getEditingShape() || editor.getSelectedShapeIds().length > 0) {
            preventDefault(e);
          }
          if (editor.menus.getOpenMenus().length > 0) return;
          if (editor.inputs.keys.has("Escape")) {
          } else {
            editor.inputs.keys.add("Escape");
            editor.cancel();
            container.focus();
          }
          return;
        }
        default: {
          if (areShortcutsDisabled(editor)) {
            return;
          }
        }
      }
      const info = {
        type: "keyboard",
        name: e.repeat ? "key_repeat" : "key_down",
        key: e.key,
        code: e.code,
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        ctrlKey: e.metaKey || e.ctrlKey,
        metaKey: e.metaKey,
        accelKey: isAccelKey(e)
      };
      editor.dispatch(info);
    };
    const handleKeyUp = (e) => {
      if (editor.wasEventAlreadyHandled(e)) return;
      editor.markEventAsHandled(e);
      if (areShortcutsDisabled(editor)) {
        return;
      }
      if (e.key === ",") {
        return;
      }
      const info = {
        type: "keyboard",
        name: "key_up",
        key: e.key,
        code: e.code,
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        ctrlKey: e.metaKey || e.ctrlKey,
        metaKey: e.metaKey,
        accelKey: isAccelKey(e)
      };
      editor.dispatch(info);
    };
    function handleTouchStart(e) {
      var _a6, _b3;
      if (container.contains(e.target)) {
        const touchXPosition = e.touches[0].pageX;
        const touchXRadius = e.touches[0].radiusX || 0;
        if (touchXPosition - touchXRadius < 10 || touchXPosition + touchXRadius > editor.getViewportScreenBounds().width - 10) {
          if (((_a6 = e.target) == null ? void 0 : _a6.tagName) === "BUTTON") {
            ;
            (_b3 = e.target) == null ? void 0 : _b3.click();
          }
          preventDefault(e);
        }
      }
    }
    const handleWheel = (e) => {
      if (container.contains(e.target) && (e.ctrlKey || e.metaKey)) {
        preventDefault(e);
      }
    };
    container.addEventListener("touchstart", handleTouchStart, { passive: false });
    container.addEventListener("wheel", handleWheel, { passive: false });
    document.addEventListener("gesturestart", preventDefault);
    document.addEventListener("gesturechange", preventDefault);
    document.addEventListener("gestureend", preventDefault);
    container.addEventListener("keydown", handleKeyDown2);
    container.addEventListener("keyup", handleKeyUp);
    return () => {
      container.removeEventListener("touchstart", handleTouchStart);
      container.removeEventListener("wheel", handleWheel);
      document.removeEventListener("gesturestart", preventDefault);
      document.removeEventListener("gesturechange", preventDefault);
      document.removeEventListener("gestureend", preventDefault);
      container.removeEventListener("keydown", handleKeyDown2);
      container.removeEventListener("keyup", handleKeyUp);
    };
  }, [editor, container, isAppFocused, isEditing]);
}
function areShortcutsDisabled(editor) {
  return editor.menus.hasOpenMenus() || activeElementShouldCaptureKeys();
}

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/useEditorComponents.mjs
var import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
var import_react38 = __toESM(require_react(), 1);

// ../node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultCollaboratorHint.mjs
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_classnames = __toESM(require_classnames(), 1);
var import_react15 = __toESM(require_react(), 1);
function DefaultCollaboratorHint({
  className,
  zoom,
  point,
  color,
  viewport,
  opacity = 1
}) {
  const rSvg = (0, import_react15.useRef)(null);
  useTransform(
    rSvg,
    clamp(point.x, viewport.minX + 5 / zoom, viewport.maxX - 5 / zoom),
    clamp(point.y, viewport.minY + 5 / zoom, viewport.maxY - 5 / zoom),
    1 / zoom,
    Vec.Angle(viewport.center, point)
  );
  const cursorHintId = useSharedSafeId("cursor_hint");
  return (0, import_jsx_runtime6.jsxs)("svg", { ref: rSvg, className: (0, import_classnames.default)("tl-overlays__item", className), "aria-hidden": "true", children: [
    (0, import_jsx_runtime6.jsx)(
      "use",
      {
        href: `#${cursorHintId}`,
        color,
        strokeWidth: 3,
        stroke: "var(--tl-color-background)"
      }
    ),
    (0, import_jsx_runtime6.jsx)("use", { href: `#${cursorHintId}`, color, opacity })
  ] });
}

// ../node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultCursor.mjs
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_classnames2 = __toESM(require_classnames(), 1);
var import_react16 = __toESM(require_react(), 1);
var DefaultCursor = (0, import_react16.memo)(function DefaultCursor2({
  className,
  zoom,
  point,
  color,
  name,
  chatMessage
}) {
  const rCursor = (0, import_react16.useRef)(null);
  useTransform(rCursor, point == null ? void 0 : point.x, point == null ? void 0 : point.y, 1 / zoom);
  const cursorId = useSharedSafeId("cursor");
  if (!point) return null;
  return (0, import_jsx_runtime7.jsxs)("div", { ref: rCursor, className: (0, import_classnames2.default)("tl-overlays__item", className), children: [
    (0, import_jsx_runtime7.jsx)("svg", { className: "tl-cursor", "aria-hidden": "true", children: (0, import_jsx_runtime7.jsx)("use", { href: `#${cursorId}`, color }) }),
    chatMessage ? (0, import_jsx_runtime7.jsxs)(import_jsx_runtime7.Fragment, { children: [
      name && (0, import_jsx_runtime7.jsx)("div", { className: "tl-nametag-title", style: { color }, children: name }),
      (0, import_jsx_runtime7.jsx)("div", { className: "tl-nametag-chat", style: { backgroundColor: color }, children: chatMessage })
    ] }) : name && (0, import_jsx_runtime7.jsx)("div", { className: "tl-nametag", style: { backgroundColor: color }, children: name })
  ] });
});

// ../node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultErrorFallback.mjs
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_classnames3 = __toESM(require_classnames(), 1);
var import_react17 = __toESM(require_react(), 1);

// ../node_modules/@tldraw/editor/dist-esm/lib/utils/runtime.mjs
var runtime = {
  openWindow(url, target, allowReferrer = false) {
    return window.open(url, target, allowReferrer ? "noopener" : "noopener noreferrer");
  },
  refreshPage() {
    window.location.reload();
  },
  async hardReset() {
    var _a6;
    return await ((_a6 = window.__tldraw__hardReset) == null ? void 0 : _a6.call(window));
  }
};
function setRuntimeOverrides(input) {
  Object.assign(runtime, input);
}

// ../node_modules/@tldraw/editor/dist-esm/lib/utils/hardResetEditor.mjs
function hardResetEditor() {
  runtime.hardReset();
}

// ../node_modules/@tldraw/editor/dist-esm/lib/utils/refreshPage.mjs
function refreshPage() {
  runtime.refreshPage();
}

// ../node_modules/@tldraw/editor/dist-esm/lib/components/ErrorBoundary.mjs
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var React3 = __toESM(require_react(), 1);
var initialState = { error: null };
var ErrorBoundary = class extends React3.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", initialState);
  }
  static getDerivedStateFromError(error) {
    return { error };
  }
  componentDidCatch(error) {
    var _a6, _b3;
    (_b3 = (_a6 = this.props).onError) == null ? void 0 : _b3.call(_a6, error);
  }
  render() {
    const { error } = this.state;
    if (error !== null) {
      const { fallback: Fallback } = this.props;
      return (0, import_jsx_runtime8.jsx)(Fallback, { error });
    }
    return this.props.children;
  }
};
function OptionalErrorBoundary({
  children,
  fallback,
  ...props
}) {
  if (fallback === null) {
    return children;
  }
  return (0, import_jsx_runtime8.jsx)(ErrorBoundary, { fallback, ...props, children });
}

// ../node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultErrorFallback.mjs
var BASE_ERROR_URL = "https://github.com/tldraw/tldraw/issues/new";
var DefaultErrorFallback = ({ error, editor }) => {
  const containerRef = (0, import_react17.useRef)(null);
  const [shouldShowError, setShouldShowError] = (0, import_react17.useState)(true);
  const [didCopy, setDidCopy] = (0, import_react17.useState)(false);
  const [shouldShowResetConfirmation, setShouldShowResetConfirmation] = (0, import_react17.useState)(false);
  let Canvas = null;
  try {
    const components = useEditorComponents();
    Canvas = components.Canvas ?? null;
  } catch {
  }
  const errorMessage = error instanceof Error ? error.message : String(error);
  const errorStack = error instanceof Error ? error.stack : null;
  const isDarkModeFromApp = useValue(
    "isDarkMode",
    () => {
      try {
        if (editor) {
          return editor.user.getIsDarkMode();
        }
      } catch {
      }
      return null;
    },
    [editor]
  );
  const [isDarkMode, setIsDarkMode] = (0, import_react17.useState)(null);
  (0, import_react17.useLayoutEffect)(() => {
    var _a6;
    if (isDarkModeFromApp !== null) {
      setIsDarkMode(isDarkModeFromApp);
    }
    let parent = (_a6 = containerRef.current) == null ? void 0 : _a6.parentElement;
    let foundParentThemeClass = false;
    while (parent) {
      if (parent.classList.contains("tl-theme__dark") || parent.classList.contains("tl-theme__light")) {
        foundParentThemeClass = true;
        break;
      }
      parent = parent.parentElement;
    }
    if (foundParentThemeClass) {
      setIsDarkMode(null);
      return;
    }
    if (typeof window !== "undefined" && window.matchMedia) {
      setIsDarkMode(window.matchMedia("(prefers-color-scheme: dark)").matches);
    }
  }, [isDarkModeFromApp]);
  (0, import_react17.useEffect)(() => {
    if (didCopy) {
      const timeout = editor == null ? void 0 : editor.timers.setTimeout(() => {
        setDidCopy(false);
      }, 2e3);
      return () => clearTimeout(timeout);
    }
  }, [didCopy, editor]);
  const copyError = () => {
    const textarea = document.createElement("textarea");
    textarea.value = errorStack ?? errorMessage;
    document.body.appendChild(textarea);
    textarea.select();
    document.execCommand("copy");
    textarea.remove();
    setDidCopy(true);
  };
  const refresh = () => {
    refreshPage();
  };
  const resetLocalState = async () => {
    hardResetEditor();
  };
  const url = new URL(BASE_ERROR_URL);
  url.searchParams.set("title", errorMessage);
  url.searchParams.set("labels", `bug`);
  url.searchParams.set(
    "body",
    `Hey, I ran into an error while using tldraw:

\`\`\`js
${errorStack ?? errorMessage}
\`\`\`

My browser: ${navigator.userAgent}`
  );
  return (0, import_jsx_runtime9.jsxs)(
    "div",
    {
      ref: containerRef,
      className: (0, import_classnames3.default)(
        "tl-container tl-error-boundary",
        // error-boundary is sometimes used outside of the theme
        // container, so we need to provide it with a theme for our
        // styles to work correctly
        isDarkMode === null ? "" : isDarkMode ? "tl-theme__dark" : "tl-theme__light"
      ),
      children: [
        (0, import_jsx_runtime9.jsx)("div", { className: "tl-error-boundary__overlay" }),
        editor && // opportunistically attempt to render the canvas to reassure
        // the user that their document is still there. there's a good
        // chance this won't work (ie the error that we're currently
        // notifying the user about originates in the canvas) so it's
        // not a big deal if it doesn't work - in that case we just have
        // a plain grey background.
        (0, import_jsx_runtime9.jsx)(ErrorBoundary, { onError: noop, fallback: () => null, children: (0, import_jsx_runtime9.jsx)(EditorProvider, { editor, children: (0, import_jsx_runtime9.jsx)("div", { className: "tl-overlay tl-error-boundary__canvas", children: Canvas ? (0, import_jsx_runtime9.jsx)(Canvas, {}) : null }) }) }),
        (0, import_jsx_runtime9.jsx)(
          "div",
          {
            className: (0, import_classnames3.default)("tl-modal", "tl-error-boundary__content", {
              "tl-error-boundary__content__expanded": shouldShowError && !shouldShowResetConfirmation
            }),
            children: shouldShowResetConfirmation ? (0, import_jsx_runtime9.jsxs)(import_jsx_runtime9.Fragment, { children: [
              (0, import_jsx_runtime9.jsx)("h2", { children: "Are you sure?" }),
              (0, import_jsx_runtime9.jsx)("p", { children: "Resetting your data will delete your drawing and cannot be undone." }),
              (0, import_jsx_runtime9.jsxs)("div", { className: "tl-error-boundary__content__actions", children: [
                (0, import_jsx_runtime9.jsx)("button", { className: "tlui-button", onClick: () => setShouldShowResetConfirmation(false), children: "Cancel" }),
                (0, import_jsx_runtime9.jsx)("button", { className: "tlui-button tl-error-boundary__reset", onClick: resetLocalState, children: "Reset data" })
              ] })
            ] }) : (0, import_jsx_runtime9.jsxs)(import_jsx_runtime9.Fragment, { children: [
              (0, import_jsx_runtime9.jsx)("h2", { children: "Something went wrong" }),
              (0, import_jsx_runtime9.jsx)("p", { children: "Please refresh your browser." }),
              (0, import_jsx_runtime9.jsx)("p", { children: "If the issue continues after refreshing, you may need to reset the tldraw data stored on your device." }),
              (0, import_jsx_runtime9.jsxs)("p", { children: [
                (0, import_jsx_runtime9.jsx)("strong", { children: "Note:" }),
                " Resetting will erase your current project and any unsaved work."
              ] }),
              (0, import_jsx_runtime9.jsxs)("p", { children: [
                "If you're developing with the SDK and need help, join us on",
                " ",
                (0, import_jsx_runtime9.jsx)("a", { href: "https://discord.tldraw.com/?utm_source=sdk&utm_medium=organic&utm_campaign=error-screen", children: "Discord" }),
                "."
              ] }),
              shouldShowError && (0, import_jsx_runtime9.jsxs)(import_jsx_runtime9.Fragment, { children: [
                "Message:",
                (0, import_jsx_runtime9.jsx)("h4", { children: (0, import_jsx_runtime9.jsx)("code", { children: errorMessage }) }),
                "Stack trace:",
                (0, import_jsx_runtime9.jsxs)("div", { className: "tl-error-boundary__content__error", children: [
                  (0, import_jsx_runtime9.jsx)("pre", { children: (0, import_jsx_runtime9.jsx)("code", { children: errorStack ?? errorMessage }) }),
                  (0, import_jsx_runtime9.jsx)("button", { className: "tlui-button", onClick: copyError, children: didCopy ? "Copied!" : "Copy" })
                ] })
              ] }),
              (0, import_jsx_runtime9.jsxs)("div", { className: "tl-error-boundary__content__actions", children: [
                (0, import_jsx_runtime9.jsx)("button", { className: "tlui-button", onClick: () => setShouldShowError(!shouldShowError), children: shouldShowError ? "Hide details" : "Show details" }),
                (0, import_jsx_runtime9.jsxs)("div", { className: "tl-error-boundary__content__actions__group", children: [
                  (0, import_jsx_runtime9.jsx)(
                    "button",
                    {
                      className: "tlui-button tl-error-boundary__reset",
                      onClick: () => setShouldShowResetConfirmation(true),
                      children: "Reset data"
                    }
                  ),
                  (0, import_jsx_runtime9.jsx)("button", { className: "tlui-button tl-error-boundary__refresh", onClick: refresh, children: "Refresh Page" })
                ] })
              ] })
            ] })
          }
        )
      ]
    }
  );
};

// ../node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultGrid.mjs
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
function DefaultGrid({ x, y, z, size: size4 }) {
  const id = useUniqueSafeId("grid");
  const editor = useEditor();
  const { gridSteps } = editor.options;
  return (0, import_jsx_runtime10.jsxs)("svg", { className: "tl-grid", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "aria-hidden": "true", children: [
    (0, import_jsx_runtime10.jsx)("defs", { children: gridSteps.map(({ min: min3, mid, step }, i) => {
      const s = step * size4 * z;
      const xo = 0.5 + x * z;
      const yo = 0.5 + y * z;
      const gxo = xo > 0 ? xo % s : s + xo % s;
      const gyo = yo > 0 ? yo % s : s + yo % s;
      const opacity = z < mid ? modulate(z, [min3, mid], [0, 1]) : 1;
      return (0, import_jsx_runtime10.jsx)(
        "pattern",
        {
          id: suffixSafeId(id, `${step}`),
          width: s,
          height: s,
          patternUnits: "userSpaceOnUse",
          children: (0, import_jsx_runtime10.jsx)("circle", { className: "tl-grid-dot", cx: gxo, cy: gyo, r: 1, opacity })
        },
        i
      );
    }) }),
    gridSteps.map(({ step }, i) => (0, import_jsx_runtime10.jsx)("rect", { width: "100%", height: "100%", fill: `url(#${id}_${step})` }, i))
  ] });
}

// ../node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultHandle.mjs
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var import_classnames4 = __toESM(require_classnames(), 1);
function DefaultHandle({ handle, isCoarse, className, zoom }) {
  const editor = useEditor();
  const br = (isCoarse ? editor.options.coarseHandleRadius : editor.options.handleRadius) / zoom;
  if (handle.type === "clone") {
    const fr2 = 3 / zoom;
    const path = `M0,${-fr2} A${fr2},${fr2} 0 0,1 0,${fr2}`;
    const index2 = SIDES.indexOf(handle.id);
    return (0, import_jsx_runtime11.jsxs)("g", { className: (0, import_classnames4.default)(`tl-handle tl-handle__${handle.type}`, className), children: [
      (0, import_jsx_runtime11.jsx)("circle", { className: "tl-handle__bg", r: br }),
      (0, import_jsx_runtime11.jsx)("path", { className: "tl-handle__fg", d: path, transform: `rotate(${-90 + 90 * index2})` })
    ] });
  }
  const fr = (handle.type === "create" && isCoarse ? 3 : 4) / Math.max(zoom, 0.25);
  return (0, import_jsx_runtime11.jsxs)("g", { className: (0, import_classnames4.default)(`tl-handle tl-handle__${handle.type}`, className), children: [
    (0, import_jsx_runtime11.jsx)("circle", { className: "tl-handle__bg", r: br }),
    (0, import_jsx_runtime11.jsx)("circle", { className: "tl-handle__fg", r: fr })
  ] });
}

// ../node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultHandles.mjs
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var DefaultHandles = ({ children }) => {
  return (0, import_jsx_runtime12.jsx)("svg", { className: "tl-user-handles tl-overlays__item", "aria-hidden": "true", children });
};

// ../node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultLoadingScreen.mjs
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);

// ../node_modules/@tldraw/editor/dist-esm/lib/TldrawEditor.mjs
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
var import_classnames6 = __toESM(require_classnames(), 1);
var import_react33 = __toESM(require_react(), 1);

// ../node_modules/@tldraw/editor/dist-esm/version.mjs
var version = "4.3.1";
var publishDates = {
  major: "2025-09-18T14:39:22.803Z",
  minor: "2026-01-21T11:56:39.106Z",
  patch: "2026-01-31T20:16:59.456Z"
};

// ../node_modules/@tldraw/editor/dist-esm/lib/config/createTLUser.mjs
var import_react19 = __toESM(require_react(), 1);

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/useIdentity.mjs
var import_react18 = __toESM(require_react(), 1);
function useIdentity(value, isEqual) {
  const ref = (0, import_react18.useRef)(value);
  if (isEqual(value, ref.current)) {
    return ref.current;
  }
  ref.current = value;
  return value;
}
var areNullableArraysShallowEqual = (a, b) => {
  a ?? (a = null);
  b ?? (b = null);
  if (a === b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  return areArraysShallowEqual(a, b);
};
function useShallowArrayIdentity(arr) {
  return useIdentity(arr, areNullableArraysShallowEqual);
}
var areNullableObjectsShallowEqual = (a, b) => {
  a ?? (a = null);
  b ?? (b = null);
  if (a === b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  return areObjectsShallowEqual(a, b);
};
function useShallowObjectIdentity(obj) {
  return useIdentity(obj, areNullableObjectsShallowEqual);
}

// ../node_modules/@tldraw/editor/dist-esm/lib/config/TLUserPreferences.mjs
var USER_DATA_KEY = "TLDRAW_USER_DATA_v3";
var userTypeValidator = validation_exports.object({
  id: validation_exports.string,
  name: validation_exports.string.nullable().optional(),
  color: validation_exports.string.nullable().optional(),
  // N.B. These are duplicated in TLdrawAppUser.
  locale: validation_exports.string.nullable().optional(),
  animationSpeed: validation_exports.number.nullable().optional(),
  areKeyboardShortcutsEnabled: validation_exports.boolean.nullable().optional(),
  edgeScrollSpeed: validation_exports.number.nullable().optional(),
  colorScheme: validation_exports.literalEnum("light", "dark", "system").optional(),
  isSnapMode: validation_exports.boolean.nullable().optional(),
  isWrapMode: validation_exports.boolean.nullable().optional(),
  isDynamicSizeMode: validation_exports.boolean.nullable().optional(),
  isPasteAtCursorMode: validation_exports.boolean.nullable().optional(),
  enhancedA11yMode: validation_exports.boolean.nullable().optional(),
  inputMode: validation_exports.literalEnum("trackpad", "mouse").nullable().optional()
});
var Versions14 = {
  AddAnimationSpeed: 1,
  AddIsSnapMode: 2,
  MakeFieldsNullable: 3,
  AddEdgeScrollSpeed: 4,
  AddExcalidrawSelectMode: 5,
  AddDynamicSizeMode: 6,
  AllowSystemColorScheme: 7,
  AddPasteAtCursor: 8,
  AddKeyboardShortcuts: 9,
  AddShowUiLabels: 10,
  AddPointerPeripheral: 11,
  RenameShowUiLabelsToEnhancedA11yMode: 12
};
var CURRENT_VERSION = Math.max(...Object.values(Versions14));
function migrateSnapshot(data) {
  if (data.version < Versions14.AddAnimationSpeed) {
    data.user.animationSpeed = 1;
  }
  if (data.version < Versions14.AddIsSnapMode) {
    data.user.isSnapMode = false;
  }
  if (data.version < Versions14.MakeFieldsNullable) {
  }
  if (data.version < Versions14.AddEdgeScrollSpeed) {
    data.user.edgeScrollSpeed = 1;
  }
  if (data.version < Versions14.AddExcalidrawSelectMode) {
    data.user.isWrapMode = false;
  }
  if (data.version < Versions14.AllowSystemColorScheme) {
    if (data.user.isDarkMode === true) {
      data.user.colorScheme = "dark";
    } else if (data.user.isDarkMode === false) {
      data.user.colorScheme = "light";
    }
    delete data.user.isDarkMode;
  }
  if (data.version < Versions14.AddDynamicSizeMode) {
    data.user.isDynamicSizeMode = false;
  }
  if (data.version < Versions14.AddPasteAtCursor) {
    data.user.isPasteAtCursorMode = false;
  }
  if (data.version < Versions14.AddKeyboardShortcuts) {
    data.user.areKeyboardShortcutsEnabled = true;
  }
  if (data.version < Versions14.AddShowUiLabels) {
    data.user.showUiLabels = false;
  }
  if (data.version < Versions14.RenameShowUiLabelsToEnhancedA11yMode) {
    data.user.enhancedA11yMode = data.user.showUiLabels;
    delete data.user.showUiLabels;
  }
  if (data.version < Versions14.AddPointerPeripheral) {
    data.user.inputMode = null;
  }
  data.version = CURRENT_VERSION;
}
var USER_COLORS = [
  "#FF802B",
  "#EC5E41",
  "#F2555A",
  "#F04F88",
  "#E34BA9",
  "#BD54C6",
  "#9D5BD2",
  "#7B66DC",
  "#02B1CC",
  "#11B3A3",
  "#39B178",
  "#55B467"
];
function getRandomColor() {
  return USER_COLORS[Math.floor(Math.random() * USER_COLORS.length)];
}
function userPrefersReducedMotion() {
  var _a6, _b3;
  if (typeof window !== "undefined" && window.matchMedia) {
    return ((_b3 = (_a6 = window.matchMedia) == null ? void 0 : _a6.call(window, "(prefers-reduced-motion: reduce)")) == null ? void 0 : _b3.matches) ?? false;
  }
  return false;
}
var defaultUserPreferences = Object.freeze({
  name: "",
  locale: getDefaultTranslationLocale(),
  color: getRandomColor(),
  // N.B. These are duplicated in TLdrawAppUser.
  edgeScrollSpeed: 1,
  animationSpeed: userPrefersReducedMotion() ? 0 : 1,
  areKeyboardShortcutsEnabled: true,
  isSnapMode: false,
  isWrapMode: false,
  isDynamicSizeMode: false,
  isPasteAtCursorMode: false,
  enhancedA11yMode: false,
  colorScheme: "light",
  inputMode: null
});
function getFreshUserPreferences() {
  return {
    id: uniqueId(),
    color: getRandomColor()
  };
}
function migrateUserPreferences(userData) {
  if (userData === null || typeof userData !== "object") {
    return getFreshUserPreferences();
  }
  if (!("version" in userData) || !("user" in userData) || typeof userData.version !== "number") {
    return getFreshUserPreferences();
  }
  const snapshot = structuredClone(userData);
  migrateSnapshot(snapshot);
  try {
    return userTypeValidator.validate(snapshot.user);
  } catch {
    return getFreshUserPreferences();
  }
}
function loadUserPreferences() {
  const userData = JSON.parse(getFromLocalStorage(USER_DATA_KEY) || "null") ?? null;
  return migrateUserPreferences(userData);
}
var globalUserPreferences = atom("globalUserData", null);
function storeUserPreferences() {
  setInLocalStorage(
    USER_DATA_KEY,
    JSON.stringify({
      version: CURRENT_VERSION,
      user: globalUserPreferences.get()
    })
  );
}
function setUserPreferences(user) {
  userTypeValidator.validate(user);
  globalUserPreferences.set(user);
  storeUserPreferences();
  broadcastUserPreferencesChange();
}
var isTest = typeof process !== "undefined" && false;
var channel = typeof BroadcastChannel !== "undefined" && !isTest ? new BroadcastChannel("tldraw-user-sync") : null;
channel == null ? void 0 : channel.addEventListener("message", (e) => {
  const data = e.data;
  if ((data == null ? void 0 : data.type) === broadcastEventKey && (data == null ? void 0 : data.origin) !== getBroadcastOrigin()) {
    globalUserPreferences.set(migrateUserPreferences(data.data));
  }
});
var _broadcastOrigin = null;
function getBroadcastOrigin() {
  if (_broadcastOrigin === null) {
    _broadcastOrigin = uniqueId();
  }
  return _broadcastOrigin;
}
var broadcastEventKey = "tldraw-user-preferences-change";
function broadcastUserPreferencesChange() {
  channel == null ? void 0 : channel.postMessage({
    type: broadcastEventKey,
    origin: getBroadcastOrigin(),
    data: {
      user: getUserPreferences(),
      version: CURRENT_VERSION
    }
  });
}
function getUserPreferences() {
  let prefs = globalUserPreferences.get();
  if (!prefs) {
    prefs = loadUserPreferences();
    setUserPreferences(prefs);
  }
  return prefs;
}

// ../node_modules/@tldraw/editor/dist-esm/lib/config/createTLUser.mjs
var defaultLocalStorageUserPrefs = computed(
  "defaultLocalStorageUserPrefs",
  () => getUserPreferences()
);
function createTLUser(opts = {}) {
  return {
    userPreferences: opts.userPreferences ?? defaultLocalStorageUserPrefs,
    setUserPreferences: opts.setUserPreferences ?? setUserPreferences
  };
}
function useTldrawUser(opts) {
  const prefs = useShallowObjectIdentity(opts.userPreferences ?? defaultLocalStorageUserPrefs);
  const userAtom = useAtom("userAtom", prefs);
  (0, import_react19.useEffect)(() => {
    userAtom.set(prefs);
  }, [prefs, userAtom]);
  return (0, import_react19.useMemo)(
    () => createTLUser({
      userPreferences: computed("userPreferences", () => {
        const userStuff = userAtom.get();
        return isSignal(userStuff) ? userStuff.get() : userStuff;
      }),
      setUserPreferences: opts.setUserPreferences
    }),
    [userAtom, opts.setUserPreferences]
  );
}

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/Editor.mjs
var import_eventemitter3 = __toESM(require_eventemitter3(), 1);

// ../node_modules/@tldraw/editor/dist-esm/lib/config/TLSessionStateSnapshot.mjs
var tabIdKey = "TLDRAW_TAB_ID_v2";
var window2 = globalThis.window;
function iOS() {
  if (!window2) return false;
  return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    window2.navigator.platform
  ) || // iPad on iOS 13 detection
  tlenv.isDarwin && "ontouchend" in document;
}
var TAB_ID = window2 ? window2[tabIdKey] ?? getFromSessionStorage(tabIdKey) ?? `TLDRAW_INSTANCE_STATE_V1_` + uniqueId() : "<error>";
if (window2) {
  window2[tabIdKey] = TAB_ID;
  if (iOS()) {
    setInSessionStorage(tabIdKey, TAB_ID);
  } else {
    deleteFromSessionStorage(tabIdKey);
  }
}
window2 == null ? void 0 : window2.addEventListener("beforeunload", () => {
  setInSessionStorage(tabIdKey, TAB_ID);
});
var Versions15 = {
  Initial: 0
};
var CURRENT_SESSION_STATE_SNAPSHOT_VERSION = Math.max(...Object.values(Versions15));
function migrate(snapshot) {
  if (snapshot.version < Versions15.Initial) {
  }
  snapshot.version = CURRENT_SESSION_STATE_SNAPSHOT_VERSION;
}
var sessionStateSnapshotValidator = validation_exports.object({
  version: validation_exports.number,
  currentPageId: pageIdValidator.optional(),
  isFocusMode: validation_exports.boolean.optional(),
  exportBackground: validation_exports.boolean.optional(),
  isDebugMode: validation_exports.boolean.optional(),
  isToolLocked: validation_exports.boolean.optional(),
  isGridMode: validation_exports.boolean.optional(),
  pageStates: validation_exports.arrayOf(
    validation_exports.object({
      pageId: pageIdValidator,
      camera: validation_exports.object({
        x: validation_exports.number,
        y: validation_exports.number,
        z: validation_exports.number
      }).optional(),
      selectedShapeIds: validation_exports.arrayOf(shapeIdValidator).optional(),
      focusedGroupId: shapeIdValidator.nullable().optional()
    })
  ).optional()
});
function migrateAndValidateSessionStateSnapshot(state) {
  if (!state || typeof state !== "object") {
    console.warn("Invalid instance state");
    return null;
  }
  if (!("version" in state) || typeof state.version !== "number") {
    console.warn("No version in instance state");
    return null;
  }
  if (state.version !== CURRENT_SESSION_STATE_SNAPSHOT_VERSION) {
    state = structuredClone(state);
    migrate(state);
  }
  try {
    return sessionStateSnapshotValidator.validate(state);
  } catch (e) {
    console.warn(e);
    return null;
  }
}
function createSessionStateSnapshotSignal(store) {
  const $allPageIds = store.query.ids("page");
  return computed(
    "sessionStateSnapshot",
    () => {
      const instanceState = store.get(TLINSTANCE_ID);
      if (!instanceState) return null;
      const allPageIds = [...$allPageIds.get()];
      return {
        version: CURRENT_SESSION_STATE_SNAPSHOT_VERSION,
        currentPageId: instanceState.currentPageId,
        exportBackground: instanceState.exportBackground,
        isFocusMode: instanceState.isFocusMode,
        isDebugMode: instanceState.isDebugMode,
        isToolLocked: instanceState.isToolLocked,
        isGridMode: instanceState.isGridMode,
        pageStates: allPageIds.map((id) => {
          const ps = store.get(InstancePageStateRecordType.createId(id));
          const camera = store.get(CameraRecordType.createId(id));
          return {
            pageId: id,
            camera: {
              x: (camera == null ? void 0 : camera.x) ?? 0,
              y: (camera == null ? void 0 : camera.y) ?? 0,
              z: (camera == null ? void 0 : camera.z) ?? 1
            },
            selectedShapeIds: (ps == null ? void 0 : ps.selectedShapeIds) ?? [],
            focusedGroupId: (ps == null ? void 0 : ps.focusedGroupId) ?? null
          };
        })
      };
    },
    { isEqual: import_lodash.default }
  );
}
function loadSessionStateSnapshotIntoStore(store, snapshot, opts) {
  const res = migrateAndValidateSessionStateSnapshot(snapshot);
  if (!res) return;
  const preserved = pluckPreservingValues(store.get(TLINSTANCE_ID));
  const primary = (opts == null ? void 0 : opts.forceOverwrite) ? res : preserved;
  const secondary = (opts == null ? void 0 : opts.forceOverwrite) ? preserved : res;
  const instanceState = store.schema.types.instance.create({
    id: TLINSTANCE_ID,
    ...preserved,
    // the integrity checker will ensure that the currentPageId is valid
    currentPageId: res.currentPageId,
    isDebugMode: (primary == null ? void 0 : primary.isDebugMode) ?? (secondary == null ? void 0 : secondary.isDebugMode),
    isFocusMode: (primary == null ? void 0 : primary.isFocusMode) ?? (secondary == null ? void 0 : secondary.isFocusMode),
    isToolLocked: (primary == null ? void 0 : primary.isToolLocked) ?? (secondary == null ? void 0 : secondary.isToolLocked),
    isGridMode: (primary == null ? void 0 : primary.isGridMode) ?? (secondary == null ? void 0 : secondary.isGridMode),
    exportBackground: (primary == null ? void 0 : primary.exportBackground) ?? (secondary == null ? void 0 : secondary.exportBackground)
  });
  store.atomic(() => {
    var _a6, _b3, _c;
    for (const ps of res.pageStates ?? []) {
      if (!store.has(ps.pageId)) continue;
      const cameraId = CameraRecordType.createId(ps.pageId);
      const instancePageState = InstancePageStateRecordType.createId(ps.pageId);
      const previousCamera = store.get(cameraId);
      const previousInstanceState = store.get(instancePageState);
      store.put([
        CameraRecordType.create({
          id: cameraId,
          x: ((_a6 = ps.camera) == null ? void 0 : _a6.x) ?? (previousCamera == null ? void 0 : previousCamera.x),
          y: ((_b3 = ps.camera) == null ? void 0 : _b3.y) ?? (previousCamera == null ? void 0 : previousCamera.y),
          z: ((_c = ps.camera) == null ? void 0 : _c.z) ?? (previousCamera == null ? void 0 : previousCamera.z)
        }),
        InstancePageStateRecordType.create({
          id: instancePageState,
          pageId: ps.pageId,
          selectedShapeIds: ps.selectedShapeIds ?? (previousInstanceState == null ? void 0 : previousInstanceState.selectedShapeIds),
          focusedGroupId: ps.focusedGroupId ?? (previousInstanceState == null ? void 0 : previousInstanceState.focusedGroupId)
        })
      ]);
    }
    store.put([instanceState]);
    store.ensureStoreIsUsable();
  });
}
function extractSessionStateFromLegacySnapshot(store) {
  var _a6;
  const instanceRecords = [];
  for (const record of Object.values(store)) {
    if ((_a6 = record.typeName) == null ? void 0 : _a6.match(/^(instance.*|pointer|camera)$/)) {
      instanceRecords.push(record);
    }
  }
  const oldInstance = instanceRecords.filter(
    (r) => r.typeName === "instance" && r.id !== TLINSTANCE_ID
  )[0];
  if (!oldInstance) return null;
  const result = {
    version: CURRENT_SESSION_STATE_SNAPSHOT_VERSION,
    currentPageId: oldInstance.currentPageId,
    exportBackground: !!oldInstance.exportBackground,
    isFocusMode: !!oldInstance.isFocusMode,
    isDebugMode: !!oldInstance.isDebugMode,
    isToolLocked: !!oldInstance.isToolLocked,
    isGridMode: false,
    pageStates: instanceRecords.filter((r) => r.typeName === "instance_page_state" && r.instanceId === oldInstance.id).map((ps) => {
      const camera = store[ps.cameraId] ?? { x: 0, y: 0, z: 1 };
      return {
        pageId: ps.pageId,
        camera: {
          x: camera.x,
          y: camera.y,
          z: camera.z
        },
        selectedShapeIds: ps.selectedShapeIds,
        focusedGroupId: ps.focusedGroupId
      };
    })
  };
  try {
    sessionStateSnapshotValidator.validate(result);
    return result;
  } catch {
    return null;
  }
}

// ../node_modules/@tldraw/editor/dist-esm/lib/config/TLEditorSnapshot.mjs
function loadSnapshot(store, _snapshot, opts) {
  let snapshot = {};
  if ("store" in _snapshot) {
    const migrationResult = store.schema.migrateStoreSnapshot(_snapshot);
    if (migrationResult.type !== "success") {
      throw new Error("Failed to migrate store snapshot: " + migrationResult.reason);
    }
    snapshot.document = {
      schema: store.schema.serialize(),
      store: filterEntries(
        migrationResult.value,
        (_, { typeName }) => store.scopedTypes.document.has(typeName)
      )
    };
  } else {
    snapshot = _snapshot;
  }
  const preservingInstanceState = pluckPreservingValues(store.get(TLINSTANCE_ID));
  const preservingSessionState = sessionStateCache.get(store, createSessionStateSnapshotSignal).get();
  store.atomic(() => {
    if (snapshot.document) {
      store.loadStoreSnapshot(snapshot.document);
    }
    if (preservingInstanceState) {
      store.update(TLINSTANCE_ID, (r) => ({ ...r, ...preservingInstanceState }));
    }
    if (preservingSessionState) {
      loadSessionStateSnapshotIntoStore(store, preservingSessionState);
    }
    if (snapshot.session) {
      loadSessionStateSnapshotIntoStore(store, snapshot.session, {
        forceOverwrite: opts == null ? void 0 : opts.forceOverwriteSessionState
      });
    }
  });
}
var sessionStateCache = new WeakCache();
function getSnapshot(store) {
  const sessionState$ = sessionStateCache.get(store, createSessionStateSnapshotSignal);
  const session = sessionState$.get();
  if (!session) {
    throw new Error("Session state is not ready yet");
  }
  return {
    document: store.getStoreSnapshot(),
    session
  };
}

// ../node_modules/@tldraw/editor/dist-esm/lib/config/defaultBindings.mjs
function checkBindings(customBindings) {
  const bindings = [];
  const addedCustomBindingTypes = /* @__PURE__ */ new Set();
  for (const customBinding of customBindings) {
    if (addedCustomBindingTypes.has(customBinding.type)) {
      throw new Error(`Binding type "${customBinding.type}" is defined more than once`);
    }
    bindings.push(customBinding);
    addedCustomBindingTypes.add(customBinding.type);
  }
  return bindings;
}

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/shapes/group/GroupShapeUtil.mjs
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);

// ../node_modules/@tldraw/editor/dist-esm/lib/components/SVGContainer.mjs
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var import_classnames5 = __toESM(require_classnames(), 1);
function SVGContainer({ children, className = "", ...rest }) {
  return (0, import_jsx_runtime13.jsx)("svg", { ...rest, className: (0, import_classnames5.default)("tl-svg-container", className), "aria-hidden": "true", children });
}

// ../node_modules/@tldraw/editor/dist-esm/lib/primitives/Box.mjs
var Box = class _Box {
  constructor(x = 0, y = 0, w = 0, h2 = 0) {
    __publicField(this, "x", 0);
    __publicField(this, "y", 0);
    __publicField(this, "w", 0);
    __publicField(this, "h", 0);
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h2;
  }
  // eslint-disable-next-line no-restricted-syntax
  get point() {
    return new Vec(this.x, this.y);
  }
  // eslint-disable-next-line no-restricted-syntax
  set point(val) {
    this.x = val.x;
    this.y = val.y;
  }
  // eslint-disable-next-line no-restricted-syntax
  get minX() {
    return this.x;
  }
  // eslint-disable-next-line no-restricted-syntax
  set minX(n) {
    this.x = n;
  }
  // eslint-disable-next-line no-restricted-syntax
  get left() {
    return this.x;
  }
  // eslint-disable-next-line no-restricted-syntax
  get midX() {
    return this.x + this.w / 2;
  }
  // eslint-disable-next-line no-restricted-syntax
  get maxX() {
    return this.x + this.w;
  }
  // eslint-disable-next-line no-restricted-syntax
  get right() {
    return this.x + this.w;
  }
  // eslint-disable-next-line no-restricted-syntax
  get minY() {
    return this.y;
  }
  // eslint-disable-next-line no-restricted-syntax
  set minY(n) {
    this.y = n;
  }
  // eslint-disable-next-line no-restricted-syntax
  get top() {
    return this.y;
  }
  // eslint-disable-next-line no-restricted-syntax
  get midY() {
    return this.y + this.h / 2;
  }
  // eslint-disable-next-line no-restricted-syntax
  get maxY() {
    return this.y + this.h;
  }
  // eslint-disable-next-line no-restricted-syntax
  get bottom() {
    return this.y + this.h;
  }
  // eslint-disable-next-line no-restricted-syntax
  get width() {
    return this.w;
  }
  // eslint-disable-next-line no-restricted-syntax
  set width(n) {
    this.w = n;
  }
  // eslint-disable-next-line no-restricted-syntax
  get height() {
    return this.h;
  }
  // eslint-disable-next-line no-restricted-syntax
  set height(n) {
    this.h = n;
  }
  // eslint-disable-next-line no-restricted-syntax
  get aspectRatio() {
    return this.width / this.height;
  }
  // eslint-disable-next-line no-restricted-syntax
  get center() {
    return new Vec(this.x + this.w / 2, this.y + this.h / 2);
  }
  // eslint-disable-next-line no-restricted-syntax
  set center(v) {
    this.x = v.x - this.w / 2;
    this.y = v.y - this.h / 2;
  }
  // eslint-disable-next-line no-restricted-syntax
  get corners() {
    return [
      new Vec(this.x, this.y),
      new Vec(this.x + this.w, this.y),
      new Vec(this.x + this.w, this.y + this.h),
      new Vec(this.x, this.y + this.h)
    ];
  }
  // eslint-disable-next-line no-restricted-syntax
  get cornersAndCenter() {
    return [
      new Vec(this.x, this.y),
      new Vec(this.x + this.w, this.y),
      new Vec(this.x + this.w, this.y + this.h),
      new Vec(this.x, this.y + this.h),
      new Vec(this.x + this.w / 2, this.y + this.h / 2)
    ];
  }
  // eslint-disable-next-line no-restricted-syntax
  get sides() {
    const { corners } = this;
    return [
      [corners[0], corners[1]],
      [corners[1], corners[2]],
      [corners[2], corners[3]],
      [corners[3], corners[0]]
    ];
  }
  // eslint-disable-next-line no-restricted-syntax
  get size() {
    return new Vec(this.w, this.h);
  }
  isValid() {
    return Number.isFinite(this.x) && Number.isFinite(this.y) && Number.isFinite(this.w) && Number.isFinite(this.h);
  }
  toFixed() {
    this.x = toPrecision(this.x);
    this.y = toPrecision(this.y);
    this.w = toPrecision(this.w);
    this.h = toPrecision(this.h);
    return this;
  }
  setTo(B) {
    this.x = B.x;
    this.y = B.y;
    this.w = B.w;
    this.h = B.h;
    return this;
  }
  set(x = 0, y = 0, w = 0, h2 = 0) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h2;
    return this;
  }
  expand(A) {
    const minX = Math.min(this.x, A.x);
    const minY = Math.min(this.y, A.y);
    const maxX = Math.max(this.x + this.w, A.x + A.w);
    const maxY = Math.max(this.y + this.h, A.y + A.h);
    this.x = minX;
    this.y = minY;
    this.w = maxX - minX;
    this.h = maxY - minY;
    return this;
  }
  expandBy(n) {
    this.x -= n;
    this.y -= n;
    this.w += n * 2;
    this.h += n * 2;
    return this;
  }
  scale(n) {
    this.x /= n;
    this.y /= n;
    this.w /= n;
    this.h /= n;
    return this;
  }
  clone() {
    const { x, y, w, h: h2 } = this;
    return new _Box(x, y, w, h2);
  }
  translate(delta) {
    this.x += delta.x;
    this.y += delta.y;
    return this;
  }
  snapToGrid(size4) {
    const minX = Math.round(this.x / size4) * size4;
    const minY = Math.round(this.y / size4) * size4;
    const maxX = Math.round((this.x + this.w) / size4) * size4;
    const maxY = Math.round((this.y + this.h) / size4) * size4;
    this.minX = minX;
    this.minY = minY;
    this.width = Math.max(1, maxX - minX);
    this.height = Math.max(1, maxY - minY);
  }
  collides(B) {
    return _Box.Collides(this, B);
  }
  contains(B) {
    return _Box.Contains(this, B);
  }
  includes(B) {
    return _Box.Includes(this, B);
  }
  containsPoint(V2, margin = 0) {
    return _Box.ContainsPoint(this, V2, margin);
  }
  getHandlePoint(handle) {
    switch (handle) {
      case "top_left":
        return new Vec(this.x, this.y);
      case "top_right":
        return new Vec(this.x + this.w, this.y);
      case "bottom_left":
        return new Vec(this.x, this.y + this.h);
      case "bottom_right":
        return new Vec(this.x + this.w, this.y + this.h);
      case "top":
        return new Vec(this.x + this.w / 2, this.y);
      case "right":
        return new Vec(this.x + this.w, this.y + this.h / 2);
      case "bottom":
        return new Vec(this.x + this.w / 2, this.y + this.h);
      case "left":
        return new Vec(this.x, this.y + this.h / 2);
    }
  }
  toJson() {
    return { x: this.x, y: this.y, w: this.w, h: this.h };
  }
  resize(handle, dx, dy) {
    const { minX: a0x, minY: a0y, maxX: a1x, maxY: a1y } = this;
    let { minX: b0x, minY: b0y, maxX: b1x, maxY: b1y } = this;
    switch (handle) {
      case "left":
      case "top_left":
      case "bottom_left": {
        b0x += dx;
        break;
      }
      case "right":
      case "top_right":
      case "bottom_right": {
        b1x += dx;
        break;
      }
    }
    switch (handle) {
      case "top":
      case "top_left":
      case "top_right": {
        b0y += dy;
        break;
      }
      case "bottom":
      case "bottom_left":
      case "bottom_right": {
        b1y += dy;
        break;
      }
    }
    const scaleX = (b1x - b0x) / (a1x - a0x);
    const scaleY = (b1y - b0y) / (a1y - a0y);
    const flipX = scaleX < 0;
    const flipY = scaleY < 0;
    if (flipX) {
      const t2 = b1x;
      b1x = b0x;
      b0x = t2;
    }
    if (flipY) {
      const t2 = b1y;
      b1y = b0y;
      b0y = t2;
    }
    this.minX = b0x;
    this.minY = b0y;
    this.width = Math.abs(b1x - b0x);
    this.height = Math.abs(b1y - b0y);
  }
  union(box) {
    const minX = Math.min(this.x, box.x);
    const minY = Math.min(this.y, box.y);
    const maxX = Math.max(this.x + this.w, box.x + box.w);
    const maxY = Math.max(this.y + this.h, box.y + box.h);
    this.x = minX;
    this.y = minY;
    this.width = maxX - minX;
    this.height = maxY - minY;
    return this;
  }
  static From(box) {
    return new _Box(box.x, box.y, box.w, box.h);
  }
  static FromCenter(center, size4) {
    return new _Box(center.x - size4.x / 2, center.y - size4.y / 2, size4.x, size4.y);
  }
  static FromPoints(points) {
    if (points.length === 0) return new _Box();
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let point;
    for (let i = 0, n = points.length; i < n; i++) {
      point = points[i];
      minX = Math.min(point.x, minX);
      minY = Math.min(point.y, minY);
      maxX = Math.max(point.x, maxX);
      maxY = Math.max(point.y, maxY);
    }
    return new _Box(minX, minY, maxX - minX, maxY - minY);
  }
  static Expand(A, B) {
    const minX = Math.min(B.minX, A.minX);
    const minY = Math.min(B.minY, A.minY);
    const maxX = Math.max(B.maxX, A.maxX);
    const maxY = Math.max(B.maxY, A.maxY);
    return new _Box(minX, minY, maxX - minX, maxY - minY);
  }
  static ExpandBy(A, n) {
    return new _Box(A.minX - n, A.minY - n, A.width + n * 2, A.height + n * 2);
  }
  static Collides(A, B) {
    return !(A.maxX < B.minX || A.minX > B.maxX || A.maxY < B.minY || A.minY > B.maxY);
  }
  static Contains(A, B) {
    return A.minX < B.minX && A.minY < B.minY && A.maxY > B.maxY && A.maxX > B.maxX;
  }
  static ContainsApproximately(A, B, precision) {
    return approximatelyLte(A.minX, B.minX, precision) && approximatelyLte(A.minY, B.minY, precision) && approximatelyLte(B.maxX, A.maxX, precision) && approximatelyLte(B.maxY, A.maxY, precision);
  }
  static Includes(A, B) {
    return _Box.Collides(A, B) || _Box.Contains(A, B);
  }
  static ContainsPoint(A, B, margin = 0) {
    return !(B.x < A.minX - margin || B.y < A.minY - margin || B.x > A.maxX + margin || B.y > A.maxY + margin);
  }
  static Common(boxes) {
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    for (let i = 0; i < boxes.length; i++) {
      const B = boxes[i];
      minX = Math.min(minX, B.minX);
      minY = Math.min(minY, B.minY);
      maxX = Math.max(maxX, B.maxX);
      maxY = Math.max(maxY, B.maxY);
    }
    return new _Box(minX, minY, maxX - minX, maxY - minY);
  }
  static Sides(A, inset = 0) {
    const { corners } = A;
    if (inset) {
    }
    return [
      [corners[0], corners[1]],
      [corners[1], corners[2]],
      [corners[2], corners[3]],
      [corners[3], corners[0]]
    ];
  }
  static Resize(box, handle, dx, dy, isAspectRatioLocked = false) {
    const { minX: a0x, minY: a0y, maxX: a1x, maxY: a1y } = box;
    let { minX: b0x, minY: b0y, maxX: b1x, maxY: b1y } = box;
    switch (handle) {
      case "left":
      case "top_left":
      case "bottom_left": {
        b0x += dx;
        break;
      }
      case "right":
      case "top_right":
      case "bottom_right": {
        b1x += dx;
        break;
      }
    }
    switch (handle) {
      case "top":
      case "top_left":
      case "top_right": {
        b0y += dy;
        break;
      }
      case "bottom":
      case "bottom_left":
      case "bottom_right": {
        b1y += dy;
        break;
      }
    }
    const scaleX = (b1x - b0x) / (a1x - a0x);
    const scaleY = (b1y - b0y) / (a1y - a0y);
    const flipX = scaleX < 0;
    const flipY = scaleY < 0;
    if (isAspectRatioLocked) {
      const aspectRatio = (a1x - a0x) / (a1y - a0y);
      const bw = Math.abs(b1x - b0x);
      const bh = Math.abs(b1y - b0y);
      const tw = bw * (scaleY < 0 ? 1 : -1) * (1 / aspectRatio);
      const th = bh * (scaleX < 0 ? 1 : -1) * aspectRatio;
      const isTall = aspectRatio < bw / bh;
      switch (handle) {
        case "top_left": {
          if (isTall) b0y = b1y + tw;
          else b0x = b1x + th;
          break;
        }
        case "top_right": {
          if (isTall) b0y = b1y + tw;
          else b1x = b0x - th;
          break;
        }
        case "bottom_right": {
          if (isTall) b1y = b0y - tw;
          else b1x = b0x - th;
          break;
        }
        case "bottom_left": {
          if (isTall) b1y = b0y - tw;
          else b0x = b1x + th;
          break;
        }
        case "bottom":
        case "top": {
          const m = (b0x + b1x) / 2;
          const w = bh * aspectRatio;
          b0x = m - w / 2;
          b1x = m + w / 2;
          break;
        }
        case "left":
        case "right": {
          const m = (b0y + b1y) / 2;
          const h2 = bw / aspectRatio;
          b0y = m - h2 / 2;
          b1y = m + h2 / 2;
          break;
        }
      }
    }
    if (flipX) {
      const t2 = b1x;
      b1x = b0x;
      b0x = t2;
    }
    if (flipY) {
      const t2 = b1y;
      b1y = b0y;
      b0y = t2;
    }
    const final = new _Box(b0x, b0y, Math.abs(b1x - b0x), Math.abs(b1y - b0y));
    return {
      box: final,
      scaleX: +(final.width / box.width * (scaleX > 0 ? 1 : -1)).toFixed(5),
      scaleY: +(final.height / box.height * (scaleY > 0 ? 1 : -1)).toFixed(5)
    };
  }
  equals(other) {
    return _Box.Equals(this, other);
  }
  static Equals(a, b) {
    return b.x === a.x && b.y === a.y && b.w === a.w && b.h === a.h;
  }
  zeroFix() {
    this.w = Math.max(1, this.w);
    this.h = Math.max(1, this.h);
    return this;
  }
  static ZeroFix(other) {
    return new _Box(other.x, other.y, Math.max(1, other.w), Math.max(1, other.h));
  }
};
function flipSelectionHandleY(handle) {
  switch (handle) {
    case "top":
      return "bottom";
    case "bottom":
      return "top";
    case "top_left":
      return "bottom_left";
    case "top_right":
      return "bottom_right";
    case "bottom_left":
      return "top_left";
    case "bottom_right":
      return "top_right";
    default:
      return handle;
  }
}
function flipSelectionHandleX(handle) {
  switch (handle) {
    case "left":
      return "right";
    case "right":
      return "left";
    case "top_left":
      return "top_right";
    case "top_right":
      return "top_left";
    case "bottom_left":
      return "bottom_right";
    case "bottom_right":
      return "bottom_left";
    default:
      return handle;
  }
}
var ORDERED_SELECTION_HANDLES = [
  "top",
  "top_right",
  "right",
  "bottom_right",
  "bottom",
  "bottom_left",
  "left",
  "top_left"
];
function rotateSelectionHandle(handle, rotation) {
  rotation = rotation % PI2;
  const numSteps = Math.round(rotation / (PI / 4));
  const currentIndex = ORDERED_SELECTION_HANDLES.indexOf(handle);
  return ORDERED_SELECTION_HANDLES[(currentIndex + numSteps) % ORDERED_SELECTION_HANDLES.length];
}
function isSelectionCorner(selection) {
  return selection === "top_left" || selection === "top_right" || selection === "bottom_right" || selection === "bottom_left";
}
var ROTATE_CORNER_TO_SELECTION_CORNER = {
  top_left_rotate: "top_left",
  top_right_rotate: "top_right",
  bottom_right_rotate: "bottom_right",
  bottom_left_rotate: "bottom_left",
  mobile_rotate: "top_left"
};

// ../node_modules/@tldraw/editor/dist-esm/lib/primitives/Mat.mjs
var Mat = class _Mat {
  constructor(a, b, c, d, e, f) {
    __publicField(this, "a", 1);
    __publicField(this, "b", 0);
    __publicField(this, "c", 0);
    __publicField(this, "d", 1);
    __publicField(this, "e", 0);
    __publicField(this, "f", 0);
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.e = e;
    this.f = f;
  }
  equals(m) {
    return this === m || this.a === m.a && this.b === m.b && this.c === m.c && this.d === m.d && this.e === m.e && this.f === m.f;
  }
  identity() {
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 1;
    this.e = 0;
    this.f = 0;
    return this;
  }
  multiply(m) {
    const m2 = m;
    const { a, b, c, d, e, f } = this;
    this.a = a * m2.a + c * m2.b;
    this.c = a * m2.c + c * m2.d;
    this.e = a * m2.e + c * m2.f + e;
    this.b = b * m2.a + d * m2.b;
    this.d = b * m2.c + d * m2.d;
    this.f = b * m2.e + d * m2.f + f;
    return this;
  }
  rotate(r, cx, cy) {
    if (r === 0) return this;
    if (cx === void 0) return this.multiply(_Mat.Rotate(r));
    return this.translate(cx, cy).multiply(_Mat.Rotate(r)).translate(-cx, -cy);
  }
  translate(x, y) {
    return this.multiply(_Mat.Translate(x, y));
  }
  scale(x, y) {
    return this.multiply(_Mat.Scale(x, y));
  }
  invert() {
    const { a, b, c, d, e, f } = this;
    const denom = a * d - b * c;
    this.a = d / denom;
    this.b = b / -denom;
    this.c = c / -denom;
    this.d = a / denom;
    this.e = (d * e - c * f) / -denom;
    this.f = (b * e - a * f) / denom;
    return this;
  }
  applyToPoint(point) {
    return _Mat.applyToPoint(this, point);
  }
  applyToPoints(points) {
    return _Mat.applyToPoints(this, points);
  }
  rotation() {
    return _Mat.Rotation(this);
  }
  point() {
    return _Mat.Point(this);
  }
  decomposed() {
    return _Mat.Decompose(this);
  }
  toCssString() {
    return _Mat.toCssString(this);
  }
  setTo(model) {
    Object.assign(this, model);
    return this;
  }
  decompose() {
    return _Mat.Decompose(this);
  }
  clone() {
    return new _Mat(this.a, this.b, this.c, this.d, this.e, this.f);
  }
  /* --------------------- Static --------------------- */
  static Identity() {
    return new _Mat(1, 0, 0, 1, 0, 0);
  }
  static Translate(x, y) {
    return new _Mat(1, 0, 0, 1, x, y);
  }
  static Rotate(r, cx, cy) {
    if (r === 0) return _Mat.Identity();
    const cosAngle = Math.cos(r);
    const sinAngle = Math.sin(r);
    const rotationMatrix = new _Mat(cosAngle, sinAngle, -sinAngle, cosAngle, 0, 0);
    if (cx === void 0) return rotationMatrix;
    return _Mat.Compose(_Mat.Translate(cx, cy), rotationMatrix, _Mat.Translate(-cx, -cy));
  }
  static Scale(x, y, cx, cy) {
    const scaleMatrix = new _Mat(x, 0, 0, y, 0, 0);
    if (cx === void 0) return scaleMatrix;
    return _Mat.Translate(cx, cy).multiply(scaleMatrix).translate(-cx, -cy);
  }
  static Multiply(m1, m2) {
    return {
      a: m1.a * m2.a + m1.c * m2.b,
      c: m1.a * m2.c + m1.c * m2.d,
      e: m1.a * m2.e + m1.c * m2.f + m1.e,
      b: m1.b * m2.a + m1.d * m2.b,
      d: m1.b * m2.c + m1.d * m2.d,
      f: m1.b * m2.e + m1.d * m2.f + m1.f
    };
  }
  static Inverse(m) {
    const denom = m.a * m.d - m.b * m.c;
    return {
      a: m.d / denom,
      b: m.b / -denom,
      c: m.c / -denom,
      d: m.a / denom,
      e: (m.d * m.e - m.c * m.f) / -denom,
      f: (m.b * m.e - m.a * m.f) / denom
    };
  }
  static Absolute(m) {
    const denom = m.a * m.d - m.b * m.c;
    return {
      a: m.d / denom,
      b: m.b / -denom,
      c: m.c / -denom,
      d: m.a / denom,
      e: (m.d * m.e - m.c * m.f) / denom,
      f: (m.b * m.e - m.a * m.f) / -denom
    };
  }
  static Compose(...matrices) {
    const matrix = _Mat.Identity();
    for (let i = 0, n = matrices.length; i < n; i++) {
      matrix.multiply(matrices[i]);
    }
    return matrix;
  }
  static Point(m) {
    return new Vec(m.e, m.f);
  }
  static Rotation(m) {
    let rotation;
    if (m.a !== 0 || m.c !== 0) {
      const hypotAc = (m.a * m.a + m.c * m.c) ** 0.5;
      rotation = Math.acos(m.a / hypotAc) * (m.c > 0 ? -1 : 1);
    } else if (m.b !== 0 || m.d !== 0) {
      const hypotBd = (m.b * m.b + m.d * m.d) ** 0.5;
      rotation = HALF_PI + Math.acos(m.b / hypotBd) * (m.d > 0 ? -1 : 1);
    } else {
      rotation = 0;
    }
    return clampRadians(rotation);
  }
  static Decompose(m) {
    let scaleX, scaleY, rotation;
    if (m.a !== 0 || m.c !== 0) {
      const hypotAc = (m.a * m.a + m.c * m.c) ** 0.5;
      scaleX = hypotAc;
      scaleY = (m.a * m.d - m.b * m.c) / hypotAc;
      rotation = Math.acos(m.a / hypotAc) * (m.c > 0 ? -1 : 1);
    } else if (m.b !== 0 || m.d !== 0) {
      const hypotBd = (m.b * m.b + m.d * m.d) ** 0.5;
      scaleX = (m.a * m.d - m.b * m.c) / hypotBd;
      scaleY = hypotBd;
      rotation = HALF_PI + Math.acos(m.b / hypotBd) * (m.d > 0 ? -1 : 1);
    } else {
      scaleX = 0;
      scaleY = 0;
      rotation = 0;
    }
    return {
      x: m.e,
      y: m.f,
      scaleX,
      scaleY,
      rotation: clampRadians(rotation)
    };
  }
  static Smooth(m, precision = 1e10) {
    m.a = Math.round(m.a * precision) / precision;
    m.b = Math.round(m.b * precision) / precision;
    m.c = Math.round(m.c * precision) / precision;
    m.d = Math.round(m.d * precision) / precision;
    m.e = Math.round(m.e * precision) / precision;
    m.f = Math.round(m.f * precision) / precision;
    return m;
  }
  static toCssString(m) {
    return `matrix(${toDomPrecision(m.a)}, ${toDomPrecision(m.b)}, ${toDomPrecision(
      m.c
    )}, ${toDomPrecision(m.d)}, ${toDomPrecision(m.e)}, ${toDomPrecision(m.f)})`;
  }
  static applyToPoint(m, point) {
    return new Vec(
      m.a * point.x + m.c * point.y + m.e,
      m.b * point.x + m.d * point.y + m.f,
      point.z
    );
  }
  static applyToXY(m, x, y) {
    return [m.a * x + m.c * y + m.e, m.b * x + m.d * y + m.f];
  }
  static applyToPoints(m, points) {
    return points.map(
      (point) => new Vec(m.a * point.x + m.c * point.y + m.e, m.b * point.x + m.d * point.y + m.f, point.z)
    );
  }
  static applyToBounds(m, box) {
    return new Box(m.e + box.minX, m.f + box.minY, box.width, box.height);
  }
  static From(m) {
    return new _Mat(m.a, m.b, m.c, m.d, m.e, m.f);
  }
  static Cast(m) {
    return m instanceof _Mat ? m : _Mat.From(m);
  }
};

// ../node_modules/@tldraw/editor/dist-esm/lib/primitives/intersect.mjs
function intersectLineSegmentLineSegment(a1, a2, b1, b2, precision = 1e-10) {
  const ABx = a1.x - b1.x;
  const ABy = a1.y - b1.y;
  const BVx = b2.x - b1.x;
  const BVy = b2.y - b1.y;
  const AVx = a2.x - a1.x;
  const AVy = a2.y - a1.y;
  const ua_t = BVx * ABy - BVy * ABx;
  const ub_t = AVx * ABy - AVy * ABx;
  const u_b = BVy * AVx - BVx * AVy;
  if (approximately(ua_t, 0, precision) || approximately(ub_t, 0, precision)) return null;
  if (approximately(u_b, 0, precision)) return null;
  if (u_b !== 0) {
    const ua = ua_t / u_b;
    const ub = ub_t / u_b;
    if (approximatelyLte(0, ua, precision) && approximatelyLte(ua, 1, precision) && approximatelyLte(0, ub, precision) && approximatelyLte(ub, 1, precision)) {
      return Vec.AddXY(a1, ua * AVx, ua * AVy);
    }
  }
  return null;
}
function intersectLineSegmentCircle(a1, a2, c, r) {
  const a = (a2.x - a1.x) * (a2.x - a1.x) + (a2.y - a1.y) * (a2.y - a1.y);
  const b = 2 * ((a2.x - a1.x) * (a1.x - c.x) + (a2.y - a1.y) * (a1.y - c.y));
  const cc = c.x * c.x + c.y * c.y + a1.x * a1.x + a1.y * a1.y - 2 * (c.x * a1.x + c.y * a1.y) - r * r;
  const deter = b * b - 4 * a * cc;
  if (deter < 0) return null;
  if (deter === 0) return null;
  const e = Math.sqrt(deter);
  const u1 = (-b + e) / (2 * a);
  const u2 = (-b - e) / (2 * a);
  if ((u1 < 0 || u1 > 1) && (u2 < 0 || u2 > 1)) {
    return null;
  }
  const result = [];
  if (0 <= u1 && u1 <= 1) result.push(Vec.Lrp(a1, a2, u1));
  if (0 <= u2 && u2 <= 1) result.push(Vec.Lrp(a1, a2, u2));
  if (result.length === 0) return null;
  return result;
}
function intersectLineSegmentPolyline(a1, a2, points) {
  const result = [];
  let segmentIntersection;
  for (let i = 0, n = points.length - 1; i < n; i++) {
    segmentIntersection = intersectLineSegmentLineSegment(a1, a2, points[i], points[i + 1]);
    if (segmentIntersection) result.push(segmentIntersection);
  }
  if (result.length === 0) return null;
  return result;
}
function intersectLineSegmentPolygon(a1, a2, points) {
  const result = [];
  let segmentIntersection;
  for (let i = 1, n = points.length; i < n + 1; i++) {
    segmentIntersection = intersectLineSegmentLineSegment(
      a1,
      a2,
      points[i - 1],
      points[i % points.length]
    );
    if (segmentIntersection) result.push(segmentIntersection);
  }
  if (result.length === 0) return null;
  return result;
}
function intersectCircleCircle(c1, r1, c2, r2) {
  let dx = c2.x - c1.x;
  let dy = c2.y - c1.y;
  const d = Math.sqrt(dx * dx + dy * dy), x = (d * d - r2 * r2 + r1 * r1) / (2 * d), y = Math.sqrt(r1 * r1 - x * x);
  dx /= d;
  dy /= d;
  return [
    new Vec(c1.x + dx * x - dy * y, c1.y + dy * x + dx * y),
    new Vec(c1.x + dx * x + dy * y, c1.y + dy * x - dx * y)
  ];
}
function intersectCirclePolygon(c, r, points) {
  const result = [];
  let a, b, int;
  for (let i = 0, n = points.length; i < n; i++) {
    a = points[i];
    b = points[(i + 1) % points.length];
    int = intersectLineSegmentCircle(a, b, c, r);
    if (int) result.push(...int);
  }
  if (result.length === 0) return null;
  return result;
}
function intersectCirclePolyline(c, r, points) {
  const result = [];
  let a, b, int;
  for (let i = 1, n = points.length; i < n; i++) {
    a = points[i - 1];
    b = points[i];
    int = intersectLineSegmentCircle(a, b, c, r);
    if (int) result.push(...int);
  }
  if (result.length === 0) return null;
  return result;
}
function intersectPolygonBounds(points, bounds) {
  const result = [];
  let segmentIntersection;
  for (const side of bounds.sides) {
    segmentIntersection = intersectLineSegmentPolygon(side[0], side[1], points);
    if (segmentIntersection) result.push(...segmentIntersection);
  }
  if (result.length === 0) return null;
  return result;
}
function ccw(A, B, C) {
  return (C.y - A.y) * (B.x - A.x) > (B.y - A.y) * (C.x - A.x);
}
function linesIntersect(A, B, C, D) {
  return ccw(A, C, D) !== ccw(B, C, D) && ccw(A, B, C) !== ccw(A, B, D);
}
function intersectPolygonPolygon(polygonA, polygonB) {
  const result = /* @__PURE__ */ new Map();
  let a, b, c, d;
  for (let i = 0, n = polygonA.length; i < n; i++) {
    a = polygonA[i];
    if (pointInPolygon(a, polygonB)) {
      const id = getPointId(a);
      if (!result.has(id)) {
        result.set(id, a);
      }
    }
  }
  for (let i = 0, n = polygonB.length; i < n; i++) {
    a = polygonB[i];
    if (pointInPolygon(a, polygonA)) {
      const id = getPointId(a);
      if (!result.has(id)) {
        result.set(id, a);
      }
    }
  }
  for (let i = 0, n = polygonA.length; i < n; i++) {
    a = polygonA[i];
    b = polygonA[(i + 1) % polygonA.length];
    for (let j = 0, m = polygonB.length; j < m; j++) {
      c = polygonB[j];
      d = polygonB[(j + 1) % polygonB.length];
      const intersection = intersectLineSegmentLineSegment(a, b, c, d);
      if (intersection !== null) {
        const id = getPointId(intersection);
        if (!result.has(id)) {
          result.set(id, intersection);
        }
      }
    }
  }
  if (result.size === 0) return null;
  return orderClockwise([...result.values()]);
}
function intersectPolys(polyA, polyB, isAClosed, isBClosed) {
  const result = /* @__PURE__ */ new Map();
  for (let i = 0, n = isAClosed ? polyA.length : polyA.length - 1; i < n; i++) {
    const currentA = polyA[i];
    const nextA = polyA[(i + 1) % polyA.length];
    for (let j = 0, m = isBClosed ? polyB.length : polyB.length - 1; j < m; j++) {
      const currentB = polyB[j];
      const nextB = polyB[(j + 1) % polyB.length];
      const intersection = intersectLineSegmentLineSegment(currentA, nextA, currentB, nextB);
      if (intersection !== null) {
        const id = getPointId(intersection);
        if (!result.has(id)) {
          result.set(id, intersection);
        }
      }
    }
  }
  return [...result.values()];
}
function getPointId(point) {
  return `${point.x},${point.y}`;
}
function orderClockwise(points) {
  const C = Vec.Average(points);
  return points.sort((A, B) => Vec.Angle(C, A) - Vec.Angle(C, B));
}
function polygonsIntersect(a, b) {
  let a0, a1, b0, b1;
  for (let i = 0, n = a.length; i < n; i++) {
    a0 = a[i];
    a1 = a[(i + 1) % n];
    for (let j = 0, m = b.length; j < m; j++) {
      b0 = b[j];
      b1 = b[(j + 1) % m];
      if (linesIntersect(a0, a1, b0, b1)) return true;
    }
  }
  return false;
}
function polygonIntersectsPolyline(polygon, polyline) {
  let a, b, c, d;
  for (let i = 0, n = polygon.length; i < n; i++) {
    a = polygon[i];
    b = polygon[(i + 1) % n];
    for (let j = 1, m = polyline.length; j < m; j++) {
      c = polyline[j - 1];
      d = polyline[j];
      if (linesIntersect(a, b, c, d)) return true;
    }
  }
  return false;
}

// ../node_modules/@tldraw/editor/dist-esm/lib/primitives/geometry/Geometry2d.mjs
var Geometry2dFilters = {
  EXCLUDE_NON_STANDARD: {
    includeLabels: false,
    includeInternal: false
  },
  INCLUDE_ALL: { includeLabels: true, includeInternal: true },
  EXCLUDE_LABELS: { includeLabels: false, includeInternal: true },
  EXCLUDE_INTERNAL: { includeLabels: true, includeInternal: false }
};
var Geometry2d = class {
  constructor(opts) {
    // todo: consider making accessors for these too, so that they can be overridden in subclasses by geometries with more complex logic
    __publicField(this, "isFilled", false);
    __publicField(this, "isClosed", true);
    __publicField(this, "isLabel", false);
    __publicField(this, "isEmptyLabel", false);
    __publicField(this, "isInternal", false);
    __publicField(this, "excludeFromShapeBounds", false);
    __publicField(this, "debugColor");
    __publicField(this, "ignore");
    __publicField(this, "_vertices");
    __publicField(this, "_boundsVertices");
    __publicField(this, "_bounds");
    __publicField(this, "_area");
    __publicField(this, "_length");
    const {
      isLabel = false,
      isEmptyLabel = false,
      isInternal = false,
      excludeFromShapeBounds = false
    } = opts;
    this.isFilled = opts.isFilled;
    this.isClosed = opts.isClosed;
    this.debugColor = opts.debugColor;
    this.ignore = opts.ignore;
    this.isLabel = isLabel;
    this.isEmptyLabel = isEmptyLabel;
    this.isInternal = isInternal;
    this.excludeFromShapeBounds = excludeFromShapeBounds;
  }
  isExcludedByFilter(filters) {
    if (!filters) return false;
    if (this.isLabel && !filters.includeLabels) return true;
    if (this.isInternal && !filters.includeInternal) return true;
    return false;
  }
  hitTestPoint(point, margin = 0, hitInside = false, _filters) {
    if (this.isClosed && (this.isFilled || hitInside) && pointInPolygon(point, this.vertices)) {
      return true;
    }
    return Vec.Dist2(point, this.nearestPoint(point)) <= margin * margin;
  }
  distanceToPoint(point, hitInside = false, filters) {
    return Vec.Dist(point, this.nearestPoint(point, filters)) * (this.isClosed && (this.isFilled || hitInside) && pointInPolygon(point, this.vertices) ? -1 : 1);
  }
  distanceToLineSegment(A, B, filters) {
    if (Vec.Equals(A, B)) return this.distanceToPoint(A, false, filters);
    const { vertices } = this;
    if (vertices.length === 0) throw Error("nearest point not found");
    if (vertices.length === 1) return Vec.Dist(A, vertices[0]);
    let nearest;
    let dist = Infinity;
    let d, p, q;
    const nextLimit = this.isClosed ? vertices.length : vertices.length - 1;
    for (let i = 0; i < vertices.length; i++) {
      p = vertices[i];
      if (i < nextLimit) {
        const next = vertices[(i + 1) % vertices.length];
        if (linesIntersect(A, B, p, next)) return 0;
      }
      q = Vec.NearestPointOnLineSegment(A, B, p, true);
      d = Vec.Dist2(p, q);
      if (d < dist) {
        dist = d;
        nearest = q;
      }
    }
    if (!nearest) throw Error("nearest point not found");
    dist = Math.sqrt(dist);
    return this.isClosed && this.isFilled && pointInPolygon(nearest, this.vertices) ? -dist : dist;
  }
  hitTestLineSegment(A, B, distance = 0, filters) {
    return this.distanceToLineSegment(A, B, filters) <= distance;
  }
  intersectLineSegment(A, B, _filters) {
    const intersections = this.isClosed ? intersectLineSegmentPolygon(A, B, this.vertices) : intersectLineSegmentPolyline(A, B, this.vertices);
    return intersections ?? [];
  }
  intersectCircle(center, radius, _filters) {
    const intersections = this.isClosed ? intersectCirclePolygon(center, radius, this.vertices) : intersectCirclePolyline(center, radius, this.vertices);
    return intersections ?? [];
  }
  intersectPolygon(polygon, _filters) {
    return intersectPolys(polygon, this.vertices, true, this.isClosed);
  }
  intersectPolyline(polyline, _filters) {
    return intersectPolys(polyline, this.vertices, false, this.isClosed);
  }
  /**
   * Find a point along the edge of the geometry that is a fraction `t` along the entire way round.
   */
  interpolateAlongEdge(t2, _filters) {
    const { vertices } = this;
    if (vertices.length === 0) return new Vec(0, 0);
    if (vertices.length === 1) return vertices[0];
    if (t2 <= 0) return vertices[0];
    const distanceToTravel = t2 * this.length;
    let distanceTraveled = 0;
    for (let i = 0; i < (this.isClosed ? vertices.length : vertices.length - 1); i++) {
      const curr = vertices[i];
      const next = vertices[(i + 1) % vertices.length];
      const dist = Vec.Dist(curr, next);
      const newDistanceTraveled = distanceTraveled + dist;
      if (newDistanceTraveled >= distanceToTravel) {
        const p = Vec.Lrp(
          curr,
          next,
          invLerp(distanceTraveled, newDistanceTraveled, distanceToTravel)
        );
        return p;
      }
      distanceTraveled = newDistanceTraveled;
    }
    return this.isClosed ? vertices[0] : vertices[vertices.length - 1];
  }
  /**
   * Take `point`, find the closest point to it on the edge of the geometry, and return how far
   * along the edge it is as a fraction of the total length.
   */
  uninterpolateAlongEdge(point, _filters) {
    const { vertices, length } = this;
    let closestSegment = null;
    let closestDistance = Infinity;
    let distanceTraveled = 0;
    if (vertices.length === 0 || vertices.length === 1) return 0;
    for (let i = 0; i < (this.isClosed ? vertices.length : vertices.length - 1); i++) {
      const curr = vertices[i];
      const next = vertices[(i + 1) % vertices.length];
      const nearestPoint = Vec.NearestPointOnLineSegment(curr, next, point, true);
      const distance = Vec.Dist(nearestPoint, point);
      if (distance < closestDistance) {
        closestDistance = distance;
        closestSegment = {
          start: curr,
          end: next,
          nearestPoint,
          distanceToStart: distanceTraveled
        };
      }
      distanceTraveled += Vec.Dist(curr, next);
    }
    assert(closestSegment);
    const distanceAlongRoute = closestSegment.distanceToStart + Vec.Dist(closestSegment.start, closestSegment.nearestPoint);
    return distanceAlongRoute / length;
  }
  isPointInBounds(point, margin = 0) {
    const { bounds } = this;
    return !(point.x < bounds.minX - margin || point.y < bounds.minY - margin || point.x > bounds.maxX + margin || point.y > bounds.maxY + margin);
  }
  overlapsPolygon(_polygon) {
    const polygon = _polygon.map((v) => Vec.From(v));
    const { vertices, center, isFilled, isEmptyLabel, isClosed } = this;
    if (isEmptyLabel) return false;
    if (vertices.some((v) => pointInPolygon(v, polygon))) {
      return true;
    }
    if (isClosed) {
      if (isFilled) {
        if (pointInPolygon(center, polygon)) {
          return true;
        }
        if (polygon.every((v) => pointInPolygon(v, vertices))) {
          return true;
        }
      }
      if (polygonsIntersect(polygon, vertices)) {
        return true;
      }
    } else {
      if (polygonIntersectsPolyline(polygon, vertices)) {
        return true;
      }
    }
    return false;
  }
  transform(transform, opts) {
    return new TransformedGeometry2d(this, transform, opts);
  }
  // eslint-disable-next-line no-restricted-syntax
  get vertices() {
    if (!this._vertices) {
      this._vertices = this.getVertices(Geometry2dFilters.EXCLUDE_LABELS);
    }
    return this._vertices;
  }
  getBoundsVertices() {
    if (this.excludeFromShapeBounds) return [];
    return this.vertices;
  }
  // eslint-disable-next-line no-restricted-syntax
  get boundsVertices() {
    if (!this._boundsVertices) {
      this._boundsVertices = this.getBoundsVertices();
    }
    return this._boundsVertices;
  }
  getBounds() {
    return Box.FromPoints(this.boundsVertices);
  }
  // eslint-disable-next-line no-restricted-syntax
  get bounds() {
    if (!this._bounds) {
      this._bounds = this.getBounds();
    }
    return this._bounds;
  }
  // eslint-disable-next-line no-restricted-syntax
  get center() {
    return this.bounds.center;
  }
  // eslint-disable-next-line no-restricted-syntax
  get area() {
    if (!this._area) {
      this._area = this.getArea();
    }
    return this._area;
  }
  getArea() {
    if (!this.isClosed) {
      return 0;
    }
    const { vertices } = this;
    let area = 0;
    for (let i = 0, n = vertices.length; i < n; i++) {
      const curr = vertices[i];
      const next = vertices[(i + 1) % n];
      area += curr.x * next.y - next.x * curr.y;
    }
    return area / 2;
  }
  toSimpleSvgPath() {
    let path = "";
    const { vertices } = this;
    const n = vertices.length;
    if (n === 0) return path;
    path += `M${vertices[0].x},${vertices[0].y}`;
    for (let i = 1; i < n; i++) {
      path += `L${vertices[i].x},${vertices[i].y}`;
    }
    if (this.isClosed) {
      path += "Z";
    }
    return path;
  }
  // eslint-disable-next-line no-restricted-syntax
  get length() {
    if (this._length) return this._length;
    this._length = this.getLength(Geometry2dFilters.EXCLUDE_LABELS);
    return this._length;
  }
  getLength(_filters) {
    const vertices = this.getVertices(_filters ?? Geometry2dFilters.EXCLUDE_LABELS);
    if (vertices.length === 0) return 0;
    let prev = vertices[0];
    let length = 0;
    for (let i = 1; i < vertices.length; i++) {
      const next = vertices[i];
      length += Vec.Dist(prev, next);
      prev = next;
    }
    if (this.isClosed) {
      length += Vec.Dist(vertices[vertices.length - 1], vertices[0]);
    }
    return length;
  }
};
var TransformedGeometry2d = class _TransformedGeometry2d extends Geometry2d {
  constructor(geometry, matrix, opts) {
    super(geometry);
    __publicField(this, "inverse");
    __publicField(this, "decomposed");
    this.geometry = geometry;
    this.matrix = matrix;
    this.inverse = Mat.Inverse(matrix);
    this.decomposed = Mat.Decompose(matrix);
    if (opts) {
      if (opts.isLabel != null) this.isLabel = opts.isLabel;
      if (opts.isInternal != null) this.isInternal = opts.isInternal;
      if (opts.debugColor != null) this.debugColor = opts.debugColor;
      if (opts.ignore != null) this.ignore = opts.ignore;
    }
    assert(
      approximately(this.decomposed.scaleX, this.decomposed.scaleY),
      "non-uniform scaling is not yet supported"
    );
  }
  getVertices(filters) {
    return this.geometry.getVertices(filters).map((v) => Mat.applyToPoint(this.matrix, v));
  }
  getBoundsVertices() {
    return this.geometry.getBoundsVertices().map((v) => Mat.applyToPoint(this.matrix, v));
  }
  nearestPoint(point, filters) {
    return Mat.applyToPoint(
      this.matrix,
      this.geometry.nearestPoint(Mat.applyToPoint(this.inverse, point), filters)
    );
  }
  hitTestPoint(point, margin = 0, hitInside, filters) {
    return this.geometry.hitTestPoint(
      Mat.applyToPoint(this.inverse, point),
      margin / this.decomposed.scaleX,
      hitInside,
      filters
    );
  }
  distanceToPoint(point, hitInside = false, filters) {
    return this.geometry.distanceToPoint(Mat.applyToPoint(this.inverse, point), hitInside, filters) * this.decomposed.scaleX;
  }
  distanceToLineSegment(A, B, filters) {
    return this.geometry.distanceToLineSegment(
      Mat.applyToPoint(this.inverse, A),
      Mat.applyToPoint(this.inverse, B),
      filters
    ) * this.decomposed.scaleX;
  }
  hitTestLineSegment(A, B, distance = 0, filters) {
    return this.geometry.hitTestLineSegment(
      Mat.applyToPoint(this.inverse, A),
      Mat.applyToPoint(this.inverse, B),
      distance / this.decomposed.scaleX,
      filters
    );
  }
  intersectLineSegment(A, B, filters) {
    return Mat.applyToPoints(
      this.matrix,
      this.geometry.intersectLineSegment(
        Mat.applyToPoint(this.inverse, A),
        Mat.applyToPoint(this.inverse, B),
        filters
      )
    );
  }
  intersectCircle(center, radius, filters) {
    return Mat.applyToPoints(
      this.matrix,
      this.geometry.intersectCircle(
        Mat.applyToPoint(this.inverse, center),
        radius / this.decomposed.scaleX,
        filters
      )
    );
  }
  intersectPolygon(polygon, filters) {
    return Mat.applyToPoints(
      this.matrix,
      this.geometry.intersectPolygon(Mat.applyToPoints(this.inverse, polygon), filters)
    );
  }
  intersectPolyline(polyline, filters) {
    return Mat.applyToPoints(
      this.matrix,
      this.geometry.intersectPolyline(Mat.applyToPoints(this.inverse, polyline), filters)
    );
  }
  transform(transform, opts) {
    return new _TransformedGeometry2d(this.geometry, Mat.Multiply(transform, this.matrix), {
      isLabel: (opts == null ? void 0 : opts.isLabel) ?? this.isLabel,
      isInternal: (opts == null ? void 0 : opts.isInternal) ?? this.isInternal,
      debugColor: (opts == null ? void 0 : opts.debugColor) ?? this.debugColor,
      ignore: (opts == null ? void 0 : opts.ignore) ?? this.ignore
    });
  }
  getSvgPathData() {
    throw new Error("Cannot get SVG path data for transformed geometry.");
  }
};

// ../node_modules/@tldraw/editor/dist-esm/lib/primitives/geometry/Group2d.mjs
var Group2d = class _Group2d extends Geometry2d {
  constructor(config) {
    super({ ...config, isClosed: true, isFilled: false });
    __publicField(this, "children", []);
    __publicField(this, "ignoredChildren", []);
    const addChildren = (children) => {
      for (const child of children) {
        if (child instanceof _Group2d) {
          addChildren(child.children);
        } else if (child.ignore) {
          this.ignoredChildren.push(child);
        } else {
          this.children.push(child);
        }
      }
    };
    addChildren(config.children);
    if (this.children.length === 0) throw Error("Group2d must have at least one child");
  }
  getVertices(filters) {
    if (this.isExcludedByFilter(filters)) return [];
    return this.children.filter((c) => !c.isExcludedByFilter(filters)).flatMap((c) => c.getVertices(filters));
  }
  nearestPoint(point, filters) {
    let dist = Infinity;
    let nearest;
    const { children } = this;
    if (children.length === 0) {
      throw Error("no children");
    }
    let p;
    let d;
    for (const child of children) {
      if (child.isExcludedByFilter(filters)) continue;
      p = child.nearestPoint(point, filters);
      d = Vec.Dist2(p, point);
      if (d < dist) {
        dist = d;
        nearest = p;
      }
    }
    if (!nearest) throw Error("nearest point not found");
    return nearest;
  }
  distanceToPoint(point, hitInside = false, filters) {
    let smallestDistance = Infinity;
    for (const child of this.children) {
      if (child.isExcludedByFilter(filters)) continue;
      const distance = child.distanceToPoint(point, hitInside, filters);
      if (distance < smallestDistance) {
        smallestDistance = distance;
      }
    }
    return smallestDistance;
  }
  hitTestPoint(point, margin, hitInside, filters = Geometry2dFilters.EXCLUDE_LABELS) {
    return !!this.children.filter((c) => !c.isExcludedByFilter(filters)).find((c) => c.hitTestPoint(point, margin, hitInside));
  }
  hitTestLineSegment(A, B, zoom, filters = Geometry2dFilters.EXCLUDE_LABELS) {
    return !!this.children.filter((c) => !c.isExcludedByFilter(filters)).find((c) => c.hitTestLineSegment(A, B, zoom));
  }
  intersectLineSegment(A, B, filters) {
    return this.children.flatMap((child) => {
      if (child.isExcludedByFilter(filters)) return EMPTY_ARRAY;
      return child.intersectLineSegment(A, B, filters);
    });
  }
  intersectCircle(center, radius, filters) {
    return this.children.flatMap((child) => {
      if (child.isExcludedByFilter(filters)) return EMPTY_ARRAY;
      return child.intersectCircle(center, radius, filters);
    });
  }
  getBoundsVertices() {
    if (this.excludeFromShapeBounds) return [];
    return this.children.flatMap((child) => child.getBoundsVertices());
  }
  intersectPolygon(polygon, filters) {
    return this.children.flatMap((child) => {
      if (child.isExcludedByFilter(filters)) return EMPTY_ARRAY;
      return child.intersectPolygon(polygon, filters);
    });
  }
  intersectPolyline(polyline, filters) {
    return this.children.flatMap((child) => {
      if (child.isExcludedByFilter(filters)) return EMPTY_ARRAY;
      return child.intersectPolyline(polyline, filters);
    });
  }
  interpolateAlongEdge(t2, filters) {
    const totalLength = this.getLength(filters);
    const distanceToTravel = t2 * totalLength;
    let distanceTraveled = 0;
    for (const child of this.children) {
      if (child.isExcludedByFilter(filters)) continue;
      const childLength = child.length;
      const newDistanceTraveled = distanceTraveled + childLength;
      if (newDistanceTraveled >= distanceToTravel) {
        return child.interpolateAlongEdge(
          invLerp(distanceTraveled, newDistanceTraveled, distanceToTravel),
          filters
        );
      }
      distanceTraveled = newDistanceTraveled;
    }
    return this.children[this.children.length - 1].interpolateAlongEdge(1, filters);
  }
  uninterpolateAlongEdge(point, filters) {
    const totalLength = this.getLength(filters);
    let closestChild = null;
    let closestDistance = Infinity;
    let distanceTraveled = 0;
    for (const child of this.children) {
      if (child.isExcludedByFilter(filters)) continue;
      const childLength = child.getLength(filters);
      const newDistanceTraveled = distanceTraveled + childLength;
      const distance = child.distanceToPoint(point, false, filters);
      if (distance < closestDistance) {
        closestDistance = distance;
        closestChild = {
          startLength: distanceTraveled,
          endLength: newDistanceTraveled,
          child
        };
      }
      distanceTraveled = newDistanceTraveled;
    }
    assert(closestChild);
    const normalizedDistanceInChild = closestChild.child.uninterpolateAlongEdge(point, filters);
    const childTLength = lerp(
      closestChild.startLength,
      closestChild.endLength,
      normalizedDistanceInChild
    );
    return childTLength / totalLength;
  }
  transform(transform) {
    return new _Group2d({
      children: this.children.map((c) => c.transform(transform)),
      isLabel: this.isLabel,
      debugColor: this.debugColor,
      ignore: this.ignore
    });
  }
  getArea() {
    return this.children[0].area;
  }
  toSimpleSvgPath() {
    let path = "";
    for (const child of this.children) {
      path += child.toSimpleSvgPath();
    }
    const corners = Box.FromPoints(this.boundsVertices).corners;
    for (let i = 0, n = corners.length; i < n; i++) {
      const corner = corners[i];
      const prevCorner = corners[(i - 1 + n) % n];
      const prevDist = corner.dist(prevCorner);
      const nextCorner = corners[(i + 1) % n];
      const nextDist = corner.dist(nextCorner);
      const A = corner.clone().lrp(prevCorner, 4 / prevDist);
      const B = corner;
      const C = corner.clone().lrp(nextCorner, 4 / nextDist);
      path += `M${A.x},${A.y} L${B.x},${B.y} L${C.x},${C.y} `;
    }
    return path;
  }
  getLength(filters) {
    let length = 0;
    for (const child of this.children) {
      if (child.isExcludedByFilter(filters)) continue;
      length += child.length;
    }
    return length;
  }
  getSvgPathData() {
    return this.children.map((c, i) => c.isLabel ? "" : c.getSvgPathData(i === 0)).join(" ");
  }
  overlapsPolygon(polygon) {
    return this.children.some((child) => child.overlapsPolygon(polygon));
  }
};

// ../node_modules/@tldraw/editor/dist-esm/lib/primitives/geometry/Edge2d.mjs
var Edge2d = class extends Geometry2d {
  constructor(config) {
    super({ ...config, isClosed: false, isFilled: false });
    __publicField(this, "_start");
    __publicField(this, "_end");
    __publicField(this, "_d");
    __publicField(this, "_u");
    __publicField(this, "_ul");
    const { start, end } = config;
    this._start = start;
    this._end = end;
    this._d = start.clone().sub(end);
    this._u = this._d.clone().uni();
    this._ul = this._u.len();
  }
  getLength() {
    return this._d.len();
  }
  getVertices() {
    return [this._start, this._end];
  }
  nearestPoint(point) {
    const { _start: start, _end: end, _d: d, _u: u, _ul: l } = this;
    if (d.len() === 0) return start;
    if (l === 0) return start;
    const k = Vec.Sub(point, start).dpr(u) / l;
    const cx = start.x + u.x * k;
    if (cx < Math.min(start.x, end.x)) return start.x < end.x ? start : end;
    if (cx > Math.max(start.x, end.x)) return start.x > end.x ? start : end;
    const cy = start.y + u.y * k;
    if (cy < Math.min(start.y, end.y)) return start.y < end.y ? start : end;
    if (cy > Math.max(start.y, end.y)) return start.y > end.y ? start : end;
    return new Vec(cx, cy);
  }
  getSvgPathData(first2 = true) {
    const { _start: start, _end: end } = this;
    return `${first2 ? `M${start.toFixed()}` : ``} L${end.toFixed()}`;
  }
};

// ../node_modules/@tldraw/editor/dist-esm/lib/primitives/geometry/Polyline2d.mjs
var Polyline2d = class extends Geometry2d {
  constructor(config) {
    super({ isClosed: false, isFilled: false, ...config });
    __publicField(this, "_points");
    __publicField(this, "_segments");
    const { points } = config;
    this._points = points;
    if (points.length < 2) {
      throw new Error("Polyline2d: points must be an array of at least 2 points");
    }
  }
  // eslint-disable-next-line no-restricted-syntax
  get segments() {
    if (!this._segments) {
      this._segments = [];
      const { vertices } = this;
      for (let i = 0, n = vertices.length - 1; i < n; i++) {
        const start = vertices[i];
        const end = vertices[i + 1];
        this._segments.push(new Edge2d({ start, end }));
      }
      if (this.isClosed) {
        this._segments.push(new Edge2d({ start: vertices[vertices.length - 1], end: vertices[0] }));
      }
    }
    return this._segments;
  }
  getLength() {
    return this.segments.reduce((acc, segment) => acc + segment.length, 0);
  }
  getVertices() {
    return this._points;
  }
  nearestPoint(A) {
    const { segments } = this;
    let nearest = this._points[0];
    let dist = Infinity;
    let p;
    let d;
    for (let i = 0; i < segments.length; i++) {
      p = segments[i].nearestPoint(A);
      d = Vec.Dist2(p, A);
      if (d < dist) {
        nearest = p;
        dist = d;
      }
    }
    if (!nearest) throw Error("nearest point not found");
    return nearest;
  }
  hitTestLineSegment(A, B, distance = 0) {
    const { segments } = this;
    for (let i = 0, n = segments.length; i < n; i++) {
      if (segments[i].hitTestLineSegment(A, B, distance)) {
        return true;
      }
    }
    return false;
  }
  getSvgPathData() {
    const { vertices } = this;
    if (vertices.length < 2) return "";
    return vertices.reduce((acc, vertex, i) => {
      if (i === 0) return `M ${vertex.x} ${vertex.y}`;
      return `${acc} L ${vertex.x} ${vertex.y}`;
    }, "");
  }
};

// ../node_modules/@tldraw/editor/dist-esm/lib/primitives/geometry/Polygon2d.mjs
var Polygon2d = class extends Polyline2d {
  constructor(config) {
    super({ ...config });
    this.isClosed = true;
    if (config.points.length < 3) {
      throw new Error("Polygon2d: points must be an array of at least 3 points");
    }
  }
};

// ../node_modules/@tldraw/editor/dist-esm/lib/primitives/geometry/Rectangle2d.mjs
var Rectangle2d = class extends Polygon2d {
  constructor(config) {
    const { x = 0, y = 0, width, height } = config;
    super({
      ...config,
      points: [
        new Vec(x, y),
        new Vec(x + width, y),
        new Vec(x + width, y + height),
        new Vec(x, y + height)
      ]
    });
    __publicField(this, "_x");
    __publicField(this, "_y");
    __publicField(this, "_w");
    __publicField(this, "_h");
    this._x = x;
    this._y = y;
    this._w = width;
    this._h = height;
  }
  getBounds() {
    return new Box(this._x, this._y, this._w, this._h);
  }
  getSvgPathData() {
    const { _x: x, _y: y, _w: w, _h: h2 } = this;
    this.negativeZeroFix();
    return `M${x},${y} h${w} v${h2} h${-w}z`;
  }
  negativeZeroFix() {
    this._x = zeroFix(this._x);
    this._y = zeroFix(this._y);
    this._w = zeroFix(this._w);
    this._h = zeroFix(this._h);
  }
};
function zeroFix(value) {
  if (Object.is(value, -0)) return 0;
  return value;
}

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/shapes/ShapeUtil.mjs
var ShapeUtil = class {
  constructor(editor) {
    /**
     * Options for this shape util. If you're implementing a custom shape util, you can override
     * this to provide customization options for your shape. If using an existing shape util, you
     * can customizing this by calling {@link ShapeUtil.configure}.
     */
    __publicField(this, "options", {});
    this.editor = editor;
  }
  /** Configure this shape utils {@link ShapeUtil.options | `options`}. */
  static configure(options2) {
    return class extends this {
      constructor() {
        super(...arguments);
        // @ts-expect-error
        __publicField(this, "options", { ...this.options, ...options2 });
      }
    };
  }
  /**
   * Get the font faces that should be rendered in the document in order for this shape to render
   * correctly.
   *
   * @param shape - The shape.
   * @public
   */
  getFontFaces(shape) {
    return EMPTY_ARRAY;
  }
  /**
   * Whether the shape can be snapped to by another shape.
   *
   * @param shape - The shape.
   * @public
   */
  canSnap(shape) {
    return true;
  }
  /**
   * Whether the shape can be tabbed to.
   *
   * @param shape - The shape.
   * @public
   */
  canTabTo(shape) {
    return true;
  }
  /**
   * Whether the shape can be scrolled while editing.
   *
   * @public
   */
  canScroll(shape) {
    return false;
  }
  /**
   * Whether the shape can be bound to. See {@link TLShapeUtilCanBindOpts} for details.
   *
   * @public
   */
  canBind(_opts) {
    return true;
  }
  /**
   * Whether the shape can be double clicked to edit.
   *
   * @public
   */
  canEdit(shape, info) {
    return false;
  }
  /**
   * Whether the shape can be resized.
   *
   * @public
   */
  canResize(shape) {
    return true;
  }
  /**
   * When the shape is resized, whether the shape's children should also be resized.
   *
   * @public
   */
  canResizeChildren(shape) {
    return true;
  }
  /**
   * Whether the shape can be edited in read-only mode.
   *
   * @public
   */
  canEditInReadonly(shape) {
    return false;
  }
  /**
   * Whether the shape can be edited while locked or while an ancestor is locked.
   *
   * @public
   */
  canEditWhileLocked(shape) {
    return false;
  }
  /**
   * Whether the shape can be cropped.
   *
   * @public
   */
  canCrop(shape) {
    return false;
  }
  /**
   * Whether the shape can participate in layout functions such as alignment or distribution.
   *
   * @param shape - The shape.
   * @param info - Additional context information: the type of action causing the layout and the
   * @public
   *
   * @public
   */
  canBeLaidOut(shape, info) {
    return true;
  }
  /**
   * Whether this shape can be culled. By default, shapes are culled for
   * performance reasons when they are outside of the viewport. Culled shapes are still rendered
   * to the DOM, but have their `display` property set to `none`.
   *
   * @param shape - The shape.
   */
  canCull(shape) {
    return true;
  }
  /**
   * Does this shape provide a background for its children? If this is true,
   * then any children with a `renderBackground` method will have their
   * backgrounds rendered _above_ this shape. Otherwise, the children's
   * backgrounds will be rendered above either the next ancestor that provides
   * a background, or the canvas background.
   *
   * @internal
   */
  providesBackgroundForChildren(shape) {
    return false;
  }
  /**
   * Whether the shape should hide its resize handles when selected.
   *
   * @public
   */
  hideResizeHandles(shape) {
    return false;
  }
  /**
   * Whether the shape should hide its rotation handles when selected.
   *
   * @public
   */
  hideRotateHandle(shape) {
    return false;
  }
  /**
   * Whether the shape should hide its selection bounds background when selected.
   *
   * @public
   */
  hideSelectionBoundsBg(shape) {
    return false;
  }
  /**
   * Whether the shape should hide its selection bounds foreground when selected.
   *
   * @public
   */
  hideSelectionBoundsFg(shape) {
    return false;
  }
  /**
   * Whether the shape's aspect ratio is locked.
   *
   * @public
   */
  isAspectRatioLocked(shape) {
    return false;
  }
  /**
   * By default, the bounds of an image export are the bounds of all the shapes it contains, plus
   * some padding. If an export includes a shape where `isExportBoundsContainer` is true, then the
   * padding is skipped _if the bounds of that shape contains all the other shapes_. This is
   * useful in cases like annotating on top of an image, where you usually want to avoid extra
   * padding around the image if you don't need it.
   *
   * @param shape - The shape to check
   * @returns True if this shape should be treated as an export bounds container
   */
  isExportBoundsContainer(shape) {
    return false;
  }
  /**
   * Get whether the shape can receive children of a given type.
   *
   * @param shape - The shape.
   * @param type - The shape type.
   * @public
   */
  canReceiveNewChildrenOfType(shape, _type) {
    return false;
  }
  /** @internal */
  expandSelectionOutlinePx(shape) {
    return 0;
  }
  /**
   * Return elements to be added to the \<defs\> section of the canvases SVG context. This can be
   * used to define SVG content (e.g. patterns & masks) that can be referred to by ID from svg
   * elements returned by `component`.
   *
   * Each def should have a unique `key`. If multiple defs from different shapes all have the same
   * key, only one will be used.
   */
  getCanvasSvgDefs() {
    return [];
  }
  /**
   * Get the geometry to use when snapping to this this shape in translate/resize operations. See
   * {@link BoundsSnapGeometry} for details.
   */
  getBoundsSnapGeometry(shape) {
    return {};
  }
  /**
   * Get the geometry to use when snapping handles to this shape. See {@link HandleSnapGeometry}
   * for details.
   */
  getHandleSnapGeometry(shape) {
    return {};
  }
  getText(shape) {
    return void 0;
  }
  getAriaDescriptor(shape) {
    return void 0;
  }
};
/**
 * Props allow you to define the shape's properties in a way that the editor can understand.
 * This has two main uses:
 *
 * 1. Validation. Shapes will be validated using these props to stop bad data from being saved.
 * 2. Styles. Each {@link @tldraw/tlschema#StyleProp} in the props can be set on many shapes at
 *    once, and will be remembered from one shape to the next.
 *
 * @example
 * ```tsx
 * import {T, TLBaseShape, TLDefaultColorStyle, DefaultColorStyle, ShapeUtil} from 'tldraw'
 *
 * type MyShape = TLBaseShape<'mine', {
 *      color: TLDefaultColorStyle,
 *      text: string,
 * }>
 *
 * class MyShapeUtil extends ShapeUtil<MyShape> {
 *     static props = {
 *         // we use tldraw's built-in color style:
 *         color: DefaultColorStyle,
 *         // validate that the text prop is a string:
 *         text: T.string,
 *     }
 * }
 * ```
 */
__publicField(ShapeUtil, "props");
/**
 * Migrations allow you to make changes to a shape's props over time. Read the
 * {@link https://www.tldraw.dev/docs/persistence#Shape-props-migrations | shape prop migrations}
 * guide for more information.
 */
__publicField(ShapeUtil, "migrations");
/**
 * The type of the shape util, which should match the shape's type.
 *
 * @public
 */
__publicField(ShapeUtil, "type");

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/shapes/group/DashedOutlineBox.mjs
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/shapes/shared/getPerfectDashProps.mjs
function getPerfectDashProps(totalLength, strokeWidth, opts = {}) {
  const {
    closed = false,
    snap = 1,
    start = "outset",
    end = "outset",
    lengthRatio = 2,
    style: style2 = "dashed",
    forceSolid = false
  } = opts;
  let dashLength = 0;
  let dashCount = 0;
  let ratio = 1;
  let gapLength = 0;
  let strokeDashoffset = 0;
  if (forceSolid) {
    return {
      strokeDasharray: "none",
      strokeDashoffset: "none"
    };
  }
  switch (style2) {
    case "dashed": {
      ratio = 1;
      dashLength = Math.min(strokeWidth * lengthRatio, totalLength / 4);
      break;
    }
    case "dotted": {
      ratio = 100;
      dashLength = strokeWidth / ratio;
      break;
    }
    default: {
      return {
        strokeDasharray: "none",
        strokeDashoffset: "none"
      };
    }
  }
  if (!closed) {
    if (start === "outset") {
      totalLength += dashLength / 2;
      strokeDashoffset += dashLength / 2;
    } else if (start === "skip") {
      totalLength -= dashLength;
      strokeDashoffset -= dashLength;
    }
    if (end === "outset") {
      totalLength += dashLength / 2;
    } else if (end === "skip") {
      totalLength -= dashLength;
    }
  }
  dashCount = Math.floor(totalLength / dashLength / (2 * ratio));
  dashCount -= dashCount % snap;
  if (dashCount < 3 && style2 === "dashed") {
    if (totalLength / strokeWidth < 4) {
      dashLength = totalLength;
      dashCount = 1;
      gapLength = 0;
    } else {
      dashLength = totalLength * (1 / 3);
      gapLength = totalLength * (1 / 3);
    }
  } else {
    dashLength = totalLength / dashCount / (2 * ratio);
    if (closed) {
      strokeDashoffset = dashLength / 2;
      gapLength = (totalLength - dashCount * dashLength) / dashCount;
    } else {
      gapLength = (totalLength - dashCount * dashLength) / Math.max(1, dashCount - 1);
    }
  }
  return {
    strokeDasharray: [dashLength, gapLength].join(" "),
    strokeDashoffset: strokeDashoffset.toString()
  };
}

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/shapes/group/DashedOutlineBox.mjs
function DashedOutlineBox({ bounds, className }) {
  const editor = useEditor();
  const zoomLevel = useValue("zoom level", () => editor.getEfficientZoomLevel(), [editor]);
  return (0, import_jsx_runtime14.jsx)("g", { className, pointerEvents: "none", strokeLinecap: "round", strokeLinejoin: "round", children: bounds.sides.map((side, i) => {
    const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
      side[0].dist(side[1]),
      1 / zoomLevel,
      {
        style: "dashed",
        lengthRatio: 4
      }
    );
    return (0, import_jsx_runtime14.jsx)(
      "line",
      {
        x1: side[0].x,
        y1: side[0].y,
        x2: side[1].x,
        y2: side[1].y,
        strokeDasharray,
        strokeDashoffset
      },
      i
    );
  }) });
}

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/shapes/group/GroupShapeUtil.mjs
var GroupShapeUtil = class extends ShapeUtil {
  hideSelectionBoundsFg() {
    return true;
  }
  canBind() {
    return false;
  }
  canResize() {
    return true;
  }
  canResizeChildren() {
    return true;
  }
  getDefaultProps() {
    return {};
  }
  getGeometry(shape) {
    const children = this.editor.getSortedChildIdsForParent(shape.id);
    if (children.length === 0) {
      return new Rectangle2d({ width: 1, height: 1, isFilled: false });
    }
    return new Group2d({
      children: children.map((childId) => {
        const shape2 = this.editor.getShape(childId);
        return this.editor.getShapeGeometry(childId).transform(this.editor.getShapeLocalTransform(shape2), { isLabel: false });
      })
    });
  }
  component(shape) {
    const isErasing = this.editor.getErasingShapeIds().includes(shape.id);
    const { hintingShapeIds } = this.editor.getCurrentPageState();
    const isHintingOtherGroup = hintingShapeIds.length > 0 && hintingShapeIds.some(
      (id) => id !== shape.id && this.editor.isShapeOfType(this.editor.getShape(id), "group")
    );
    const isFocused = this.editor.getCurrentPageState().focusedGroupId !== shape.id;
    if (!isErasing && // always show the outline while we're erasing the group
    // show the outline while the group is focused unless something outside of the group is being hinted
    // this happens dropping shapes from a group onto some outside group
    (isFocused || isHintingOtherGroup)) {
      return null;
    }
    const bounds = this.editor.getShapeGeometry(shape).bounds;
    return (0, import_jsx_runtime15.jsx)(SVGContainer, { children: (0, import_jsx_runtime15.jsx)(DashedOutlineBox, { className: "tl-group", bounds }) });
  }
  indicator(shape) {
    const bounds = this.editor.getShapeGeometry(shape).bounds;
    return (0, import_jsx_runtime15.jsx)(DashedOutlineBox, { className: "", bounds });
  }
  onChildrenChange(group) {
    const children = this.editor.getSortedChildIdsForParent(group.id);
    if (children.length === 0) {
      if (this.editor.getCurrentPageState().focusedGroupId === group.id) {
        this.editor.popFocusedGroupId();
      }
      this.editor.deleteShapes([group.id]);
      return;
    } else if (children.length === 1) {
      if (this.editor.getCurrentPageState().focusedGroupId === group.id) {
        this.editor.popFocusedGroupId();
      }
      this.editor.reparentShapes(children, group.parentId);
      this.editor.deleteShapes([group.id]);
      return;
    }
  }
};
__publicField(GroupShapeUtil, "type", "group");
__publicField(GroupShapeUtil, "props", groupShapeProps);
__publicField(GroupShapeUtil, "migrations", groupShapeMigrations);

// ../node_modules/@tldraw/editor/dist-esm/lib/config/defaultShapes.mjs
var coreShapes = [
  // created by grouping interactions, probably the corest core shape that we have
  GroupShapeUtil
];
var coreShapeTypes = new Set(coreShapes.map((s) => s.type));
function checkShapesAndAddCore(customShapes) {
  const shapes = [...coreShapes];
  const addedCustomShapeTypes = /* @__PURE__ */ new Set();
  for (const customShape of customShapes) {
    if (coreShapeTypes.has(customShape.type)) {
      throw new Error(
        `Shape type "${customShape.type}" is a core shapes type and cannot be overridden`
      );
    }
    if (addedCustomShapeTypes.has(customShape.type)) {
      throw new Error(`Shape type "${customShape.type}" is defined more than once`);
    }
    shapes.push(customShape);
    addedCustomShapeTypes.add(customShape.type);
  }
  return shapes;
}

// ../node_modules/@tldraw/editor/dist-esm/lib/exports/exportToSvg.mjs
var import_react_dom2 = __toESM(require_react_dom(), 1);
var import_client = __toESM(require_client(), 1);

// ../node_modules/@tldraw/editor/dist-esm/lib/exports/fetchCache.mjs
function fetchCache(cb, init2) {
  const cache = /* @__PURE__ */ new Map();
  return async function fetchCached(url) {
    const existing = cache.get(url);
    if (existing) return existing;
    const promise = (async () => {
      try {
        const response = await fetch2(url, init2);
        assert(response.ok);
        return await cb(response);
      } catch (err) {
        console.error(err);
        return null;
      }
    })();
    cache.set(url, promise);
    return promise;
  };
}
var resourceToDataUrl = fetchCache(async (response) => {
  return await FileHelpers.blobToDataUrl(await response.blob());
});

// ../node_modules/@tldraw/editor/dist-esm/lib/exports/parseCss.mjs
var importsRegex = /@import\s+(?:"([^"]+)"|'([^']+)'|url\s*\(\s*(?:"([^"]+)"|'([^']+)'|([^'")]+))\s*\))([^;]+);/gi;
var fontFaceRegex = /@font-face\s*{([^}]+)}/gi;
var urlsRegex = /url\s*\(\s*(?:"([^"]+)"|'([^']+)'|([^'")]+))\s*\)/gi;
var fontFamilyRegex = /(?:^|;)\s*font-family\s*:\s*(?:([^'"][^;\n]+)|"([^"]+)"|'([^']+)')\s*(?:;|$)/gi;
function parseCssImports(css) {
  return Array.from(css.matchAll(importsRegex), (m) => ({
    url: m[1] || m[2] || m[3] || m[4] || m[5],
    extras: m[6]
  }));
}
function parseCssFontFaces(css, baseUrl) {
  return Array.from(css.matchAll(fontFaceRegex), (m) => {
    const fontFace = m[1];
    const urls = Array.from(fontFace.matchAll(urlsRegex), (m2) => {
      var _a6;
      const original = m2[1] || m2[2] || m2[3];
      return {
        original,
        resolved: ((_a6 = safeParseUrl(original, baseUrl)) == null ? void 0 : _a6.href) ?? null
      };
    });
    const fontFamilies = new Set(
      Array.from(fontFace.matchAll(fontFamilyRegex), (m2) => (m2[1] || m2[2] || m2[3]).toLowerCase())
    );
    return { fontFace, urls, fontFamilies };
  });
}
function parseCssFontFamilyValue(value) {
  const valueRegex = /\s*(?:([^'"][^;\n\s,]+)|"([^"]+)"|'([^']+)')\s*/gi;
  const separatorRegex = /\s*,\s*/gi;
  const fontFamilies = /* @__PURE__ */ new Set();
  while (true) {
    const valueMatch = valueRegex.exec(value);
    if (!valueMatch) {
      break;
    }
    const fontFamily = valueMatch[1] || valueMatch[2] || valueMatch[3];
    fontFamilies.add(fontFamily.toLowerCase());
    separatorRegex.lastIndex = valueRegex.lastIndex;
    const separatorMatch = separatorRegex.exec(value);
    if (!separatorMatch) {
      break;
    }
    valueRegex.lastIndex = separatorRegex.lastIndex;
  }
  return fontFamilies;
}
function shouldIncludeCssProperty(property) {
  if (property.startsWith("-")) return false;
  if (property.startsWith("animation")) return false;
  if (property.startsWith("transition")) return false;
  if (property === "cursor") return false;
  if (property === "pointer-events") return false;
  if (property === "user-select") return false;
  if (property === "touch-action") return false;
  return true;
}
function parseCss(css, baseUrl) {
  return {
    imports: parseCssImports(css),
    fontFaces: parseCssFontFaces(css, baseUrl)
  };
}
function parseCssValueUrls(value) {
  return Array.from(value.matchAll(urlsRegex), (m) => ({
    original: m[0],
    url: m[1] || m[2] || m[3]
  })).filter((m) => !m.url.startsWith("#"));
}

// ../node_modules/@tldraw/editor/dist-esm/lib/exports/FontEmbedder.mjs
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decoratorStart = (base2) => [, , , __create((base2 == null ? void 0 : base2[__knownSymbol("metadata")]) ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self2, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self2) : value = fns[i].call(self2, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc(k < 4 ? target : { get [name]() {
    return __privateGet2(this, extra);
  }, set [name](x) {
    return __privateSet2(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet2 : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet2(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __publicField2 = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg2) => member.has(obj) || __typeError("Cannot " + msg2);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet2 = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet2 = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _onFontFamilyValue_dec;
var _init;
var SVG_EXPORT_CLASSNAME = "tldraw-svg-export";
_onFontFamilyValue_dec = [bind];
var FontEmbedder = class {
  constructor() {
    __runInitializers(_init, 5, this);
    __publicField2(this, "fontFacesPromise", null);
    __publicField2(this, "foundFontNames", /* @__PURE__ */ new Set());
    __publicField2(this, "fontFacesToEmbed", /* @__PURE__ */ new Set());
    __publicField2(this, "pendingPromises", []);
  }
  startFindingCurrentDocumentFontFaces() {
    assert(!this.fontFacesPromise, "FontEmbedder already started");
    this.fontFacesPromise = getCurrentDocumentFontFaces();
  }
  onFontFamilyValue(fontFamilyValue) {
    assert(this.fontFacesPromise, "FontEmbedder not started");
    const fonts = parseCssFontFamilyValue(fontFamilyValue);
    for (const font of fonts) {
      if (this.foundFontNames.has(font)) return;
      this.foundFontNames.add(font);
      this.pendingPromises.push(
        this.fontFacesPromise.then((fontFaces) => {
          const relevantFontFaces = fontFaces.filter((fontFace) => fontFace.fontFamilies.has(font));
          for (const fontFace of relevantFontFaces) {
            if (this.fontFacesToEmbed.has(fontFace)) continue;
            this.fontFacesToEmbed.add(fontFace);
            for (const url of fontFace.urls) {
              if (!url.resolved || url.embedded) continue;
              url.embedded = resourceToDataUrl(url.resolved);
            }
          }
        })
      );
    }
  }
  async createCss() {
    await Promise.all(this.pendingPromises);
    let css = "";
    for (const fontFace of this.fontFacesToEmbed) {
      let fontFaceString = `@font-face {${fontFace.fontFace}}`;
      for (const url of fontFace.urls) {
        if (!url.embedded) continue;
        const dataUrl = await url.embedded;
        if (!dataUrl) continue;
        fontFaceString = fontFaceString.replace(url.original, dataUrl);
      }
      css += fontFaceString;
    }
    return css;
  }
};
_init = __decoratorStart(null);
__decorateElement(_init, 1, "onFontFamilyValue", _onFontFamilyValue_dec, FontEmbedder);
__decoratorMetadata(_init, FontEmbedder);
async function getCurrentDocumentFontFaces() {
  var _a6;
  const fontFaces = [];
  const styleSheetsWithoutSvgExports = Array.from(document.styleSheets).filter(
    (styleSheet) => {
      var _a7;
      return !((_a7 = styleSheet.ownerNode) == null ? void 0 : _a7.closest(`.${SVG_EXPORT_CLASSNAME}`));
    }
  );
  for (const styleSheet of styleSheetsWithoutSvgExports) {
    let cssRules2;
    try {
      cssRules2 = styleSheet.cssRules;
    } catch {
    }
    if (cssRules2) {
      for (const rule of styleSheet.cssRules) {
        if (rule instanceof CSSFontFaceRule) {
          fontFaces.push(parseCssFontFaces(rule.cssText, styleSheet.href ?? document.baseURI));
        } else if (rule instanceof CSSImportRule) {
          const absoluteUrl = new URL(rule.href, ((_a6 = rule.parentStyleSheet) == null ? void 0 : _a6.href) ?? document.baseURI);
          fontFaces.push(fetchCssFontFaces(absoluteUrl.href));
        }
      }
    } else if (styleSheet.href) {
      fontFaces.push(fetchCssFontFaces(styleSheet.href));
    }
  }
  return compact(await Promise.all(fontFaces)).flat();
}
var fetchCssFontFaces = fetchCache(async (response) => {
  const parsed = parseCss(await response.text(), response.url);
  const importedFontFaces = await Promise.all(
    parsed.imports.map(({ url }) => fetchCssFontFaces(new URL(url, response.url).href))
  );
  return [...parsed.fontFaces, ...compact(importedFontFaces).flat()];
});

// ../node_modules/@tldraw/editor/dist-esm/lib/exports/cssRules.mjs
var isCoveredByCurrentColor = (value, property, { currentColor }) => {
  return value === "currentColor" || value === currentColor;
};
var isInherited = (value, property, { parentStyles }) => {
  return parentStyles[property] === value;
};
var isExcludedBorder = (borderDirection) => (value, property, { getStyle }) => {
  const borderWidth = getStyle(`border-${borderDirection}-width`);
  const borderStyle = getStyle(`border-${borderDirection}-style`);
  if (borderWidth === "0px") return true;
  if (borderStyle === "none") return true;
  return false;
};
var cssRules = {
  // currentColor properties:
  "border-block-end-color": isCoveredByCurrentColor,
  "border-block-start-color": isCoveredByCurrentColor,
  "border-bottom-color": isCoveredByCurrentColor,
  "border-inline-end-color": isCoveredByCurrentColor,
  "border-inline-start-color": isCoveredByCurrentColor,
  "border-left-color": isCoveredByCurrentColor,
  "border-right-color": isCoveredByCurrentColor,
  "border-top-color": isCoveredByCurrentColor,
  "caret-color": isCoveredByCurrentColor,
  "column-rule-color": isCoveredByCurrentColor,
  "outline-color": isCoveredByCurrentColor,
  "text-decoration": (value, property, { currentColor }) => {
    return value === "none solid currentColor" || value === "none solid " + currentColor;
  },
  "text-decoration-color": isCoveredByCurrentColor,
  "text-emphasis-color": isCoveredByCurrentColor,
  // inherited properties:
  "border-collapse": isInherited,
  "border-spacing": isInherited,
  "caption-side": isInherited,
  // N.B. We shouldn't inherit 'color' because there's some UA styling, e.g. `mark` elements
  // 'color': isInherited,
  cursor: isInherited,
  direction: isInherited,
  "empty-cells": isInherited,
  "font-family": isInherited,
  "font-size": isInherited,
  "font-style": isInherited,
  "font-variant": isInherited,
  "font-weight": isInherited,
  "font-size-adjust": isInherited,
  "font-stretch": isInherited,
  font: isInherited,
  "letter-spacing": isInherited,
  "line-height": isInherited,
  "list-style-image": isInherited,
  "list-style-position": isInherited,
  "list-style-type": isInherited,
  "list-style": isInherited,
  orphans: isInherited,
  "overflow-wrap": isInherited,
  quotes: isInherited,
  "stroke-linecap": isInherited,
  "stroke-linejoin": isInherited,
  "tab-size": isInherited,
  "text-align": isInherited,
  "text-align-last": isInherited,
  "text-indent": isInherited,
  "text-justify": isInherited,
  "text-shadow": isInherited,
  "text-transform": isInherited,
  visibility: isInherited,
  "white-space": isInherited,
  "white-space-collapse": isInherited,
  widows: isInherited,
  "word-break": isInherited,
  "word-spacing": isInherited,
  "word-wrap": isInherited,
  // special border cases - we have a weird case (tailwind seems to trigger this) where all
  // border-styles sometimes get set to 'solid', but the border-width is 0 so they don't render.
  // but in SVGs, **sometimes**, the border-width defaults (i think from a UA style-sheet? but
  // honestly can't tell) to 1.5px so the border displays. we work around this by only including
  // border styles at all if both the border-width and border-style are set to something that
  // would show a border.
  "border-top": isExcludedBorder("top"),
  "border-right": isExcludedBorder("right"),
  "border-bottom": isExcludedBorder("bottom"),
  "border-left": isExcludedBorder("left"),
  "border-block-end": isExcludedBorder("block-end"),
  "border-block-start": isExcludedBorder("block-start"),
  "border-inline-end": isExcludedBorder("inline-end"),
  "border-inline-start": isExcludedBorder("inline-start"),
  "border-top-style": isExcludedBorder("top"),
  "border-right-style": isExcludedBorder("right"),
  "border-bottom-style": isExcludedBorder("bottom"),
  "border-left-style": isExcludedBorder("left"),
  "border-block-end-style": isExcludedBorder("block-end"),
  "border-block-start-style": isExcludedBorder("block-start"),
  "border-inline-end-style": isExcludedBorder("inline-end"),
  "border-inline-start-style": isExcludedBorder("inline-start"),
  "border-top-width": isExcludedBorder("top"),
  "border-right-width": isExcludedBorder("right"),
  "border-bottom-width": isExcludedBorder("bottom"),
  "border-left-width": isExcludedBorder("left"),
  "border-block-end-width": isExcludedBorder("block-end"),
  "border-block-start-width": isExcludedBorder("block-start"),
  "border-inline-end-width": isExcludedBorder("inline-end")
};

// ../node_modules/@tldraw/editor/dist-esm/lib/exports/domUtils.mjs
function getRenderedChildNodes(node) {
  if (node.shadowRoot) {
    return node.shadowRoot.childNodes;
  }
  if (isShadowSlotElement(node)) {
    const assignedNodes = node.assignedNodes();
    if (assignedNodes == null ? void 0 : assignedNodes.length) {
      return assignedNodes;
    }
  }
  return node.childNodes;
}
function* getRenderedChildren(node) {
  for (const child of getRenderedChildNodes(node)) {
    if (isElement(child)) yield child;
  }
}
function getWindow(node) {
  var _a6;
  return ((_a6 = node.ownerDocument) == null ? void 0 : _a6.defaultView) ?? globalThis;
}
function isElement(node) {
  return node instanceof getWindow(node).Element;
}
function isShadowRoot(node) {
  return node instanceof getWindow(node).ShadowRoot;
}
function isInShadowRoot(node) {
  return "getRootNode" in node && isShadowRoot(node.getRootNode());
}
function isShadowSlotElement(node) {
  return isInShadowRoot(node) && node instanceof getWindow(node).HTMLSlotElement;
}
function elementStyle(element) {
  return element.style;
}
function getComputedStyle2(element, pseudoElement) {
  return getWindow(element).getComputedStyle(element, pseudoElement);
}

// ../node_modules/@tldraw/editor/dist-esm/lib/exports/StyleEmbedder.mjs
var NO_STYLES = {};
var StyleEmbedder = class {
  constructor(root) {
    __publicField(this, "styles", /* @__PURE__ */ new Map());
    __publicField(this, "fonts", new FontEmbedder());
    this.root = root;
  }
  readRootElementStyles(rootElement) {
    this.readElementStyles(rootElement, {
      shouldRespectDefaults: false,
      shouldSkipInheritedParentStyles: false
    });
    const children = Array.from(getRenderedChildren(rootElement));
    while (children.length) {
      const child = children.pop();
      children.push(...getRenderedChildren(child));
      this.readElementStyles(child, {
        shouldRespectDefaults: true,
        shouldSkipInheritedParentStyles: true
      });
    }
  }
  readElementStyles(element, { shouldRespectDefaults = true, shouldSkipInheritedParentStyles = true }) {
    var _a6;
    const defaultStyles = shouldRespectDefaults ? getDefaultStylesForTagName(element.tagName.toLowerCase()) : NO_STYLES;
    const parentStyles = Object.assign({}, NO_STYLES);
    if (shouldSkipInheritedParentStyles) {
      let el = element.parentElement;
      while (el) {
        const currentStyles = (_a6 = this.styles.get(el)) == null ? void 0 : _a6.self;
        for (const style2 in currentStyles) {
          if (!parentStyles[style2]) {
            parentStyles[style2] = currentStyles[style2];
          }
        }
        el = el.parentElement;
      }
    }
    const info = {
      self: styleFromElement(element, { defaultStyles, parentStyles }),
      before: styleFromPseudoElement(element, "::before"),
      after: styleFromPseudoElement(element, "::after")
    };
    this.styles.set(element, info);
  }
  fetchResources() {
    const promises = [];
    for (const info of this.styles.values()) {
      for (const styles of objectMapValues(info)) {
        if (!styles) continue;
        for (const [property, value] of Object.entries(styles)) {
          if (!value) continue;
          if (property === "font-family") {
            this.fonts.onFontFamilyValue(value);
          }
          const urlMatches = parseCssValueUrls(value);
          if (urlMatches.length === 0) continue;
          promises.push(
            ...urlMatches.map(async ({ url, original }) => {
              const dataUrl = await resourceToDataUrl(url) ?? "data:";
              styles[property] = value.replace(original, `url("${dataUrl}")`);
            })
          );
        }
      }
    }
    return Promise.all(promises);
  }
  // custom elements are tricky. if we serialize the dom as-is, the custom elements wont have
  // their shadow-dom contents serialized. after we've read all the styles, we need to unwrap the
  // contents of each custom elements shadow dom directly into the parent element itself.
  unwrapCustomElements() {
    const visited = /* @__PURE__ */ new Set();
    const visit = (element, clonedParent) => {
      if (visited.has(element)) return;
      visited.add(element);
      const shadowRoot = element.shadowRoot;
      if (shadowRoot) {
        const clonedCustomEl = document.createElement("div");
        this.styles.set(clonedCustomEl, this.styles.get(element));
        clonedCustomEl.setAttribute("data-tl-custom-element", element.tagName);
        (clonedParent ?? element.parentElement).appendChild(clonedCustomEl);
        for (const child of shadowRoot.childNodes) {
          if (child instanceof Element) {
            visit(child, clonedCustomEl);
          } else {
            clonedCustomEl.appendChild(child.cloneNode(true));
          }
        }
        element.remove();
      } else if (clonedParent) {
        if (element.tagName.toLowerCase() === "style") {
          return;
        }
        const clonedEl = element.cloneNode(false);
        this.styles.set(clonedEl, this.styles.get(element));
        clonedParent.appendChild(clonedEl);
        for (const child of getRenderedChildNodes(element)) {
          if (child instanceof Element) {
            visit(child, clonedEl);
          } else {
            clonedEl.appendChild(child.cloneNode(true));
          }
        }
      }
    };
    for (const element of this.styles.keys()) {
      visit(element, null);
    }
  }
  embedStyles() {
    let css = "";
    for (const [element, info] of this.styles) {
      if (info.after || info.before) {
        const className = `pseudo-${uniqueId()}`;
        element.classList.add(className);
        if (info.before) {
          css += `.${className}::before {${formatCss(info.before)}}
`;
        }
        if (info.after) {
          css += `.${className}::after {${formatCss(info.after)}}
`;
        }
      }
      const style2 = elementStyle(element);
      for (const [property, value] of Object.entries(info.self)) {
        if (!value) continue;
        style2.setProperty(property, value);
      }
      if (style2.fontKerning === "auto") {
        style2.fontKerning = "normal";
      }
    }
    return css;
  }
  async getFontFaceCss() {
    return await this.fonts.createCss();
  }
  dispose() {
    destroyDefaultStyleFrame();
  }
};
function styleFromElement(element, { defaultStyles, parentStyles }) {
  if (element.computedStyleMap) {
    return styleFromComputedStyleMap(element.computedStyleMap(), { defaultStyles, parentStyles });
  }
  return styleFromComputedStyle(getComputedStyle2(element), { defaultStyles, parentStyles });
}
function styleFromPseudoElement(element, pseudo) {
  const style2 = getComputedStyle2(element, pseudo);
  const content = style2.getPropertyValue("content");
  if (content === "" || content === "none") {
    return void 0;
  }
  return styleFromComputedStyle(style2, { defaultStyles: NO_STYLES, parentStyles: NO_STYLES });
}
function styleFromComputedStyleMap(style2, { defaultStyles, parentStyles }) {
  var _a6;
  const styles = {};
  const currentColor = ((_a6 = style2.get("color")) == null ? void 0 : _a6.toString()) || "";
  const ruleOptions = {
    currentColor,
    parentStyles,
    defaultStyles,
    getStyle: (property) => {
      var _a7;
      return ((_a7 = style2.get(property)) == null ? void 0 : _a7.toString()) ?? "";
    }
  };
  for (const property of style2.keys()) {
    if (!shouldIncludeCssProperty(property)) continue;
    const value = style2.get(property).toString();
    if (defaultStyles[property] === value) continue;
    const rule = getOwnProperty(cssRules, property);
    if (rule && rule(value, property, ruleOptions)) continue;
    styles[property] = value;
  }
  return styles;
}
function styleFromComputedStyle(style2, { defaultStyles, parentStyles }) {
  const styles = {};
  const currentColor = style2.color;
  const ruleOptions = {
    currentColor,
    parentStyles,
    defaultStyles,
    getStyle: (property) => style2.getPropertyValue(property)
  };
  for (const property in style2) {
    if (!shouldIncludeCssProperty(property)) continue;
    const value = style2.getPropertyValue(property);
    if (defaultStyles[property] === value) continue;
    const rule = getOwnProperty(cssRules, property);
    if (rule && rule(value, property, ruleOptions)) continue;
    styles[property] = value;
  }
  return styles;
}
function formatCss(style2) {
  let cssText = "";
  for (const [property, value] of Object.entries(style2)) {
    cssText += `${property}: ${value};`;
  }
  return cssText;
}
var defaultStyleFrame;
var defaultStylesByTagName = {};
function getDefaultStyleFrame() {
  if (!defaultStyleFrame) {
    const frame = document.createElement("iframe");
    frame.style.display = "none";
    document.body.appendChild(frame);
    const frameDocument = assertExists(frame.contentDocument, "frame must have a document");
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    const foreignObject = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
    svg.appendChild(foreignObject);
    frameDocument.body.appendChild(svg);
    defaultStyleFrame = { iframe: frame, foreignObject, document: frameDocument };
  }
  return defaultStyleFrame;
}
function destroyDefaultStyleFrame() {
  if (defaultStyleFrame) {
    document.body.removeChild(defaultStyleFrame.iframe);
    defaultStyleFrame = void 0;
  }
}
var defaultStyleReadOptions = { defaultStyles: NO_STYLES, parentStyles: NO_STYLES };
function getDefaultStylesForTagName(tagName) {
  let existing = defaultStylesByTagName[tagName];
  if (!existing) {
    const { foreignObject, document: document2 } = getDefaultStyleFrame();
    const element = document2.createElement(tagName);
    foreignObject.appendChild(element);
    existing = element.computedStyleMap ? styleFromComputedStyleMap(element.computedStyleMap(), defaultStyleReadOptions) : styleFromComputedStyle(getComputedStyle2(element), defaultStyleReadOptions);
    foreignObject.removeChild(element);
    defaultStylesByTagName[tagName] = existing;
  }
  return existing;
}

// ../node_modules/@tldraw/editor/dist-esm/lib/exports/embedMedia.mjs
function copyAttrs(source, target) {
  const attrs = Array.from(source.attributes);
  attrs.forEach((attr) => {
    target.setAttribute(attr.name, attr.value);
  });
}
function replace(original, replacement) {
  original.replaceWith(replacement);
  return replacement;
}
async function createImage(dataUrl, cloneAttributesFrom) {
  const image = document.createElement("img");
  if (cloneAttributesFrom) {
    copyAttrs(cloneAttributesFrom, image);
  }
  image.setAttribute("src", dataUrl ?? "data:");
  image.setAttribute("decoding", "sync");
  image.setAttribute("loading", "eager");
  try {
    await image.decode();
  } catch {
  }
  return image;
}
async function getCanvasReplacement(canvas) {
  try {
    const dataURL = canvas.toDataURL();
    return await createImage(dataURL, canvas);
  } catch {
    return await createImage(null, canvas);
  }
}
async function getVideoReplacement(video) {
  try {
    const dataUrl = await MediaHelpers.getVideoFrameAsDataUrl(video);
    return createImage(dataUrl, video);
  } catch (err) {
    console.error("Could not get video frame", err);
  }
  if (video.poster) {
    const dataUrl = await resourceToDataUrl(video.poster);
    return createImage(dataUrl, video);
  }
  return createImage(null, video);
}
async function embedMedia(node) {
  if (node instanceof HTMLCanvasElement) {
    return replace(node, await getCanvasReplacement(node));
  } else if (node instanceof HTMLVideoElement) {
    return replace(node, await getVideoReplacement(node));
  } else if (node instanceof HTMLImageElement) {
    const src = node.currentSrc || node.src;
    const dataUrl = await resourceToDataUrl(src);
    node.setAttribute("src", dataUrl ?? "data:");
    node.setAttribute("decoding", "sync");
    node.setAttribute("loading", "eager");
    try {
      await node.decode();
    } catch {
    }
    return node;
  } else if (node instanceof HTMLInputElement) {
    node.setAttribute("value", node.value);
  } else if (node instanceof HTMLTextAreaElement) {
    node.textContent = node.value;
  }
  await Promise.all(
    Array.from(getRenderedChildren(node), (child) => embedMedia(child))
  );
}

// ../node_modules/@tldraw/editor/dist-esm/lib/exports/getSvgJsx.mjs
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var import_react23 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);

// ../node_modules/@tldraw/editor/dist-esm/lib/components/Shape.mjs
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var import_react20 = __toESM(require_react(), 1);

// ../node_modules/@tldraw/editor/dist-esm/lib/utils/areShapesContentEqual.mjs
var areShapesContentEqual = (a, b) => a.props === b.props && a.meta === b.meta;

// ../node_modules/@tldraw/editor/dist-esm/lib/components/Shape.mjs
var Shape = (0, import_react20.memo)(function Shape2({
  id,
  shape,
  util,
  index: index2,
  backgroundIndex,
  opacity
}) {
  const editor = useEditor();
  const { ShapeErrorFallback, ShapeWrapper } = useEditorComponents();
  const containerRef = (0, import_react20.useRef)(null);
  const bgContainerRef = (0, import_react20.useRef)(null);
  (0, import_react20.useEffect)(() => {
    return react("load fonts", () => {
      const fonts = editor.fonts.getShapeFontFaces(id);
      editor.fonts.requestFonts(fonts);
    });
  }, [editor, id]);
  const memoizedStuffRef = (0, import_react20.useRef)({
    transform: "",
    clipPath: "none",
    width: 0,
    height: 0,
    x: 0,
    y: 0,
    isCulled: false
  });
  useQuickReactor(
    "set shape stuff",
    () => {
      const shape2 = editor.getShape(id);
      if (!shape2) return;
      const prev = memoizedStuffRef.current;
      const clipPath = editor.getShapeClipPath(id) ?? "none";
      if (clipPath !== prev.clipPath) {
        setStyleProperty(containerRef.current, "clip-path", clipPath);
        setStyleProperty(bgContainerRef.current, "clip-path", clipPath);
        prev.clipPath = clipPath;
      }
      const pageTransform = editor.getShapePageTransform(id);
      const transform = Mat.toCssString(pageTransform);
      const bounds = editor.getShapeGeometry(shape2).bounds;
      if (transform !== prev.transform) {
        setStyleProperty(containerRef.current, "transform", transform);
        setStyleProperty(bgContainerRef.current, "transform", transform);
        prev.transform = transform;
      }
      const width = Math.max(bounds.width, 1);
      const height = Math.max(bounds.height, 1);
      if (width !== prev.width || height !== prev.height) {
        setStyleProperty(containerRef.current, "width", width + "px");
        setStyleProperty(containerRef.current, "height", height + "px");
        setStyleProperty(bgContainerRef.current, "width", width + "px");
        setStyleProperty(bgContainerRef.current, "height", height + "px");
        prev.width = width;
        prev.height = height;
      }
    },
    [editor]
  );
  (0, import_react20.useLayoutEffect)(() => {
    const container = containerRef.current;
    const bgContainer = bgContainerRef.current;
    setStyleProperty(container, "opacity", opacity);
    setStyleProperty(bgContainer, "opacity", opacity);
    setStyleProperty(container, "z-index", index2);
    setStyleProperty(bgContainer, "z-index", backgroundIndex);
  }, [opacity, index2, backgroundIndex]);
  useQuickReactor(
    "set display",
    () => {
      const shape2 = editor.getShape(id);
      if (!shape2) return;
      const culledShapes = editor.getCulledShapes();
      const isCulled = culledShapes.has(id);
      if (isCulled !== memoizedStuffRef.current.isCulled) {
        setStyleProperty(containerRef.current, "display", isCulled ? "none" : "block");
        setStyleProperty(bgContainerRef.current, "display", isCulled ? "none" : "block");
        memoizedStuffRef.current.isCulled = isCulled;
      }
    },
    [editor]
  );
  const annotateError2 = (0, import_react20.useCallback)(
    (error) => editor.annotateError(error, { origin: "shape", willCrashApp: false }),
    [editor]
  );
  if (!shape || !ShapeWrapper) return null;
  return (0, import_jsx_runtime16.jsxs)(import_jsx_runtime16.Fragment, { children: [
    util.backgroundComponent && (0, import_jsx_runtime16.jsx)(ShapeWrapper, { ref: bgContainerRef, shape, isBackground: true, children: (0, import_jsx_runtime16.jsx)(OptionalErrorBoundary, { fallback: ShapeErrorFallback, onError: annotateError2, children: (0, import_jsx_runtime16.jsx)(InnerShapeBackground, { shape, util }) }) }),
    (0, import_jsx_runtime16.jsx)(ShapeWrapper, { ref: containerRef, shape, isBackground: false, children: (0, import_jsx_runtime16.jsx)(OptionalErrorBoundary, { fallback: ShapeErrorFallback, onError: annotateError2, children: (0, import_jsx_runtime16.jsx)(InnerShape, { shape, util }) }) })
  ] });
});
var InnerShape = (0, import_react20.memo)(
  function InnerShape2({ shape, util }) {
    return useStateTracking(
      "InnerShape:" + shape.type,
      () => (
        // always fetch the latest shape from the store even if the props/meta have not changed, to avoid
        // calling the render method with stale data.
        util.component(util.editor.store.unsafeGetWithoutCapture(shape.id))
      ),
      [util, shape.id]
    );
  },
  (prev, next) => areShapesContentEqual(prev.shape, next.shape) && prev.util === next.util
);
var InnerShapeBackground = (0, import_react20.memo)(
  function InnerShapeBackground2({
    shape,
    util
  }) {
    return useStateTracking(
      "InnerShape:" + shape.type,
      () => {
        var _a6;
        return (
          // always fetch the latest shape from the store even if the props/meta have not changed, to avoid
          // calling the render method with stale data.
          (_a6 = util.backgroundComponent) == null ? void 0 : _a6.call(util, util.editor.store.unsafeGetWithoutCapture(shape.id))
        );
      },
      [util, shape.id]
    );
  },
  (prev, next) => prev.shape.props === next.shape.props && prev.shape.meta === next.shape.meta && prev.util === next.util
);

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/types/SvgExportContext.mjs
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var import_react22 = __toESM(require_react(), 1);

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/useEvent.mjs
var import_react21 = __toESM(require_react(), 1);
function useEvent(handler) {
  const handlerRef = (0, import_react21.useRef)(void 0);
  (0, import_react21.useLayoutEffect)(() => {
    handlerRef.current = handler;
  });
  (0, import_react21.useDebugValue)(handler);
  return (0, import_react21.useCallback)((...args) => {
    const fn = handlerRef.current;
    assert(fn, "fn does not exist");
    return fn(...args);
  }, []);
}
function useReactiveEvent(handler) {
  const handlerAtom = useAtom("useReactiveEvent", () => handler);
  (0, import_react21.useLayoutEffect)(() => {
    handlerAtom.set(handler);
  });
  (0, import_react21.useDebugValue)(handler);
  return (0, import_react21.useCallback)(
    (...args) => {
      const fn = handlerAtom.get();
      assert(fn, "fn does not exist");
      return fn(...args);
    },
    [handlerAtom]
  );
}

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/types/SvgExportContext.mjs
var Context = (0, import_react22.createContext)(null);
function SvgExportContextProvider({
  context,
  editor,
  children
}) {
  const Provider3 = editor.options.exportProvider;
  return (0, import_jsx_runtime17.jsx)(EditorProvider, { editor, children: (0, import_jsx_runtime17.jsx)(ContainerProvider, { container: editor.getContainer(), children: (0, import_jsx_runtime17.jsx)(Context.Provider, { value: context, children: (0, import_jsx_runtime17.jsx)(Provider3, { children }) }) }) });
}
function useSvgExportContext() {
  return (0, import_react22.useContext)(Context);
}
function useDelaySvgExport() {
  const ctx = (0, import_react22.useContext)(Context);
  const [promise] = (0, import_react22.useState)(promiseWithResolve);
  (0, import_react22.useEffect)(() => {
    ctx == null ? void 0 : ctx.waitUntil(promise);
    return () => {
      promise.resolve();
    };
  }, [promise, ctx]);
  return useEvent(() => {
    promise.resolve();
  });
}

// ../node_modules/@tldraw/editor/dist-esm/lib/exports/ExportDelay.mjs
var __create2 = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __knownSymbol2 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError2 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name2 = (target, value) => __defProp2(target, "name", { value, configurable: true });
var __decoratorStart2 = (base2) => [, , , __create2((base2 == null ? void 0 : base2[__knownSymbol2("metadata")]) ?? null)];
var __decoratorStrings2 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn2 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError2("Function expected") : fn;
var __decoratorContext2 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings2[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError2("Already initialized") : fns.push(__expectFn2(fn || null)) });
var __decoratorMetadata2 = (array, target) => __defNormalProp2(target, __knownSymbol2("metadata"), array[3]);
var __runInitializers2 = (array, flags, self2, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self2) : value = fns[i].call(self2, value);
  return value;
};
var __decorateElement2 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings2[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc2(k < 4 ? target : { get [name]() {
    return __privateGet3(this, extra);
  }, set [name](x) {
    return __privateSet3(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name2(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name2(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext2(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn2(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet3 : __privateMethod2)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet3(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn2(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError2("Object expected");
    else __expectFn2(fn = it.get) && (desc.get = fn), __expectFn2(fn = it.set) && (desc.set = fn), __expectFn2(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata2(array, target), desc && __defProp2(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __publicField3 = (obj, key, value) => __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck2 = (obj, member, msg2) => member.has(obj) || __typeError2("Cannot " + msg2);
var __privateIn2 = (member, obj) => Object(obj) !== obj ? __typeError2('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet3 = (obj, member, getter) => (__accessCheck2(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet3 = (obj, member, value, setter) => (__accessCheck2(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod2 = (obj, member, method) => (__accessCheck2(obj, member, "access private method"), method);
var _waitUntil_dec;
var _init2;
_waitUntil_dec = [bind];
var ExportDelay = class {
  constructor(maxDelayTimeMs) {
    this.maxDelayTimeMs = maxDelayTimeMs;
    __runInitializers2(_init2, 5, this);
    __publicField3(this, "isResolved", false);
    __publicField3(this, "promisesToWaitFor", []);
  }
  waitUntil(promise) {
    if (this.isResolved) {
      throw new Error(
        "Cannot `waitUntil` - the export has already been resolved. Make sure to call `waitUntil` as soon as possible during an export - ie within the first react effect after rendering."
      );
    }
    this.promisesToWaitFor.push(
      promise.catch((err) => console.error("Error while waiting for export:", err))
    );
  }
  async resolvePromises() {
    let lastLength = null;
    while (this.promisesToWaitFor.length !== lastLength) {
      lastLength = this.promisesToWaitFor.length;
      await Promise.allSettled(this.promisesToWaitFor);
      await sleep(0);
    }
  }
  async resolve() {
    const timeoutPromise = sleep(this.maxDelayTimeMs).then(() => "timeout");
    const resolvePromise = this.resolvePromises().then(() => "resolved");
    const result = await Promise.race([timeoutPromise, resolvePromise]);
    if (result === "timeout") {
      console.warn("[tldraw] Export delay timed out after ${this.maxDelayTimeMs}ms");
    }
    this.isResolved = true;
  }
};
_init2 = __decoratorStart2(null);
__decorateElement2(_init2, 1, "waitUntil", _waitUntil_dec, ExportDelay);
__decoratorMetadata2(_init2, ExportDelay);

// ../node_modules/@tldraw/editor/dist-esm/lib/exports/getSvgJsx.mjs
function getSvgJsx(editor, ids, opts = {}) {
  var _a6, _b3;
  if (!window.document) throw Error("No document");
  const {
    scale = 1,
    // should we include the background in the export? or is it transparent?
    background = editor.getInstanceState().exportBackground,
    padding = editor.options.defaultSvgPadding,
    preserveAspectRatio
  } = opts;
  const isDarkMode = opts.darkMode ?? editor.user.getIsDarkMode();
  const shapeIdsToInclude = editor.getShapeAndDescendantIds(ids);
  const renderingShapes = editor.getUnorderedRenderingShapes(false).filter(({ id }) => shapeIdsToInclude.has(id));
  const singleFrameShapeId = ids.length === 1 && editor.isShapeOfType(editor.getShape(ids[0]), "frame") ? ids[0] : null;
  let bbox = null;
  if (opts.bounds) {
    bbox = opts.bounds.clone().expandBy(padding);
  } else {
    bbox = getExportDefaultBounds(editor, renderingShapes, padding, singleFrameShapeId);
  }
  if (!bbox) return;
  const w = bbox.width * scale;
  const h2 = bbox.height * scale;
  try {
    (_b3 = (_a6 = document.body).focus) == null ? void 0 : _b3.call(_a6);
  } catch {
  }
  const exportDelay = new ExportDelay(editor.options.maxExportDelayMs);
  const initialEffectPromise = promiseWithResolve();
  exportDelay.waitUntil(initialEffectPromise);
  const svg = (0, import_jsx_runtime18.jsx)(
    SvgExport,
    {
      editor,
      preserveAspectRatio,
      scale,
      pixelRatio: opts.pixelRatio ?? null,
      bbox,
      background,
      singleFrameShapeId,
      isDarkMode,
      renderingShapes,
      onMount: initialEffectPromise.resolve,
      waitUntil: exportDelay.waitUntil
    }
  );
  return { jsx: svg, width: w, height: h2, exportDelay };
}
function getExportDefaultBounds(editor, renderingShapes, padding, singleFrameShapeId) {
  let isBoundedByContainer = false;
  let bbox = null;
  for (const { id } of renderingShapes) {
    const maskedPageBounds = editor.getShapeMaskedPageBounds(id);
    if (!maskedPageBounds) continue;
    const shape = editor.getShape(id);
    const isContainer = editor.getShapeUtil(shape).isExportBoundsContainer(shape);
    if (bbox) {
      if (isContainer && Box.ContainsApproximately(maskedPageBounds, bbox)) {
        isBoundedByContainer = true;
        bbox = maskedPageBounds.clone();
      } else {
        if (isBoundedByContainer && !Box.ContainsApproximately(bbox, maskedPageBounds)) {
          isBoundedByContainer = false;
        }
        bbox.union(maskedPageBounds);
      }
    } else {
      isBoundedByContainer = isContainer;
      bbox = maskedPageBounds.clone();
    }
  }
  if (!bbox) return null;
  if (!singleFrameShapeId && !isBoundedByContainer) {
    bbox.expandBy(padding);
  }
  return bbox;
}
function SvgExport({
  editor,
  preserveAspectRatio,
  scale,
  pixelRatio,
  bbox,
  background,
  singleFrameShapeId,
  isDarkMode,
  renderingShapes,
  onMount,
  waitUntil
}) {
  const masksId = useUniqueSafeId();
  const theme = getDefaultColorTheme({ isDarkMode });
  const stateAtom = useAtom("export state", { defsById: {}, shapeElements: null });
  const { defsById, shapeElements } = useValue(stateAtom);
  const addExportDef = useEvent((def) => {
    stateAtom.update((state) => {
      if (hasOwnProperty(state.defsById, def.key)) return state;
      const promise = Promise.resolve(def.getElement());
      waitUntil(
        promise.then((result) => {
          stateAtom.update((state2) => ({
            ...state2,
            defsById: { ...state2.defsById, [def.key]: { pending: false, element: result } }
          }));
        })
      );
      return {
        ...state,
        defsById: { ...state.defsById, [def.key]: { pending: true, element: promise } }
      };
    });
  });
  const exportContext = (0, import_react23.useMemo)(
    () => ({
      isDarkMode,
      waitUntil,
      addExportDef,
      scale,
      pixelRatio,
      async resolveAssetUrl(assetId, width) {
        const asset = editor.getAsset(assetId);
        if (!asset || asset.type !== "image" && asset.type !== "video") return null;
        return await editor.resolveAssetUrl(assetId, {
          screenScale: scale * (width / asset.props.w),
          shouldResolveToOriginal: pixelRatio === null,
          dpr: pixelRatio ?? void 0
        });
      }
    }),
    [isDarkMode, waitUntil, addExportDef, scale, pixelRatio, editor]
  );
  const didRenderRef = (0, import_react23.useRef)(false);
  (0, import_react23.useLayoutEffect)(() => {
    if (didRenderRef.current) {
      throw new Error("SvgExport should only render once - do not use with react strict mode");
    }
    didRenderRef.current = true;
    (async () => {
      const shapeDefs = {};
      const unorderedShapeElementPromises = renderingShapes.map(
        async ({ id, opacity, index: index2, backgroundIndex }) => {
          var _a6, _b3;
          if (id === singleFrameShapeId) return [];
          const shape = editor.getShape(id);
          if (editor.isShapeOfType(shape, "group")) return [];
          const elements = [];
          const util = editor.getShapeUtil(shape);
          if (util.toSvg || util.toBackgroundSvg) {
            const [toSvgResult, toBackgroundSvgResult] = await Promise.all([
              (_a6 = util.toSvg) == null ? void 0 : _a6.call(util, shape, exportContext),
              (_b3 = util.toBackgroundSvg) == null ? void 0 : _b3.call(util, shape, exportContext)
            ]);
            const pageTransform = editor.getShapePageTransform(shape);
            let pageTransformString = pageTransform.toCssString();
            let scale2 = 1;
            if ("scale" in shape.props) {
              if (shape.props.scale !== 1) {
                scale2 = shape.props.scale;
                pageTransformString = `${pageTransformString} scale(${shape.props.scale}, ${shape.props.scale})`;
              }
            }
            const pageMask = editor.getShapeMask(shape.id);
            const shapeMask = pageMask ? Mat.From(Mat.Inverse(pageTransform)).applyToPoints(pageMask) : null;
            const shapeMaskId = suffixSafeId(masksId, shape.id);
            if (shapeMask) {
              shapeDefs[shapeMaskId] = {
                pending: false,
                element: (0, import_jsx_runtime18.jsx)("clipPath", { id: shapeMaskId, children: (0, import_jsx_runtime18.jsx)(
                  "path",
                  {
                    d: `M${shapeMask.map(({ x, y }) => `${x / scale2},${y / scale2}`).join("L")}Z`
                  }
                ) })
              };
            }
            if (toSvgResult) {
              elements.push({
                zIndex: index2,
                element: (0, import_jsx_runtime18.jsx)(
                  "g",
                  {
                    transform: pageTransformString,
                    opacity,
                    clipPath: pageMask ? `url(#${shapeMaskId})` : void 0,
                    children: toSvgResult
                  },
                  `fg_${shape.id}`
                )
              });
            }
            if (toBackgroundSvgResult) {
              elements.push({
                zIndex: backgroundIndex,
                element: (0, import_jsx_runtime18.jsx)(
                  "g",
                  {
                    transform: pageTransformString,
                    opacity,
                    clipPath: pageMask ? `url(#${shapeMaskId})` : void 0,
                    children: toBackgroundSvgResult
                  },
                  `bg_${shape.id}`
                )
              });
            }
          } else {
            elements.push({
              zIndex: index2,
              element: (0, import_jsx_runtime18.jsx)(
                ForeignObjectShape,
                {
                  shape,
                  util,
                  component: InnerShape,
                  className: "tl-shape",
                  bbox,
                  opacity
                },
                `fg_${shape.id}`
              )
            });
            if (util.backgroundComponent) {
              elements.push({
                zIndex: backgroundIndex,
                element: (0, import_jsx_runtime18.jsx)(
                  ForeignObjectShape,
                  {
                    shape,
                    util,
                    component: InnerShapeBackground,
                    className: "tl-shape tl-shape-background",
                    bbox,
                    opacity
                  },
                  `bg_${shape.id}`
                )
              });
            }
          }
          return elements;
        }
      );
      const unorderedShapeElements = (await Promise.all(unorderedShapeElementPromises)).flat();
      (0, import_react_dom.flushSync)(() => {
        stateAtom.update((state) => ({
          ...state,
          shapeElements: unorderedShapeElements.sort((a, b) => a.zIndex - b.zIndex).map(({ element }) => element),
          defsById: { ...state.defsById, ...shapeDefs }
        }));
      });
    })();
  }, [bbox, editor, exportContext, masksId, renderingShapes, singleFrameShapeId, stateAtom]);
  (0, import_react23.useEffect)(() => {
    const fontsInUse = /* @__PURE__ */ new Set();
    for (const { id } of renderingShapes) {
      for (const font of editor.fonts.getShapeFontFaces(id)) {
        fontsInUse.add(font);
      }
    }
    for (const font of fontsInUse) {
      addExportDef({
        key: uniqueId(),
        getElement: async () => {
          const declaration = await editor.fonts.toEmbeddedCssDeclaration(font);
          return (0, import_jsx_runtime18.jsx)("style", { nonce: editor.options.nonce, children: declaration });
        }
      });
    }
  }, [editor, renderingShapes, addExportDef]);
  (0, import_react23.useEffect)(() => {
    if (shapeElements === null) return;
    onMount();
  }, [onMount, shapeElements]);
  let backgroundColor = background ? theme.background : "transparent";
  if (singleFrameShapeId && background) {
    const frameShapeUtil = editor.getShapeUtil("frame");
    if (frameShapeUtil == null ? void 0 : frameShapeUtil.options.showColors) {
      const shape = editor.getShape(singleFrameShapeId);
      backgroundColor = getColorValue(theme, shape.props.color, "frameFill");
    } else {
      backgroundColor = theme.solid;
    }
  }
  return (0, import_jsx_runtime18.jsx)(SvgExportContextProvider, { editor, context: exportContext, children: (0, import_jsx_runtime18.jsxs)(
    "svg",
    {
      preserveAspectRatio,
      direction: "ltr",
      width: bbox.width * scale,
      height: bbox.height * scale,
      viewBox: `${bbox.minX} ${bbox.minY} ${bbox.width} ${bbox.height}`,
      strokeLinecap: "round",
      strokeLinejoin: "round",
      style: { backgroundColor },
      "data-color-mode": isDarkMode ? "dark" : "light",
      className: `tl-container tl-theme__force-sRGB ${isDarkMode ? "tl-theme__dark" : "tl-theme__light"}`,
      children: [
        (0, import_jsx_runtime18.jsx)("defs", { children: Object.entries(defsById).map(
          ([key, def]) => def.pending ? null : (0, import_jsx_runtime18.jsx)(import_react23.Fragment, { children: def.element }, key)
        ) }),
        shapeElements
      ]
    }
  ) });
}
function ForeignObjectShape({
  shape,
  util,
  className,
  component: Component2,
  bbox,
  opacity
}) {
  const editor = useEditor();
  const transform = Mat.Translate(-bbox.minX, -bbox.minY).multiply(
    editor.getShapePageTransform(shape.id)
  );
  const bounds = editor.getShapeGeometry(shape.id).bounds;
  const width = Math.max(bounds.width, 1);
  const height = Math.max(bounds.height, 1);
  return (0, import_jsx_runtime18.jsx)(ErrorBoundary, { fallback: () => null, children: (0, import_jsx_runtime18.jsx)(
    "foreignObject",
    {
      x: bbox.minX,
      y: bbox.minY,
      width: bbox.w,
      height: bbox.h,
      className: "tl-shape-foreign-object tl-export-embed-styles",
      children: (0, import_jsx_runtime18.jsx)(
        "div",
        {
          className,
          "data-shape-type": shape.type,
          style: {
            clipPath: editor.getShapeClipPath(shape.id),
            transform: transform.toCssString(),
            width,
            height,
            opacity
          },
          children: (0, import_jsx_runtime18.jsx)(Component2, { shape, util })
        }
      )
    }
  ) });
}

// ../node_modules/@tldraw/editor/dist-esm/lib/exports/exportToSvg.mjs
var idCounter = 1;
async function exportToSvg(editor, shapeIds, opts = {}) {
  const result = getSvgJsx(editor, shapeIds, opts);
  if (!result) return void 0;
  const container = editor.getContainer();
  const renderTarget = document.createElement("div");
  renderTarget.className = SVG_EXPORT_CLASSNAME;
  renderTarget.inert = true;
  renderTarget.tabIndex = -1;
  Object.assign(renderTarget.style, {
    position: "absolute",
    top: "0px",
    left: "0px",
    width: result.width + "px",
    height: result.height + "px",
    pointerEvents: "none",
    opacity: 0
  });
  container.appendChild(renderTarget);
  const root = (0, import_client.createRoot)(renderTarget, { identifierPrefix: `export_${idCounter++}_` });
  try {
    await Promise.resolve();
    (0, import_react_dom2.flushSync)(() => {
      root.render(result.jsx);
    });
    await result.exportDelay.resolve();
    const svg = renderTarget.firstElementChild;
    assert(svg instanceof SVGSVGElement, "Expected an SVG element");
    await applyChangesToForeignObjects(svg);
    return { svg, width: result.width, height: result.height };
  } finally {
    setTimeout(() => {
      root.unmount();
      container.removeChild(renderTarget);
    }, 0);
  }
}
async function applyChangesToForeignObjects(svg) {
  const foreignObjectChildren = [
    ...svg.querySelectorAll("foreignObject.tl-export-embed-styles > *")
  ];
  if (!foreignObjectChildren.length) return;
  const styleEmbedder = new StyleEmbedder(svg);
  try {
    styleEmbedder.fonts.startFindingCurrentDocumentFontFaces();
    await Promise.all(foreignObjectChildren.map((el) => embedMedia(el)));
    for (const el of foreignObjectChildren) {
      styleEmbedder.readRootElementStyles(el);
    }
    await styleEmbedder.fetchResources();
    const fontCss = await styleEmbedder.getFontFaceCss();
    styleEmbedder.unwrapCustomElements();
    const pseudoCss = styleEmbedder.embedStyles();
    if (fontCss || pseudoCss) {
      const style2 = document.createElementNS("http://www.w3.org/2000/svg", "style");
      style2.textContent = `${fontCss}
${pseudoCss}`;
      svg.prepend(style2);
    }
  } finally {
    styleEmbedder.dispose();
  }
}

// ../node_modules/@tldraw/editor/dist-esm/lib/utils/browserCanvasMaxSize.mjs
var maxCanvasSizes = null;
function getBrowserCanvasMaxSize() {
  if (!maxCanvasSizes) {
    maxCanvasSizes = {
      maxWidth: getCanvasSize("width"),
      // test very wide but 1 pixel tall canvases
      maxHeight: getCanvasSize("height"),
      // test very tall but 1 pixel wide canvases
      maxArea: getCanvasSize("area")
      // test square canvases
    };
  }
  return maxCanvasSizes;
}
var MAX_SAFE_CANVAS_DIMENSION = 8192;
var MAX_SAFE_CANVAS_AREA = 4096 * 4096;
var TEST_SIZES = {
  area: [
    // Chrome 70 (Mac, Win)
    // Chrome 68 (Android 4.4)
    // Edge 17 (Win)
    // Safari 7-12 (Mac)
    16384,
    // Chrome 68 (Android 7.1-9)
    14188,
    // Chrome 68 (Android 5)
    11402,
    // Firefox 63 (Mac, Win)
    11180,
    // Chrome 68 (Android 6)
    10836,
    // IE 9-11 (Win)
    8192,
    // IE Mobile (Windows Phone 8.x)
    // Safari (iOS 9 - 12)
    4096
  ],
  height: [
    // Safari 7-12 (Mac)
    // Safari (iOS 9-12)
    8388607,
    // Chrome 83 (Mac, Win)
    65535,
    // Chrome 70 (Mac, Win)
    // Chrome 68 (Android 4.4-9)
    // Firefox 63 (Mac, Win)
    32767,
    // Edge 17 (Win)
    // IE11 (Win)
    16384,
    // IE 9-10 (Win)
    8192,
    // IE Mobile (Windows Phone 8.x)
    4096
  ],
  width: [
    // Safari 7-12 (Mac)
    // Safari (iOS 9-12)
    4194303,
    // Chrome 83 (Mac, Win)
    65535,
    // Chrome 70 (Mac, Win)
    // Chrome 68 (Android 4.4-9)
    // Firefox 63 (Mac, Win)
    32767,
    // Edge 17 (Win)
    // IE11 (Win)
    16384,
    // IE 9-10 (Win)
    8192,
    // IE Mobile (Windows Phone 8.x)
    4096
  ]
};
function getCanvasSize(dimension) {
  const cropCvs = document.createElement("canvas");
  cropCvs.width = 1;
  cropCvs.height = 1;
  const cropCtx = cropCvs.getContext("2d");
  for (const size4 of TEST_SIZES[dimension]) {
    const w = dimension === "height" ? 1 : size4;
    const h2 = dimension === "width" ? 1 : size4;
    const testCvs = document.createElement("canvas");
    testCvs.width = w;
    testCvs.height = h2;
    const testCtx = testCvs.getContext("2d");
    testCtx.fillRect(w - 1, h2 - 1, 1, 1);
    cropCtx.drawImage(testCvs, w - 1, h2 - 1, 1, 1, 0, 0, 1, 1);
    const isTestPassed = cropCtx.getImageData(0, 0, 1, 1).data[3] !== 0;
    testCvs.width = 0;
    testCvs.height = 0;
    if (isTestPassed) {
      cropCvs.width = 0;
      cropCvs.height = 0;
      if (dimension === "area") {
        return size4 * size4;
      } else {
        return size4;
      }
    }
  }
  cropCvs.width = 0;
  cropCvs.height = 0;
  throw Error("Failed to determine maximum canvas dimension");
}
function clampToBrowserMaxCanvasSize(width, height) {
  if (width <= MAX_SAFE_CANVAS_DIMENSION && height <= MAX_SAFE_CANVAS_DIMENSION && width * height <= MAX_SAFE_CANVAS_AREA) {
    return [width, height];
  }
  const { maxWidth, maxHeight, maxArea } = getBrowserCanvasMaxSize();
  const aspectRatio = width / height;
  if (width > maxWidth) {
    width = maxWidth;
    height = width / aspectRatio;
  }
  if (height > maxHeight) {
    height = maxHeight;
    width = height * aspectRatio;
  }
  if (width * height > maxArea) {
    const ratio = Math.sqrt(maxArea / (width * height));
    width *= ratio;
    height *= ratio;
  }
  return [width, height];
}

// ../node_modules/@tldraw/editor/dist-esm/lib/exports/getSvgAsImage.mjs
async function getSvgAsImage(svgString, options2) {
  const { type, width, height, quality = 1, pixelRatio = 2 } = options2;
  let [clampedWidth, clampedHeight] = clampToBrowserMaxCanvasSize(
    width * pixelRatio,
    height * pixelRatio
  );
  clampedWidth = Math.floor(clampedWidth);
  clampedHeight = Math.floor(clampedHeight);
  const effectiveScale = clampedWidth / width;
  const svgUrl = await FileHelpers.blobToDataUrl(new Blob([svgString], { type: "image/svg+xml" }));
  const canvas = await new Promise((resolve) => {
    const image = Image();
    image.crossOrigin = "anonymous";
    image.onload = async () => {
      if (tlenv.isSafari) {
        await sleep(250);
      }
      const canvas2 = document.createElement("canvas");
      const ctx = canvas2.getContext("2d");
      canvas2.width = clampedWidth;
      canvas2.height = clampedHeight;
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      ctx.drawImage(image, 0, 0, clampedWidth, clampedHeight);
      URL.revokeObjectURL(svgUrl);
      resolve(canvas2);
    };
    image.onerror = () => {
      resolve(null);
    };
    image.src = svgUrl;
  });
  if (!canvas) return null;
  const blob = await new Promise(
    (resolve) => canvas.toBlob(
      (blob2) => {
        if (!blob2 || debugFlags.throwToBlob.get()) {
          resolve(null);
        }
        resolve(blob2);
      },
      "image/" + type,
      quality
    )
  );
  if (!blob) return null;
  if (type === "png") {
    const view = new DataView(await blob.arrayBuffer());
    return PngHelpers.setPhysChunk(view, effectiveScale, {
      type: "image/" + type
    });
  } else {
    return blob;
  }
}

// ../node_modules/@tldraw/editor/dist-esm/lib/globals/menus.mjs
var tlmenus = {
  /**
   * A set of strings representing any open menus. When menus are open,
   * certain interactions will behave differently; for example, when a
   * draw tool is selected and a menu is open, a pointer-down will not
   * create a dot (because the user is probably trying to close the menu)
   * however a pointer-down event followed by a drag will begin drawing
   * a line (because the user is BOTH trying to close the menu AND start
   * drawing a line).
   *
   * @public
   */
  menus: atom("open menus", []),
  /**
   * Get the current open menus.
   *
   * @param contextId - An optional context to get menus for.
   *
   * @public
   */
  getOpenMenus(contextId) {
    if (contextId) return this.menus.get().filter((m) => m.endsWith("-" + contextId));
    return this.menus.get();
  },
  /**
   * Add an open menu.
   *
   * @example
   * ```ts
   * addOpenMenu('menu-id')
   * addOpenMenu('menu-id', myEditorId)
   * ```
   *
   * @param id - The id of the menu to add.
   * @param contextId - An optional context to add the menu to.
   *
   * @public
   */
  addOpenMenu(id, contextId = "") {
    const idWithContext = contextId ? `${id}-${contextId}` : id;
    const menus = new Set(this.menus.get());
    if (!menus.has(idWithContext)) {
      menus.add(idWithContext);
      this.menus.set([...menus]);
    }
  },
  /**
   * Delete an open menu.
   *
   * @example
   * ```ts
   * deleteOpenMenu('menu-id')
   * deleteOpenMenu('menu-id', myEditorId)
   * ```
   *
   * @param id - The id of the menu to delete.
   * @param contextId - An optional context to delete the menu from.
   *
   * @public
   */
  deleteOpenMenu(id, contextId = "") {
    const idWithContext = contextId ? `${id}-${contextId}` : id;
    const menus = new Set(this.menus.get());
    if (menus.has(idWithContext)) {
      menus.delete(idWithContext);
      this.menus.set([...menus]);
    }
  },
  /**
   * Clear all open menus.
   *
   * @example
   * ```ts
   * clearOpenMenus()
   * clearOpenMenus(myEditorId)
   * ```
   *
   * @param contextId - An optional context to clear menus for.
   *
   * @public
   */
  clearOpenMenus(contextId) {
    this.menus.set(contextId ? this.menus.get().filter((m) => !m.endsWith("-" + contextId)) : []);
  },
  _hiddenMenus: [],
  /**
   * Hide all open menus. Restore them with the `showOpenMenus` method.
   *
   * @example
   * ```ts
   * hideOpenMenus()
   * hideOpenMenus(myEditorId)
   * ```
   *
   * @param contextId - An optional context to hide menus for.
   *
   * @public
   */
  hideOpenMenus(contextId) {
    this._hiddenMenus = [...this.getOpenMenus(contextId)];
    if (this._hiddenMenus.length === 0) return;
    for (const menu of this._hiddenMenus) {
      this.deleteOpenMenu(menu, contextId);
    }
  },
  /**
   * Show all hidden menus.
   *
   * @example
   * ```ts
   * showOpenMenus()
   * showOpenMenus(myEditorId)
   * ```
   *
   * @param contextId - An optional context to show menus for.
   *
   * @public
   */
  showOpenMenus(contextId) {
    if (this._hiddenMenus.length === 0) return;
    for (const menu of this._hiddenMenus) {
      this.addOpenMenu(menu, contextId);
    }
    this._hiddenMenus = [];
  },
  /**
   * Get whether a menu is open for a given context.
   *
   * @example
   * ```ts
   * isMenuOpem(id, myEditorId)
   * ```
   *
   * @param id - The id of the menu to check.
   * @param contextId - An optional context to check menus for.
   *
   * @public
   */
  isMenuOpen(id, contextId) {
    return this.getOpenMenus(contextId).includes(`${id}-${contextId}`);
  },
  /**
   * Get whether any menus are open for a given context.
   *
   * @example
   * ```ts
   * hasOpenMenus(myEditorId)
   * ```
   *
   * @param contextId - A context to check menus for.
   *
   * @public
   */
  hasOpenMenus(contextId) {
    return this.getOpenMenus(contextId).length > 0;
  },
  /**
   * Get whether any menus are open for any context.
   *
   * @example
   * ```ts
   * hasAnyOpenMenus()
   * ```
   *
   * @public
   */
  hasAnyOpenMenus() {
    return this.getOpenMenus().length > 0;
  },
  forContext(contextId) {
    return {
      getOpenMenus: () => this.getOpenMenus(contextId),
      addOpenMenu: (id) => this.addOpenMenu(id, contextId),
      deleteOpenMenu: (id) => this.deleteOpenMenu(id, contextId),
      clearOpenMenus: () => this.clearOpenMenus(contextId),
      // Gets whether any menus are open
      isMenuOpen: (id) => this.isMenuOpen(id, contextId),
      hasOpenMenus: () => this.hasOpenMenus(contextId),
      hasAnyOpenMenus: () => this.hasAnyOpenMenus()
    };
  }
};

// ../node_modules/@tldraw/editor/dist-esm/lib/globals/time.mjs
var tltime = new Timers();

// ../node_modules/@tldraw/editor/dist-esm/lib/options.mjs
var import_react24 = __toESM(require_react(), 1);
var defaultTldrawOptions = {
  maxShapesPerPage: 4e3,
  maxFilesAtOnce: 100,
  maxPages: 40,
  animationMediumMs: 320,
  followChaseViewportSnap: 2,
  doubleClickDurationMs: 450,
  multiClickDurationMs: 200,
  coarseDragDistanceSquared: 36,
  // 6 squared
  dragDistanceSquared: 16,
  // 4 squared
  uiDragDistanceSquared: 16,
  // 4 squared
  // it's really easy to accidentally drag from the toolbar on mobile, so we use a much larger
  // threshold than usual here to try and prevent accidental drags.
  uiCoarseDragDistanceSquared: 625,
  // 25 squared
  defaultSvgPadding: 32,
  cameraSlideFriction: 0.09,
  gridSteps: [
    { min: -1, mid: 0.15, step: 64 },
    { min: 0.05, mid: 0.375, step: 16 },
    { min: 0.15, mid: 1, step: 4 },
    { min: 0.7, mid: 2.5, step: 1 }
  ],
  collaboratorInactiveTimeoutMs: 6e4,
  collaboratorIdleTimeoutMs: 3e3,
  collaboratorCheckIntervalMs: 1200,
  cameraMovingTimeoutMs: 64,
  hitTestMargin: 8,
  edgeScrollDelay: 200,
  edgeScrollEaseDuration: 200,
  edgeScrollSpeed: 25,
  edgeScrollDistance: 8,
  coarsePointerWidth: 12,
  coarseHandleRadius: 20,
  handleRadius: 12,
  longPressDurationMs: 500,
  textShadowLod: 0.35,
  adjacentShapeMargin: 10,
  flattenImageBoundsExpand: 64,
  flattenImageBoundsPadding: 16,
  laserDelayMs: 1200,
  maxExportDelayMs: 5e3,
  tooltipDelayMs: 700,
  temporaryAssetPreviewLifetimeMs: 18e4,
  actionShortcutsLocation: "swap",
  createTextOnCanvasDoubleClick: true,
  exportProvider: import_react24.Fragment,
  enableToolbarKeyboardShortcuts: true,
  maxFontsToLoadBeforeRender: Infinity,
  nonce: void 0,
  debouncedZoom: true,
  debouncedZoomThreshold: 500,
  spacebarPanning: true,
  zoomToFitPadding: 128,
  snapThreshold: 8
};

// ../node_modules/@tldraw/editor/dist-esm/lib/utils/SharedStylesMap.mjs
function sharedStyleEquals(a, b) {
  if (!b) return false;
  switch (a.type) {
    case "mixed":
      return b.type === "mixed";
    case "shared":
      return b.type === "shared" && a.value === b.value;
    default:
      throw exhaustiveSwitchError(a);
  }
}
var ReadonlySharedStyleMap = class {
  constructor(entries) {
    /** @internal */
    __publicField(this, "map");
    this.map = new Map(entries);
  }
  get(prop) {
    return this.map.get(prop);
  }
  getAsKnownValue(prop) {
    const value = this.get(prop);
    if (!value) return void 0;
    if (value.type === "mixed") return void 0;
    return value.value;
  }
  // eslint-disable-next-line no-restricted-syntax
  get size() {
    return this.map.size;
  }
  equals(other) {
    if (this.size !== other.size) return false;
    const checkedKeys = /* @__PURE__ */ new Set();
    for (const [styleProp, value] of this) {
      if (!sharedStyleEquals(value, other.get(styleProp))) return false;
      checkedKeys.add(styleProp);
    }
    for (const [styleProp, value] of other) {
      if (checkedKeys.has(styleProp)) continue;
      if (!sharedStyleEquals(value, this.get(styleProp))) return false;
    }
    return true;
  }
  keys() {
    return this.map.keys();
  }
  values() {
    return this.map.values();
  }
  entries() {
    return this.map.entries();
  }
  [Symbol.iterator]() {
    return this.map[Symbol.iterator]();
  }
};
var SharedStyleMap = class extends ReadonlySharedStyleMap {
  set(prop, value) {
    this.map.set(prop, value);
  }
  applyValue(prop, value) {
    const existingValue = this.get(prop);
    if (!existingValue) {
      this.set(prop, { type: "shared", value });
      return;
    }
    switch (existingValue.type) {
      case "mixed":
        return;
      case "shared":
        if (existingValue.value !== value) {
          this.set(prop, { type: "mixed" });
        }
        return;
      default:
        exhaustiveSwitchError(existingValue, "type");
    }
  }
};

// ../node_modules/@tldraw/editor/dist-esm/lib/utils/assets.mjs
function dataUrlToFile(url, filename, mimeType) {
  return fetch2(url).then(function(res) {
    return res.arrayBuffer();
  }).then(function(buf) {
    return new File([buf], filename, { type: mimeType });
  });
}
var CDN_BASE_URL = "https://cdn.tldraw.com";
function getDefaultCdnBaseUrl() {
  return `${CDN_BASE_URL}/${version}`;
}

// ../node_modules/@tldraw/editor/dist-esm/lib/utils/deepLinks.mjs
function createDeepLinkString(deepLink) {
  switch (deepLink.type) {
    case "shapes": {
      const ids = deepLink.shapeIds.map((id) => encodeId(id.slice("shape:".length)));
      return `s${ids.join(".")}`;
    }
    case "page": {
      return "p" + encodeId(PageRecordType.parseId(deepLink.pageId));
    }
    case "viewport": {
      const { bounds, pageId } = deepLink;
      let res = `v${Math.round(bounds.x)}.${Math.round(bounds.y)}.${Math.round(bounds.w)}.${Math.round(bounds.h)}`;
      if (pageId) {
        res += "." + encodeId(PageRecordType.parseId(pageId));
      }
      return res;
    }
    default:
      exhaustiveSwitchError(deepLink);
  }
}
function parseDeepLinkString(deepLinkString) {
  const type = deepLinkString[0];
  switch (type) {
    case "s": {
      const shapeIds = deepLinkString.slice(1).split(".").filter(Boolean).map((id) => createShapeId(decodeURIComponent(id)));
      return { type: "shapes", shapeIds };
    }
    case "p": {
      const pageId = PageRecordType.createId(decodeURIComponent(deepLinkString.slice(1)));
      return { type: "page", pageId };
    }
    case "v": {
      const [x, y, w, h2, pageId] = deepLinkString.slice(1).split(".");
      return {
        type: "viewport",
        bounds: new Box(Number(x), Number(y), Number(w), Number(h2)),
        pageId: pageId ? PageRecordType.createId(decodeURIComponent(pageId)) : void 0
      };
    }
    default:
      throw Error("Invalid deep link string");
  }
}
function encodeId(str) {
  return encodeURIComponent(str).replace(/\./g, "%2E");
}

// ../node_modules/@tldraw/editor/dist-esm/lib/utils/getIncrementedName.mjs
function getIncrementedName(name, others) {
  var _a6;
  let result = name;
  const set = new Set(others);
  while (set.has(result)) {
    result = ((_a6 = /^.*(\d+)$/.exec(result)) == null ? void 0 : _a6[1]) ? result.replace(/(\d+)(?=\D?)$/, (m) => {
      return (+m + 1).toString();
    }) : `${result} 1`;
  }
  return result;
}

// ../node_modules/@tldraw/editor/dist-esm/lib/utils/reorderShapes.mjs
function getReorderingShapesChanges(editor, operation, ids, opts) {
  if (ids.length === 0) return [];
  const parents = /* @__PURE__ */ new Map();
  for (const shape of compact(ids.map((id) => editor.getShape(id)))) {
    const { parentId } = shape;
    if (!parents.has(parentId)) {
      parents.set(parentId, {
        children: compact(
          editor.getSortedChildIdsForParent(parentId).map((id) => editor.getShape(id))
        ),
        moving: /* @__PURE__ */ new Set()
      });
    }
    parents.get(parentId).moving.add(shape);
  }
  const changes = [];
  switch (operation) {
    case "toBack": {
      parents.forEach(({ moving, children }) => reorderToBack(moving, children, changes));
      break;
    }
    case "toFront": {
      parents.forEach(({ moving, children }) => reorderToFront(moving, children, changes));
      break;
    }
    case "forward": {
      parents.forEach(
        ({ moving, children }) => reorderForward(editor, moving, children, changes, opts)
      );
      break;
    }
    case "backward": {
      parents.forEach(
        ({ moving, children }) => reorderBackward(editor, moving, children, changes, opts)
      );
      break;
    }
  }
  return changes;
}
function reorderToBack(moving, children, changes) {
  const len = children.length;
  if (moving.size === len) return;
  let below;
  let above;
  for (let i = 0; i < len; i++) {
    const shape = children[i];
    if (moving.has(shape)) {
      below = shape.index;
      moving.delete(shape);
    } else {
      above = shape.index;
      break;
    }
  }
  if (moving.size === 0) {
    return;
  } else {
    const indices = getIndicesBetween(below, above, moving.size);
    changes.push(
      ...Array.from(moving.values()).sort(sortByIndex).map((shape, i) => ({ ...shape, index: indices[i] }))
    );
  }
}
function reorderToFront(moving, children, changes) {
  const len = children.length;
  if (moving.size === len) return;
  let below;
  let above;
  for (let i = len - 1; i > -1; i--) {
    const shape = children[i];
    if (moving.has(shape)) {
      above = shape.index;
      moving.delete(shape);
    } else {
      below = shape.index;
      break;
    }
  }
  if (moving.size === 0) {
    return;
  } else {
    const indices = getIndicesBetween(below, above, moving.size);
    changes.push(
      ...Array.from(moving.values()).sort(sortByIndex).map((shape, i) => ({ ...shape, index: indices[i] }))
    );
  }
}
function getOverlapChecker(editor, moving) {
  const movingBounds = compact(
    Array.from(moving).map((shape) => {
      const bounds = editor.getShapePageBounds(shape);
      if (!bounds) return null;
      return { shape, bounds };
    })
  );
  const isOverlapping = (child) => {
    const bounds = editor.getShapePageBounds(child);
    if (!bounds) return false;
    return movingBounds.some((other) => {
      return other.bounds.includes(bounds);
    });
  };
  return isOverlapping;
}
function reorderForward(editor, moving, children, changes, opts) {
  var _a6;
  const isOverlapping = getOverlapChecker(editor, moving);
  const len = children.length;
  if (moving.size === len) return;
  let state = { name: "skipping" };
  for (let i = 0; i < len; i++) {
    const isMoving = moving.has(children[i]);
    switch (state.name) {
      case "skipping": {
        if (!isMoving) continue;
        state = { name: "selecting", selectIndex: i };
        break;
      }
      case "selecting": {
        if (isMoving) continue;
        if (!(opts == null ? void 0 : opts.considerAllShapes) && !isOverlapping(children[i])) continue;
        const { selectIndex } = state;
        getIndicesBetween(children[i].index, (_a6 = children[i + 1]) == null ? void 0 : _a6.index, i - selectIndex).forEach(
          (index2, k) => {
            const child = children[selectIndex + k];
            if (!moving.has(child)) return;
            changes.push({ ...child, index: index2 });
          }
        );
        state = { name: "skipping" };
        break;
      }
    }
  }
}
function reorderBackward(editor, moving, children, changes, opts) {
  var _a6;
  const isOverlapping = getOverlapChecker(editor, moving);
  const len = children.length;
  if (moving.size === len) return;
  let state = { name: "skipping" };
  for (let i = len - 1; i > -1; i--) {
    const isMoving = moving.has(children[i]);
    switch (state.name) {
      case "skipping": {
        if (!isMoving) continue;
        state = { name: "selecting", selectIndex: i };
        break;
      }
      case "selecting": {
        if (isMoving) continue;
        if (!(opts == null ? void 0 : opts.considerAllShapes) && !isOverlapping(children[i])) continue;
        getIndicesBetween((_a6 = children[i - 1]) == null ? void 0 : _a6.index, children[i].index, state.selectIndex - i).forEach(
          (index2, k) => {
            const child = children[i + k + 1];
            if (!moving.has(child)) return;
            changes.push({ ...child, index: index2 });
          }
        );
        state = { name: "skipping" };
        break;
      }
    }
  }
}

// ../node_modules/@tldraw/editor/dist-esm/lib/utils/rotation.mjs
function getRotationSnapshot({
  editor,
  ids
}) {
  const shapes = compact(ids.map((id) => editor.getShape(id)));
  const rotation = editor.getShapesSharedRotation(ids);
  const rotatedPageBounds = editor.getShapesRotatedPageBounds(ids);
  if (!rotatedPageBounds) {
    return null;
  }
  const initialPageCenter = rotatedPageBounds.center.clone().rotWith(rotatedPageBounds.point, rotation);
  return {
    initialPageCenter,
    initialCursorAngle: initialPageCenter.angle(editor.inputs.getOriginPagePoint()),
    initialShapesRotation: rotation,
    shapeSnapshots: shapes.map((shape) => ({
      shape,
      initialPagePoint: editor.getShapePageTransform(shape.id).point()
    }))
  };
}
function applyRotationToSnapshotShapes({
  delta,
  editor,
  snapshot,
  stage,
  centerOverride
}) {
  const { initialPageCenter, shapeSnapshots } = snapshot;
  editor.updateShapes(
    shapeSnapshots.map(({ shape, initialPagePoint }) => {
      const parentTransform = isShapeId(shape.parentId) ? editor.getShapePageTransform(shape.parentId) : Mat.Identity();
      const newPagePoint = Vec.RotWith(initialPagePoint, centerOverride ?? initialPageCenter, delta);
      const newLocalPoint = Mat.applyToPoint(
        // use the current parent transform in case it has moved/resized since the start
        // (e.g. if rotating a shape at the edge of a group)
        Mat.Inverse(parentTransform),
        newPagePoint
      );
      const newRotation = canonicalizeRotation(shape.rotation + delta);
      return {
        id: shape.id,
        type: shape.type,
        x: newLocalPoint.x,
        y: newLocalPoint.y,
        rotation: newRotation
      };
    })
  );
  const changes = [];
  shapeSnapshots.forEach(({ shape }) => {
    var _a6, _b3, _c;
    const current = editor.getShape(shape.id);
    if (!current) return;
    const util = editor.getShapeUtil(shape);
    if (stage === "start" || stage === "one-off") {
      const changeStart = (_a6 = util.onRotateStart) == null ? void 0 : _a6.call(util, shape);
      if (changeStart) changes.push(changeStart);
    }
    const changeUpdate = (_b3 = util.onRotate) == null ? void 0 : _b3.call(util, shape, current);
    if (changeUpdate) changes.push(changeUpdate);
    if (stage === "end" || stage === "one-off") {
      const changeEnd = (_c = util.onRotateEnd) == null ? void 0 : _c.call(util, shape, current);
      if (changeEnd) changes.push(changeEnd);
    }
  });
  if (changes.length > 0) {
    editor.updateShapes(changes);
  }
}

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/derivations/bindingsIndex.mjs
function fromScratch(bindingsQuery) {
  const allBindings = bindingsQuery.get();
  const shapesToBindings = /* @__PURE__ */ new Map();
  for (const binding of allBindings) {
    const { fromId, toId } = binding;
    const bindingsForFromShape = shapesToBindings.get(fromId);
    if (!bindingsForFromShape) {
      shapesToBindings.set(fromId, [binding]);
    } else {
      bindingsForFromShape.push(binding);
    }
    const bindingsForToShape = shapesToBindings.get(toId);
    if (!bindingsForToShape) {
      shapesToBindings.set(toId, [binding]);
    } else {
      bindingsForToShape.push(binding);
    }
  }
  return shapesToBindings;
}
var bindingsIndex = (editor) => {
  const { store } = editor;
  const bindingsHistory = store.query.filterHistory("binding");
  const bindingsQuery = store.query.records("binding");
  return computed("arrowBindingsIndex", (_lastValue, lastComputedEpoch) => {
    if (isUninitialized(_lastValue)) {
      return fromScratch(bindingsQuery);
    }
    const lastValue = _lastValue;
    const diff = bindingsHistory.getDiffSince(lastComputedEpoch);
    if (diff === RESET_VALUE) {
      return fromScratch(bindingsQuery);
    }
    let nextValue = void 0;
    function removingBinding(binding) {
      nextValue ?? (nextValue = new Map(lastValue));
      const prevFrom = nextValue.get(binding.fromId);
      const nextFrom = prevFrom == null ? void 0 : prevFrom.filter((b) => b.id !== binding.id);
      if (!(nextFrom == null ? void 0 : nextFrom.length)) {
        nextValue.delete(binding.fromId);
      } else {
        nextValue.set(binding.fromId, nextFrom);
      }
      const prevTo = nextValue.get(binding.toId);
      const nextTo = prevTo == null ? void 0 : prevTo.filter((b) => b.id !== binding.id);
      if (!(nextTo == null ? void 0 : nextTo.length)) {
        nextValue.delete(binding.toId);
      } else {
        nextValue.set(binding.toId, nextTo);
      }
    }
    function ensureNewArray(shapeId) {
      nextValue ?? (nextValue = new Map(lastValue));
      let result = nextValue.get(shapeId);
      if (!result) {
        result = [];
        nextValue.set(shapeId, result);
      } else if (result === lastValue.get(shapeId)) {
        result = result.slice(0);
        nextValue.set(shapeId, result);
      }
      return result;
    }
    function addBinding(binding) {
      ensureNewArray(binding.fromId).push(binding);
      ensureNewArray(binding.toId).push(binding);
    }
    for (const changes of diff) {
      for (const newBinding of objectMapValues(changes.added)) {
        addBinding(newBinding);
      }
      for (const [prev, next] of objectMapValues(changes.updated)) {
        removingBinding(prev);
        addBinding(next);
      }
      for (const prev of objectMapValues(changes.removed)) {
        removingBinding(prev);
      }
    }
    return nextValue ?? lastValue;
  });
};

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/derivations/notVisibleShapes.mjs
function notVisibleShapes(editor) {
  return computed("notVisibleShapes", function updateNotVisibleShapes(prevValue) {
    const shapeIds = editor.getCurrentPageShapeIds();
    const nextValue = /* @__PURE__ */ new Set();
    const viewportPageBounds = editor.getViewportPageBounds();
    const viewMinX = viewportPageBounds.minX;
    const viewMinY = viewportPageBounds.minY;
    const viewMaxX = viewportPageBounds.maxX;
    const viewMaxY = viewportPageBounds.maxY;
    for (const id of shapeIds) {
      const pageBounds = editor.getShapePageBounds(id);
      if (pageBounds !== void 0 && pageBounds.maxX >= viewMinX && pageBounds.minX <= viewMaxX && pageBounds.maxY >= viewMinY && pageBounds.minY <= viewMaxY) {
        continue;
      }
      const shape = editor.getShape(id);
      if (!shape) continue;
      const canCull = editor.getShapeUtil(shape.type).canCull(shape);
      if (!canCull) continue;
      nextValue.add(id);
    }
    if (isUninitialized(prevValue)) {
      return nextValue;
    }
    if (prevValue.size !== nextValue.size) return nextValue;
    for (const prev of prevValue) {
      if (!nextValue.has(prev)) {
        return nextValue;
      }
    }
    return prevValue;
  });
}

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/derivations/parentsToChildren.mjs
function fromScratch2(shapeIdsQuery, store) {
  const result = {};
  const shapeIds = shapeIdsQuery.get();
  const sortedShapes = Array.from(shapeIds, (id) => store.get(id)).sort(sortByIndex);
  sortedShapes.forEach((shape) => {
    var _a6;
    result[_a6 = shape.parentId] ?? (result[_a6] = []);
    result[shape.parentId].push(shape.id);
  });
  return result;
}
var parentsToChildren = (store) => {
  const shapeIdsQuery = store.query.ids("shape");
  const shapeHistory = store.query.filterHistory("shape");
  return computed(
    "parentsToChildrenWithIndexes",
    (lastValue, lastComputedEpoch) => {
      if (isUninitialized(lastValue)) {
        return fromScratch2(shapeIdsQuery, store);
      }
      const diff = shapeHistory.getDiffSince(lastComputedEpoch);
      if (diff === RESET_VALUE) {
        return fromScratch2(shapeIdsQuery, store);
      }
      if (diff.length === 0) return lastValue;
      let newValue = null;
      const ensureNewArray = (parentId) => {
        if (!newValue) {
          newValue = { ...lastValue };
        }
        if (!newValue[parentId]) {
          newValue[parentId] = [];
        } else if (newValue[parentId] === lastValue[parentId]) {
          newValue[parentId] = [...newValue[parentId]];
        }
      };
      const toSort = /* @__PURE__ */ new Set();
      let changes;
      for (let i = 0, n = diff.length; i < n; i++) {
        changes = diff[i];
        for (const record of Object.values(changes.added)) {
          if (!isShape(record)) continue;
          ensureNewArray(record.parentId);
          newValue[record.parentId].push(record.id);
          toSort.add(newValue[record.parentId]);
        }
        for (const [from2, to] of Object.values(changes.updated)) {
          if (!isShape(to)) continue;
          if (!isShape(from2)) continue;
          if (from2.parentId !== to.parentId) {
            ensureNewArray(from2.parentId);
            ensureNewArray(to.parentId);
            newValue[from2.parentId].splice(newValue[from2.parentId].indexOf(to.id), 1);
            newValue[to.parentId].push(to.id);
            toSort.add(newValue[to.parentId]);
          } else if (from2.index !== to.index) {
            ensureNewArray(to.parentId);
            const idx = newValue[to.parentId].indexOf(to.id);
            newValue[to.parentId][idx] = to.id;
            toSort.add(newValue[to.parentId]);
          }
        }
        for (const record of Object.values(changes.removed)) {
          if (!isShape(record)) continue;
          ensureNewArray(record.parentId);
          newValue[record.parentId].splice(newValue[record.parentId].indexOf(record.id), 1);
        }
      }
      for (const arr of toSort) {
        let writeIdx = 0;
        for (let readIdx = 0; readIdx < arr.length; readIdx++) {
          if (store.get(arr[readIdx])) {
            arr[writeIdx++] = arr[readIdx];
          }
        }
        arr.length = writeIdx;
        arr.sort((a, b) => {
          const shapeA = store.get(a);
          const shapeB = store.get(b);
          return sortByIndex(shapeA, shapeB);
        });
      }
      return newValue ?? lastValue;
    }
  );
};

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/derivations/shapeIdsInCurrentPage.mjs
var isShapeInPage = (store, pageId, shape) => {
  while (!isPageId(shape.parentId)) {
    const parent = store.get(shape.parentId);
    if (!parent) return false;
    shape = parent;
  }
  return shape.parentId === pageId;
};
var deriveShapeIdsInCurrentPage = (store, getCurrentPageId) => {
  const shapesIndex = store.query.ids("shape");
  let lastPageId = null;
  function fromScratch3() {
    const currentPageId = getCurrentPageId();
    lastPageId = currentPageId;
    return new Set(
      [...shapesIndex.get()].filter((id) => isShapeInPage(store, currentPageId, store.get(id)))
    );
  }
  return computed("_shapeIdsInCurrentPage", (prevValue, lastComputedEpoch) => {
    if (isUninitialized(prevValue)) {
      return fromScratch3();
    }
    const currentPageId = getCurrentPageId();
    if (currentPageId !== lastPageId) {
      return fromScratch3();
    }
    const diff = store.history.getDiffSince(lastComputedEpoch);
    if (diff === RESET_VALUE) {
      return fromScratch3();
    }
    const builder = new IncrementalSetConstructor(
      prevValue
    );
    for (const changes of diff) {
      for (const record of Object.values(changes.added)) {
        if (isShape(record) && isShapeInPage(store, currentPageId, record)) {
          builder.add(record.id);
        }
      }
      for (const [_from, to] of Object.values(changes.updated)) {
        if (isShape(to)) {
          if (isShapeInPage(store, currentPageId, to)) {
            builder.add(to.id);
          } else {
            builder.remove(to.id);
          }
        }
      }
      for (const id of Object.keys(changes.removed)) {
        if (isShapeId(id)) {
          builder.remove(id);
        }
      }
    }
    const result = builder.get();
    if (!result) {
      return prevValue;
    }
    return withDiff(result.value, result.diff);
  });
};

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/managers/ClickManager/ClickManager.mjs
var __create3 = Object.create;
var __defProp3 = Object.defineProperty;
var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
var __knownSymbol3 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError3 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name3 = (target, value) => __defProp3(target, "name", { value, configurable: true });
var __decoratorStart3 = (base2) => [, , , __create3((base2 == null ? void 0 : base2[__knownSymbol3("metadata")]) ?? null)];
var __decoratorStrings3 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn3 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError3("Function expected") : fn;
var __decoratorContext3 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings3[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError3("Already initialized") : fns.push(__expectFn3(fn || null)) });
var __decoratorMetadata3 = (array, target) => __defNormalProp3(target, __knownSymbol3("metadata"), array[3]);
var __runInitializers3 = (array, flags, self2, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self2) : value = fns[i].call(self2, value);
  return value;
};
var __decorateElement3 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings3[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc3(k < 4 ? target : { get [name]() {
    return __privateGet4(this, extra);
  }, set [name](x) {
    return __privateSet4(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name3(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name3(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext3(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn3(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet4 : __privateMethod3)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet4(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn3(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError3("Object expected");
    else __expectFn3(fn = it.get) && (desc.get = fn), __expectFn3(fn = it.set) && (desc.set = fn), __expectFn3(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata3(array, target), desc && __defProp3(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __publicField4 = (obj, key, value) => __defNormalProp3(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck3 = (obj, member, msg2) => member.has(obj) || __typeError3("Cannot " + msg2);
var __privateIn3 = (member, obj) => Object(obj) !== obj ? __typeError3('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet4 = (obj, member, getter) => (__accessCheck3(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet4 = (obj, member, value, setter) => (__accessCheck3(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod3 = (obj, member, method) => (__accessCheck3(obj, member, "access private method"), method);
var _cancelDoubleClickTimeout_dec;
var __getClickTimeout_dec;
var _init3;
var MAX_CLICK_DISTANCE = 40;
__getClickTimeout_dec = [bind], _cancelDoubleClickTimeout_dec = [bind];
var ClickManager = class {
  constructor(editor) {
    this.editor = editor;
    __runInitializers3(_init3, 5, this);
    __publicField4(this, "_clickId", "");
    __publicField4(this, "_clickTimeout");
    __publicField4(this, "_clickScreenPoint");
    __publicField4(this, "_previousScreenPoint");
    __publicField4(this, "_clickState", "idle");
    __publicField4(this, "lastPointerInfo", {});
  }
  _getClickTimeout(state, id = uniqueId()) {
    this._clickId = id;
    clearTimeout(this._clickTimeout);
    this._clickTimeout = this.editor.timers.setTimeout(
      () => {
        if (this._clickState === state && this._clickId === id) {
          switch (this._clickState) {
            case "pendingTriple": {
              this.editor.dispatch({
                ...this.lastPointerInfo,
                type: "click",
                name: "double_click",
                phase: "settle"
              });
              break;
            }
            case "pendingQuadruple": {
              this.editor.dispatch({
                ...this.lastPointerInfo,
                type: "click",
                name: "triple_click",
                phase: "settle"
              });
              break;
            }
            case "pendingOverflow": {
              this.editor.dispatch({
                ...this.lastPointerInfo,
                type: "click",
                name: "quadruple_click",
                phase: "settle"
              });
              break;
            }
            default: {
            }
          }
          this._clickState = "idle";
        }
      },
      state === "idle" || state === "pendingDouble" ? this.editor.options.doubleClickDurationMs : this.editor.options.multiClickDurationMs
    );
  }
  /**
   * The current click state.
   *
   * @public
   */
  // eslint-disable-next-line no-restricted-syntax
  get clickState() {
    return this._clickState;
  }
  handlePointerEvent(info) {
    switch (info.name) {
      case "pointer_down": {
        if (!this._clickState) return info;
        this._clickScreenPoint = Vec.From(info.point);
        if (this._previousScreenPoint && Vec.Dist2(this._previousScreenPoint, this._clickScreenPoint) > MAX_CLICK_DISTANCE ** 2) {
          this._clickState = "idle";
        }
        this._previousScreenPoint = this._clickScreenPoint;
        this.lastPointerInfo = info;
        switch (this._clickState) {
          case "pendingDouble": {
            this._clickState = "pendingTriple";
            this._clickTimeout = this._getClickTimeout(this._clickState);
            return {
              ...info,
              type: "click",
              name: "double_click",
              phase: "down"
            };
          }
          case "pendingTriple": {
            this._clickState = "pendingQuadruple";
            this._clickTimeout = this._getClickTimeout(this._clickState);
            return {
              ...info,
              type: "click",
              name: "triple_click",
              phase: "down"
            };
          }
          case "pendingQuadruple": {
            this._clickState = "pendingOverflow";
            this._clickTimeout = this._getClickTimeout(this._clickState);
            return {
              ...info,
              type: "click",
              name: "quadruple_click",
              phase: "down"
            };
          }
          case "idle": {
            this._clickState = "pendingDouble";
            break;
          }
          case "pendingOverflow": {
            this._clickState = "overflow";
            break;
          }
          default: {
          }
        }
        this._clickTimeout = this._getClickTimeout(this._clickState);
        return info;
      }
      case "pointer_up": {
        if (!this._clickState) return info;
        this._clickScreenPoint = Vec.From(info.point);
        switch (this._clickState) {
          case "pendingTriple": {
            return {
              ...this.lastPointerInfo,
              type: "click",
              name: "double_click",
              phase: "up"
            };
          }
          case "pendingQuadruple": {
            return {
              ...this.lastPointerInfo,
              type: "click",
              name: "triple_click",
              phase: "up"
            };
          }
          case "pendingOverflow": {
            return {
              ...this.lastPointerInfo,
              type: "click",
              name: "quadruple_click",
              phase: "up"
            };
          }
          default: {
          }
        }
        return info;
      }
      case "pointer_move": {
        if (this._clickState !== "idle" && this._clickScreenPoint && Vec.Dist2(this._clickScreenPoint, this.editor.inputs.getCurrentScreenPoint()) > (this.editor.getInstanceState().isCoarsePointer ? this.editor.options.coarseDragDistanceSquared : this.editor.options.dragDistanceSquared)) {
          this.cancelDoubleClickTimeout();
        }
        return info;
      }
    }
    return info;
  }
  cancelDoubleClickTimeout() {
    this._clickTimeout = clearTimeout(this._clickTimeout);
    this._clickState = "idle";
  }
};
_init3 = __decoratorStart3(null);
__decorateElement3(_init3, 1, "_getClickTimeout", __getClickTimeout_dec, ClickManager);
__decorateElement3(_init3, 1, "cancelDoubleClickTimeout", _cancelDoubleClickTimeout_dec, ClickManager);
__decoratorMetadata3(_init3, ClickManager);

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/managers/EdgeScrollManager/EdgeScrollManager.mjs
var EdgeScrollManager = class {
  constructor(editor) {
    __publicField(this, "_isEdgeScrolling", false);
    __publicField(this, "_edgeScrollDuration", -1);
    this.editor = editor;
  }
  getIsEdgeScrolling() {
    return this._isEdgeScrolling;
  }
  /**
   * Update the camera position when the mouse is close to the edge of the screen.
   * Run this on every tick when in a state where edge scrolling is enabled.
   *
   * @public
   */
  updateEdgeScrolling(elapsed) {
    const { editor } = this;
    const edgeScrollProximityFactor = this.getEdgeScroll();
    if (edgeScrollProximityFactor.x === 0 && edgeScrollProximityFactor.y === 0) {
      if (this._isEdgeScrolling) {
        this._isEdgeScrolling = false;
        this._edgeScrollDuration = 0;
      }
    } else {
      if (!this._isEdgeScrolling) {
        this._isEdgeScrolling = true;
        this._edgeScrollDuration = 0;
      }
      this._edgeScrollDuration += elapsed;
      if (this._edgeScrollDuration > editor.options.edgeScrollDelay) {
        const eased = editor.options.edgeScrollEaseDuration > 0 ? EASINGS.easeInCubic(
          Math.min(
            1,
            this._edgeScrollDuration / (editor.options.edgeScrollDelay + editor.options.edgeScrollEaseDuration)
          )
        ) : 1;
        this.moveCameraWhenCloseToEdge({
          x: edgeScrollProximityFactor.x * eased,
          y: edgeScrollProximityFactor.y * eased
        });
      }
    }
  }
  /**
   * Helper function to get the scroll proximity factor for a given position.
   * @param position - The mouse position on the axis.
   * @param dimension - The component dimension on the axis.
   * @param isCoarse - Whether the pointer is coarse.
   * @param insetStart - Whether the pointer is inset at the start of the axis.
   * @param insetEnd - Whether the pointer is inset at the end of the axis.
   * @internal
   */
  getEdgeProximityFactors(position, dimension, isCoarse, insetStart, insetEnd) {
    const { editor } = this;
    const dist = editor.options.edgeScrollDistance;
    const pw = isCoarse ? editor.options.coarsePointerWidth : 0;
    const pMin = position - pw;
    const pMax = position + pw;
    const min3 = insetStart ? 0 : dist;
    const max2 = insetEnd ? dimension : dimension - dist;
    if (pMin < min3) {
      return Math.min(1, (min3 - pMin) / dist);
    } else if (pMax > max2) {
      return -Math.min(1, (pMax - max2) / dist);
    }
    return 0;
  }
  getEdgeScroll() {
    const { editor } = this;
    const { x, y } = editor.inputs.getCurrentScreenPoint();
    const screenBounds = editor.getViewportScreenBounds();
    const {
      isCoarsePointer,
      insets: [t2, r, b, l]
    } = editor.getInstanceState();
    const proximityFactorX = this.getEdgeProximityFactors(x, screenBounds.w, isCoarsePointer, l, r);
    const proximityFactorY = this.getEdgeProximityFactors(y, screenBounds.h, isCoarsePointer, t2, b);
    return {
      x: proximityFactorX,
      y: proximityFactorY
    };
  }
  /**
   * Moves the camera when the mouse is close to the edge of the screen.
   * @public
   */
  moveCameraWhenCloseToEdge(proximityFactor) {
    const { editor } = this;
    if (!editor.inputs.getIsDragging() || editor.inputs.getIsPanning() || editor.getCameraOptions().isLocked)
      return;
    if (proximityFactor.x === 0 && proximityFactor.y === 0) return;
    const screenBounds = editor.getViewportScreenBounds();
    const screenSizeFactorX = screenBounds.w < 1e3 ? 0.612 : 1;
    const screenSizeFactorY = screenBounds.h < 1e3 ? 0.612 : 1;
    const zoomLevel = editor.getZoomLevel();
    const pxSpeed = editor.user.getEdgeScrollSpeed() * editor.options.edgeScrollSpeed;
    const scrollDeltaX = pxSpeed * proximityFactor.x * screenSizeFactorX / zoomLevel;
    const scrollDeltaY = pxSpeed * proximityFactor.y * screenSizeFactorY / zoomLevel;
    const { x, y, z } = editor.getCamera();
    editor.setCamera(new Vec(x + scrollDeltaX, y + scrollDeltaY, z));
  }
};

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/managers/FocusManager/FocusManager.mjs
var FocusManager = class {
  constructor(editor, autoFocus) {
    __publicField(this, "disposeSideEffectListener");
    this.editor = editor;
    this.disposeSideEffectListener = editor.sideEffects.registerAfterChangeHandler(
      "instance",
      (prev, next) => {
        if (prev.isFocused !== next.isFocused) {
          this.updateContainerClass();
        }
      }
    );
    const currentFocusState = editor.getInstanceState().isFocused;
    if (autoFocus !== currentFocusState) {
      editor.updateInstanceState({ isFocused: !!autoFocus });
    }
    this.updateContainerClass();
    document.body.addEventListener("keydown", this.handleKeyDown.bind(this));
    document.body.addEventListener("mousedown", this.handleMouseDown.bind(this));
  }
  /**
   * The editor's focus state and the container's focus state
   * are not necessarily always in sync. For that reason we
   * can't rely on the css `:focus` or `:focus-within` selectors to style the
   * editor when it is in focus.
   *
   * For that reason we synchronize the editor's focus state with a
   * special class on the container: tl-container__focused
   */
  updateContainerClass() {
    const container = this.editor.getContainer();
    const instanceState = this.editor.getInstanceState();
    if (instanceState.isFocused) {
      container.classList.add("tl-container__focused");
    } else {
      container.classList.remove("tl-container__focused");
    }
    container.classList.add("tl-container__no-focus-ring");
  }
  handleKeyDown(keyEvent2) {
    const container = this.editor.getContainer();
    const activeEl = document.activeElement;
    if (this.editor.isIn("select.editing_shape") && !(activeEl == null ? void 0 : activeEl.closest(".tlui-contextual-toolbar")))
      return;
    if (activeEl === container && this.editor.getSelectedShapeIds().length > 0) return;
    if (["Tab", "ArrowUp", "ArrowDown"].includes(keyEvent2.key)) {
      container.classList.remove("tl-container__no-focus-ring");
    }
  }
  handleMouseDown() {
    const container = this.editor.getContainer();
    container.classList.add("tl-container__no-focus-ring");
  }
  focus() {
    this.editor.getContainer().focus();
  }
  blur() {
    this.editor.complete();
    this.editor.getContainer().blur();
  }
  dispose() {
    var _a6;
    document.body.removeEventListener("keydown", this.handleKeyDown.bind(this));
    document.body.removeEventListener("mousedown", this.handleMouseDown.bind(this));
    (_a6 = this.disposeSideEffectListener) == null ? void 0 : _a6.call(this);
  }
};

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/managers/FontManager/FontManager.mjs
var FontManager = class {
  constructor(editor, assetUrls) {
    __publicField(this, "shapeFontFacesCache");
    __publicField(this, "shapeFontLoadStateCache");
    __publicField(this, "fontStates", new AtomMap("font states"));
    __publicField(this, "fontsToLoad", /* @__PURE__ */ new Set());
    this.editor = editor;
    this.assetUrls = assetUrls;
    this.shapeFontFacesCache = editor.store.createComputedCache(
      "shape font faces",
      (shape) => {
        const shapeUtil = this.editor.getShapeUtil(shape);
        return shapeUtil.getFontFaces(shape);
      },
      {
        areResultsEqual: areArraysShallowEqual,
        areRecordsEqual: (a, b) => a.props === b.props && a.meta === b.meta
      }
    );
    this.shapeFontLoadStateCache = editor.store.createCache(
      (id) => {
        const fontFacesComputed = computed("font faces", () => this.getShapeFontFaces(id));
        return computed(
          "font load state",
          () => {
            const states = fontFacesComputed.get().map((face) => this.getFontState(face));
            return states;
          },
          { isEqual: areArraysShallowEqual }
        );
      }
    );
  }
  getShapeFontFaces(shape) {
    const shapeId = typeof shape === "string" ? shape : shape.id;
    return this.shapeFontFacesCache.get(shapeId) ?? EMPTY_ARRAY;
  }
  trackFontsForShape(shape) {
    const shapeId = typeof shape === "string" ? shape : shape.id;
    this.shapeFontLoadStateCache.get(shapeId);
  }
  async loadRequiredFontsForCurrentPage(limit = Infinity) {
    const neededFonts = /* @__PURE__ */ new Set();
    for (const shapeId of this.editor.getCurrentPageShapeIds()) {
      for (const font of this.getShapeFontFaces(this.editor.getShape(shapeId))) {
        neededFonts.add(font);
      }
    }
    if (neededFonts.size > limit) {
      return;
    }
    const promises = Array.from(neededFonts, (font) => this.ensureFontIsLoaded(font));
    await Promise.all(promises);
  }
  getFontState(font) {
    return this.fontStates.get(font) ?? null;
  }
  ensureFontIsLoaded(font) {
    const existingState = this.getFontState(font);
    if (existingState) return existingState.loadingPromise;
    const instance = this.findOrCreateFontFace(font);
    const state = {
      state: "loading",
      instance,
      loadingPromise: instance.load().then(() => {
        document.fonts.add(instance);
        this.fontStates.update(font, (s) => ({ ...s, state: "ready" }));
      }).catch((err) => {
        console.error(err);
        this.fontStates.update(font, (s) => ({ ...s, state: "error" }));
      })
    };
    this.fontStates.set(font, state);
    return state.loadingPromise;
  }
  requestFonts(fonts) {
    if (!this.fontsToLoad.size) {
      queueMicrotask(() => {
        if (this.editor.isDisposed) return;
        const toLoad = this.fontsToLoad;
        this.fontsToLoad = /* @__PURE__ */ new Set();
        transact(() => {
          for (const font of toLoad) {
            this.ensureFontIsLoaded(font);
          }
        });
      });
    }
    for (const font of fonts) {
      this.fontsToLoad.add(font);
    }
  }
  findOrCreateFontFace(font) {
    var _a6;
    for (const existing of document.fonts) {
      if (existing.family === font.family && objectMapEntries(defaultFontFaceDescriptors).every(
        ([key, defaultValue]) => existing[key] === (font[key] ?? defaultValue)
      )) {
        return existing;
      }
    }
    const url = ((_a6 = this.assetUrls) == null ? void 0 : _a6[font.src.url]) ?? font.src.url;
    const instance = new FontFace(font.family, `url(${JSON.stringify(url)})`, {
      ...mapObjectMapValues(defaultFontFaceDescriptors, (key) => font[key]),
      display: "swap"
    });
    document.fonts.add(instance);
    return instance;
  }
  async toEmbeddedCssDeclaration(font) {
    var _a6;
    const url = ((_a6 = this.assetUrls) == null ? void 0 : _a6[font.src.url]) ?? font.src.url;
    const dataUrl = await FileHelpers.urlToDataUrl(url);
    const src = compact([
      `url("${dataUrl}")`,
      font.src.format ? `format(${font.src.format})` : null,
      font.src.tech ? `tech(${font.src.tech})` : null
    ]).join(" ");
    return compact([
      `@font-face {`,
      `  font-family: "${font.family}";`,
      font.ascentOverride ? `  ascent-override: ${font.ascentOverride};` : null,
      font.descentOverride ? `  descent-override: ${font.descentOverride};` : null,
      font.stretch ? `  font-stretch: ${font.stretch};` : null,
      font.style ? `  font-style: ${font.style};` : null,
      font.weight ? `  font-weight: ${font.weight};` : null,
      font.featureSettings ? `  font-feature-settings: ${font.featureSettings};` : null,
      font.lineGapOverride ? `  line-gap-override: ${font.lineGapOverride};` : null,
      font.unicodeRange ? `  unicode-range: ${font.unicodeRange};` : null,
      `  src: ${src};`,
      `}`
    ]).join("\n");
  }
};
var defaultFontFaceDescriptors = {
  style: "normal",
  weight: "normal",
  stretch: "normal",
  unicodeRange: "U+0-10FFFF",
  featureSettings: "normal",
  ascentOverride: "normal",
  descentOverride: "normal",
  lineGapOverride: "normal"
};

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/managers/HistoryManager/HistoryManager.mjs
var HistoryRecorderState = ((HistoryRecorderState2) => {
  HistoryRecorderState2["Recording"] = "recording";
  HistoryRecorderState2["RecordingPreserveRedoStack"] = "recordingPreserveRedoStack";
  HistoryRecorderState2["Paused"] = "paused";
  return HistoryRecorderState2;
})(HistoryRecorderState || {});
var HistoryManager = class {
  constructor(opts) {
    __publicField(this, "store");
    __publicField(this, "dispose");
    __publicField(this, "state", "recording");
    __publicField(this, "pendingDiff", new PendingDiff());
    __publicField(this, "stacks", atom(
      "HistoryManager.stacks",
      {
        undos: stack(),
        redos: stack()
      },
      {
        isEqual: (a, b) => a.undos === b.undos && a.redos === b.redos
      }
    ));
    __publicField(this, "annotateError");
    /** @internal */
    __publicField(this, "_isInBatch", false);
    this.store = opts.store;
    this.annotateError = opts.annotateError ?? noop;
    this.dispose = this.store.addHistoryInterceptor((entry, source) => {
      if (source !== "user") return;
      switch (this.state) {
        case "recording":
          this.pendingDiff.apply(entry.changes);
          this.stacks.update(({ undos }) => ({ undos, redos: stack() }));
          break;
        case "recordingPreserveRedoStack":
          this.pendingDiff.apply(entry.changes);
          break;
        case "paused":
          break;
        default:
          exhaustiveSwitchError(this.state);
      }
    });
  }
  flushPendingDiff() {
    if (this.pendingDiff.isEmpty()) return;
    const diff = this.pendingDiff.clear();
    this.stacks.update(({ undos, redos }) => ({
      undos: undos.push({ type: "diff", diff }),
      redos
    }));
  }
  getNumUndos() {
    return this.stacks.get().undos.length + (this.pendingDiff.isEmpty() ? 0 : 1);
  }
  getNumRedos() {
    return this.stacks.get().redos.length;
  }
  batch(fn, opts) {
    const previousState = this.state;
    if (previousState !== "paused" && (opts == null ? void 0 : opts.history)) {
      this.state = modeToState[opts.history];
    }
    try {
      if (this._isInBatch) {
        transact(fn);
        return this;
      }
      this._isInBatch = true;
      try {
        transact(fn);
      } catch (error) {
        this.annotateError(error);
        throw error;
      } finally {
        this._isInBatch = false;
      }
      return this;
    } finally {
      this.state = previousState;
    }
  }
  // History
  _undo({ pushToRedoStack, toMark = void 0 }) {
    var _a6;
    const previousState = this.state;
    this.state = "paused";
    try {
      let { undos, redos } = this.stacks.get();
      const pendingDiff = this.pendingDiff.clear();
      const isPendingDiffEmpty = isRecordsDiffEmpty(pendingDiff);
      const diffToUndo = reverseRecordsDiff(pendingDiff);
      if (pushToRedoStack && !isPendingDiffEmpty) {
        redos = redos.push({ type: "diff", diff: pendingDiff });
      }
      let didFindMark = false;
      if (isPendingDiffEmpty) {
        while (((_a6 = undos.head) == null ? void 0 : _a6.type) === "stop") {
          const mark = undos.head;
          undos = undos.tail;
          if (pushToRedoStack) {
            redos = redos.push(mark);
          }
          if (mark.id === toMark) {
            didFindMark = true;
            break;
          }
        }
      }
      if (!didFindMark) {
        loop: while (undos.head) {
          const undo2 = undos.head;
          undos = undos.tail;
          if (pushToRedoStack) {
            redos = redos.push(undo2);
          }
          switch (undo2.type) {
            case "diff":
              squashRecordDiffsMutable(diffToUndo, [reverseRecordsDiff(undo2.diff)]);
              break;
            case "stop":
              if (!toMark) break loop;
              if (undo2.id === toMark) {
                didFindMark = true;
                break loop;
              }
              break;
            default:
              exhaustiveSwitchError(undo2);
          }
        }
      }
      if (!didFindMark && toMark) {
        return this;
      }
      this.store.applyDiff(diffToUndo, { ignoreEphemeralKeys: true });
      this.store.ensureStoreIsUsable();
      this.stacks.set({ undos, redos });
    } finally {
      this.state = previousState;
    }
    return this;
  }
  undo() {
    this._undo({ pushToRedoStack: true });
    return this;
  }
  redo() {
    var _a6;
    const previousState = this.state;
    this.state = "paused";
    try {
      this.flushPendingDiff();
      let { undos, redos } = this.stacks.get();
      if (redos.length === 0) {
        return this;
      }
      while (((_a6 = redos.head) == null ? void 0 : _a6.type) === "stop") {
        undos = undos.push(redos.head);
        redos = redos.tail;
      }
      const diffToRedo = createEmptyRecordsDiff();
      while (redos.head) {
        const redo2 = redos.head;
        undos = undos.push(redo2);
        redos = redos.tail;
        if (redo2.type === "diff") {
          squashRecordDiffsMutable(diffToRedo, [redo2.diff]);
        } else {
          break;
        }
      }
      this.store.applyDiff(diffToRedo, { ignoreEphemeralKeys: true });
      this.store.ensureStoreIsUsable();
      this.stacks.set({ undos, redos });
    } finally {
      this.state = previousState;
    }
    return this;
  }
  bail() {
    this._undo({ pushToRedoStack: false });
    return this;
  }
  bailToMark(id) {
    if (id) {
      this._undo({ pushToRedoStack: false, toMark: id });
    }
    return this;
  }
  squashToMark(id) {
    var _a6;
    let top = this.stacks.get().undos;
    const popped = [];
    while (top.head && !(top.head.type === "stop" && top.head.id === id)) {
      if (top.head.type === "diff") {
        popped.push(top.head.diff);
      }
      top = top.tail;
    }
    if (!top.head || ((_a6 = top.head) == null ? void 0 : _a6.id) !== id) {
      console.error("Could not find mark to squash to: ", id);
      return this;
    }
    if (popped.length === 0) {
      return this;
    }
    const diff = createEmptyRecordsDiff();
    squashRecordDiffsMutable(diff, popped.reverse());
    this.stacks.update(({ redos }) => ({
      undos: top.push({
        type: "diff",
        diff
      }),
      redos
    }));
    return this;
  }
  /** @internal */
  _mark(id) {
    transact(() => {
      this.flushPendingDiff();
      this.stacks.update(({ undos, redos }) => ({ undos: undos.push({ type: "stop", id }), redos }));
    });
  }
  clear() {
    this.stacks.set({ undos: stack(), redos: stack() });
    this.pendingDiff.clear();
  }
  /** @internal */
  getMarkIdMatching(idSubstring) {
    let top = this.stacks.get().undos;
    while (top.head) {
      if (top.head.type === "stop" && top.head.id.includes(idSubstring)) {
        return top.head.id;
      }
      top = top.tail;
    }
    return null;
  }
  /** @internal */
  debug() {
    const { undos, redos } = this.stacks.get();
    return {
      undos: stackToArray(undos),
      redos: stackToArray(redos),
      pendingDiff: this.pendingDiff.debug(),
      state: this.state
    };
  }
};
var modeToState = {
  record: "recording",
  "record-preserveRedoStack": "recordingPreserveRedoStack",
  ignore: "paused"
  /* Paused */
};
var PendingDiff = class {
  constructor() {
    __publicField(this, "diff", createEmptyRecordsDiff());
    __publicField(this, "isEmptyAtom", atom("PendingDiff.isEmpty", true));
  }
  clear() {
    const diff = this.diff;
    this.diff = createEmptyRecordsDiff();
    this.isEmptyAtom.set(true);
    return diff;
  }
  isEmpty() {
    return this.isEmptyAtom.get();
  }
  apply(diff) {
    squashRecordDiffsMutable(this.diff, [diff]);
    this.isEmptyAtom.set(isRecordsDiffEmpty(this.diff));
  }
  debug() {
    return { diff: this.diff, isEmpty: this.isEmpty() };
  }
};
function stack() {
  return EMPTY_STACK_ITEM;
}
var EmptyStackItem = class {
  constructor() {
    __publicField(this, "length", 0);
    __publicField(this, "head", null);
    __publicField(this, "tail", this);
  }
  push(head) {
    return new StackItem(head, this);
  }
};
var EMPTY_STACK_ITEM = new EmptyStackItem();
var StackItem = class _StackItem {
  constructor(head, tail) {
    __publicField(this, "length");
    this.head = head;
    this.tail = tail;
    this.length = tail.length + 1;
  }
  push(head) {
    return new _StackItem(head, this);
  }
};
function stackToArray(stack2) {
  if (!stack2.length) {
    return EMPTY_ARRAY;
  }
  const arr = [];
  while (stack2.length) {
    arr.push(stack2.head);
    stack2 = stack2.tail;
  }
  return arr;
}

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/managers/InputsManager/InputsManager.mjs
var __create4 = Object.create;
var __defProp4 = Object.defineProperty;
var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
var __knownSymbol4 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError4 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp4 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name4 = (target, value) => __defProp4(target, "name", { value, configurable: true });
var __decoratorStart4 = (base2) => [, , , __create4((base2 == null ? void 0 : base2[__knownSymbol4("metadata")]) ?? null)];
var __decoratorStrings4 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn4 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError4("Function expected") : fn;
var __decoratorContext4 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings4[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError4("Already initialized") : fns.push(__expectFn4(fn || null)) });
var __decoratorMetadata4 = (array, target) => __defNormalProp4(target, __knownSymbol4("metadata"), array[3]);
var __runInitializers4 = (array, flags, self2, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self2) : value = fns[i].call(self2, value);
  return value;
};
var __decorateElement4 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings4[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc4(k < 4 ? target : { get [name]() {
    return __privateGet5(this, extra);
  }, set [name](x) {
    return __privateSet5(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name4(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name4(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext4(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn4(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet5 : __privateMethod4)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet5(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn4(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError4("Object expected");
    else __expectFn4(fn = it.get) && (desc.get = fn), __expectFn4(fn = it.set) && (desc.set = fn), __expectFn4(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata4(array, target), desc && __defProp4(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __publicField5 = (obj, key, value) => __defNormalProp4(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck4 = (obj, member, msg2) => member.has(obj) || __typeError4("Cannot " + msg2);
var __privateIn4 = (member, obj) => Object(obj) !== obj ? __typeError4('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet5 = (obj, member, getter) => (__accessCheck4(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet5 = (obj, member, value, setter) => (__accessCheck4(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod4 = (obj, member, method) => (__accessCheck4(obj, member, "access private method"), method);
var __getHasCollaborators_dec;
var _init4;
__getHasCollaborators_dec = [computed];
var InputsManager = class {
  constructor(editor) {
    this.editor = editor;
    __runInitializers4(_init4, 5, this);
    __publicField5(this, "_originPagePoint", atom("originPagePoint", new Vec()));
    __publicField5(this, "_originScreenPoint", atom("originScreenPoint", new Vec()));
    __publicField5(this, "_previousPagePoint", atom("previousPagePoint", new Vec()));
    __publicField5(this, "_previousScreenPoint", atom("previousScreenPoint", new Vec()));
    __publicField5(this, "_currentPagePoint", atom("currentPagePoint", new Vec()));
    __publicField5(this, "_currentScreenPoint", atom("currentScreenPoint", new Vec()));
    __publicField5(this, "_pointerVelocity", atom("pointerVelocity", new Vec()));
    __publicField5(this, "keys", new AtomSet("keys"));
    __publicField5(this, "buttons", new AtomSet("buttons"));
    __publicField5(this, "_isPen", atom("isPen", false));
    __publicField5(this, "_shiftKey", atom("shiftKey", false));
    __publicField5(this, "_metaKey", atom("metaKey", false));
    __publicField5(this, "_ctrlKey", atom("ctrlKey", false));
    __publicField5(this, "_altKey", atom("altKey", false));
    __publicField5(this, "_isDragging", atom("isDragging", false));
    __publicField5(this, "_isPointing", atom("isPointing", false));
    __publicField5(this, "_isPinching", atom("isPinching", false));
    __publicField5(this, "_isEditing", atom("isEditing", false));
    __publicField5(this, "_isPanning", atom("isPanning", false));
    __publicField5(this, "_isSpacebarPanning", atom("isSpacebarPanning", false));
    __publicField5(this, "_velocityPrevPoint", new Vec());
  }
  /**
   * The most recent pointer down's position in the current page space.
   */
  getOriginPagePoint() {
    return this._originPagePoint.get();
  }
  /**
   * @deprecated Use `getOriginPagePoint()` instead.
   */
  // eslint-disable-next-line no-restricted-syntax
  get originPagePoint() {
    return this.getOriginPagePoint();
  }
  /**
   * The most recent pointer down's position in screen space.
   */
  getOriginScreenPoint() {
    return this._originScreenPoint.get();
  }
  /**
   * @deprecated Use `getOriginScreenPoint()` instead.
   */
  // eslint-disable-next-line no-restricted-syntax
  get originScreenPoint() {
    return this.getOriginScreenPoint();
  }
  /**
   * The previous pointer position in the current page space.
   */
  getPreviousPagePoint() {
    return this._previousPagePoint.get();
  }
  /**
   * @deprecated Use `getPreviousPagePoint()` instead.
   */
  // eslint-disable-next-line no-restricted-syntax
  get previousPagePoint() {
    return this.getPreviousPagePoint();
  }
  /**
   * The previous pointer position in screen space.
   */
  getPreviousScreenPoint() {
    return this._previousScreenPoint.get();
  }
  /**
   * @deprecated Use `getPreviousScreenPoint()` instead.
   */
  // eslint-disable-next-line no-restricted-syntax
  get previousScreenPoint() {
    return this.getPreviousScreenPoint();
  }
  /**
   * The most recent pointer position in the current page space.
   */
  getCurrentPagePoint() {
    return this._currentPagePoint.get();
  }
  /**
   * @deprecated Use `getCurrentPagePoint()` instead.
   */
  // eslint-disable-next-line no-restricted-syntax
  get currentPagePoint() {
    return this.getCurrentPagePoint();
  }
  /**
   * The most recent pointer position in screen space.
   */
  getCurrentScreenPoint() {
    return this._currentScreenPoint.get();
  }
  /**
   * @deprecated Use `getCurrentScreenPoint()` instead.
   */
  // eslint-disable-next-line no-restricted-syntax
  get currentScreenPoint() {
    return this.getCurrentScreenPoint();
  }
  /**
   * Velocity of mouse pointer, in pixels per millisecond.
   */
  getPointerVelocity() {
    return this._pointerVelocity.get();
  }
  /**
   * @deprecated Use `getPointerVelocity()` instead.
   */
  // eslint-disable-next-line no-restricted-syntax
  get pointerVelocity() {
    return this.getPointerVelocity();
  }
  /**
   * Normally you shouldn't need to set the pointer velocity directly, this is set by the tick manager.
   * However, this is currently used in tests to fake pointer velocity.
   * @param pointerVelocity - The pointer velocity.
   * @internal
   */
  setPointerVelocity(pointerVelocity) {
    this._pointerVelocity.set(pointerVelocity);
  }
  /**
   * Whether the input is from a pen.
   */
  getIsPen() {
    return this._isPen.get();
  }
  /**
   * @deprecated Use `getIsPen()` instead.
   */
  // eslint-disable-next-line no-restricted-syntax
  get isPen() {
    return this.getIsPen();
  }
  // eslint-disable-next-line no-restricted-syntax
  set isPen(isPen) {
    this.setIsPen(isPen);
  }
  /**
   * @param isPen - Whether the input is from a pen.
   */
  setIsPen(isPen) {
    this._isPen.set(isPen);
  }
  /**
   * Whether the shift key is currently pressed.
   */
  getShiftKey() {
    return this._shiftKey.get();
  }
  /**
   * @deprecated Use `getShiftKey()` instead.
   */
  // eslint-disable-next-line no-restricted-syntax
  get shiftKey() {
    return this.getShiftKey();
  }
  // eslint-disable-next-line no-restricted-syntax
  set shiftKey(shiftKey) {
    this.setShiftKey(shiftKey);
  }
  /**
   * @param shiftKey - Whether the shift key is pressed.
   * @internal
   */
  setShiftKey(shiftKey) {
    this._shiftKey.set(shiftKey);
  }
  /**
   * Whether the meta key is currently pressed.
   */
  getMetaKey() {
    return this._metaKey.get();
  }
  /**
   * @deprecated Use `getMetaKey()` instead.
   */
  // eslint-disable-next-line no-restricted-syntax
  get metaKey() {
    return this.getMetaKey();
  }
  // eslint-disable-next-line no-restricted-syntax
  set metaKey(metaKey) {
    this.setMetaKey(metaKey);
  }
  /**
   * @param metaKey - Whether the meta key is pressed.
   * @internal
   */
  setMetaKey(metaKey) {
    this._metaKey.set(metaKey);
  }
  /**
   * Whether the ctrl or command key is currently pressed.
   */
  getCtrlKey() {
    return this._ctrlKey.get();
  }
  /**
   * @deprecated Use `getCtrlKey()` instead.
   */
  // eslint-disable-next-line no-restricted-syntax
  get ctrlKey() {
    return this.getCtrlKey();
  }
  // eslint-disable-next-line no-restricted-syntax
  set ctrlKey(ctrlKey2) {
    this.setCtrlKey(ctrlKey2);
  }
  /**
   * @param ctrlKey - Whether the ctrl key is pressed.
   * @internal
   */
  setCtrlKey(ctrlKey2) {
    this._ctrlKey.set(ctrlKey2);
  }
  /**
   * Whether the alt or option key is currently pressed.
   */
  getAltKey() {
    return this._altKey.get();
  }
  /**
   * @deprecated Use `getAltKey()` instead.
   */
  // eslint-disable-next-line no-restricted-syntax
  get altKey() {
    return this.getAltKey();
  }
  // eslint-disable-next-line no-restricted-syntax
  set altKey(altKey2) {
    this.setAltKey(altKey2);
  }
  /**
   * @param altKey - Whether the alt key is pressed.
   * @internal
   */
  setAltKey(altKey2) {
    this._altKey.set(altKey2);
  }
  /**
   * Is the accelerator key (cmd on mac, ctrl elsewhere) currently pressed.
   */
  getAccelKey() {
    return isAccelKey({ metaKey: this.getMetaKey(), ctrlKey: this.getCtrlKey() });
  }
  /**
   * @deprecated Use `getAccelKey()` instead.
   */
  // eslint-disable-next-line no-restricted-syntax
  get accelKey() {
    return this.getAccelKey();
  }
  /**
   * Whether the user is dragging.
   */
  getIsDragging() {
    return this._isDragging.get();
  }
  /**
   * Soon to be deprecated, use `getIsDragging()` instead.
   */
  // eslint-disable-next-line no-restricted-syntax
  get isDragging() {
    return this.getIsDragging();
  }
  // eslint-disable-next-line no-restricted-syntax
  set isDragging(isDragging) {
    this.setIsDragging(isDragging);
  }
  /**
   * @param isDragging - Whether the user is dragging.
   */
  setIsDragging(isDragging) {
    this._isDragging.set(isDragging);
  }
  /**
   * Whether the user is pointing.
   */
  getIsPointing() {
    return this._isPointing.get();
  }
  /**
   * @deprecated Use `getIsPointing()` instead.
   */
  // eslint-disable-next-line no-restricted-syntax
  get isPointing() {
    return this.getIsPointing();
  }
  // eslint-disable-next-line no-restricted-syntax
  set isPointing(isPointing) {
    this.setIsPointing(isPointing);
  }
  /**
   * @param isPointing - Whether the user is pointing.
   * @internal
   */
  setIsPointing(isPointing) {
    this._isPointing.set(isPointing);
  }
  /**
   * Whether the user is pinching.
   */
  getIsPinching() {
    return this._isPinching.get();
  }
  /**
   * @deprecated Use `getIsPinching()` instead.
   */
  // eslint-disable-next-line no-restricted-syntax
  get isPinching() {
    return this.getIsPinching();
  }
  // eslint-disable-next-line no-restricted-syntax
  set isPinching(isPinching) {
    this.setIsPinching(isPinching);
  }
  /**
   * @param isPinching - Whether the user is pinching.
   * @internal
   */
  setIsPinching(isPinching) {
    this._isPinching.set(isPinching);
  }
  /**
   * Whether the user is editing.
   */
  getIsEditing() {
    return this._isEditing.get();
  }
  /**
   * @deprecated Use `getIsEditing()` instead.
   */
  // eslint-disable-next-line no-restricted-syntax
  get isEditing() {
    return this.getIsEditing();
  }
  // eslint-disable-next-line no-restricted-syntax
  set isEditing(isEditing) {
    this.setIsEditing(isEditing);
  }
  /**
   * @param isEditing - Whether the user is editing.
   */
  setIsEditing(isEditing) {
    this._isEditing.set(isEditing);
  }
  /**
   * Whether the user is panning.
   */
  getIsPanning() {
    return this._isPanning.get();
  }
  /**
   * @deprecated Use `getIsPanning()` instead.
   */
  // eslint-disable-next-line no-restricted-syntax
  get isPanning() {
    return this.getIsPanning();
  }
  // eslint-disable-next-line no-restricted-syntax
  set isPanning(isPanning) {
    this.setIsPanning(isPanning);
  }
  /**
   * @param isPanning - Whether the user is panning.
   * @internal
   */
  setIsPanning(isPanning) {
    this._isPanning.set(isPanning);
  }
  /**
   * Whether the user is spacebar panning.
   */
  getIsSpacebarPanning() {
    return this._isSpacebarPanning.get();
  }
  /**
   * @deprecated Use `getIsSpacebarPanning()` instead.
   */
  // eslint-disable-next-line no-restricted-syntax
  get isSpacebarPanning() {
    return this.getIsSpacebarPanning();
  }
  // eslint-disable-next-line no-restricted-syntax
  set isSpacebarPanning(isSpacebarPanning) {
    this.setIsSpacebarPanning(isSpacebarPanning);
  }
  /**
   * @param isSpacebarPanning - Whether the user is spacebar panning.
   * @internal
   */
  setIsSpacebarPanning(isSpacebarPanning) {
    this._isSpacebarPanning.set(isSpacebarPanning);
  }
  _getHasCollaborators() {
    return this.editor.getCollaborators().length > 0;
  }
  /**
   * Update the pointer velocity based on elapsed time. Called by the tick manager.
   * @param elapsed - The time elapsed since the last tick in milliseconds.
   * @internal
   */
  updatePointerVelocity(elapsed) {
    const currentScreenPoint = this.getCurrentScreenPoint();
    const pointerVelocity = this.getPointerVelocity();
    if (elapsed === 0) return;
    const delta = Vec.Sub(currentScreenPoint, this._velocityPrevPoint);
    this._velocityPrevPoint = currentScreenPoint.clone();
    const length = delta.len();
    const direction = length ? delta.div(length) : new Vec(0, 0);
    const next = pointerVelocity.clone().lrp(direction.mul(length / elapsed), 0.5);
    if (Math.abs(next.x) < 0.01) next.x = 0;
    if (Math.abs(next.y) < 0.01) next.y = 0;
    if (!pointerVelocity.equals(next)) {
      this._pointerVelocity.set(next);
    }
  }
  /**
   * Update the input points from a pointer, pinch, or wheel event.
   *
   * @param info - The event info.
   * @internal
   */
  updateFromEvent(info) {
    const currentScreenPoint = this._currentScreenPoint.__unsafe__getWithoutCapture();
    const currentPagePoint = this._currentPagePoint.__unsafe__getWithoutCapture();
    const isPinching = this._isPinching.__unsafe__getWithoutCapture();
    const { screenBounds } = this.editor.store.unsafeGetWithoutCapture(TLINSTANCE_ID);
    const { x: cx, y: cy, z: cz } = unsafe__withoutCapture(() => this.editor.getCamera());
    const sx = info.point.x - screenBounds.x;
    const sy = info.point.y - screenBounds.y;
    const sz = info.point.z ?? 0.5;
    this._previousScreenPoint.set(currentScreenPoint);
    this._previousPagePoint.set(currentPagePoint);
    this._currentScreenPoint.set(new Vec(sx, sy));
    const nx = sx / cz - cx;
    const ny = sy / cz - cy;
    if (isFinite(nx) && isFinite(ny)) {
      this._currentPagePoint.set(new Vec(nx, ny, sz));
    }
    this._isPen.set(info.type === "pointer" && info.isPen);
    if (info.name === "pointer_down" || isPinching) {
      this._pointerVelocity.set(new Vec());
      this._originScreenPoint.set(this._currentScreenPoint.__unsafe__getWithoutCapture());
      this._originPagePoint.set(this._currentPagePoint.__unsafe__getWithoutCapture());
    }
    if (this._getHasCollaborators()) {
      this.editor.run(
        () => {
          var _a6;
          const pagePoint = this._currentPagePoint.__unsafe__getWithoutCapture();
          this.editor.store.put([
            {
              id: TLPOINTER_ID,
              typeName: "pointer",
              x: pagePoint.x,
              y: pagePoint.y,
              lastActivityTimestamp: (
                // If our pointer moved only because we're following some other user, then don't
                // update our last activity timestamp; otherwise, update it to the current timestamp.
                info.type === "pointer" && info.pointerId === INTERNAL_POINTER_IDS.CAMERA_MOVE ? ((_a6 = this.editor.store.unsafeGetWithoutCapture(TLPOINTER_ID)) == null ? void 0 : _a6.lastActivityTimestamp) ?? Date.now() : Date.now()
              ),
              meta: {}
            }
          ]);
        },
        { history: "ignore" }
      );
    }
  }
  toJson() {
    return {
      originPagePoint: this._originPagePoint.get().toJson(),
      originScreenPoint: this._originScreenPoint.get().toJson(),
      previousPagePoint: this._previousPagePoint.get().toJson(),
      previousScreenPoint: this._previousScreenPoint.get().toJson(),
      currentPagePoint: this._currentPagePoint.get().toJson(),
      currentScreenPoint: this._currentScreenPoint.get().toJson(),
      pointerVelocity: this._pointerVelocity.get().toJson(),
      shiftKey: this._shiftKey.get(),
      metaKey: this._metaKey.get(),
      ctrlKey: this._ctrlKey.get(),
      altKey: this._altKey.get(),
      isPen: this._isPen.get(),
      isDragging: this._isDragging.get(),
      isPointing: this._isPointing.get(),
      isPinching: this._isPinching.get(),
      isEditing: this._isEditing.get(),
      isPanning: this._isPanning.get(),
      isSpacebarPanning: this._isSpacebarPanning.get(),
      keys: Array.from(this.keys.keys()),
      buttons: Array.from(this.buttons.keys())
    };
  }
};
_init4 = __decoratorStart4(null);
__decorateElement4(_init4, 1, "_getHasCollaborators", __getHasCollaborators_dec, InputsManager);
__decoratorMetadata4(_init4, InputsManager);

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/managers/ScribbleManager/ScribbleManager.mjs
var ScribbleManager = class {
  constructor(editor) {
    __publicField(this, "scribbleItems", /* @__PURE__ */ new Map());
    __publicField(this, "state", "paused");
    this.editor = editor;
  }
  addScribble(scribble, id = uniqueId()) {
    const item = {
      id,
      scribble: {
        id,
        size: 20,
        color: "accent",
        opacity: 0.8,
        delay: 0,
        points: [],
        shrink: 0.1,
        taper: true,
        ...scribble,
        state: "starting"
      },
      timeoutMs: 0,
      delayRemaining: scribble.delay ?? 0,
      prev: null,
      next: null
    };
    this.scribbleItems.set(id, item);
    return item;
  }
  reset() {
    this.editor.updateInstanceState({ scribbles: [] });
    this.scribbleItems.clear();
  }
  /**
   * Start stopping the scribble. The scribble won't be removed until its last point is cleared.
   *
   * @public
   */
  stop(id) {
    const item = this.scribbleItems.get(id);
    if (!item) throw Error(`Scribble with id ${id} not found`);
    item.delayRemaining = Math.min(item.delayRemaining, 200);
    item.scribble.state = "stopping";
    return item;
  }
  /**
   * Set the scribble's next point.
   *
   * @param id - The id of the scribble to add a point to.
   * @param x - The x coordinate of the point.
   * @param y - The y coordinate of the point.
   * @param z - The z coordinate of the point.
   * @public
   */
  addPoint(id, x, y, z = 0.5) {
    const item = this.scribbleItems.get(id);
    if (!item) throw Error(`Scribble with id ${id} not found`);
    const { prev } = item;
    const point = { x, y, z };
    if (!prev || Vec.Dist(prev, point) >= 1) {
      item.next = point;
    }
    return item;
  }
  /**
   * Update on each animation frame.
   *
   * @param elapsed - The number of milliseconds since the last tick.
   * @public
   */
  tick(elapsed) {
    if (this.scribbleItems.size === 0) return;
    this.editor.run(() => {
      this.scribbleItems.forEach((item) => {
        if (item.scribble.state === "starting") {
          const { next: next2, prev: prev2 } = item;
          if (next2 && next2 !== prev2) {
            item.prev = next2;
            item.scribble.points.push(next2);
          }
          if (item.scribble.points.length > 8) {
            item.scribble.state = "active";
          }
          return;
        }
        if (item.delayRemaining > 0) {
          item.delayRemaining = Math.max(0, item.delayRemaining - elapsed);
        }
        item.timeoutMs += elapsed;
        if (item.timeoutMs >= 16) {
          item.timeoutMs = 0;
        }
        const { delayRemaining, timeoutMs, prev, next, scribble } = item;
        switch (scribble.state) {
          case "active": {
            if (next && next !== prev) {
              item.prev = next;
              scribble.points.push(next);
              if (delayRemaining === 0) {
                if (scribble.points.length > 8) {
                  scribble.points.shift();
                }
              }
            } else {
              if (timeoutMs === 0) {
                if (scribble.points.length > 1) {
                  scribble.points.shift();
                } else {
                  item.delayRemaining = scribble.delay;
                }
              }
            }
            break;
          }
          case "stopping": {
            if (item.delayRemaining === 0) {
              if (timeoutMs === 0) {
                if (scribble.points.length === 1) {
                  this.scribbleItems.delete(item.id);
                  return;
                }
                if (scribble.shrink) {
                  scribble.size = Math.max(1, scribble.size * (1 - scribble.shrink));
                }
                scribble.points.shift();
              }
            }
            break;
          }
          case "paused": {
            break;
          }
        }
      });
      this.editor.updateInstanceState({
        scribbles: Array.from(this.scribbleItems.values()).map(({ scribble }) => ({
          ...scribble,
          points: [...scribble.points]
        })).slice(-5)
        // limit to three as a minor sanity check
      });
    });
  }
};

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/managers/SnapManager/BoundsSnaps.mjs
var __create5 = Object.create;
var __defProp5 = Object.defineProperty;
var __getOwnPropDesc5 = Object.getOwnPropertyDescriptor;
var __knownSymbol5 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError5 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp5 = (obj, key, value) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name5 = (target, value) => __defProp5(target, "name", { value, configurable: true });
var __decoratorStart5 = (base2) => [, , , __create5((base2 == null ? void 0 : base2[__knownSymbol5("metadata")]) ?? null)];
var __decoratorStrings5 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn5 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError5("Function expected") : fn;
var __decoratorContext5 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings5[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError5("Already initialized") : fns.push(__expectFn5(fn || null)) });
var __decoratorMetadata5 = (array, target) => __defNormalProp5(target, __knownSymbol5("metadata"), array[3]);
var __runInitializers5 = (array, flags, self2, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self2) : value = fns[i].call(self2, value);
  return value;
};
var __decorateElement5 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings5[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc5(k < 4 ? target : { get [name]() {
    return __privateGet6(this, extra);
  }, set [name](x) {
    return __privateSet6(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name5(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name5(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext5(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn5(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet6 : __privateMethod5)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet6(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn5(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError5("Object expected");
    else __expectFn5(fn = it.get) && (desc.get = fn), __expectFn5(fn = it.set) && (desc.set = fn), __expectFn5(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata5(array, target), desc && __defProp5(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __publicField6 = (obj, key, value) => __defNormalProp5(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck5 = (obj, member, msg2) => member.has(obj) || __typeError5("Cannot " + msg2);
var __privateIn5 = (member, obj) => Object(obj) !== obj ? __typeError5('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet6 = (obj, member, getter) => (__accessCheck5(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet6 = (obj, member, value, setter) => (__accessCheck5(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod5 = (obj, member, method) => (__accessCheck5(obj, member, "access private method"), method);
var _getVisibleGaps_dec;
var _getSnappableGapNodes_dec;
var _getSnappablePoints_dec;
var _getSnapPointsCache_dec;
var _init5;
var round = (x) => {
  const decimalPlacesTolerance = 8;
  return Math.round(x * 10 ** decimalPlacesTolerance) / 10 ** decimalPlacesTolerance;
};
function findAdjacentGaps(gaps, shapeId, gapLength, direction, intersection) {
  const matches2 = gaps.filter(
    (gap) => (direction === "forward" ? gap.startNode.id === shapeId : gap.endNode.id === shapeId) && round(gap.length) === round(gapLength) && rangeIntersection(
      gap.breadthIntersection[0],
      gap.breadthIntersection[1],
      intersection[0],
      intersection[1]
    )
  );
  if (matches2.length === 0) return [];
  const nextNodes = /* @__PURE__ */ new Set();
  matches2.forEach((match) => {
    const node = direction === "forward" ? match.endNode.id : match.startNode.id;
    if (!nextNodes.has(node)) {
      nextNodes.add(node);
      const foundGaps = findAdjacentGaps(
        gaps,
        node,
        gapLength,
        direction,
        rangeIntersection(
          match.breadthIntersection[0],
          match.breadthIntersection[1],
          intersection[0],
          intersection[1]
        )
      );
      matches2.push(...foundGaps);
    }
  });
  return matches2;
}
function dedupeGapSnaps(snaps) {
  snaps.sort((a, b) => b.gaps.length - a.gaps.length);
  for (let i = snaps.length - 1; i > 0; i--) {
    const snap = snaps[i];
    for (let j = i - 1; j >= 0; j--) {
      const otherSnap = snaps[j];
      if (otherSnap.direction === snap.direction && snap.gaps.every(
        (gap) => otherSnap.gaps.some(
          (otherGap) => round(gap.startEdge[0].x) === round(otherGap.startEdge[0].x) && round(gap.startEdge[0].y) === round(otherGap.startEdge[0].y) && round(gap.startEdge[1].x) === round(otherGap.startEdge[1].x) && round(gap.startEdge[1].y) === round(otherGap.startEdge[1].y)
        ) && otherSnap.gaps.some(
          (otherGap) => round(gap.endEdge[0].x) === round(otherGap.endEdge[0].x) && round(gap.endEdge[0].y) === round(otherGap.endEdge[0].y) && round(gap.endEdge[1].x) === round(otherGap.endEdge[1].x) && round(gap.endEdge[1].y) === round(otherGap.endEdge[1].y)
        )
      )) {
        snaps.splice(i, 1);
        break;
      }
    }
  }
}
_getSnapPointsCache_dec = [computed], _getSnappablePoints_dec = [computed], _getSnappableGapNodes_dec = [computed], _getVisibleGaps_dec = [computed];
var BoundsSnaps = class {
  constructor(manager) {
    this.manager = manager;
    __runInitializers5(_init5, 5, this);
    __publicField6(this, "editor");
    this.editor = manager.editor;
  }
  getSnapPointsCache() {
    const { editor } = this;
    return editor.store.createComputedCache("snapPoints", (shape) => {
      const pageTransform = editor.getShapePageTransform(shape.id);
      if (!pageTransform) return void 0;
      const boundsSnapGeometry = editor.getShapeUtil(shape).getBoundsSnapGeometry(shape);
      const snapPoints = boundsSnapGeometry.points ?? editor.getShapeGeometry(shape).bounds.cornersAndCenter;
      if (!pageTransform || !snapPoints) return void 0;
      return snapPoints.map((point, i) => {
        const { x, y } = Mat.applyToPoint(pageTransform, point);
        return { x, y, id: `${shape.id}:${i}` };
      });
    });
  }
  getSnapPoints(shapeId) {
    return this.getSnapPointsCache().get(shapeId) ?? [];
  }
  getSnappablePoints() {
    const snapPointsCache = this.getSnapPointsCache();
    const snappableShapes = this.manager.getSnappableShapes();
    const result = [];
    for (const shapeId of snappableShapes) {
      const snapPoints = snapPointsCache.get(shapeId);
      if (snapPoints) {
        result.push(...snapPoints);
      }
    }
    return result;
  }
  getSnappableGapNodes() {
    return Array.from(this.manager.getSnappableShapes(), (shapeId) => ({
      id: shapeId,
      pageBounds: assertExists(this.editor.getShapePageBounds(shapeId))
    }));
  }
  getVisibleGaps() {
    const horizontal = [];
    const vertical = [];
    let startNode, endNode;
    const sortedShapesOnCurrentPageHorizontal = this.getSnappableGapNodes().sort((a, b) => {
      return a.pageBounds.minX - b.pageBounds.minX;
    });
    for (let i = 0; i < sortedShapesOnCurrentPageHorizontal.length; i++) {
      startNode = sortedShapesOnCurrentPageHorizontal[i];
      for (let j = i + 1; j < sortedShapesOnCurrentPageHorizontal.length; j++) {
        endNode = sortedShapesOnCurrentPageHorizontal[j];
        if (
          // is there space between the boxes
          startNode.pageBounds.maxX < endNode.pageBounds.minX && // and they overlap in the y axis
          rangesOverlap(
            startNode.pageBounds.minY,
            startNode.pageBounds.maxY,
            endNode.pageBounds.minY,
            endNode.pageBounds.maxY
          )
        ) {
          horizontal.push({
            startNode,
            endNode,
            startEdge: [
              new Vec(startNode.pageBounds.maxX, startNode.pageBounds.minY),
              new Vec(startNode.pageBounds.maxX, startNode.pageBounds.maxY)
            ],
            endEdge: [
              new Vec(endNode.pageBounds.minX, endNode.pageBounds.minY),
              new Vec(endNode.pageBounds.minX, endNode.pageBounds.maxY)
            ],
            length: endNode.pageBounds.minX - startNode.pageBounds.maxX,
            breadthIntersection: rangeIntersection(
              startNode.pageBounds.minY,
              startNode.pageBounds.maxY,
              endNode.pageBounds.minY,
              endNode.pageBounds.maxY
            )
          });
        }
      }
    }
    const sortedShapesOnCurrentPageVertical = sortedShapesOnCurrentPageHorizontal.sort((a, b) => {
      return a.pageBounds.minY - b.pageBounds.minY;
    });
    for (let i = 0; i < sortedShapesOnCurrentPageVertical.length; i++) {
      startNode = sortedShapesOnCurrentPageVertical[i];
      for (let j = i + 1; j < sortedShapesOnCurrentPageVertical.length; j++) {
        endNode = sortedShapesOnCurrentPageVertical[j];
        if (
          // is there space between the boxes
          startNode.pageBounds.maxY < endNode.pageBounds.minY && // do they overlap in the x axis
          rangesOverlap(
            startNode.pageBounds.minX,
            startNode.pageBounds.maxX,
            endNode.pageBounds.minX,
            endNode.pageBounds.maxX
          )
        ) {
          vertical.push({
            startNode,
            endNode,
            startEdge: [
              new Vec(startNode.pageBounds.minX, startNode.pageBounds.maxY),
              new Vec(startNode.pageBounds.maxX, startNode.pageBounds.maxY)
            ],
            endEdge: [
              new Vec(endNode.pageBounds.minX, endNode.pageBounds.minY),
              new Vec(endNode.pageBounds.maxX, endNode.pageBounds.minY)
            ],
            length: endNode.pageBounds.minY - startNode.pageBounds.maxY,
            breadthIntersection: rangeIntersection(
              startNode.pageBounds.minX,
              startNode.pageBounds.maxX,
              endNode.pageBounds.minX,
              endNode.pageBounds.maxX
            )
          });
        }
      }
    }
    return { horizontal, vertical };
  }
  snapTranslateShapes({
    lockedAxis,
    initialSelectionPageBounds,
    initialSelectionSnapPoints,
    dragDelta
  }) {
    var _a6, _b3;
    const snapThreshold = this.manager.getSnapThreshold();
    const visibleSnapPointsNotInSelection = this.getSnappablePoints();
    const selectionPageBounds = initialSelectionPageBounds.clone().translate(dragDelta);
    const selectionSnapPoints = initialSelectionSnapPoints.map(
      ({ x, y }, i) => ({
        id: "selection:" + i,
        x: x + dragDelta.x,
        y: y + dragDelta.y
      })
    );
    const otherNodeSnapPoints = visibleSnapPointsNotInSelection;
    const nearestSnapsX = [];
    const nearestSnapsY = [];
    const minOffset = new Vec(snapThreshold, snapThreshold);
    this.collectPointSnaps({
      minOffset,
      nearestSnapsX,
      nearestSnapsY,
      otherNodeSnapPoints,
      selectionSnapPoints
    });
    this.collectGapSnaps({
      selectionPageBounds,
      nearestSnapsX,
      nearestSnapsY,
      minOffset
    });
    const nudge = new Vec(
      lockedAxis === "x" ? 0 : ((_a6 = nearestSnapsX[0]) == null ? void 0 : _a6.nudge) ?? 0,
      lockedAxis === "y" ? 0 : ((_b3 = nearestSnapsY[0]) == null ? void 0 : _b3.nudge) ?? 0
    );
    minOffset.x = 0;
    minOffset.y = 0;
    nearestSnapsX.length = 0;
    nearestSnapsY.length = 0;
    selectionSnapPoints.forEach((s) => {
      s.x += nudge.x;
      s.y += nudge.y;
    });
    selectionPageBounds.translate(nudge);
    this.collectPointSnaps({
      minOffset,
      nearestSnapsX,
      nearestSnapsY,
      otherNodeSnapPoints,
      selectionSnapPoints
    });
    this.collectGapSnaps({
      selectionPageBounds,
      nearestSnapsX,
      nearestSnapsY,
      minOffset
    });
    const pointSnapsLines = this.getPointSnapLines({
      nearestSnapsX,
      nearestSnapsY
    });
    const gapSnapLines = this.getGapSnapLines({
      selectionPageBounds,
      nearestSnapsX,
      nearestSnapsY
    });
    this.manager.setIndicators([...gapSnapLines, ...pointSnapsLines]);
    return { nudge };
  }
  snapResizeShapes({
    initialSelectionPageBounds,
    dragDelta,
    handle: originalHandle,
    isAspectRatioLocked,
    isResizingFromCenter
  }) {
    var _a6, _b3;
    const snapThreshold = this.manager.getSnapThreshold();
    const {
      box: unsnappedResizedPageBounds,
      scaleX,
      scaleY
    } = Box.Resize(
      initialSelectionPageBounds,
      originalHandle,
      isResizingFromCenter ? dragDelta.x * 2 : dragDelta.x,
      isResizingFromCenter ? dragDelta.y * 2 : dragDelta.y,
      isAspectRatioLocked
    );
    let handle = originalHandle;
    if (scaleX < 0) {
      handle = flipSelectionHandleX(handle);
    }
    if (scaleY < 0) {
      handle = flipSelectionHandleY(handle);
    }
    if (isResizingFromCenter) {
      unsnappedResizedPageBounds.center = initialSelectionPageBounds.center;
    }
    const isXLocked = handle === "top" || handle === "bottom";
    const isYLocked = handle === "left" || handle === "right";
    const selectionSnapPoints = getResizeSnapPointsForHandle(handle, unsnappedResizedPageBounds);
    const otherNodeSnapPoints = this.getSnappablePoints();
    const nearestSnapsX = [];
    const nearestSnapsY = [];
    const minOffset = new Vec(snapThreshold, snapThreshold);
    this.collectPointSnaps({
      minOffset,
      nearestSnapsX,
      nearestSnapsY,
      otherNodeSnapPoints,
      selectionSnapPoints
    });
    const nudge = new Vec(
      isXLocked ? 0 : ((_a6 = nearestSnapsX[0]) == null ? void 0 : _a6.nudge) ?? 0,
      isYLocked ? 0 : ((_b3 = nearestSnapsY[0]) == null ? void 0 : _b3.nudge) ?? 0
    );
    if (isAspectRatioLocked && isSelectionCorner(handle) && nudge.len() !== 0) {
      const primaryNudgeAxis = nearestSnapsX.length && nearestSnapsY.length ? Math.abs(nudge.x) < Math.abs(nudge.y) ? "x" : "y" : nearestSnapsX.length ? "x" : "y";
      const ratio = initialSelectionPageBounds.aspectRatio;
      if (primaryNudgeAxis === "x") {
        nearestSnapsY.length = 0;
        nudge.y = nudge.x / ratio;
        if (handle === "bottom_left" || handle === "top_right") {
          nudge.y = -nudge.y;
        }
      } else {
        nearestSnapsX.length = 0;
        nudge.x = nudge.y * ratio;
        if (handle === "bottom_left" || handle === "top_right") {
          nudge.x = -nudge.x;
        }
      }
    }
    const snappedDelta = Vec.Add(dragDelta, nudge);
    const { box: snappedResizedPageBounds } = Box.Resize(
      initialSelectionPageBounds,
      originalHandle,
      isResizingFromCenter ? snappedDelta.x * 2 : snappedDelta.x,
      isResizingFromCenter ? snappedDelta.y * 2 : snappedDelta.y,
      isAspectRatioLocked
    );
    if (isResizingFromCenter) {
      snappedResizedPageBounds.center = initialSelectionPageBounds.center;
    }
    const snappedSelectionPoints = getResizeSnapPointsForHandle("any", snappedResizedPageBounds);
    nearestSnapsX.length = 0;
    nearestSnapsY.length = 0;
    minOffset.x = 0;
    minOffset.y = 0;
    this.collectPointSnaps({
      minOffset,
      nearestSnapsX,
      nearestSnapsY,
      otherNodeSnapPoints,
      selectionSnapPoints: snappedSelectionPoints
    });
    const pointSnaps = this.getPointSnapLines({
      nearestSnapsX,
      nearestSnapsY
    });
    this.manager.setIndicators([...pointSnaps]);
    return { nudge };
  }
  collectPointSnaps({
    selectionSnapPoints,
    otherNodeSnapPoints,
    minOffset,
    nearestSnapsX,
    nearestSnapsY
  }) {
    for (const thisSnapPoint of selectionSnapPoints) {
      for (const otherSnapPoint of otherNodeSnapPoints) {
        const offset4 = Vec.Sub(thisSnapPoint, otherSnapPoint);
        const offsetX = Math.abs(offset4.x);
        const offsetY = Math.abs(offset4.y);
        if (round(offsetX) <= round(minOffset.x)) {
          if (round(offsetX) < round(minOffset.x)) {
            nearestSnapsX.length = 0;
          }
          nearestSnapsX.push({
            type: "points",
            points: { thisPoint: thisSnapPoint, otherPoint: otherSnapPoint },
            nudge: otherSnapPoint.x - thisSnapPoint.x
          });
          minOffset.x = offsetX;
        }
        if (round(offsetY) <= round(minOffset.y)) {
          if (round(offsetY) < round(minOffset.y)) {
            nearestSnapsY.length = 0;
          }
          nearestSnapsY.push({
            type: "points",
            points: { thisPoint: thisSnapPoint, otherPoint: otherSnapPoint },
            nudge: otherSnapPoint.y - thisSnapPoint.y
          });
          minOffset.y = offsetY;
        }
      }
    }
  }
  collectGapSnaps({
    selectionPageBounds,
    minOffset,
    nearestSnapsX,
    nearestSnapsY
  }) {
    const { horizontal, vertical } = this.getVisibleGaps();
    for (const gap of horizontal) {
      if (!rangesOverlap(
        gap.breadthIntersection[0],
        gap.breadthIntersection[1],
        selectionPageBounds.minY,
        selectionPageBounds.maxY
      )) {
        continue;
      }
      const gapMidX = gap.startEdge[0].x + gap.length / 2;
      const centerNudge = gapMidX - selectionPageBounds.center.x;
      const gapIsLargerThanSelection = gap.length > selectionPageBounds.width;
      if (gapIsLargerThanSelection && round(Math.abs(centerNudge)) <= round(minOffset.x)) {
        if (round(Math.abs(centerNudge)) < round(minOffset.x)) {
          nearestSnapsX.length = 0;
        }
        minOffset.x = Math.abs(centerNudge);
        const snap = {
          type: "gap_center",
          gap,
          nudge: centerNudge
        };
        const otherCenterSnap = nearestSnapsX.find(({ type }) => type === "gap_center");
        const gapBreadthsOverlap = otherCenterSnap && rangeIntersection(
          gap.breadthIntersection[0],
          gap.breadthIntersection[1],
          otherCenterSnap.gap.breadthIntersection[0],
          otherCenterSnap.gap.breadthIntersection[1]
        );
        if (otherCenterSnap && otherCenterSnap.gap.length > gap.length && gapBreadthsOverlap) {
          nearestSnapsX[nearestSnapsX.indexOf(otherCenterSnap)] = snap;
        } else if (!otherCenterSnap || !gapBreadthsOverlap) {
          nearestSnapsX.push(snap);
        }
      }
      const duplicationLeftX = gap.startNode.pageBounds.minX - gap.length;
      const selectionRightX = selectionPageBounds.maxX;
      const duplicationLeftNudge = duplicationLeftX - selectionRightX;
      if (round(Math.abs(duplicationLeftNudge)) <= round(minOffset.x)) {
        if (round(Math.abs(duplicationLeftNudge)) < round(minOffset.x)) {
          nearestSnapsX.length = 0;
        }
        minOffset.x = Math.abs(duplicationLeftNudge);
        nearestSnapsX.push({
          type: "gap_duplicate",
          gap,
          protrusionDirection: "left",
          nudge: duplicationLeftNudge
        });
      }
      const duplicationRightX = gap.endNode.pageBounds.maxX + gap.length;
      const selectionLeftX = selectionPageBounds.minX;
      const duplicationRightNudge = duplicationRightX - selectionLeftX;
      if (round(Math.abs(duplicationRightNudge)) <= round(minOffset.x)) {
        if (round(Math.abs(duplicationRightNudge)) < round(minOffset.x)) {
          nearestSnapsX.length = 0;
        }
        minOffset.x = Math.abs(duplicationRightNudge);
        nearestSnapsX.push({
          type: "gap_duplicate",
          gap,
          protrusionDirection: "right",
          nudge: duplicationRightNudge
        });
      }
    }
    for (const gap of vertical) {
      if (!rangesOverlap(
        gap.breadthIntersection[0],
        gap.breadthIntersection[1],
        selectionPageBounds.minX,
        selectionPageBounds.maxX
      )) {
        continue;
      }
      const gapMidY = gap.startEdge[0].y + gap.length / 2;
      const centerNudge = gapMidY - selectionPageBounds.center.y;
      const gapIsLargerThanSelection = gap.length > selectionPageBounds.height;
      if (gapIsLargerThanSelection && round(Math.abs(centerNudge)) <= round(minOffset.y)) {
        if (round(Math.abs(centerNudge)) < round(minOffset.y)) {
          nearestSnapsY.length = 0;
        }
        minOffset.y = Math.abs(centerNudge);
        const snap = {
          type: "gap_center",
          gap,
          nudge: centerNudge
        };
        const otherCenterSnap = nearestSnapsY.find(({ type }) => type === "gap_center");
        const gapBreadthsOverlap = otherCenterSnap && rangesOverlap(
          otherCenterSnap.gap.breadthIntersection[0],
          otherCenterSnap.gap.breadthIntersection[1],
          gap.breadthIntersection[0],
          gap.breadthIntersection[1]
        );
        if (otherCenterSnap && otherCenterSnap.gap.length > gap.length && gapBreadthsOverlap) {
          nearestSnapsY[nearestSnapsY.indexOf(otherCenterSnap)] = snap;
        } else if (!otherCenterSnap || !gapBreadthsOverlap) {
          nearestSnapsY.push(snap);
        }
        continue;
      }
      const duplicationTopY = gap.startNode.pageBounds.minY - gap.length;
      const selectionBottomY = selectionPageBounds.maxY;
      const duplicationTopNudge = duplicationTopY - selectionBottomY;
      if (round(Math.abs(duplicationTopNudge)) <= round(minOffset.y)) {
        if (round(Math.abs(duplicationTopNudge)) < round(minOffset.y)) {
          nearestSnapsY.length = 0;
        }
        minOffset.y = Math.abs(duplicationTopNudge);
        nearestSnapsY.push({
          type: "gap_duplicate",
          gap,
          protrusionDirection: "top",
          nudge: duplicationTopNudge
        });
      }
      const duplicationBottomY = gap.endNode.pageBounds.maxY + gap.length;
      const selectionTopY = selectionPageBounds.minY;
      const duplicationBottomNudge = duplicationBottomY - selectionTopY;
      if (round(Math.abs(duplicationBottomNudge)) <= round(minOffset.y)) {
        if (round(Math.abs(duplicationBottomNudge)) < round(minOffset.y)) {
          nearestSnapsY.length = 0;
        }
        minOffset.y = Math.abs(duplicationBottomNudge);
        nearestSnapsY.push({
          type: "gap_duplicate",
          gap,
          protrusionDirection: "bottom",
          nudge: duplicationBottomNudge
        });
      }
    }
  }
  getPointSnapLines({
    nearestSnapsX,
    nearestSnapsY
  }) {
    const snapGroupsX = {};
    const snapGroupsY = {};
    if (nearestSnapsX.length > 0) {
      for (const snap of nearestSnapsX) {
        if (snap.type === "points") {
          const key = round(snap.points.otherPoint.x);
          if (!snapGroupsX[key]) {
            snapGroupsX[key] = [];
          }
          snapGroupsX[key].push(snap.points);
        }
      }
    }
    if (nearestSnapsY.length > 0) {
      for (const snap of nearestSnapsY) {
        if (snap.type === "points") {
          const key = round(snap.points.otherPoint.y);
          if (!snapGroupsY[key]) {
            snapGroupsY[key] = [];
          }
          snapGroupsY[key].push(snap.points);
        }
      }
    }
    return Object.values(snapGroupsX).concat(Object.values(snapGroupsY)).map((snapGroup) => ({
      id: uniqueId(),
      type: "points",
      points: dedupe(
        snapGroup.map((snap) => Vec.From(snap.otherPoint)).concat(snapGroup.map((snap) => Vec.From(snap.thisPoint))),
        (a, b) => a.equals(b)
      )
    }));
  }
  getGapSnapLines({
    selectionPageBounds,
    nearestSnapsX,
    nearestSnapsY
  }) {
    const { vertical, horizontal } = this.getVisibleGaps();
    const selectionSides = {
      top: selectionPageBounds.sides[0],
      right: selectionPageBounds.sides[1],
      // need bottom and left to be sorted asc, which .sides is not.
      bottom: [selectionPageBounds.corners[3], selectionPageBounds.corners[2]],
      left: [selectionPageBounds.corners[0], selectionPageBounds.corners[3]]
    };
    const result = [];
    if (nearestSnapsX.length > 0) {
      for (const snap of nearestSnapsX) {
        if (snap.type === "points") continue;
        const {
          gap: { breadthIntersection, startEdge, startNode, endNode, length, endEdge }
        } = snap;
        switch (snap.type) {
          case "gap_center": {
            const newGapsLength = (length - selectionPageBounds.width) / 2;
            const gapBreadthIntersection = rangeIntersection(
              breadthIntersection[0],
              breadthIntersection[1],
              selectionPageBounds.minY,
              selectionPageBounds.maxY
            );
            result.push({
              type: "gaps",
              direction: "horizontal",
              id: uniqueId(),
              gaps: [
                ...findAdjacentGaps(
                  horizontal,
                  startNode.id,
                  newGapsLength,
                  "backward",
                  gapBreadthIntersection
                ),
                {
                  startEdge,
                  endEdge: selectionSides.left
                },
                {
                  startEdge: selectionSides.right,
                  endEdge
                },
                ...findAdjacentGaps(
                  horizontal,
                  endNode.id,
                  newGapsLength,
                  "forward",
                  gapBreadthIntersection
                )
              ]
            });
            break;
          }
          case "gap_duplicate": {
            const gapBreadthIntersection = rangeIntersection(
              breadthIntersection[0],
              breadthIntersection[1],
              selectionPageBounds.minY,
              selectionPageBounds.maxY
            );
            result.push({
              type: "gaps",
              direction: "horizontal",
              id: uniqueId(),
              gaps: snap.protrusionDirection === "left" ? [
                {
                  startEdge: selectionSides.right,
                  endEdge: startEdge.map(
                    (v) => v.clone().addXY(-startNode.pageBounds.width, 0)
                  )
                },
                { startEdge, endEdge },
                ...findAdjacentGaps(
                  horizontal,
                  endNode.id,
                  length,
                  "forward",
                  gapBreadthIntersection
                )
              ] : [
                ...findAdjacentGaps(
                  horizontal,
                  startNode.id,
                  length,
                  "backward",
                  gapBreadthIntersection
                ),
                { startEdge, endEdge },
                {
                  startEdge: endEdge.map(
                    (v) => v.clone().addXY(snap.gap.endNode.pageBounds.width, 0)
                  ),
                  endEdge: selectionSides.left
                }
              ]
            });
            break;
          }
        }
      }
    }
    if (nearestSnapsY.length > 0) {
      for (const snap of nearestSnapsY) {
        if (snap.type === "points") continue;
        const {
          gap: { breadthIntersection, startEdge, startNode, endNode, length, endEdge }
        } = snap;
        switch (snap.type) {
          case "gap_center": {
            const newGapsLength = (length - selectionPageBounds.height) / 2;
            const gapBreadthIntersection = rangeIntersection(
              breadthIntersection[0],
              breadthIntersection[1],
              selectionPageBounds.minX,
              selectionPageBounds.maxX
            );
            result.push({
              type: "gaps",
              direction: "vertical",
              id: uniqueId(),
              gaps: [
                ...findAdjacentGaps(
                  vertical,
                  startNode.id,
                  newGapsLength,
                  "backward",
                  gapBreadthIntersection
                ),
                {
                  startEdge,
                  endEdge: selectionSides.top
                },
                {
                  startEdge: selectionSides.bottom,
                  endEdge
                },
                ...findAdjacentGaps(
                  vertical,
                  snap.gap.endNode.id,
                  newGapsLength,
                  "forward",
                  gapBreadthIntersection
                )
              ]
            });
            break;
          }
          case "gap_duplicate":
            {
              const gapBreadthIntersection = rangeIntersection(
                breadthIntersection[0],
                breadthIntersection[1],
                selectionPageBounds.minX,
                selectionPageBounds.maxX
              );
              result.push({
                type: "gaps",
                direction: "vertical",
                id: uniqueId(),
                gaps: snap.protrusionDirection === "top" ? [
                  {
                    startEdge: selectionSides.bottom,
                    endEdge: startEdge.map(
                      (v) => v.clone().addXY(0, -startNode.pageBounds.height)
                    )
                  },
                  { startEdge, endEdge },
                  ...findAdjacentGaps(
                    vertical,
                    endNode.id,
                    length,
                    "forward",
                    gapBreadthIntersection
                  )
                ] : [
                  ...findAdjacentGaps(
                    vertical,
                    startNode.id,
                    length,
                    "backward",
                    gapBreadthIntersection
                  ),
                  { startEdge, endEdge },
                  {
                    startEdge: endEdge.map(
                      (v) => v.clone().addXY(0, endNode.pageBounds.height)
                    ),
                    endEdge: selectionSides.top
                  }
                ]
              });
            }
            break;
        }
      }
    }
    dedupeGapSnaps(result);
    return result;
  }
};
_init5 = __decoratorStart5(null);
__decorateElement5(_init5, 1, "getSnapPointsCache", _getSnapPointsCache_dec, BoundsSnaps);
__decorateElement5(_init5, 1, "getSnappablePoints", _getSnappablePoints_dec, BoundsSnaps);
__decorateElement5(_init5, 1, "getSnappableGapNodes", _getSnappableGapNodes_dec, BoundsSnaps);
__decorateElement5(_init5, 1, "getVisibleGaps", _getVisibleGaps_dec, BoundsSnaps);
__decoratorMetadata5(_init5, BoundsSnaps);
function getResizeSnapPointsForHandle(handle, selectionPageBounds) {
  const { minX, maxX, minY, maxY } = selectionPageBounds;
  const result = [];
  switch (handle) {
    case "top":
    case "left":
    case "top_left":
    case "any":
      result.push({
        id: "top_left",
        handle: "top_left",
        x: minX,
        y: minY
      });
  }
  switch (handle) {
    case "top":
    case "right":
    case "top_right":
    case "any":
      result.push({
        id: "top_right",
        handle: "top_right",
        x: maxX,
        y: minY
      });
  }
  switch (handle) {
    case "bottom":
    case "right":
    case "bottom_right":
    case "any":
      result.push({
        id: "bottom_right",
        handle: "bottom_right",
        x: maxX,
        y: maxY
      });
  }
  switch (handle) {
    case "bottom":
    case "left":
    case "bottom_left":
    case "any":
      result.push({
        id: "bottom_left",
        handle: "bottom_left",
        x: minX,
        y: maxY
      });
  }
  return result;
}

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/managers/SnapManager/HandleSnaps.mjs
var __create6 = Object.create;
var __defProp6 = Object.defineProperty;
var __getOwnPropDesc6 = Object.getOwnPropertyDescriptor;
var __knownSymbol6 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError6 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp6 = (obj, key, value) => key in obj ? __defProp6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name6 = (target, value) => __defProp6(target, "name", { value, configurable: true });
var __decoratorStart6 = (base2) => [, , , __create6((base2 == null ? void 0 : base2[__knownSymbol6("metadata")]) ?? null)];
var __decoratorStrings6 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn6 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError6("Function expected") : fn;
var __decoratorContext6 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings6[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError6("Already initialized") : fns.push(__expectFn6(fn || null)) });
var __decoratorMetadata6 = (array, target) => __defNormalProp6(target, __knownSymbol6("metadata"), array[3]);
var __runInitializers6 = (array, flags, self2, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self2) : value = fns[i].call(self2, value);
  return value;
};
var __decorateElement6 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings6[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc6(k < 4 ? target : { get [name]() {
    return __privateGet7(this, extra);
  }, set [name](x) {
    return __privateSet7(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name6(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name6(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext6(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn6(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet7 : __privateMethod6)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet7(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn6(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError6("Object expected");
    else __expectFn6(fn = it.get) && (desc.get = fn), __expectFn6(fn = it.set) && (desc.set = fn), __expectFn6(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata6(array, target), desc && __defProp6(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __publicField7 = (obj, key, value) => __defNormalProp6(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck6 = (obj, member, msg2) => member.has(obj) || __typeError6("Cannot " + msg2);
var __privateIn6 = (member, obj) => Object(obj) !== obj ? __typeError6('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet7 = (obj, member, getter) => (__accessCheck6(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet7 = (obj, member, value, setter) => (__accessCheck6(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod6 = (obj, member, method) => (__accessCheck6(obj, member, "access private method"), method);
var _getSnapGeometryCache_dec;
var _init6;
var defaultGetSelfSnapOutline = () => null;
var defaultGetSelfSnapPoints = () => [];
_getSnapGeometryCache_dec = [computed];
var HandleSnaps = class {
  constructor(manager) {
    this.manager = manager;
    __runInitializers6(_init6, 5, this);
    __publicField7(this, "editor");
    this.editor = manager.editor;
  }
  getSnapGeometryCache() {
    const { editor } = this;
    return editor.store.createComputedCache("handle snap geometry", (shape) => {
      const snapGeometry = editor.getShapeUtil(shape).getHandleSnapGeometry(shape);
      const getSelfSnapOutline = snapGeometry.getSelfSnapOutline ? snapGeometry.getSelfSnapOutline.bind(snapGeometry) : defaultGetSelfSnapOutline;
      const getSelfSnapPoints = snapGeometry.getSelfSnapPoints ? snapGeometry.getSelfSnapPoints.bind(snapGeometry) : defaultGetSelfSnapPoints;
      return {
        outline: snapGeometry.outline === void 0 ? editor.getShapeGeometry(shape) : snapGeometry.outline,
        points: snapGeometry.points ?? [],
        getSelfSnapOutline,
        getSelfSnapPoints
      };
    });
  }
  *iterateSnapPointsInPageSpace(currentShapeId, currentHandle) {
    var _a6, _b3;
    const selfSnapPoints = (_a6 = this.getSnapGeometryCache().get(currentShapeId)) == null ? void 0 : _a6.getSelfSnapPoints(currentHandle);
    if (selfSnapPoints && selfSnapPoints.length) {
      const shapePageTransform = assertExists(this.editor.getShapePageTransform(currentShapeId));
      for (const point of selfSnapPoints) {
        yield shapePageTransform.applyToPoint(point);
      }
    }
    for (const shapeId of this.manager.getSnappableShapes()) {
      if (shapeId === currentShapeId) continue;
      const snapPoints = (_b3 = this.getSnapGeometryCache().get(shapeId)) == null ? void 0 : _b3.points;
      if (!snapPoints || !snapPoints.length) continue;
      const shapePageTransform = assertExists(this.editor.getShapePageTransform(shapeId));
      for (const point of snapPoints) {
        yield shapePageTransform.applyToPoint(point);
      }
    }
  }
  *iterateSnapOutlines(currentShapeId, currentHandle) {
    var _a6, _b3;
    const selfSnapOutline = (_a6 = this.getSnapGeometryCache().get(currentShapeId)) == null ? void 0 : _a6.getSelfSnapOutline(currentHandle);
    if (selfSnapOutline) {
      yield { shapeId: currentShapeId, outline: selfSnapOutline };
    }
    for (const shapeId of this.manager.getSnappableShapes()) {
      if (shapeId === currentShapeId) continue;
      const snapOutline = (_b3 = this.getSnapGeometryCache().get(shapeId)) == null ? void 0 : _b3.outline;
      if (!snapOutline) continue;
      yield { shapeId, outline: snapOutline };
    }
  }
  getHandleSnapPosition({
    currentShapeId,
    handle,
    handleInPageSpace
  }) {
    const snapThreshold = this.manager.getSnapThreshold();
    let minDistanceForSnapPoint = snapThreshold;
    let nearestSnapPoint = null;
    for (const snapPoint of this.iterateSnapPointsInPageSpace(currentShapeId, handle)) {
      if (Vec.DistMin(handleInPageSpace, snapPoint, minDistanceForSnapPoint)) {
        minDistanceForSnapPoint = Vec.Dist(handleInPageSpace, snapPoint);
        nearestSnapPoint = snapPoint;
      }
    }
    if (nearestSnapPoint) return nearestSnapPoint;
    let minDistanceForOutline = snapThreshold;
    let nearestPointOnOutline = null;
    for (const { shapeId, outline } of this.iterateSnapOutlines(currentShapeId, handle)) {
      const shapePageTransform = assertExists(this.editor.getShapePageTransform(shapeId));
      const pointInShapeSpace = this.editor.getPointInShapeSpace(shapeId, handleInPageSpace);
      const nearestShapePointInShapeSpace = outline.nearestPoint(pointInShapeSpace);
      const nearestInPageSpace = shapePageTransform.applyToPoint(nearestShapePointInShapeSpace);
      if (Vec.DistMin(handleInPageSpace, nearestInPageSpace, minDistanceForOutline)) {
        minDistanceForOutline = Vec.Dist(handleInPageSpace, nearestInPageSpace);
        nearestPointOnOutline = nearestInPageSpace;
      }
    }
    if (nearestPointOnOutline) return nearestPointOnOutline;
    return null;
  }
  getHandleSnapData({
    handle,
    currentShapeId
  }) {
    const snapThreshold = this.manager.getSnapThreshold();
    const currentShapeTransform = assertExists(this.editor.getShapePageTransform(currentShapeId));
    const handleInPageSpace = currentShapeTransform.applyToPoint(handle);
    let nearestXSnap = null;
    let nearestYSnap = null;
    let minOffsetX = snapThreshold;
    let minOffsetY = snapThreshold;
    for (const snapPoint of this.iterateSnapPointsInPageSpace(currentShapeId, handle)) {
      const offsetX = Math.abs(handleInPageSpace.x - snapPoint.x);
      const offsetY = Math.abs(handleInPageSpace.y - snapPoint.y);
      if (offsetX < minOffsetX) {
        minOffsetX = offsetX;
        nearestXSnap = snapPoint;
      }
      if (offsetY < minOffsetY) {
        minOffsetY = offsetY;
        nearestYSnap = snapPoint;
      }
    }
    if (!nearestXSnap && !nearestYSnap) {
      return null;
    }
    const nudge = new Vec(
      nearestXSnap ? nearestXSnap.x - handleInPageSpace.x : 0,
      nearestYSnap ? nearestYSnap.y - handleInPageSpace.y : 0
    );
    const snappedHandle = Vec.Add(handleInPageSpace, nudge);
    const snaps = [];
    if (nearestXSnap) {
      const snappedHandleOnX = new Vec(nearestXSnap.x, snappedHandle.y);
      snaps.push({
        id: uniqueId(),
        type: "points",
        points: [nearestXSnap, snappedHandleOnX]
      });
    }
    if (nearestYSnap) {
      const snappedHandleOnY = new Vec(snappedHandle.x, nearestYSnap.y);
      snaps.push({
        id: uniqueId(),
        type: "points",
        points: [nearestYSnap, snappedHandleOnY]
      });
    }
    return { snaps, nudge };
  }
  snapHandle({
    currentShapeId,
    handle
  }) {
    const currentShapeTransform = assertExists(this.editor.getShapePageTransform(currentShapeId));
    const handleInPageSpace = currentShapeTransform.applyToPoint(handle);
    const snapType = handle.canSnap ? "point" : handle.snapType;
    if (snapType === "point") {
      const snapPosition = this.getHandleSnapPosition({ currentShapeId, handle, handleInPageSpace });
      if (!snapPosition) {
        return null;
      }
      this.manager.setIndicators([
        {
          id: uniqueId(),
          type: "points",
          points: [snapPosition]
        }
      ]);
      return { nudge: Vec.Sub(snapPosition, handleInPageSpace) };
    }
    if (snapType === "align") {
      const snapData = this.getHandleSnapData({
        handle,
        currentShapeId
      });
      if (!snapData) {
        return null;
      }
      this.manager.setIndicators(snapData.snaps);
      return { nudge: snapData.nudge };
    }
    return null;
  }
};
_init6 = __decoratorStart6(null);
__decorateElement6(_init6, 1, "getSnapGeometryCache", _getSnapGeometryCache_dec, HandleSnaps);
__decoratorMetadata6(_init6, HandleSnaps);

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/managers/SnapManager/SnapManager.mjs
var __create7 = Object.create;
var __defProp7 = Object.defineProperty;
var __getOwnPropDesc7 = Object.getOwnPropertyDescriptor;
var __knownSymbol7 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError7 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp7 = (obj, key, value) => key in obj ? __defProp7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name7 = (target, value) => __defProp7(target, "name", { value, configurable: true });
var __decoratorStart7 = (base2) => [, , , __create7((base2 == null ? void 0 : base2[__knownSymbol7("metadata")]) ?? null)];
var __decoratorStrings7 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn7 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError7("Function expected") : fn;
var __decoratorContext7 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings7[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError7("Already initialized") : fns.push(__expectFn7(fn || null)) });
var __decoratorMetadata7 = (array, target) => __defNormalProp7(target, __knownSymbol7("metadata"), array[3]);
var __runInitializers7 = (array, flags, self2, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self2) : value = fns[i].call(self2, value);
  return value;
};
var __decorateElement7 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings7[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc7(k < 4 ? target : { get [name]() {
    return __privateGet8(this, extra);
  }, set [name](x) {
    return __privateSet8(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name7(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name7(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext7(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn7(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet8 : __privateMethod7)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet8(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn7(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError7("Object expected");
    else __expectFn7(fn = it.get) && (desc.get = fn), __expectFn7(fn = it.set) && (desc.set = fn), __expectFn7(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata7(array, target), desc && __defProp7(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __publicField8 = (obj, key, value) => __defNormalProp7(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck7 = (obj, member, msg2) => member.has(obj) || __typeError7("Cannot " + msg2);
var __privateIn7 = (member, obj) => Object(obj) !== obj ? __typeError7('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet8 = (obj, member, getter) => (__accessCheck7(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet8 = (obj, member, value, setter) => (__accessCheck7(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod7 = (obj, member, method) => (__accessCheck7(obj, member, "access private method"), method);
var _getCurrentCommonAncestor_dec;
var _getSnappableShapes_dec;
var _getSnapThreshold_dec;
var _init7;
_getSnapThreshold_dec = [computed], _getSnappableShapes_dec = [computed], _getCurrentCommonAncestor_dec = [computed];
var SnapManager = class {
  constructor(editor) {
    this.editor = editor;
    __runInitializers7(_init7, 5, this);
    __publicField8(this, "shapeBounds");
    __publicField8(this, "handles");
    __publicField8(this, "_snapIndicators", atom("snapLines", void 0));
    this.shapeBounds = new BoundsSnaps(this);
    this.handles = new HandleSnaps(this);
  }
  getIndicators() {
    return this._snapIndicators.get() ?? EMPTY_ARRAY;
  }
  clearIndicators() {
    if (this.getIndicators().length) {
      this._snapIndicators.set(void 0);
    }
  }
  setIndicators(indicators) {
    this._snapIndicators.set(indicators);
  }
  getSnapThreshold() {
    return this.editor.options.snapThreshold / this.editor.getZoomLevel();
  }
  getSnappableShapes() {
    const { editor } = this;
    const renderingBounds = editor.getViewportPageBounds();
    const selectedShapeIds = editor.getSelectedShapeIds();
    const snappableShapes = /* @__PURE__ */ new Set();
    const collectSnappableShapesFromParent = (parentId) => {
      if (isShapeId(parentId)) {
        const parent = editor.getShape(parentId);
        if (parent && editor.isShapeOfType(parent, "frame")) {
          snappableShapes.add(parentId);
        }
      }
      const sortedChildIds = editor.getSortedChildIdsForParent(parentId);
      for (const childId of sortedChildIds) {
        if (selectedShapeIds.includes(childId)) continue;
        const childShape = editor.getShape(childId);
        if (!childShape) continue;
        const util = editor.getShapeUtil(childShape);
        if (!util.canSnap(childShape)) continue;
        const pageBounds = editor.getShapePageBounds(childId);
        if (!(pageBounds && renderingBounds.includes(pageBounds))) continue;
        if (editor.isShapeOfType(childShape, "group")) {
          collectSnappableShapesFromParent(childId);
          continue;
        }
        snappableShapes.add(childId);
      }
    };
    collectSnappableShapesFromParent(this.getCurrentCommonAncestor() ?? editor.getCurrentPageId());
    return snappableShapes;
  }
  getCurrentCommonAncestor() {
    return this.editor.findCommonAncestor(this.editor.getSelectedShapes());
  }
};
_init7 = __decoratorStart7(null);
__decorateElement7(_init7, 1, "getSnapThreshold", _getSnapThreshold_dec, SnapManager);
__decorateElement7(_init7, 1, "getSnappableShapes", _getSnappableShapes_dec, SnapManager);
__decorateElement7(_init7, 1, "getCurrentCommonAncestor", _getCurrentCommonAncestor_dec, SnapManager);
__decoratorMetadata7(_init7, SnapManager);

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/managers/TextManager/TextManager.mjs
var fixNewLines = /\r?\n|\r/g;
function normalizeTextForDom(text) {
  return text.replace(fixNewLines, "\n").split("\n").map((x) => x || " ").join("\n");
}
var textAlignmentsForLtr = {
  start: "left",
  "start-legacy": "left",
  middle: "center",
  "middle-legacy": "center",
  end: "right",
  "end-legacy": "right"
};
var spaceCharacterRegex = /\s/;
var initialDefaultStyles = Object.freeze({
  "overflow-wrap": "break-word",
  "word-break": "auto",
  width: null,
  height: null,
  "max-width": null,
  "min-width": null
});
var TextManager = class {
  constructor(editor) {
    __publicField(this, "elm");
    this.editor = editor;
    const elm = document.createElement("div");
    elm.classList.add("tl-text");
    elm.classList.add("tl-text-measure");
    elm.setAttribute("dir", "auto");
    elm.tabIndex = -1;
    this.editor.getContainer().appendChild(elm);
    this.elm = elm;
    for (const key of objectMapKeys(initialDefaultStyles)) {
      elm.style.setProperty(key, initialDefaultStyles[key]);
    }
  }
  setElementStyles(styles) {
    const stylesToReinstate = {};
    for (const key of objectMapKeys(styles)) {
      if (typeof styles[key] === "string") {
        const oldValue = this.elm.style.getPropertyValue(key);
        if (oldValue === styles[key]) continue;
        stylesToReinstate[key] = oldValue;
        this.elm.style.setProperty(key, styles[key]);
      }
    }
    return () => {
      for (const key of objectMapKeys(stylesToReinstate)) {
        this.elm.style.setProperty(key, stylesToReinstate[key]);
      }
    };
  }
  dispose() {
    return this.elm.remove();
  }
  measureText(textToMeasure, opts) {
    const div = document.createElement("div");
    div.textContent = normalizeTextForDom(textToMeasure);
    return this.measureHtml(div.innerHTML, opts);
  }
  measureHtml(html, opts) {
    const { elm } = this;
    const newStyles = {
      "font-family": opts.fontFamily,
      "font-style": opts.fontStyle,
      "font-weight": opts.fontWeight,
      "font-size": opts.fontSize + "px",
      "line-height": opts.lineHeight.toString(),
      padding: opts.padding,
      "max-width": opts.maxWidth ? opts.maxWidth + "px" : void 0,
      "min-width": opts.minWidth ? opts.minWidth + "px" : void 0,
      "overflow-wrap": opts.disableOverflowWrapBreaking ? "normal" : void 0,
      ...opts.otherStyles
    };
    const restoreStyles = this.setElementStyles(newStyles);
    try {
      elm.innerHTML = html;
      const scrollWidth = opts.measureScrollWidth ? elm.scrollWidth : 0;
      const rect = elm.getBoundingClientRect();
      return {
        x: 0,
        y: 0,
        w: rect.width,
        h: rect.height,
        scrollWidth
      };
    } finally {
      restoreStyles();
    }
  }
  /**
   * Given an html element, measure the position of each span of unbroken
   * word/white-space characters within any text nodes it contains.
   */
  measureElementTextNodeSpans(element, { shouldTruncateToFirstLine = false } = {}) {
    const spans = [];
    const elmBounds = element.getBoundingClientRect();
    const offsetX = -elmBounds.left;
    const offsetY = -elmBounds.top;
    const range = new Range();
    const textNode = element.childNodes[0];
    let idx = 0;
    let currentSpan = null;
    let prevCharWasSpaceCharacter = null;
    let prevCharTop = 0;
    let prevCharLeftForRTLTest = 0;
    let didTruncate = false;
    for (const childNode of element.childNodes) {
      if (childNode.nodeType !== Node.TEXT_NODE) continue;
      for (const char of childNode.textContent ?? "") {
        range.setStart(textNode, idx);
        range.setEnd(textNode, idx + char.length);
        const rects = range.getClientRects();
        const rect = rects[rects.length - 1];
        const top = rect.top + offsetY;
        const left = rect.left + offsetX;
        const right = rect.right + offsetX;
        const isRTL2 = left < prevCharLeftForRTLTest;
        const isSpaceCharacter = spaceCharacterRegex.test(char);
        if (
          // If we're at a word boundary...
          isSpaceCharacter !== prevCharWasSpaceCharacter || // ...or we're on a different line...
          top !== prevCharTop || // ...or we're at the start of the text and haven't created a span yet...
          !currentSpan
        ) {
          if (currentSpan) {
            if (shouldTruncateToFirstLine && top !== prevCharTop) {
              didTruncate = true;
              break;
            }
            spans.push(currentSpan);
          }
          currentSpan = {
            box: { x: left, y: top, w: rect.width, h: rect.height },
            text: char
          };
          prevCharLeftForRTLTest = left;
        } else {
          if (isRTL2) {
            currentSpan.box.x = left;
          }
          currentSpan.box.w = isRTL2 ? currentSpan.box.w + rect.width : right - currentSpan.box.x;
          currentSpan.text += char;
        }
        if (char === "\n") {
          prevCharLeftForRTLTest = 0;
        }
        prevCharWasSpaceCharacter = isSpaceCharacter;
        prevCharTop = top;
        idx += char.length;
      }
    }
    if (currentSpan) {
      spans.push(currentSpan);
    }
    return { spans, didTruncate };
  }
  /**
   * Measure text into individual spans. Spans are created by rendering the
   * text, then dividing it up according to line breaks and word boundaries.
   *
   * It works by having the browser render the text, then measuring the
   * position of each character. You can use this to replicate the text-layout
   * algorithm of the current browser in e.g. an SVG export.
   */
  measureTextSpans(textToMeasure, opts) {
    if (textToMeasure === "") return [];
    const { elm } = this;
    const shouldTruncateToFirstLine = opts.overflow === "truncate-ellipsis" || opts.overflow === "truncate-clip";
    const elementWidth = Math.ceil(opts.width - opts.padding * 2);
    const newStyles = {
      "font-family": opts.fontFamily,
      "font-style": opts.fontStyle,
      "font-weight": opts.fontWeight,
      "font-size": opts.fontSize + "px",
      "line-height": opts.lineHeight.toString(),
      width: `${elementWidth}px`,
      height: "min-content",
      "text-align": textAlignmentsForLtr[opts.textAlign],
      "overflow-wrap": shouldTruncateToFirstLine ? "anywhere" : void 0,
      "word-break": shouldTruncateToFirstLine ? "break-all" : void 0,
      ...opts.otherStyles
    };
    const restoreStyles = this.setElementStyles(newStyles);
    try {
      const normalizedText = normalizeTextForDom(textToMeasure);
      elm.textContent = normalizedText;
      const { spans, didTruncate } = this.measureElementTextNodeSpans(elm, {
        shouldTruncateToFirstLine
      });
      if (opts.overflow === "truncate-ellipsis" && didTruncate) {
        elm.textContent = "…";
        const ellipsisWidth = Math.ceil(this.measureElementTextNodeSpans(elm).spans[0].box.w);
        elm.style.setProperty("width", `${elementWidth - ellipsisWidth}px`);
        elm.textContent = normalizedText;
        const truncatedSpans = this.measureElementTextNodeSpans(elm, {
          shouldTruncateToFirstLine: true
        }).spans;
        const lastSpan = truncatedSpans[truncatedSpans.length - 1];
        truncatedSpans.push({
          text: "…",
          box: {
            x: Math.min(lastSpan.box.x + lastSpan.box.w, opts.width - opts.padding - ellipsisWidth),
            y: lastSpan.box.y,
            w: ellipsisWidth,
            h: lastSpan.box.h
          }
        });
        return truncatedSpans;
      }
      return spans;
    } finally {
      restoreStyles();
    }
  }
};

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/managers/TickManager/TickManager.mjs
var __create8 = Object.create;
var __defProp8 = Object.defineProperty;
var __getOwnPropDesc8 = Object.getOwnPropertyDescriptor;
var __knownSymbol8 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError8 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp8 = (obj, key, value) => key in obj ? __defProp8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name8 = (target, value) => __defProp8(target, "name", { value, configurable: true });
var __decoratorStart8 = (base2) => [, , , __create8((base2 == null ? void 0 : base2[__knownSymbol8("metadata")]) ?? null)];
var __decoratorStrings8 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn8 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError8("Function expected") : fn;
var __decoratorContext8 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings8[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError8("Already initialized") : fns.push(__expectFn8(fn || null)) });
var __decoratorMetadata8 = (array, target) => __defNormalProp8(target, __knownSymbol8("metadata"), array[3]);
var __runInitializers8 = (array, flags, self2, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self2) : value = fns[i].call(self2, value);
  return value;
};
var __decorateElement8 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings8[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc8(k < 4 ? target : { get [name]() {
    return __privateGet9(this, extra);
  }, set [name](x) {
    return __privateSet9(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name8(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name8(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext8(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn8(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet9 : __privateMethod8)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet9(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn8(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError8("Object expected");
    else __expectFn8(fn = it.get) && (desc.get = fn), __expectFn8(fn = it.set) && (desc.set = fn), __expectFn8(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata8(array, target), desc && __defProp8(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __publicField9 = (obj, key, value) => __defNormalProp8(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck8 = (obj, member, msg2) => member.has(obj) || __typeError8("Cannot " + msg2);
var __privateIn8 = (member, obj) => Object(obj) !== obj ? __typeError8('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet9 = (obj, member, getter) => (__accessCheck8(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet9 = (obj, member, value, setter) => (__accessCheck8(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod8 = (obj, member, method) => (__accessCheck8(obj, member, "access private method"), method);
var _dispose_dec;
var _tick_dec;
var _init8;
var throttleToNextFrame2 = typeof process !== "undefined" && false ? (
  // At test time we should use actual raf and not throttle, because throttle was set up to evaluate immediately during tests, which causes stack overflow
  // for the tick manager since it sets up a raf loop.
  (function mockThrottle(cb) {
    const frame = requestAnimationFrame(cb);
    return () => cancelAnimationFrame(frame);
  })
) : throttleToNextFrame;
_tick_dec = [bind], _dispose_dec = [bind];
var TickManager = class {
  constructor(editor) {
    this.editor = editor;
    __runInitializers8(_init8, 5, this);
    __publicField9(this, "cancelRaf");
    __publicField9(this, "isPaused", true);
    __publicField9(this, "now", 0);
    this.editor.disposables.add(this.dispose);
    this.start();
  }
  start() {
    var _a6;
    this.isPaused = false;
    (_a6 = this.cancelRaf) == null ? void 0 : _a6.call(this);
    this.cancelRaf = throttleToNextFrame2(this.tick);
    this.now = Date.now();
  }
  tick() {
    if (this.isPaused) {
      return;
    }
    const now = Date.now();
    const elapsed = now - this.now;
    this.now = now;
    this.editor.inputs.updatePointerVelocity(elapsed);
    this.editor.emit("frame", elapsed);
    this.editor.emit("tick", elapsed);
    this.cancelRaf = throttleToNextFrame2(this.tick);
  }
  dispose() {
    var _a6;
    this.isPaused = true;
    (_a6 = this.cancelRaf) == null ? void 0 : _a6.call(this);
  }
};
_init8 = __decoratorStart8(null);
__decorateElement8(_init8, 1, "tick", _tick_dec, TickManager);
__decorateElement8(_init8, 1, "dispose", _dispose_dec, TickManager);
__decoratorMetadata8(_init8, TickManager);

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/managers/UserPreferencesManager/UserPreferencesManager.mjs
var __create9 = Object.create;
var __defProp9 = Object.defineProperty;
var __getOwnPropDesc9 = Object.getOwnPropertyDescriptor;
var __knownSymbol9 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError9 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp9 = (obj, key, value) => key in obj ? __defProp9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name9 = (target, value) => __defProp9(target, "name", { value, configurable: true });
var __decoratorStart9 = (base2) => [, , , __create9((base2 == null ? void 0 : base2[__knownSymbol9("metadata")]) ?? null)];
var __decoratorStrings9 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn9 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError9("Function expected") : fn;
var __decoratorContext9 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings9[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError9("Already initialized") : fns.push(__expectFn9(fn || null)) });
var __decoratorMetadata9 = (array, target) => __defNormalProp9(target, __knownSymbol9("metadata"), array[3]);
var __runInitializers9 = (array, flags, self2, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self2) : value = fns[i].call(self2, value);
  return value;
};
var __decorateElement9 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings9[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc9(k < 4 ? target : { get [name]() {
    return __privateGet10(this, extra);
  }, set [name](x) {
    return __privateSet10(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name9(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name9(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext9(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn9(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet10 : __privateMethod9)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet10(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn9(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError9("Object expected");
    else __expectFn9(fn = it.get) && (desc.get = fn), __expectFn9(fn = it.set) && (desc.set = fn), __expectFn9(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata9(array, target), desc && __defProp9(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __publicField10 = (obj, key, value) => __defNormalProp9(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck9 = (obj, member, msg2) => member.has(obj) || __typeError9("Cannot " + msg2);
var __privateIn9 = (member, obj) => Object(obj) !== obj ? __typeError9('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet10 = (obj, member, getter) => (__accessCheck9(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet10 = (obj, member, value, setter) => (__accessCheck9(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod9 = (obj, member, method) => (__accessCheck9(obj, member, "access private method"), method);
var _getInputMode_dec;
var _getEnhancedA11yMode_dec;
var _getIsPasteAtCursorMode_dec;
var _getIsDynamicResizeMode_dec;
var _getIsWrapMode_dec;
var _getIsSnapMode_dec;
var _getColor_dec;
var _getLocale_dec;
var _getName_dec;
var _getId_dec;
var _getAreKeyboardShortcutsEnabled_dec;
var _getAnimationSpeed_dec;
var _getEdgeScrollSpeed_dec;
var _getIsDarkMode_dec;
var _getUserPreferences_dec;
var _init9;
_getUserPreferences_dec = [computed], _getIsDarkMode_dec = [computed], _getEdgeScrollSpeed_dec = [computed], _getAnimationSpeed_dec = [computed], _getAreKeyboardShortcutsEnabled_dec = [computed], _getId_dec = [computed], _getName_dec = [computed], _getLocale_dec = [computed], _getColor_dec = [computed], _getIsSnapMode_dec = [computed], _getIsWrapMode_dec = [computed], _getIsDynamicResizeMode_dec = [computed], _getIsPasteAtCursorMode_dec = [computed], _getEnhancedA11yMode_dec = [computed], _getInputMode_dec = [computed];
var UserPreferencesManager = class {
  constructor(user, inferDarkMode) {
    this.user = user;
    this.inferDarkMode = inferDarkMode;
    __runInitializers9(_init9, 5, this);
    __publicField10(this, "systemColorScheme", atom("systemColorScheme", "light"));
    __publicField10(this, "disposables", /* @__PURE__ */ new Set());
    if (typeof window === "undefined" || !window.matchMedia) return;
    const darkModeMediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
    if (darkModeMediaQuery == null ? void 0 : darkModeMediaQuery.matches) {
      this.systemColorScheme.set("dark");
    }
    const handleChange = (e) => {
      if (e.matches) {
        this.systemColorScheme.set("dark");
      } else {
        this.systemColorScheme.set("light");
      }
    };
    darkModeMediaQuery == null ? void 0 : darkModeMediaQuery.addEventListener("change", handleChange);
    this.disposables.add(() => darkModeMediaQuery == null ? void 0 : darkModeMediaQuery.removeEventListener("change", handleChange));
  }
  dispose() {
    this.disposables.forEach((d) => d());
  }
  updateUserPreferences(userPreferences) {
    this.user.setUserPreferences({
      ...this.user.userPreferences.get(),
      ...userPreferences
    });
  }
  getUserPreferences() {
    return {
      id: this.getId(),
      name: this.getName(),
      locale: this.getLocale(),
      color: this.getColor(),
      animationSpeed: this.getAnimationSpeed(),
      areKeyboardShortcutsEnabled: this.getAreKeyboardShortcutsEnabled(),
      isSnapMode: this.getIsSnapMode(),
      colorScheme: this.user.userPreferences.get().colorScheme,
      isDarkMode: this.getIsDarkMode(),
      isWrapMode: this.getIsWrapMode(),
      isDynamicResizeMode: this.getIsDynamicResizeMode(),
      enhancedA11yMode: this.getEnhancedA11yMode(),
      inputMode: this.getInputMode()
    };
  }
  getIsDarkMode() {
    switch (this.user.userPreferences.get().colorScheme) {
      case "dark":
        return true;
      case "light":
        return false;
      case "system":
        return this.systemColorScheme.get() === "dark";
      default:
        return this.inferDarkMode ? this.systemColorScheme.get() === "dark" : false;
    }
  }
  getEdgeScrollSpeed() {
    return this.user.userPreferences.get().edgeScrollSpeed ?? defaultUserPreferences.edgeScrollSpeed;
  }
  getAnimationSpeed() {
    return this.user.userPreferences.get().animationSpeed ?? defaultUserPreferences.animationSpeed;
  }
  getAreKeyboardShortcutsEnabled() {
    return this.user.userPreferences.get().areKeyboardShortcutsEnabled ?? defaultUserPreferences.areKeyboardShortcutsEnabled;
  }
  getId() {
    return this.user.userPreferences.get().id;
  }
  getName() {
    var _a6;
    return ((_a6 = this.user.userPreferences.get().name) == null ? void 0 : _a6.trim()) ?? defaultUserPreferences.name;
  }
  getLocale() {
    return this.user.userPreferences.get().locale ?? defaultUserPreferences.locale;
  }
  getColor() {
    return this.user.userPreferences.get().color ?? defaultUserPreferences.color;
  }
  getIsSnapMode() {
    return this.user.userPreferences.get().isSnapMode ?? defaultUserPreferences.isSnapMode;
  }
  getIsWrapMode() {
    return this.user.userPreferences.get().isWrapMode ?? defaultUserPreferences.isWrapMode;
  }
  getIsDynamicResizeMode() {
    return this.user.userPreferences.get().isDynamicSizeMode ?? defaultUserPreferences.isDynamicSizeMode;
  }
  getIsPasteAtCursorMode() {
    return this.user.userPreferences.get().isPasteAtCursorMode ?? defaultUserPreferences.isPasteAtCursorMode;
  }
  getEnhancedA11yMode() {
    return this.user.userPreferences.get().enhancedA11yMode ?? defaultUserPreferences.enhancedA11yMode;
  }
  getInputMode() {
    return this.user.userPreferences.get().inputMode ?? defaultUserPreferences.inputMode;
  }
};
_init9 = __decoratorStart9(null);
__decorateElement9(_init9, 1, "getUserPreferences", _getUserPreferences_dec, UserPreferencesManager);
__decorateElement9(_init9, 1, "getIsDarkMode", _getIsDarkMode_dec, UserPreferencesManager);
__decorateElement9(_init9, 1, "getEdgeScrollSpeed", _getEdgeScrollSpeed_dec, UserPreferencesManager);
__decorateElement9(_init9, 1, "getAnimationSpeed", _getAnimationSpeed_dec, UserPreferencesManager);
__decorateElement9(_init9, 1, "getAreKeyboardShortcutsEnabled", _getAreKeyboardShortcutsEnabled_dec, UserPreferencesManager);
__decorateElement9(_init9, 1, "getId", _getId_dec, UserPreferencesManager);
__decorateElement9(_init9, 1, "getName", _getName_dec, UserPreferencesManager);
__decorateElement9(_init9, 1, "getLocale", _getLocale_dec, UserPreferencesManager);
__decorateElement9(_init9, 1, "getColor", _getColor_dec, UserPreferencesManager);
__decorateElement9(_init9, 1, "getIsSnapMode", _getIsSnapMode_dec, UserPreferencesManager);
__decorateElement9(_init9, 1, "getIsWrapMode", _getIsWrapMode_dec, UserPreferencesManager);
__decorateElement9(_init9, 1, "getIsDynamicResizeMode", _getIsDynamicResizeMode_dec, UserPreferencesManager);
__decorateElement9(_init9, 1, "getIsPasteAtCursorMode", _getIsPasteAtCursorMode_dec, UserPreferencesManager);
__decorateElement9(_init9, 1, "getEnhancedA11yMode", _getEnhancedA11yMode_dec, UserPreferencesManager);
__decorateElement9(_init9, 1, "getInputMode", _getInputMode_dec, UserPreferencesManager);
__decoratorMetadata9(_init9, UserPreferencesManager);

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/types/event-types.mjs
var EVENT_NAME_MAP = {
  wheel: "onWheel",
  pointer_down: "onPointerDown",
  pointer_move: "onPointerMove",
  long_press: "onLongPress",
  pointer_up: "onPointerUp",
  right_click: "onRightClick",
  middle_click: "onMiddleClick",
  key_down: "onKeyDown",
  key_up: "onKeyUp",
  key_repeat: "onKeyRepeat",
  cancel: "onCancel",
  complete: "onComplete",
  interrupt: "onInterrupt",
  double_click: "onDoubleClick",
  triple_click: "onTripleClick",
  quadruple_click: "onQuadrupleClick",
  tick: "onTick"
};

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/tools/StateNode.mjs
var STATE_NODES_TO_MEASURE = [
  "brushing",
  "cropping",
  "dragging",
  "dragging_handle",
  "drawing",
  "erasing",
  "lasering",
  "resizing",
  "rotating",
  "scribble_brushing",
  "translating"
];
var StateNode = class {
  constructor(editor, parent) {
    __publicField(this, "performanceTracker");
    __publicField(this, "id");
    __publicField(this, "type");
    __publicField(this, "shapeType");
    __publicField(this, "initial");
    __publicField(this, "children");
    __publicField(this, "isLockable");
    __publicField(this, "useCoalescedEvents");
    __publicField(this, "parent");
    __publicField(this, "_path");
    __publicField(this, "_current");
    __publicField(this, "_isActive");
    /**
     * This is a hack / escape hatch that will tell the editor to
     * report a different state as active (in `getCurrentToolId()`) when
     * this state is active. This is usually used when a tool transitions
     * to a child of a different state for a certain interaction and then
     * returns to the original tool when that interaction completes; and
     * where we would want to show the original tool as active in the UI.
     *
     * @public
     */
    __publicField(this, "_currentToolIdMask", atom("curent tool id mask", void 0));
    this.editor = editor;
    const { id, children, initial, isLockable, useCoalescedEvents } = this.constructor;
    this.id = id;
    this._isActive = atom("toolIsActive" + this.id, false);
    this._current = atom("toolState" + this.id, void 0);
    this._path = computed("toolPath" + this.id, () => {
      const current = this.getCurrent();
      return this.id + (current ? `.${current.getPath()}` : "");
    });
    this.parent = parent ?? {};
    if (parent) {
      if (children && initial) {
        this.type = "branch";
        this.initial = initial;
        this.children = Object.fromEntries(
          children().map((Ctor) => [Ctor.id, new Ctor(this.editor, this)])
        );
        this._current.set(this.children[this.initial]);
      } else {
        this.type = "leaf";
      }
    } else {
      this.type = "root";
      if (children && initial) {
        this.initial = initial;
        this.children = Object.fromEntries(
          children().map((Ctor) => [Ctor.id, new Ctor(this.editor, this)])
        );
        this._current.set(this.children[this.initial]);
      }
    }
    this.isLockable = isLockable;
    this.useCoalescedEvents = useCoalescedEvents;
    this.performanceTracker = new PerformanceTracker();
  }
  /**
   * This node's path of active state nodes
   *
   * @public
   */
  getPath() {
    return this._path.get();
  }
  /**
   * This node's current active child node, if any.
   *
   * @public
   */
  getCurrent() {
    return this._current.get();
  }
  /**
   * Whether this node is active.
   *
   * @public
   */
  getIsActive() {
    return this._isActive.get();
  }
  /**
   * Transition to a new active child state node.
   *
   * @example
   * ```ts
   * parentState.transition('childStateA')
   * parentState.transition('childStateB', { myData: 4 })
   *```
   *
   * @param id - The id of the child state node to transition to.
   * @param info - Any data to pass to the `onEnter` and `onExit` handlers.
   *
   * @public
   */
  transition(id, info = {}) {
    var _a6;
    const path = id.split(".");
    let currState = this;
    for (let i = 0; i < path.length; i++) {
      const id2 = path[i];
      const prevChildState = currState.getCurrent();
      const nextChildState = (_a6 = currState.children) == null ? void 0 : _a6[id2];
      if (!nextChildState) {
        throw Error(`${currState.id} - no child state exists with the id ${id2}.`);
      }
      if ((prevChildState == null ? void 0 : prevChildState.id) !== nextChildState.id) {
        prevChildState == null ? void 0 : prevChildState.exit(info, id2);
        currState._current.set(nextChildState);
        nextChildState.enter(info, (prevChildState == null ? void 0 : prevChildState.id) || "initial");
        if (!nextChildState.getIsActive()) break;
      }
      currState = nextChildState;
    }
    return this;
  }
  handleEvent(info) {
    var _a6;
    const cbName = EVENT_NAME_MAP[info.name];
    const currentActiveChild = this._current.__unsafe__getWithoutCapture();
    (_a6 = this[cbName]) == null ? void 0 : _a6.call(this, info);
    if (this._isActive.__unsafe__getWithoutCapture() && currentActiveChild && currentActiveChild === this._current.__unsafe__getWithoutCapture()) {
      currentActiveChild.handleEvent(info);
    }
  }
  // todo: move this logic into transition
  enter(info, from2) {
    var _a6;
    if (debugFlags.measurePerformance.get() && STATE_NODES_TO_MEASURE.includes(this.id)) {
      this.performanceTracker.start(this.id);
    }
    this._isActive.set(true);
    (_a6 = this.onEnter) == null ? void 0 : _a6.call(this, info, from2);
    if (this.children && this.initial && this.getIsActive()) {
      const initial = this.children[this.initial];
      this._current.set(initial);
      initial.enter(info, from2);
    }
  }
  // todo: move this logic into transition
  exit(info, to) {
    var _a6, _b3;
    if (debugFlags.measurePerformance.get() && this.performanceTracker.isStarted()) {
      this.performanceTracker.stop();
    }
    this._isActive.set(false);
    (_a6 = this.onExit) == null ? void 0 : _a6.call(this, info, to);
    if (!this.getIsActive()) {
      (_b3 = this.getCurrent()) == null ? void 0 : _b3.exit(info, to);
    }
  }
  getCurrentToolIdMask() {
    return this._currentToolIdMask.get();
  }
  setCurrentToolIdMask(id) {
    this._currentToolIdMask.set(id);
  }
  /**
   * Add a child node to this state node.
   *
   * @public
   */
  addChild(childConstructor) {
    if (this.type === "leaf") {
      throw new Error("StateNode.addChild: cannot add child to a leaf node");
    }
    if (!this.children) {
      this.children = {};
    }
    const child = new childConstructor(this.editor, this);
    if (this.children[child.id]) {
      throw new Error(`StateNode.addChild: a child with id '${child.id}' already exists`);
    }
    this.children[child.id] = child;
    return this;
  }
};
__publicField(StateNode, "id");
__publicField(StateNode, "initial");
__publicField(StateNode, "children");
__publicField(StateNode, "isLockable", true);
__publicField(StateNode, "useCoalescedEvents", false);

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/tools/RootState.mjs
var RootState = class extends StateNode {
  static children() {
    return [];
  }
  onKeyDown(info) {
    var _a6;
    switch (info.code) {
      case "KeyZ": {
        if (!(info.shiftKey || info.ctrlKey)) {
          const currentTool = this.getCurrent();
          if (currentTool && ((_a6 = currentTool.getCurrent()) == null ? void 0 : _a6.id) === "idle" && this.children["zoom"]) {
            this.editor.setCurrentTool("zoom", { ...info, onInteractionEnd: currentTool.id });
          }
        }
        break;
      }
    }
  }
};
__publicField(RootState, "id", "root");
__publicField(RootState, "initial", "");

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/Editor.mjs
var __create10 = Object.create;
var __defProp10 = Object.defineProperty;
var __getOwnPropDesc10 = Object.getOwnPropertyDescriptor;
var __knownSymbol10 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError10 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp10 = (obj, key, value) => key in obj ? __defProp10(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name10 = (target, value) => __defProp10(target, "name", { value, configurable: true });
var __decoratorStart10 = (base2) => [, , , __create10((base2 == null ? void 0 : base2[__knownSymbol10("metadata")]) ?? null)];
var __decoratorStrings10 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn10 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError10("Function expected") : fn;
var __decoratorContext10 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings10[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError10("Already initialized") : fns.push(__expectFn10(fn || null)) });
var __decoratorMetadata10 = (array, target) => __defNormalProp10(target, __knownSymbol10("metadata"), array[3]);
var __runInitializers10 = (array, flags, self2, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self2) : value = fns[i].call(self2, value);
  return value;
};
var __decorateElement10 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings10[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc10(k < 4 ? target : { get [name]() {
    return __privateGet11(this, extra);
  }, set [name](x) {
    return __privateSet11(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name10(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name10(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext10(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn10(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet11 : __privateMethod10)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet11(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn10(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError10("Object expected");
    else __expectFn10(fn = it.get) && (desc.get = fn), __expectFn10(fn = it.set) && (desc.set = fn), __expectFn10(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata10(array, target), desc && __defProp10(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __publicField11 = (obj, key, value) => __defNormalProp10(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck10 = (obj, member, msg2) => member.has(obj) || __typeError10("Cannot " + msg2);
var __privateIn10 = (member, obj) => Object(obj) !== obj ? __typeError10('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet11 = (obj, member, getter) => (__accessCheck10(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet11 = (obj, member, value, setter) => (__accessCheck10(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod10 = (obj, member, method) => (__accessCheck10(obj, member, "access private method"), method);
var __setMetaKeyTimeout_dec;
var __setCtrlKeyTimeout_dec;
var __setAltKeyTimeout_dec;
var __setShiftKeyTimeout_dec;
var _getIsReadonly_dec;
var _getIsFocused_dec;
var _getSharedOpacity_dec;
var _getSharedStyles_dec;
var __getSelectionSharedStyles_dec;
var __getBindingsIndexCache_dec;
var _getCurrentPageRenderingShapesSorted_dec;
var _getCurrentPageShapesSorted_dec;
var _getCurrentPageShapes_dec;
var _getCurrentPageBounds_dec;
var _getCulledShapes_dec;
var _getNotVisibleShapes_dec;
var __getShapeMaskedPageBoundsCache_dec;
var __getShapeMaskCache_dec;
var __getShapeClipPathCache_dec;
var __getShapePageBoundsCache_dec;
var __getShapePageTransformCache_dec;
var __getShapeHandlesCache_dec;
var __getAllAssetsQuery_dec;
var _getCurrentPageShapeIdsSorted_dec;
var _getCurrentPageId_dec;
var _getPages_dec;
var __getAllPagesQuery_dec;
var _getRenderingShapes_dec;
var _getCollaboratorsOnCurrentPage_dec;
var _getCollaborators_dec;
var __getCollaboratorsQuery_dec;
var _getViewportPageBounds_dec;
var _getViewportScreenCenter_dec;
var _getViewportScreenBounds_dec;
var _getEfficientZoomLevel_dec;
var __getAboveDebouncedZoomThreshold_dec;
var _getDebouncedZoomLevel_dec;
var _getZoomLevel_dec;
var _getCameraForFollowing_dec;
var _getViewportPageBoundsForFollowing_dec;
var _getCamera_dec;
var __unsafe_getCameraId_dec;
var _getErasingShapes_dec;
var _getErasingShapeIds_dec;
var _getHintingShape_dec;
var _getHintingShapeIds_dec;
var _getHoveredShape_dec;
var _getHoveredShapeId_dec;
var _getRichTextEditor_dec;
var _getEditingShape_dec;
var _getEditingShapeId_dec;
var _getFocusedGroup_dec;
var _getFocusedGroupId_dec;
var _getSelectionRotatedScreenBounds_dec;
var _getSelectionRotatedPageBounds_dec;
var _getSelectionRotation_dec;
var _getSelectionPageBounds_dec;
var _getOnlySelectedShape_dec;
var _getOnlySelectedShapeId_dec;
var _getCurrentPageShapesInReadingOrder_dec;
var _getSelectedShapes_dec;
var _getSelectedShapeIds_dec;
var __getCurrentPageStateId_dec;
var _getCurrentPageState_dec;
var __getPageStatesQuery_dec;
var _getPageStates_dec;
var _getInstanceState_dec;
var _getDocumentSettings_dec;
var _getCurrentToolId_dec;
var _getCurrentTool_dec;
var _getPath_dec;
var _canRedo_dec;
var _canUndo_dec;
var _getIsShapeHiddenCache_dec;
var _a3;
var _init10;
var Editor = class extends (_a3 = import_eventemitter3.default, _getIsShapeHiddenCache_dec = [computed], _canUndo_dec = [computed], _canRedo_dec = [computed], _getPath_dec = [computed], _getCurrentTool_dec = [computed], _getCurrentToolId_dec = [computed], _getDocumentSettings_dec = [computed], _getInstanceState_dec = [computed], _getPageStates_dec = [computed], __getPageStatesQuery_dec = [computed], _getCurrentPageState_dec = [computed], __getCurrentPageStateId_dec = [computed], _getSelectedShapeIds_dec = [computed], _getSelectedShapes_dec = [computed], _getCurrentPageShapesInReadingOrder_dec = [computed], _getOnlySelectedShapeId_dec = [computed], _getOnlySelectedShape_dec = [computed], _getSelectionPageBounds_dec = [computed], _getSelectionRotation_dec = [computed], _getSelectionRotatedPageBounds_dec = [computed], _getSelectionRotatedScreenBounds_dec = [computed], _getFocusedGroupId_dec = [computed], _getFocusedGroup_dec = [computed], _getEditingShapeId_dec = [computed], _getEditingShape_dec = [computed], _getRichTextEditor_dec = [computed], _getHoveredShapeId_dec = [computed], _getHoveredShape_dec = [computed], _getHintingShapeIds_dec = [computed], _getHintingShape_dec = [computed], _getErasingShapeIds_dec = [computed], _getErasingShapes_dec = [computed], __unsafe_getCameraId_dec = [computed], _getCamera_dec = [computed], _getViewportPageBoundsForFollowing_dec = [computed], _getCameraForFollowing_dec = [computed], _getZoomLevel_dec = [computed], _getDebouncedZoomLevel_dec = [computed], __getAboveDebouncedZoomThreshold_dec = [computed], _getEfficientZoomLevel_dec = [computed], _getViewportScreenBounds_dec = [computed], _getViewportScreenCenter_dec = [computed], _getViewportPageBounds_dec = [computed], __getCollaboratorsQuery_dec = [computed], _getCollaborators_dec = [computed], _getCollaboratorsOnCurrentPage_dec = [computed], _getRenderingShapes_dec = [computed], __getAllPagesQuery_dec = [computed], _getPages_dec = [computed], _getCurrentPageId_dec = [computed], _getCurrentPageShapeIdsSorted_dec = [computed], __getAllAssetsQuery_dec = [computed], __getShapeHandlesCache_dec = [computed], __getShapePageTransformCache_dec = [computed], __getShapePageBoundsCache_dec = [computed], __getShapeClipPathCache_dec = [computed], __getShapeMaskCache_dec = [computed], __getShapeMaskedPageBoundsCache_dec = [computed], _getNotVisibleShapes_dec = [computed], _getCulledShapes_dec = [computed], _getCurrentPageBounds_dec = [computed], _getCurrentPageShapes_dec = [computed], _getCurrentPageShapesSorted_dec = [computed], _getCurrentPageRenderingShapesSorted_dec = [computed], __getBindingsIndexCache_dec = [computed], __getSelectionSharedStyles_dec = [computed], _getSharedStyles_dec = [computed({ isEqual: (a, b) => a.equals(b) })], _getSharedOpacity_dec = [computed], _getIsFocused_dec = [computed], _getIsReadonly_dec = [computed], __setShiftKeyTimeout_dec = [bind], __setAltKeyTimeout_dec = [bind], __setCtrlKeyTimeout_dec = [bind], __setMetaKeyTimeout_dec = [bind], _a3) {
  constructor({
    store,
    user,
    shapeUtils,
    bindingUtils,
    tools,
    getContainer,
    cameraOptions,
    textOptions,
    initialState: initialState2,
    autoFocus,
    inferDarkMode,
    options: options2,
    getShapeVisibility,
    fontAssetUrls
  }) {
    var _a6;
    super();
    __runInitializers10(_init10, 5, this);
    __publicField11(this, "id", uniqueId());
    __publicField11(this, "_getShapeVisibility");
    __publicField11(this, "options");
    __publicField11(this, "contextId", uniqueId());
    __publicField11(this, "store");
    __publicField11(this, "root");
    __publicField11(this, "disposables", /* @__PURE__ */ new Set());
    __publicField11(this, "isDisposed", false);
    __publicField11(this, "_tickManager");
    __publicField11(this, "inputs");
    __publicField11(this, "snaps");
    __publicField11(this, "timers", tltime.forContext(this.contextId));
    __publicField11(this, "user");
    __publicField11(this, "textMeasure");
    __publicField11(this, "fonts");
    __publicField11(this, "scribbles");
    __publicField11(this, "sideEffects");
    __publicField11(this, "edgeScrollManager");
    __publicField11(this, "focusManager");
    __publicField11(this, "getContainer");
    __publicField11(this, "shapeUtils");
    __publicField11(this, "styleProps");
    __publicField11(this, "bindingUtils");
    __publicField11(this, "history");
    __publicField11(this, "_shouldIgnoreShapeLock", false);
    __publicField11(this, "_crashingError", null);
    __publicField11(this, "_isChangingStyleTimeout", -1);
    __publicField11(this, "menus", tlmenus.forContext(this.contextId));
    __publicField11(this, "_currentRichTextEditor", atom("rich text editor", null));
    __publicField11(this, "_textOptions");
    __publicField11(this, "_debouncedZoomLevel", atom("debounced zoom level", 1));
    __publicField11(this, "_cameraOptions", atom("camera options", DEFAULT_CAMERA_OPTIONS));
    __publicField11(this, "_viewportAnimation", null);
    __publicField11(this, "_willSetInitialBounds", true);
    __publicField11(this, "_isLockedOnFollowingUser", atom("isLockedOnFollowingUser", false));
    __publicField11(this, "_cameraState", atom("camera state", "idle"));
    __publicField11(this, "_cameraStateTimeoutRemaining", 0);
    __publicField11(this, "_currentPageShapeIds");
    __publicField11(this, "_shapeGeometryCaches", {});
    __publicField11(this, "_notVisibleShapes", notVisibleShapes(this));
    __publicField11(this, "_parentIdsToChildIds");
    __publicField11(this, "animatingShapes", /* @__PURE__ */ new Map());
    __publicField11(this, "externalAssetContentHandlers", {
      file: null,
      url: null
    });
    __publicField11(this, "temporaryAssetPreview", /* @__PURE__ */ new Map());
    __publicField11(this, "externalContentHandlers", {
      text: null,
      files: null,
      "file-replace": null,
      embed: null,
      "svg-text": null,
      url: null,
      tldraw: null,
      excalidraw: null
    });
    __publicField11(this, "_clickManager", new ClickManager(this));
    __publicField11(this, "_prevCursor", "default");
    __publicField11(this, "_shiftKeyTimeout", -1);
    __publicField11(this, "_altKeyTimeout", -1);
    __publicField11(this, "_ctrlKeyTimeout", -1);
    __publicField11(this, "_metaKeyTimeout", -1);
    __publicField11(this, "_restoreToolId", "select");
    __publicField11(this, "_didPinch", false);
    __publicField11(this, "_selectedShapeIdsAtPointerDown", []);
    __publicField11(this, "_longPressTimeout", -1);
    __publicField11(this, "capturedPointerId", null);
    __publicField11(this, "performanceTracker");
    __publicField11(this, "performanceTrackerTimeout", -1);
    __publicField11(this, "handledEvents", /* @__PURE__ */ new WeakSet());
    __publicField11(this, "_pendingEventsForNextTick", []);
    this._getShapeVisibility = getShapeVisibility;
    this.options = { ...defaultTldrawOptions, ...options2 };
    this.store = store;
    this.history = new HistoryManager({
      store,
      annotateError: (error) => {
        this.annotateError(error, { origin: "history.batch", willCrashApp: true });
        this.crash(error);
      }
    });
    this.snaps = new SnapManager(this);
    this.disposables.add(this.timers.dispose);
    this._cameraOptions.set({ ...DEFAULT_CAMERA_OPTIONS, ...cameraOptions });
    this._textOptions = atom("text options", textOptions ?? null);
    this.user = new UserPreferencesManager(user ?? createTLUser(), inferDarkMode ?? false);
    this.disposables.add(() => this.user.dispose());
    this.getContainer = getContainer;
    this.textMeasure = new TextManager(this);
    this.disposables.add(() => this.textMeasure.dispose());
    this.fonts = new FontManager(this, fontAssetUrls);
    this._tickManager = new TickManager(this);
    this.inputs = new InputsManager(this);
    class NewRoot extends RootState {
    }
    __publicField(NewRoot, "initial", initialState2 ?? "");
    this.root = new NewRoot(this);
    this.root.children = {};
    this.markEventAsHandled = this.markEventAsHandled.bind(this);
    const allShapeUtils = checkShapesAndAddCore(shapeUtils);
    const _shapeUtils = {};
    const _styleProps = {};
    const allStylesById = /* @__PURE__ */ new Map();
    for (const Util of allShapeUtils) {
      const util = new Util(this);
      _shapeUtils[Util.type] = util;
      const propKeysByStyle = getShapePropKeysByStyle(Util.props ?? {});
      _styleProps[Util.type] = propKeysByStyle;
      for (const style2 of propKeysByStyle.keys()) {
        if (!allStylesById.has(style2.id)) {
          allStylesById.set(style2.id, style2);
        } else if (allStylesById.get(style2.id) !== style2) {
          throw Error(
            `Multiple style props with id "${style2.id}" in use. Style prop IDs must be unique.`
          );
        }
      }
    }
    this.shapeUtils = _shapeUtils;
    this.styleProps = _styleProps;
    const allBindingUtils = checkBindings(bindingUtils);
    const _bindingUtils = {};
    for (const Util of allBindingUtils) {
      const util = new Util(this);
      _bindingUtils[Util.type] = util;
    }
    this.bindingUtils = _bindingUtils;
    for (const Tool of [...tools]) {
      if (hasOwnProperty(this.root.children, Tool.id)) {
        throw Error(`Can't override tool with id "${Tool.id}"`);
      }
      this.root.children[Tool.id] = new Tool(this, this.root);
    }
    this.scribbles = new ScribbleManager(this);
    const cleanupInstancePageState = (prevPageState, shapesNoLongerInPage) => {
      let nextPageState = null;
      const selectedShapeIds = prevPageState.selectedShapeIds.filter(
        (id) => !shapesNoLongerInPage.has(id)
      );
      if (selectedShapeIds.length !== prevPageState.selectedShapeIds.length) {
        if (!nextPageState) nextPageState = { ...prevPageState };
        nextPageState.selectedShapeIds = selectedShapeIds;
      }
      const erasingShapeIds = prevPageState.erasingShapeIds.filter(
        (id) => !shapesNoLongerInPage.has(id)
      );
      if (erasingShapeIds.length !== prevPageState.erasingShapeIds.length) {
        if (!nextPageState) nextPageState = { ...prevPageState };
        nextPageState.erasingShapeIds = erasingShapeIds;
      }
      if (prevPageState.hoveredShapeId && shapesNoLongerInPage.has(prevPageState.hoveredShapeId)) {
        if (!nextPageState) nextPageState = { ...prevPageState };
        nextPageState.hoveredShapeId = null;
      }
      if (prevPageState.editingShapeId && shapesNoLongerInPage.has(prevPageState.editingShapeId)) {
        if (!nextPageState) nextPageState = { ...prevPageState };
        nextPageState.editingShapeId = null;
      }
      const hintingShapeIds = prevPageState.hintingShapeIds.filter(
        (id) => !shapesNoLongerInPage.has(id)
      );
      if (hintingShapeIds.length !== prevPageState.hintingShapeIds.length) {
        if (!nextPageState) nextPageState = { ...prevPageState };
        nextPageState.hintingShapeIds = hintingShapeIds;
      }
      if (prevPageState.focusedGroupId && shapesNoLongerInPage.has(prevPageState.focusedGroupId)) {
        if (!nextPageState) nextPageState = { ...prevPageState };
        nextPageState.focusedGroupId = null;
      }
      return nextPageState;
    };
    this.sideEffects = this.store.sideEffects;
    let deletedBindings = /* @__PURE__ */ new Map();
    const deletedShapeIds = /* @__PURE__ */ new Set();
    const invalidParents = /* @__PURE__ */ new Set();
    let invalidBindingTypes = /* @__PURE__ */ new Set();
    this.disposables.add(
      this.sideEffects.registerOperationCompleteHandler(() => {
        var _a7, _b3, _c, _d;
        deletedShapeIds.clear();
        for (const parentId of invalidParents) {
          invalidParents.delete(parentId);
          const parent = this.getShape(parentId);
          if (!parent) continue;
          const util = this.getShapeUtil(parent);
          const changes = (_a7 = util.onChildrenChange) == null ? void 0 : _a7.call(util, parent);
          if (changes == null ? void 0 : changes.length) {
            this.updateShapes(changes);
          }
        }
        if (invalidBindingTypes.size) {
          const t2 = invalidBindingTypes;
          invalidBindingTypes = /* @__PURE__ */ new Set();
          for (const type of t2) {
            const util = this.getBindingUtil(type);
            (_b3 = util.onOperationComplete) == null ? void 0 : _b3.call(util);
          }
        }
        if (deletedBindings.size) {
          const t2 = deletedBindings;
          deletedBindings = /* @__PURE__ */ new Map();
          for (const opts of t2.values()) {
            (_d = (_c = this.getBindingUtil(opts.binding)).onAfterDelete) == null ? void 0 : _d.call(_c, opts);
          }
        }
        this.emit("update");
      })
    );
    this.disposables.add(
      this.sideEffects.register({
        shape: {
          afterChange: (shapeBefore, shapeAfter) => {
            var _a7, _b3, _c, _d;
            for (const binding of this.getBindingsInvolvingShape(shapeAfter)) {
              invalidBindingTypes.add(binding.type);
              if (binding.fromId === shapeAfter.id) {
                (_b3 = (_a7 = this.getBindingUtil(binding)).onAfterChangeFromShape) == null ? void 0 : _b3.call(_a7, {
                  binding,
                  shapeBefore,
                  shapeAfter,
                  reason: "self"
                });
              }
              if (binding.toId === shapeAfter.id) {
                (_d = (_c = this.getBindingUtil(binding)).onAfterChangeToShape) == null ? void 0 : _d.call(_c, {
                  binding,
                  shapeBefore,
                  shapeAfter,
                  reason: "self"
                });
              }
            }
            if (shapeBefore.parentId !== shapeAfter.parentId) {
              const notifyBindingAncestryChange = (id) => {
                var _a8, _b4, _c2, _d2;
                const descendantShape = this.getShape(id);
                if (!descendantShape) return;
                for (const binding of this.getBindingsInvolvingShape(descendantShape)) {
                  invalidBindingTypes.add(binding.type);
                  if (binding.fromId === descendantShape.id) {
                    (_b4 = (_a8 = this.getBindingUtil(binding)).onAfterChangeFromShape) == null ? void 0 : _b4.call(_a8, {
                      binding,
                      shapeBefore: descendantShape,
                      shapeAfter: descendantShape,
                      reason: "ancestry"
                    });
                  }
                  if (binding.toId === descendantShape.id) {
                    (_d2 = (_c2 = this.getBindingUtil(binding)).onAfterChangeToShape) == null ? void 0 : _d2.call(_c2, {
                      binding,
                      shapeBefore: descendantShape,
                      shapeAfter: descendantShape,
                      reason: "ancestry"
                    });
                  }
                }
              };
              notifyBindingAncestryChange(shapeAfter.id);
              this.visitDescendants(shapeAfter.id, notifyBindingAncestryChange);
            }
            if (shapeBefore.parentId !== shapeAfter.parentId && isPageId(shapeAfter.parentId)) {
              const allMovingIds = /* @__PURE__ */ new Set([shapeBefore.id]);
              this.visitDescendants(shapeBefore.id, (id) => {
                allMovingIds.add(id);
              });
              for (const instancePageState of this.getPageStates()) {
                if (instancePageState.pageId === shapeAfter.parentId) continue;
                const nextPageState = cleanupInstancePageState(instancePageState, allMovingIds);
                if (nextPageState) {
                  this.store.put([nextPageState]);
                }
              }
            }
            if (shapeBefore.parentId && isShapeId(shapeBefore.parentId)) {
              invalidParents.add(shapeBefore.parentId);
            }
            if (shapeAfter.parentId !== shapeBefore.parentId && isShapeId(shapeAfter.parentId)) {
              invalidParents.add(shapeAfter.parentId);
            }
          },
          beforeDelete: (shape) => {
            var _a7, _b3, _c, _d;
            if (deletedShapeIds.has(shape.id)) return;
            if (shape.parentId && isShapeId(shape.parentId)) {
              invalidParents.add(shape.parentId);
            }
            deletedShapeIds.add(shape.id);
            const deleteBindingIds = [];
            for (const binding of this.getBindingsInvolvingShape(shape)) {
              invalidBindingTypes.add(binding.type);
              deleteBindingIds.push(binding.id);
              const util = this.getBindingUtil(binding);
              if (binding.fromId === shape.id) {
                (_a7 = util.onBeforeIsolateToShape) == null ? void 0 : _a7.call(util, { binding, removedShape: shape });
                (_b3 = util.onBeforeDeleteFromShape) == null ? void 0 : _b3.call(util, { binding, shape });
              } else {
                (_c = util.onBeforeIsolateFromShape) == null ? void 0 : _c.call(util, { binding, removedShape: shape });
                (_d = util.onBeforeDeleteToShape) == null ? void 0 : _d.call(util, { binding, shape });
              }
            }
            if (deleteBindingIds.length) {
              this.deleteBindings(deleteBindingIds);
            }
            const deletedIds = /* @__PURE__ */ new Set([shape.id]);
            const updates = compact(
              this.getPageStates().map((pageState) => {
                return cleanupInstancePageState(pageState, deletedIds);
              })
            );
            if (updates.length) {
              this.store.put(updates);
            }
          }
        },
        binding: {
          beforeCreate: (binding) => {
            var _a7, _b3;
            const next = (_b3 = (_a7 = this.getBindingUtil(binding)).onBeforeCreate) == null ? void 0 : _b3.call(_a7, { binding });
            if (next) return next;
            return binding;
          },
          afterCreate: (binding) => {
            var _a7, _b3;
            invalidBindingTypes.add(binding.type);
            (_b3 = (_a7 = this.getBindingUtil(binding)).onAfterCreate) == null ? void 0 : _b3.call(_a7, { binding });
          },
          beforeChange: (bindingBefore, bindingAfter) => {
            var _a7, _b3;
            const updated = (_b3 = (_a7 = this.getBindingUtil(bindingAfter)).onBeforeChange) == null ? void 0 : _b3.call(_a7, {
              bindingBefore,
              bindingAfter
            });
            if (updated) return updated;
            return bindingAfter;
          },
          afterChange: (bindingBefore, bindingAfter) => {
            var _a7, _b3;
            invalidBindingTypes.add(bindingAfter.type);
            (_b3 = (_a7 = this.getBindingUtil(bindingAfter)).onAfterChange) == null ? void 0 : _b3.call(_a7, { bindingBefore, bindingAfter });
          },
          beforeDelete: (binding) => {
            var _a7, _b3;
            (_b3 = (_a7 = this.getBindingUtil(binding)).onBeforeDelete) == null ? void 0 : _b3.call(_a7, { binding });
          },
          afterDelete: (binding) => {
            var _a7, _b3;
            (_b3 = (_a7 = this.getBindingUtil(binding)).onAfterDelete) == null ? void 0 : _b3.call(_a7, { binding });
            invalidBindingTypes.add(binding.type);
          }
        },
        page: {
          afterCreate: (record) => {
            const cameraId = CameraRecordType.createId(record.id);
            const _pageStateId = InstancePageStateRecordType.createId(record.id);
            if (!this.store.has(cameraId)) {
              this.store.put([CameraRecordType.create({ id: cameraId })]);
            }
            if (!this.store.has(_pageStateId)) {
              this.store.put([
                InstancePageStateRecordType.create({ id: _pageStateId, pageId: record.id })
              ]);
            }
          },
          afterDelete: (record, source) => {
            var _a7, _b3;
            if (((_a7 = this.getInstanceState()) == null ? void 0 : _a7.currentPageId) === record.id) {
              const backupPageId = (_b3 = this.getPages().find((p) => p.id !== record.id)) == null ? void 0 : _b3.id;
              if (backupPageId) {
                this.store.put([{ ...this.getInstanceState(), currentPageId: backupPageId }]);
              } else if (source === "user") {
                this.store.ensureStoreIsUsable();
              }
            }
            const cameraId = CameraRecordType.createId(record.id);
            const instance_PageStateId = InstancePageStateRecordType.createId(record.id);
            this.store.remove([cameraId, instance_PageStateId]);
          }
        },
        instance: {
          afterChange: (prev, next, source) => {
            var _a7;
            if (!this.store.has(next.currentPageId)) {
              const backupPageId = this.store.has(prev.currentPageId) ? prev.currentPageId : (_a7 = this.getPages()[0]) == null ? void 0 : _a7.id;
              if (backupPageId) {
                this.store.update(next.id, (instance) => ({
                  ...instance,
                  currentPageId: backupPageId
                }));
              } else if (source === "user") {
                this.store.ensureStoreIsUsable();
              }
            }
          }
        },
        instance_page_state: {
          afterChange: (prev, next) => {
            if ((prev == null ? void 0 : prev.selectedShapeIds) !== (next == null ? void 0 : next.selectedShapeIds)) {
              const filtered = next.selectedShapeIds.filter((id) => {
                var _a7, _b3;
                let parentId = (_a7 = this.getShape(id)) == null ? void 0 : _a7.parentId;
                while (isShapeId(parentId)) {
                  if (next.selectedShapeIds.includes(parentId)) {
                    return false;
                  }
                  parentId = (_b3 = this.getShape(parentId)) == null ? void 0 : _b3.parentId;
                }
                return true;
              });
              let nextFocusedGroupId = null;
              if (filtered.length > 0) {
                const commonGroupAncestor = this.findCommonAncestor(
                  compact(filtered.map((id) => this.getShape(id))),
                  (shape) => this.isShapeOfType(shape, "group")
                );
                if (commonGroupAncestor) {
                  nextFocusedGroupId = commonGroupAncestor;
                }
              } else {
                if (next == null ? void 0 : next.focusedGroupId) {
                  nextFocusedGroupId = next.focusedGroupId;
                }
              }
              if (filtered.length !== next.selectedShapeIds.length || nextFocusedGroupId !== next.focusedGroupId) {
                this.store.put([
                  {
                    ...next,
                    selectedShapeIds: filtered,
                    focusedGroupId: nextFocusedGroupId ?? null
                  }
                ]);
              }
            }
          }
        }
      })
    );
    this._currentPageShapeIds = deriveShapeIdsInCurrentPage(
      this.store,
      () => this.getCurrentPageId()
    );
    this._parentIdsToChildIds = parentsToChildren(this.store);
    this.disposables.add(
      this.store.listen((changes) => {
        this.emit("change", changes);
      })
    );
    this.disposables.add(this.history.dispose);
    this.run(
      () => {
        this.store.ensureStoreIsUsable();
        this._updateCurrentPageState({
          editingShapeId: null,
          hoveredShapeId: null,
          erasingShapeIds: []
        });
      },
      { history: "ignore" }
    );
    if (initialState2 && this.root.children[initialState2] === void 0) {
      throw Error(`No state found for initialState "${initialState2}".`);
    }
    this.root.enter(void 0, "initial");
    this.edgeScrollManager = new EdgeScrollManager(this);
    this.focusManager = new FocusManager(this, autoFocus);
    this.disposables.add(this.focusManager.dispose.bind(this.focusManager));
    if (this.getInstanceState().followingUserId) {
      this.stopFollowingUser();
    }
    this.on("tick", this._flushEventsForTick);
    this.timers.requestAnimationFrame(() => {
      this._tickManager.start();
    });
    this.performanceTracker = new PerformanceTracker();
    if ((_a6 = this.store.props.collaboration) == null ? void 0 : _a6.mode) {
      const mode = this.store.props.collaboration.mode;
      this.disposables.add(
        react("update collaboration mode", () => {
          this.store.put([{ ...this.getInstanceState(), isReadonly: mode.get() === "readonly" }]);
        })
      );
    }
  }
  getIsShapeHiddenCache() {
    if (!this._getShapeVisibility) return null;
    return this.store.createComputedCache("isShapeHidden", (shape) => {
      const visibility = this._getShapeVisibility(shape, this);
      const isParentHidden = PageRecordType.isId(shape.parentId) ? false : this.isShapeHidden(shape.parentId);
      if (isParentHidden) return visibility !== "visible";
      return visibility === "hidden";
    });
  }
  isShapeHidden(shapeOrId) {
    if (!this._getShapeVisibility) return false;
    return !!this.getIsShapeHiddenCache().get(
      typeof shapeOrId === "string" ? shapeOrId : shapeOrId.id
    );
  }
  /**
   * Set a tool. Useful if you need to add a tool to the state chart on demand,
   * after the editor has already been initialized.
   *
   * @param Tool - The tool to set.
   * @param parent - The parent state node to set the tool on.
   *
   * @public
   */
  setTool(Tool, parent) {
    parent ?? (parent = this.root);
    if (hasOwnProperty(parent.children, Tool.id)) {
      throw Error(`Can't override tool with id "${Tool.id}"`);
    }
    parent.children[Tool.id] = new Tool(this, parent);
  }
  /**
   * Remove a tool. Useful if you need to remove a tool from the state chart on demand,
   * after the editor has already been initialized.
   *
   * @param Tool - The tool to delete.
   * @param parent - The parent state node to remove the tool from.
   *
   * @public
   */
  removeTool(Tool, parent) {
    parent ?? (parent = this.root);
    if (hasOwnProperty(parent.children, Tool.id)) {
      delete parent.children[Tool.id];
    }
  }
  /**
   * Dispose the editor.
   *
   * @public
   */
  dispose() {
    this.disposables.forEach((dispose) => dispose());
    this.disposables.clear();
    this.store.dispose();
    this.isDisposed = true;
    this.emit("dispose");
  }
  getShapeUtil(arg) {
    const type = typeof arg === "string" ? arg : arg.type;
    const shapeUtil = getOwnProperty(this.shapeUtils, type);
    assert(shapeUtil, `No shape util found for type "${type}"`);
    return shapeUtil;
  }
  hasShapeUtil(arg) {
    const type = typeof arg === "string" ? arg : arg.type;
    return hasOwnProperty(this.shapeUtils, type);
  }
  getBindingUtil(arg) {
    const type = typeof arg === "string" ? arg : arg.type;
    const bindingUtil = getOwnProperty(this.bindingUtils, type);
    assert(bindingUtil, `No binding util found for type "${type}"`);
    return bindingUtil;
  }
  /**
   * Undo to the last mark.
   *
   * @example
   * ```ts
   * editor.undo()
   * ```
   *
   * @public
   */
  undo() {
    this._flushEventsForTick(0);
    this.complete();
    this.history.undo();
    return this;
  }
  canUndo() {
    return this.history.getNumUndos() > 0;
  }
  getCanUndo() {
    return this.canUndo();
  }
  /**
   * Redo to the next mark.
   *
   * @example
   * ```ts
   * editor.redo()
   * ```
   *
   * @public
   */
  redo() {
    this._flushEventsForTick(0);
    this.complete();
    this.history.redo();
    return this;
  }
  canRedo() {
    return this.history.getNumRedos() > 0;
  }
  getCanRedo() {
    return this.canRedo();
  }
  clearHistory() {
    this.history.clear();
    return this;
  }
  /**
   * Create a new "mark", or stopping point, in the undo redo history. Creating a mark will clear
   * any redos. You typically want to do this just before a user interaction begins or is handled.
   *
   * @example
   * ```ts
   * editor.markHistoryStoppingPoint()
   * editor.flipShapes(editor.getSelectedShapes())
   * ```
   * @example
   * ```ts
   * const beginRotateMark = editor.markHistoryStoppingPoint()
   * // if the use cancels the rotation, you can bail back to this mark
   * editor.bailToMark(beginRotateMark)
   * ```
   *
   * @public
   * @param name - The name of the mark, useful for debugging the undo/redo stacks
   * @returns a unique id for the mark that can be used with `squashToMark` or `bailToMark`.
   */
  markHistoryStoppingPoint(name) {
    const id = `[${name ?? "stop"}]_${uniqueId()}`;
    this.history._mark(id);
    return id;
  }
  /**
   * @internal this is only used to implement some backwards-compatibility logic. Should be fine to delete after 6 months or whatever.
   */
  getMarkIdMatching(idSubstring) {
    return this.history.getMarkIdMatching(idSubstring);
  }
  /**
   * Coalesces all changes since the given mark into a single change, removing any intermediate marks.
   *
   * This is useful if you need to 'compress' the recent history to simplify the undo/redo experience of a complex interaction.
   *
   * @example
   * ```ts
   * const bumpShapesMark = editor.markHistoryStoppingPoint()
   * // ... some changes
   * editor.squashToMark(bumpShapesMark)
   * ```
   *
   * @param markId - The mark id to squash to.
   */
  squashToMark(markId) {
    this.history.squashToMark(markId);
    return this;
  }
  /**
   * Undo to the closest mark, discarding the changes so they cannot be redone.
   *
   * @example
   * ```ts
   * editor.bail()
   * ```
   *
   * @public
   */
  bail() {
    this.history.bail();
    return this;
  }
  /**
   * Undo to the given mark, discarding the changes so they cannot be redone.
   *
   * @example
   * ```ts
   * const beginDrag = editor.markHistoryStoppingPoint()
   * // ... some changes
   * editor.bailToMark(beginDrag)
   * ```
   *
   * @public
   */
  bailToMark(id) {
    this.history.bailToMark(id);
    return this;
  }
  /**
   * Run a function in a transaction with optional options for context.
   * You can use the options to change the way that history is treated
   * or allow changes to locked shapes.
   *
   * @example
   * ```ts
   * // updating with
   * editor.run(() => {
   * 	editor.updateShape({ ...myShape, x: 100 })
   * }, { history: "ignore" })
   *
   * // forcing changes / deletions for locked shapes
   * editor.toggleLock([myShape])
   * editor.run(() => {
   * 	editor.updateShape({ ...myShape, x: 100 })
   * 	editor.deleteShape(myShape)
   * }, { ignoreShapeLock: true }, )
   * ```
   *
   * @param fn - The callback function to run.
   * @param opts - The options for the batch.
   *
   *
   * @public
   */
  run(fn, opts) {
    const previousIgnoreShapeLock = this._shouldIgnoreShapeLock;
    this._shouldIgnoreShapeLock = (opts == null ? void 0 : opts.ignoreShapeLock) ?? previousIgnoreShapeLock;
    try {
      this.history.batch(fn, opts);
    } finally {
      this._shouldIgnoreShapeLock = previousIgnoreShapeLock;
    }
    return this;
  }
  /* --------------------- Errors --------------------- */
  /** @internal */
  annotateError(error, {
    origin,
    willCrashApp,
    tags,
    extras
  }) {
    const defaultAnnotations = this.createErrorAnnotations(origin, willCrashApp);
    annotateError(error, {
      tags: { ...defaultAnnotations.tags, ...tags },
      extras: { ...defaultAnnotations.extras, ...extras }
    });
    if (willCrashApp) {
      this.store.markAsPossiblyCorrupted();
    }
    return this;
  }
  /** @internal */
  createErrorAnnotations(origin, willCrashApp) {
    try {
      const editingShapeId = this.getEditingShapeId();
      return {
        tags: {
          origin,
          willCrashApp
        },
        extras: {
          activeStateNode: this.root.getPath(),
          selectedShapes: this.getSelectedShapes().map((s) => {
            const { props, ...rest } = s;
            const { text: _text, richText: _richText, ...restProps } = props;
            return {
              ...rest,
              props: restProps
            };
          }),
          selectionCount: this.getSelectedShapes().length,
          editingShape: editingShapeId ? this.getShape(editingShapeId) : void 0,
          inputs: this.inputs.toJson(),
          pageState: this.getCurrentPageState(),
          instanceState: this.getInstanceState(),
          collaboratorCount: this.getCollaboratorsOnCurrentPage().length
        }
      };
    } catch {
      return {
        tags: {
          origin,
          willCrashApp
        },
        extras: {}
      };
    }
  }
  /**
   * We can't use an `atom` here because there's a chance that when `crashAndReportError` is called,
   * we're in a transaction that's about to be rolled back due to the same error we're currently
   * reporting.
   *
   * Instead, to listen to changes to this value, you need to listen to editor's `crash` event.
   *
   * @internal
   */
  getCrashingError() {
    return this._crashingError;
  }
  /** @internal */
  crash(error) {
    this._crashingError = error;
    this.store.markAsPossiblyCorrupted();
    this.emit("crash", { error });
    return this;
  }
  getPath() {
    return this.root.getPath().split("root.")[1];
  }
  /**
   * Get whether a certain tool (or other state node) is currently active.
   *
   * @example
   * ```ts
   * editor.isIn('select')
   * editor.isIn('select.brushing')
   * ```
   *
   * @param path - The path of active states, separated by periods.
   *
   * @public
   */
  isIn(path) {
    const ids = path.split(".").reverse();
    let state = this.root;
    while (ids.length > 0) {
      const id = ids.pop();
      if (!id) return true;
      const current = state.getCurrent();
      if ((current == null ? void 0 : current.id) === id) {
        if (ids.length === 0) return true;
        state = current;
        continue;
      } else return false;
    }
    return false;
  }
  /**
   * Get whether the state node is in any of the given active paths.
   *
   * @example
   * ```ts
   * state.isInAny('select', 'erase')
   * state.isInAny('select.brushing', 'erase.idle')
   * ```
   *
   * @public
   */
  isInAny(...paths) {
    return paths.some((path) => this.isIn(path));
  }
  /**
   * Set the selected tool.
   *
   * @example
   * ```ts
   * editor.setCurrentTool('hand')
   * editor.setCurrentTool('hand', { date: Date.now() })
   * ```
   *
   * @param id - The id of the tool to select.
   * @param info - Arbitrary data to pass along into the transition.
   *
   * @public
   */
  setCurrentTool(id, info = {}) {
    this.root.transition(id, info);
    return this;
  }
  getCurrentTool() {
    return this.root.getCurrent();
  }
  getCurrentToolId() {
    const currentTool = this.getCurrentTool();
    if (!currentTool) return "";
    return currentTool.getCurrentToolIdMask() ?? currentTool.id;
  }
  /**
   * Get a descendant by its path.
   *
   * @example
   * ```ts
   * editor.getStateDescendant('select')
   * editor.getStateDescendant('select.brushing')
   * ```
   *
   * @param path - The descendant's path of state ids, separated by periods.
   *
   * @public
   */
  getStateDescendant(path) {
    var _a6;
    const ids = path.split(".").reverse();
    let state = this.root;
    while (ids.length > 0) {
      const id = ids.pop();
      if (!id) return state;
      const childState = (_a6 = state.children) == null ? void 0 : _a6[id];
      if (!childState) return void 0;
      state = childState;
    }
    return state;
  }
  getDocumentSettings() {
    return this.store.get(TLDOCUMENT_ID);
  }
  /**
   * Update the global document settings that apply to all users.
   *
   * @public
   **/
  updateDocumentSettings(settings) {
    this.run(
      () => {
        this.store.put([{ ...this.getDocumentSettings(), ...settings }]);
      },
      { history: "ignore" }
    );
    return this;
  }
  getInstanceState() {
    return this.store.get(TLINSTANCE_ID);
  }
  /**
   * Update the instance's state.
   *
   * @param partial - A partial object to update the instance state with.
   * @param historyOptions - History batch options.
   *
   * @public
   */
  updateInstanceState(partial, historyOptions) {
    this._updateInstanceState(partial, { history: "ignore", ...historyOptions });
    if (partial.isChangingStyle !== void 0) {
      clearTimeout(this._isChangingStyleTimeout);
      if (partial.isChangingStyle === true) {
        this._isChangingStyleTimeout = this.timers.setTimeout(() => {
          this._updateInstanceState({ isChangingStyle: false }, { history: "ignore" });
        }, 1e3);
      }
    }
    return this;
  }
  /** @internal */
  _updateInstanceState(partial, opts) {
    this.run(() => {
      this.store.put([
        {
          ...this.getInstanceState(),
          ...partial
        }
      ]);
    }, opts);
  }
  /* --------------------- Cursor --------------------- */
  /**
   * Set the cursor.
   *
   * @param cursor - The cursor to set.
   * @public
   */
  setCursor(cursor) {
    this.updateInstanceState({ cursor: { ...this.getInstanceState().cursor, ...cursor } });
    return this;
  }
  getPageStates() {
    return this._getPageStatesQuery().get();
  }
  _getPageStatesQuery() {
    return this.store.query.records("instance_page_state");
  }
  getCurrentPageState() {
    return this.store.get(this._getCurrentPageStateId());
  }
  _getCurrentPageStateId() {
    return InstancePageStateRecordType.createId(this.getCurrentPageId());
  }
  /**
   * Update this instance's page state.
   *
   * @example
   * ```ts
   * editor.updateCurrentPageState({ id: 'page1', editingShapeId: 'shape:123' })
   * ```
   *
   * @param partial - The partial of the page state object containing the changes.
   *
   * @public
   */
  updateCurrentPageState(partial) {
    this._updateCurrentPageState(partial);
    return this;
  }
  _updateCurrentPageState(partial) {
    this.store.update(partial.id ?? this.getCurrentPageState().id, (state) => ({
      ...state,
      ...partial
    }));
  }
  getSelectedShapeIds() {
    return this.getCurrentPageState().selectedShapeIds;
  }
  getSelectedShapes() {
    return compact(this.getSelectedShapeIds().map((id) => this.store.get(id)));
  }
  /**
   * Select one or more shapes.
   *
   * @example
   * ```ts
   * editor.setSelectedShapes(['id1'])
   * editor.setSelectedShapes(['id1', 'id2'])
   * ```
   *
   * @param shapes - The shape (or shape ids) to select.
   *
   * @public
   */
  setSelectedShapes(shapes) {
    return this.run(
      () => {
        const ids = shapes.map((shape) => typeof shape === "string" ? shape : shape.id);
        const { selectedShapeIds: prevSelectedShapeIds } = this.getCurrentPageState();
        const prevSet = new Set(prevSelectedShapeIds);
        if (ids.length === prevSet.size && ids.every((id) => prevSet.has(id))) return null;
        this.store.put([{ ...this.getCurrentPageState(), selectedShapeIds: ids }]);
      },
      { history: "record-preserveRedoStack" }
    );
  }
  /**
   * Determine whether or not any of a shape's ancestors are selected.
   *
   * @param shape - The shape (or shape id) of the shape to check.
   *
   * @public
   */
  isAncestorSelected(shape) {
    const id = typeof shape === "string" ? shape : (shape == null ? void 0 : shape.id) ?? null;
    const _shape = this.getShape(id);
    if (!_shape) return false;
    const selectedShapeIds = this.getSelectedShapeIds();
    return !!this.findShapeAncestor(_shape, (parent) => selectedShapeIds.includes(parent.id));
  }
  /**
   * Select one or more shapes.
   *
   * @example
   * ```ts
   * editor.select('id1')
   * editor.select('id1', 'id2')
   * ```
   *
   * @param shapes - The shape (or the shape ids) to select.
   *
   * @public
   */
  select(...shapes) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((shape) => shape.id);
    this.setSelectedShapes(ids);
    return this;
  }
  /**
   * Remove a shape from the existing set of selected shapes.
   *
   * @example
   * ```ts
   * editor.deselect(shape.id)
   * ```
   *
   * @public
   */
  deselect(...shapes) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((shape) => shape.id);
    const selectedShapeIds = this.getSelectedShapeIds();
    if (selectedShapeIds.length > 0 && ids.length > 0) {
      this.setSelectedShapes(selectedShapeIds.filter((id) => !ids.includes(id)));
    }
    return this;
  }
  /**
   * Select all shapes. If the user has selected shapes that share a parent,
   * select all shapes within that parent. If the user has not selected any shapes,
   * or if the shapes shapes are only on select all shapes on the current page.
   *
   * @example
   * ```ts
   * editor.selectAll()
   * ```
   *
   * @public
   */
  selectAll() {
    let parentToSelectWithinId = null;
    const selectedShapeIds = this.getSelectedShapeIds();
    if (selectedShapeIds.length > 0) {
      for (const id of selectedShapeIds) {
        const shape = this.getShape(id);
        if (!shape) continue;
        if (parentToSelectWithinId === null) {
          parentToSelectWithinId = shape.parentId;
        } else if (parentToSelectWithinId !== shape.parentId) {
          return this;
        }
      }
    }
    if (!parentToSelectWithinId) {
      parentToSelectWithinId = this.getCurrentPageId();
    }
    const ids = this.getSortedChildIdsForParent(parentToSelectWithinId);
    if (ids.length <= 0) return this;
    this.setSelectedShapes(this._getUnlockedShapeIds(ids));
    return this;
  }
  /**
   * Select the next shape in the reading order or in cardinal order.
   *
   * @example
   * ```ts
   * editor.selectAdjacentShape('next')
   * ```
   *
   * @public
   */
  selectAdjacentShape(direction) {
    var _a6, _b3;
    const selectedShapeIds = this.getSelectedShapeIds();
    const firstParentId = selectedShapeIds[0] ? (_a6 = this.getShape(selectedShapeIds[0])) == null ? void 0 : _a6.parentId : null;
    const isSelectedWithinContainer = firstParentId && selectedShapeIds.every((shapeId) => {
      var _a7;
      return ((_a7 = this.getShape(shapeId)) == null ? void 0 : _a7.parentId) === firstParentId;
    }) && !isPageId(firstParentId);
    const filteredShapes = isSelectedWithinContainer ? this.getCurrentPageShapes().filter((shape2) => shape2.parentId === firstParentId) : this.getCurrentPageShapes().filter((shape2) => isPageId(shape2.parentId));
    const readingOrderShapes = isSelectedWithinContainer ? this._getShapesInReadingOrder(filteredShapes) : this.getCurrentPageShapesInReadingOrder();
    const currentShapeId = selectedShapeIds.length === 1 ? selectedShapeIds[0] : (_b3 = readingOrderShapes.find((shape2) => selectedShapeIds.includes(shape2.id))) == null ? void 0 : _b3.id;
    let adjacentShapeId;
    if (direction === "next" || direction === "prev") {
      const shapeIds = readingOrderShapes.map((shape2) => shape2.id);
      const currentIndex = currentShapeId ? shapeIds.indexOf(currentShapeId) : -1;
      const adjacentIndex = (currentIndex + (direction === "next" ? 1 : -1) + shapeIds.length) % shapeIds.length;
      adjacentShapeId = shapeIds[adjacentIndex];
    } else {
      if (!currentShapeId) return;
      adjacentShapeId = this.getNearestAdjacentShape(filteredShapes, currentShapeId, direction);
    }
    const shape = this.getShape(adjacentShapeId);
    if (!shape) return;
    this._selectShapesAndZoom([shape.id]);
  }
  getCurrentPageShapesInReadingOrder() {
    const shapes = this.getCurrentPageShapes().filter((shape) => isPageId(shape.parentId));
    return this._getShapesInReadingOrder(shapes);
  }
  _getShapesInReadingOrder(shapes) {
    const SHALLOW_ANGLE = 20;
    const ROW_THRESHOLD = 100;
    const tabbableShapes = shapes.filter((shape) => this.getShapeUtil(shape).canTabTo(shape));
    if (tabbableShapes.length <= 1) return tabbableShapes;
    const shapesWithCenters = tabbableShapes.map((shape) => ({
      shape,
      center: this.getShapePageBounds(shape).center
    }));
    shapesWithCenters.sort((a, b) => a.center.y - b.center.y);
    const rows = [];
    for (const shapeWithCenter of shapesWithCenters) {
      let rowIndex = -1;
      for (let i = rows.length - 1; i >= 0; i--) {
        const row = rows[i];
        const lastShapeInRow = row[row.length - 1];
        if (Math.abs(shapeWithCenter.center.y - lastShapeInRow.center.y) < ROW_THRESHOLD) {
          rowIndex = i;
          break;
        }
      }
      if (rowIndex === -1) {
        rows.push([shapeWithCenter]);
      } else {
        rows[rowIndex].push(shapeWithCenter);
      }
    }
    for (const row of rows) {
      row.sort((a, b) => a.center.x - b.center.x);
    }
    for (const row of rows) {
      if (row.length <= 2) continue;
      for (let i = 0; i < row.length - 2; i++) {
        const currentShape = row[i];
        const nextShape = row[i + 1];
        const nextNextShape = row[i + 2];
        const dist1 = Vec.Dist2(currentShape.center, nextShape.center);
        const dist2 = Vec.Dist2(currentShape.center, nextNextShape.center);
        if (dist2 < dist1 * 0.9) {
          const angle = Math.abs(
            Vec.Angle(currentShape.center, nextNextShape.center) * (180 / Math.PI)
          );
          if (angle <= SHALLOW_ANGLE) {
            ;
            [row[i + 1], row[i + 2]] = [row[i + 2], row[i + 1]];
          }
        }
      }
    }
    return rows.flat().map((item) => item.shape);
  }
  /**
   * Find the nearest adjacent shape in a specific direction.
   *
   * @public
   */
  getNearestAdjacentShape(shapes, currentShapeId, direction) {
    const directionToAngle = { right: 0, left: 180, down: 90, up: 270 };
    const currentShape = this.getShape(currentShapeId);
    if (!currentShape) return currentShapeId;
    const tabbableShapes = shapes.filter(
      (shape) => this.getShapeUtil(shape).canTabTo(shape) && shape.id !== currentShapeId
    );
    if (!tabbableShapes.length) return currentShapeId;
    const currentCenter = this.getShapePageBounds(currentShape).center;
    const shapesWithCenters = tabbableShapes.map((shape) => ({
      shape,
      center: this.getShapePageBounds(shape).center
    }));
    const shapesInDirection = shapesWithCenters.filter(({ center }) => {
      const isRight = center.x > currentCenter.x;
      const isDown = center.y > currentCenter.y;
      const xDist = center.x - currentCenter.x;
      const yDist = center.y - currentCenter.y;
      const isInXDirection = Math.abs(yDist) < Math.abs(xDist) * 2;
      const isInYDirection = Math.abs(xDist) < Math.abs(yDist) * 2;
      if (direction === "left" || direction === "right") {
        return isInXDirection && (direction === "right" ? isRight : !isRight);
      }
      if (direction === "up" || direction === "down") {
        return isInYDirection && (direction === "down" ? isDown : !isDown);
      }
    });
    if (shapesInDirection.length === 0) return currentShapeId;
    const lowestScoringShape = minBy(shapesInDirection, ({ center }) => {
      const distance = Vec.Dist2(currentCenter, center);
      const dirProp = ["left", "right"].includes(direction) ? "x" : "y";
      const directionalDistance = Math.abs(center[dirProp] - currentCenter[dirProp]);
      const offProp = ["left", "right"].includes(direction) ? "y" : "x";
      const offAxisDeviation = Math.abs(center[offProp] - currentCenter[offProp]);
      const angle = Math.abs(Vec.Angle(currentCenter, center) * (180 / Math.PI));
      const angleDeviation = Math.abs(angle - directionToAngle[direction]);
      return distance * 1 + // Base distance
      offAxisDeviation * 2 + // Heavy penalty for off-axis deviation
      (distance - directionalDistance) * 1.5 + // Penalty for diagonal distance
      angleDeviation * 0.5;
    });
    return lowestScoringShape.shape.id;
  }
  selectParentShape() {
    const selectedShape = this.getOnlySelectedShape();
    if (!selectedShape) return;
    const parentShape = this.getShape(selectedShape.parentId);
    if (!parentShape) return;
    this._selectShapesAndZoom([parentShape.id]);
  }
  selectFirstChildShape() {
    const selectedShapes = this.getSelectedShapes();
    if (!selectedShapes.length) return;
    const selectedShape = selectedShapes[0];
    const children = this.getSortedChildIdsForParent(selectedShape.id).map((id) => this.getShape(id)).filter((i) => i);
    const sortedChildren = this._getShapesInReadingOrder(children);
    if (sortedChildren.length === 0) return;
    this._selectShapesAndZoom([sortedChildren[0].id]);
  }
  _selectShapesAndZoom(ids) {
    this.setSelectedShapes(ids);
    this.zoomToSelectionIfOffscreen(256, {
      animation: {
        duration: this.options.animationMediumMs
      },
      inset: 0
    });
  }
  /**
   * Clear the selection.
   *
   * @example
   * ```ts
   * editor.selectNone()
   * ```
   *
   * @public
   */
  selectNone() {
    if (this.getSelectedShapeIds().length > 0) {
      this.setSelectedShapes([]);
    }
    return this;
  }
  getOnlySelectedShapeId() {
    var _a6;
    return ((_a6 = this.getOnlySelectedShape()) == null ? void 0 : _a6.id) ?? null;
  }
  getOnlySelectedShape() {
    const selectedShapes = this.getSelectedShapes();
    return selectedShapes.length === 1 ? selectedShapes[0] : null;
  }
  /**
   * Get the page bounds of all the provided shapes.
   *
   * @public
   */
  getShapesPageBounds(shapeIds) {
    const bounds = compact(shapeIds.map((id) => this.getShapePageBounds(id)));
    if (bounds.length === 0) return null;
    return Box.Common(bounds);
  }
  getSelectionPageBounds() {
    return this.getShapesPageBounds(this.getSelectedShapeIds());
  }
  /**
   * The bounds of the selection bounding box in the current page space.
   *
   * @readonly
   * @public
   */
  getSelectionScreenBounds() {
    const bounds = this.getSelectionPageBounds();
    if (!bounds) return void 0;
    const { x, y } = this.pageToScreen(bounds.point);
    const zoom = this.getZoomLevel();
    return new Box(x, y, bounds.width * zoom, bounds.height * zoom);
  }
  /**
   * @internal
   */
  getShapesSharedRotation(shapeIds) {
    let foundFirst = false;
    let rotation = 0;
    for (let i = 0, n = shapeIds.length; i < n; i++) {
      const pageTransform = this.getShapePageTransform(shapeIds[i]);
      if (!pageTransform) continue;
      if (foundFirst) {
        if (pageTransform.rotation() !== rotation) {
          return 0;
        }
      } else {
        foundFirst = true;
        rotation = pageTransform.rotation();
      }
    }
    return rotation;
  }
  getSelectionRotation() {
    return this.getShapesSharedRotation(this.getSelectedShapeIds());
  }
  /**
   * @internal
   */
  getShapesRotatedPageBounds(shapeIds) {
    if (shapeIds.length === 0) {
      return void 0;
    }
    const selectionRotation = this.getShapesSharedRotation(shapeIds);
    if (selectionRotation === 0) {
      return this.getShapesPageBounds(shapeIds) ?? void 0;
    }
    if (shapeIds.length === 1) {
      const bounds = this.getShapeGeometry(shapeIds[0]).bounds.clone();
      const pageTransform = this.getShapePageTransform(shapeIds[0]);
      bounds.point = pageTransform.applyToPoint(bounds.point);
      return bounds;
    }
    const boxFromRotatedVertices = Box.FromPoints(
      shapeIds.flatMap((id) => {
        const pageTransform = this.getShapePageTransform(id);
        if (!pageTransform) return [];
        return pageTransform.applyToPoints(this.getShapeGeometry(id).bounds.corners);
      }).map((p) => p.rot(-selectionRotation))
    );
    boxFromRotatedVertices.point = boxFromRotatedVertices.point.rot(selectionRotation);
    return boxFromRotatedVertices;
  }
  getSelectionRotatedPageBounds() {
    return this.getShapesRotatedPageBounds(this.getSelectedShapeIds());
  }
  getSelectionRotatedScreenBounds() {
    const bounds = this.getSelectionRotatedPageBounds();
    if (!bounds) return void 0;
    const { x, y } = this.pageToScreen(bounds.point);
    const zoom = this.getZoomLevel();
    return new Box(x, y, bounds.width * zoom, bounds.height * zoom);
  }
  getFocusedGroupId() {
    return this.getCurrentPageState().focusedGroupId ?? this.getCurrentPageId();
  }
  getFocusedGroup() {
    const focusedGroupId = this.getFocusedGroupId();
    return focusedGroupId ? this.getShape(focusedGroupId) : void 0;
  }
  /**
   * Set the current focused group shape.
   *
   * @param shape - The group shape id (or group shape's id) to set as the focused group shape.
   *
   * @public
   */
  setFocusedGroup(shape) {
    const id = typeof shape === "string" ? shape : (shape == null ? void 0 : shape.id) ?? null;
    if (id !== null) {
      const shape2 = this.getShape(id);
      if (!shape2) {
        throw Error(`Editor.setFocusedGroup: Shape with id ${id} does not exist`);
      }
      if (!this.isShapeOfType(shape2, "group")) {
        throw Error(
          `Editor.setFocusedGroup: Cannot set focused group to shape of type ${shape2.type}`
        );
      }
    }
    if (id === this.getFocusedGroupId()) return this;
    return this.run(
      () => {
        this.store.update(this.getCurrentPageState().id, (s) => ({ ...s, focusedGroupId: id }));
      },
      { history: "record-preserveRedoStack" }
    );
  }
  /**
   * Exit the current focused group, moving up to the next parent group if there is one.
   *
   * @public
   */
  popFocusedGroupId() {
    const focusedGroup = this.getFocusedGroup();
    if (focusedGroup) {
      const match = this.findShapeAncestor(
        focusedGroup,
        (shape) => this.isShapeOfType(shape, "group")
      );
      this.setFocusedGroup((match == null ? void 0 : match.id) ?? null);
      this.select(focusedGroup.id);
    } else {
      this.setFocusedGroup(null);
      this.selectNone();
    }
    return this;
  }
  getEditingShapeId() {
    return this.getCurrentPageState().editingShapeId;
  }
  getEditingShape() {
    const editingShapeId = this.getEditingShapeId();
    return editingShapeId ? this.getShape(editingShapeId) : void 0;
  }
  /**
   * Whether the shape can be edited.
   *
   * @param shape - The shape (or shape id) to check if it can be edited.
   * @param info - The info about the edit start.
   *
   * @public
   * @returns true if the shape can be edited, false otherwise.
   */
  canEditShape(shape, info) {
    const id = typeof shape === "string" ? shape : (shape == null ? void 0 : shape.id) ?? null;
    if (!id) return false;
    if (id === this.getEditingShapeId()) return false;
    const _shape = this.getShape(id);
    if (!_shape) return false;
    const util = this.getShapeUtil(_shape);
    const _info = info ?? { type: "unknown" };
    if (!util.canEdit(_shape, _info)) return false;
    if (this.getIsReadonly() && !util.canEditInReadonly(_shape)) return false;
    if (this.isShapeOrAncestorLocked(_shape) && !util.canEditWhileLocked(_shape)) return false;
    return true;
  }
  /**
   * Set the current editing shape.
   *
   * @example
   * ```ts
   * editor.setEditingShape(myShape)
   * editor.setEditingShape(myShape.id)
   * ```
   *
   * @param shape - The shape (or shape id) to set as editing.
   *
   * @public
   */
  setEditingShape(shape) {
    const id = typeof shape === "string" ? shape : (shape == null ? void 0 : shape.id) ?? null;
    if (!id) {
      this.run(
        () => {
          var _a6, _b3;
          const prevEditingShapeId = this.getEditingShapeId();
          if (prevEditingShapeId) {
            const prevEditingShape = this.getShape(prevEditingShapeId);
            if (prevEditingShape) {
              (_b3 = (_a6 = this.getShapeUtil(prevEditingShape)).onEditEnd) == null ? void 0 : _b3.call(_a6, prevEditingShape);
            }
          }
          this._updateCurrentPageState({ editingShapeId: null });
          this._currentRichTextEditor.set(null);
        },
        { history: "ignore" }
      );
      return this;
    }
    if (!this.canEditShape(id)) return this;
    this.run(
      () => {
        var _a6, _b3, _c, _d;
        const prevEditingShapeId = this.getEditingShapeId();
        if (prevEditingShapeId) {
          const prevEditingShape = this.getShape(prevEditingShapeId);
          if (prevEditingShape) {
            (_b3 = (_a6 = this.getShapeUtil(prevEditingShape)).onEditEnd) == null ? void 0 : _b3.call(_a6, prevEditingShape);
          }
        }
        this._updateCurrentPageState({ editingShapeId: null });
        this._currentRichTextEditor.set(null);
        this.select(id);
        this._updateCurrentPageState({ editingShapeId: id });
        const nextEditingShape = this.getShape(id);
        (_d = (_c = this.getShapeUtil(nextEditingShape)).onEditStart) == null ? void 0 : _d.call(_c, nextEditingShape);
      },
      { history: "ignore" }
    );
    return this;
  }
  getRichTextEditor() {
    return this._currentRichTextEditor.get();
  }
  /**
   * Set the current editing shape's rich text editor.
   *
   * @example
   * ```ts
   * editor.setRichTextEditor(richTextEditorView)
   * ```
   *
   * @param textEditor - The text editor to set as the current editing shape's text editor.
   *
   * @public
   */
  setRichTextEditor(textEditor) {
    this._currentRichTextEditor.set(textEditor);
    return this;
  }
  getHoveredShapeId() {
    return this.getCurrentPageState().hoveredShapeId;
  }
  getHoveredShape() {
    const hoveredShapeId = this.getHoveredShapeId();
    return hoveredShapeId ? this.getShape(hoveredShapeId) : void 0;
  }
  /**
   * Set the editor's current hovered shape.
   *
   * @example
   * ```ts
   * editor.setHoveredShape(myShape)
   * editor.setHoveredShape(myShape.id)
   * ```
   *
   * @param shape - The shape (or shape id) to set as hovered.
   *
   * @public
   */
  setHoveredShape(shape) {
    const id = typeof shape === "string" ? shape : (shape == null ? void 0 : shape.id) ?? null;
    if (id === this.getHoveredShapeId()) return this;
    this.run(
      () => {
        this.updateCurrentPageState({ hoveredShapeId: id });
      },
      { history: "ignore" }
    );
    return this;
  }
  getHintingShapeIds() {
    return this.getCurrentPageState().hintingShapeIds;
  }
  getHintingShape() {
    const hintingShapeIds = this.getHintingShapeIds();
    return compact(hintingShapeIds.map((id) => this.getShape(id)));
  }
  /**
   * Set the editor's current hinting shapes.
   *
   * @example
   * ```ts
   * editor.setHintingShapes([myShape])
   * editor.setHintingShapes([myShape.id])
   * ```
   *
   * @param shapes - The shapes (or shape ids) to set as hinting.
   *
   * @public
   */
  setHintingShapes(shapes) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((shape) => shape.id);
    this.run(
      () => {
        this._updateCurrentPageState({ hintingShapeIds: dedupe(ids) });
      },
      { history: "ignore" }
    );
    return this;
  }
  getErasingShapeIds() {
    return this.getCurrentPageState().erasingShapeIds;
  }
  getErasingShapes() {
    const erasingShapeIds = this.getErasingShapeIds();
    return compact(erasingShapeIds.map((id) => this.getShape(id)));
  }
  /**
   * Set the editor's current erasing shapes.
   *
   * @example
   * ```ts
   * editor.setErasingShapes([myShape])
   * editor.setErasingShapes([myShape.id])
   * ```
   *
   * @param shapes - The shapes (or shape ids) to set as hinting.
   *
   * @public
   */
  setErasingShapes(shapes) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((shape) => shape.id);
    ids.sort();
    const erasingShapeIds = this.getErasingShapeIds();
    this.run(
      () => {
        if (ids.length === erasingShapeIds.length) {
          for (let i = 0; i < ids.length; i++) {
            if (ids[i] !== erasingShapeIds[i]) {
              this._updateCurrentPageState({ erasingShapeIds: ids });
              break;
            }
          }
        } else {
          this._updateCurrentPageState({ erasingShapeIds: ids });
        }
      },
      { history: "ignore" }
    );
    return this;
  }
  // Cropping
  /**
   * The current cropping shape's id.
   *
   * @public
   */
  getCroppingShapeId() {
    return this.getCurrentPageState().croppingShapeId;
  }
  /**
   * Whether the shape can be cropped.
   *
   * @param shape - The shape (or shape id) to check if it can be cropped.
   *
   * @public
   * @returns true if the shape can be cropped, false otherwise.
   */
  canCropShape(shape) {
    if (!shape) return false;
    const id = typeof shape === "string" ? shape : (shape == null ? void 0 : shape.id) ?? null;
    if (!id) return false;
    const _shape = this.getShape(id);
    if (!_shape) return false;
    const util = this.getShapeUtil(_shape);
    if (!util.canCrop(_shape)) return false;
    if (this.isShapeOrAncestorLocked(_shape)) return false;
    return true;
  }
  /**
   * Set the current cropping shape.
   *
   * @example
   * ```ts
   * editor.setCroppingShape(myShape)
   * editor.setCroppingShape(myShape.id)
   * ```
   *
   *
   * @param shape - The shape (or shape id) to set as cropping.
   *
   * @public
   */
  setCroppingShape(shape) {
    const id = typeof shape === "string" ? shape : (shape == null ? void 0 : shape.id) ?? null;
    if (id !== this.getCroppingShapeId()) {
      this.run(
        () => {
          if (!id) {
            this.updateCurrentPageState({ croppingShapeId: null });
          } else if (this.canCropShape(id)) {
            this.updateCurrentPageState({ croppingShapeId: id });
          }
        },
        { history: "ignore" }
      );
    }
    return this;
  }
  /**
   * Get the current text options.
   *
   * @example
   * ```ts
   * editor.getTextOptions()
   * ```
   *
   *  @public */
  getTextOptions() {
    return assertExists(this._textOptions.get(), "Cannot use text without setting textOptions");
  }
  _unsafe_getCameraId() {
    return CameraRecordType.createId(this.getCurrentPageId());
  }
  getCamera() {
    const baseCamera = this.store.get(this._unsafe_getCameraId());
    if (this._isLockedOnFollowingUser.get()) {
      const followingCamera = this.getCameraForFollowing();
      if (followingCamera) {
        return { ...baseCamera, ...followingCamera };
      }
    }
    return baseCamera;
  }
  _getFollowingPresence(targetUserId) {
    const visited = [this.user.getId()];
    const collaborators = this.getCollaborators();
    let leaderPresence = null;
    while (targetUserId && !visited.includes(targetUserId)) {
      leaderPresence = collaborators.find((c) => c.userId === targetUserId) ?? null;
      targetUserId = (leaderPresence == null ? void 0 : leaderPresence.followingUserId) ?? null;
      if (leaderPresence) {
        visited.push(leaderPresence.userId);
      }
    }
    return leaderPresence;
  }
  getViewportPageBoundsForFollowing() {
    const leaderPresence = this._getFollowingPresence(this.getInstanceState().followingUserId);
    if (!(leaderPresence == null ? void 0 : leaderPresence.camera) || !(leaderPresence == null ? void 0 : leaderPresence.screenBounds)) return null;
    const { w: lw, h: lh } = leaderPresence.screenBounds;
    const { x: lx, y: ly, z: lz2 } = leaderPresence.camera;
    const theirViewport = new Box(-lx, -ly, lw / lz2, lh / lz2);
    const ourViewport = this.getViewportScreenBounds().clone();
    const ourAspectRatio = ourViewport.width / ourViewport.height;
    ourViewport.width = theirViewport.width;
    ourViewport.height = ourViewport.width / ourAspectRatio;
    if (ourViewport.height < theirViewport.height) {
      ourViewport.height = theirViewport.height;
      ourViewport.width = ourViewport.height * ourAspectRatio;
    }
    ourViewport.center = theirViewport.center;
    return ourViewport;
  }
  getCameraForFollowing() {
    const viewport = this.getViewportPageBoundsForFollowing();
    if (!viewport) return null;
    return {
      x: -viewport.x,
      y: -viewport.y,
      z: this.getViewportScreenBounds().w / viewport.width
    };
  }
  getZoomLevel() {
    return this.getCamera().z;
  }
  getDebouncedZoomLevel() {
    if (this.options.debouncedZoom) {
      if (this.getCameraState() === "idle") {
        return this.getZoomLevel();
      } else {
        return this._debouncedZoomLevel.get();
      }
    }
    return this.getZoomLevel();
  }
  _getAboveDebouncedZoomThreshold() {
    return this.getCurrentPageShapeIds().size > this.options.debouncedZoomThreshold;
  }
  getEfficientZoomLevel() {
    return this._getAboveDebouncedZoomThreshold() ? this.getDebouncedZoomLevel() : this.getZoomLevel();
  }
  /**
   * Get the camera's initial or reset zoom level.
   *
   * @example
   * ```ts
   * editor.getInitialZoom()
   * ```
   *
   * @public */
  getInitialZoom() {
    const cameraOptions = this.getCameraOptions();
    if (!cameraOptions.constraints) return 1;
    if (cameraOptions.constraints.initialZoom === "default") return 1;
    const { zx, zy } = getCameraFitXFitY(this, cameraOptions);
    switch (cameraOptions.constraints.initialZoom) {
      case "fit-min": {
        return Math.max(zx, zy);
      }
      case "fit-max": {
        return Math.min(zx, zy);
      }
      case "fit-x": {
        return zx;
      }
      case "fit-y": {
        return zy;
      }
      case "fit-min-100": {
        return Math.min(1, Math.max(zx, zy));
      }
      case "fit-max-100": {
        return Math.min(1, Math.min(zx, zy));
      }
      case "fit-x-100": {
        return Math.min(1, zx);
      }
      case "fit-y-100": {
        return Math.min(1, zy);
      }
      default: {
        throw exhaustiveSwitchError(cameraOptions.constraints.initialZoom);
      }
    }
  }
  /**
   * Get the camera's base level for calculating actual zoom levels based on the zoom steps.
   *
   * @example
   * ```ts
   * editor.getBaseZoom()
   * ```
   *
   * @public */
  getBaseZoom() {
    const cameraOptions = this.getCameraOptions();
    if (!cameraOptions.constraints) return 1;
    if (cameraOptions.constraints.baseZoom === "default") return 1;
    const { zx, zy } = getCameraFitXFitY(this, cameraOptions);
    switch (cameraOptions.constraints.baseZoom) {
      case "fit-min": {
        return Math.max(zx, zy);
      }
      case "fit-max": {
        return Math.min(zx, zy);
      }
      case "fit-x": {
        return zx;
      }
      case "fit-y": {
        return zy;
      }
      case "fit-min-100": {
        return Math.min(1, Math.max(zx, zy));
      }
      case "fit-max-100": {
        return Math.min(1, Math.min(zx, zy));
      }
      case "fit-x-100": {
        return Math.min(1, zx);
      }
      case "fit-y-100": {
        return Math.min(1, zy);
      }
      default: {
        throw exhaustiveSwitchError(cameraOptions.constraints.baseZoom);
      }
    }
  }
  /**
   * Get the current camera options.
   *
   * @example
   * ```ts
   * editor.getCameraOptions()
   * ```
   *
   *  @public */
  getCameraOptions() {
    return this._cameraOptions.get();
  }
  /**
   * Set the camera options. Changing the options won't immediately change the camera itself, so you may want to call `setCamera` after changing the options.
   *
   * @example
   * ```ts
   * editor.setCameraOptions(myCameraOptions)
   * editor.setCamera(editor.getCamera())
   * ```
   *
   * @param opts - The camera options to set.
   *
   * @public */
  setCameraOptions(opts) {
    var _a6;
    const next = structuredClone({
      ...this._cameraOptions.__unsafe__getWithoutCapture(),
      ...opts
    });
    if (((_a6 = next.zoomSteps) == null ? void 0 : _a6.length) < 1) next.zoomSteps = [1];
    this._cameraOptions.set(next);
    this.setCamera(this.getCamera());
    return this;
  }
  /** @internal */
  getConstrainedCamera(point, opts) {
    const currentCamera = this.getCamera();
    let { x, y, z = currentCamera.z } = point;
    if (!(opts == null ? void 0 : opts.force)) {
      const cameraOptions = this.getCameraOptions();
      const zoomMin = cameraOptions.zoomSteps[0];
      const zoomMax = last(cameraOptions.zoomSteps);
      const vsb = this.getViewportScreenBounds();
      if (cameraOptions.constraints) {
        const { constraints } = cameraOptions;
        const py = Math.min(constraints.padding.y, vsb.w / 2);
        const px = Math.min(constraints.padding.x, vsb.h / 2);
        const bounds = Box.From(cameraOptions.constraints.bounds);
        const zx = (vsb.w - px * 2) / bounds.w;
        const zy = (vsb.h - py * 2) / bounds.h;
        const baseZoom = this.getBaseZoom();
        const maxZ = zoomMax * baseZoom;
        const minZ = zoomMin * baseZoom;
        if (opts == null ? void 0 : opts.reset) {
          z = this.getInitialZoom();
        }
        if (z < minZ || z > maxZ) {
          const { x: cx, y: cy, z: cz } = currentCamera;
          const cxA = -cx + vsb.w / cz / 2;
          const cyA = -cy + vsb.h / cz / 2;
          z = clamp(z, minZ, maxZ);
          const cxB = -cx + vsb.w / z / 2;
          const cyB = -cy + vsb.h / z / 2;
          x = cx + cxB - cxA;
          y = cy + cyB - cyA;
        }
        const minX = px / z - bounds.x;
        const minY = py / z - bounds.y;
        const freeW = (vsb.w - px * 2) / z - bounds.w;
        const freeH = (vsb.h - py * 2) / z - bounds.h;
        const originX = minX + freeW * constraints.origin.x;
        const originY = minY + freeH * constraints.origin.y;
        const behaviorX = typeof constraints.behavior === "string" ? constraints.behavior : constraints.behavior.x;
        const behaviorY = typeof constraints.behavior === "string" ? constraints.behavior : constraints.behavior.y;
        if (opts == null ? void 0 : opts.reset) {
          x = originX;
          y = originY;
        } else {
          switch (behaviorX) {
            case "fixed": {
              x = originX;
              break;
            }
            case "contain": {
              if (z < zx) x = originX;
              else x = clamp(x, minX + freeW, minX);
              break;
            }
            case "inside": {
              if (z < zx) x = clamp(x, minX, (vsb.w - px) / z - bounds.w);
              else x = clamp(x, minX + freeW, minX);
              break;
            }
            case "outside": {
              x = clamp(x, px / z - bounds.w, (vsb.w - px) / z);
              break;
            }
            case "free": {
              break;
            }
            default: {
              throw exhaustiveSwitchError(behaviorX);
            }
          }
          switch (behaviorY) {
            case "fixed": {
              y = originY;
              break;
            }
            case "contain": {
              if (z < zy) y = originY;
              else y = clamp(y, minY + freeH, minY);
              break;
            }
            case "inside": {
              if (z < zy) y = clamp(y, minY, (vsb.h - py) / z - bounds.h);
              else y = clamp(y, minY + freeH, minY);
              break;
            }
            case "outside": {
              y = clamp(y, py / z - bounds.h, (vsb.h - py) / z);
              break;
            }
            case "free": {
              break;
            }
            default: {
              throw exhaustiveSwitchError(behaviorY);
            }
          }
        }
      } else {
        if (z > zoomMax || z < zoomMin) {
          const { x: cx, y: cy, z: cz } = currentCamera;
          z = clamp(z, zoomMin, zoomMax);
          x = cx + (-cx + vsb.w / z / 2) - (-cx + vsb.w / cz / 2);
          y = cy + (-cy + vsb.h / z / 2) - (-cy + vsb.h / cz / 2);
        }
      }
    }
    return { x, y, z };
  }
  /** @internal */
  _setCamera(point, opts) {
    const currentCamera = this.getCamera();
    const { x, y, z } = this.getConstrainedCamera(point, opts);
    if (currentCamera.x === x && currentCamera.y === y && currentCamera.z === z) {
      return this;
    }
    transact(() => {
      const camera = { ...currentCamera, x, y, z };
      this.run(
        () => {
          this.store.put([camera]);
        },
        { history: "ignore" }
      );
      const currentScreenPoint = this.inputs.getCurrentScreenPoint();
      const currentPagePoint = this.inputs.getCurrentPagePoint();
      if (currentScreenPoint.x / z - x !== currentPagePoint.x || currentScreenPoint.y / z - y !== currentPagePoint.y) {
        this.updatePointer({
          immediate: opts == null ? void 0 : opts.immediate,
          pointerId: INTERNAL_POINTER_IDS.CAMERA_MOVE
        });
      }
      this._tickCameraState();
    });
    return this;
  }
  /**
   * Set the current camera.
   *
   * @example
   * ```ts
   * editor.setCamera({ x: 0, y: 0})
   * editor.setCamera({ x: 0, y: 0, z: 1.5})
   * editor.setCamera({ x: 0, y: 0, z: 1.5}, { animation: { duration: 1000, easing: (t) => t * t } })
   * ```
   *
   * @param point - The new camera position.
   * @param opts - The camera move options.
   *
   * @public
   */
  setCamera(point, opts) {
    const { isLocked } = this._cameraOptions.__unsafe__getWithoutCapture();
    if (isLocked && !(opts == null ? void 0 : opts.force)) return this;
    this.stopCameraAnimation();
    if (this.getInstanceState().followingUserId) {
      this.stopFollowingUser();
    }
    const _point = Vec.Cast(point);
    if (!Number.isFinite(_point.x)) _point.x = 0;
    if (!Number.isFinite(_point.y)) _point.y = 0;
    if (_point.z === void 0 || !Number.isFinite(_point.z)) point.z = this.getZoomLevel();
    const camera = this.getConstrainedCamera(_point, opts);
    if (opts == null ? void 0 : opts.animation) {
      const { width, height } = this.getViewportScreenBounds();
      this._animateToViewport(
        new Box(-camera.x, -camera.y, width / camera.z, height / camera.z),
        opts
      );
    } else {
      this._setCamera(camera, {
        ...opts,
        // we already did the constraining, so we don't need to do it again
        force: true
      });
    }
    return this;
  }
  /**
   * Center the camera on a point (in the current page space).
   *
   * @example
   * ```ts
   * editor.centerOnPoint({ x: 100, y: 100 })
   * editor.centerOnPoint({ x: 100, y: 100 }, { animation: { duration: 200 } })
   * ```
   *
   * @param point - The point in the current page space to center on.
   * @param opts - The camera move options.
   *
   * @public
   */
  centerOnPoint(point, opts) {
    const { isLocked } = this.getCameraOptions();
    if (isLocked && !(opts == null ? void 0 : opts.force)) return this;
    const { width: pw, height: ph } = this.getViewportPageBounds();
    this.setCamera(new Vec(-(point.x - pw / 2), -(point.y - ph / 2), this.getCamera().z), opts);
    return this;
  }
  /**
   * Zoom the camera to fit the current page's content in the viewport.
   *
   * @example
   * ```ts
   * editor.zoomToFit()
   * editor.zoomToFit({ animation: { duration: 200 } })
   * ```
   *
   * @param opts - The camera move options.
   *
   * @public
   */
  zoomToFit(opts) {
    const ids = [...this.getCurrentPageShapeIds()];
    if (ids.length <= 0) return this;
    const pageBounds = Box.Common(compact(ids.map((id) => this.getShapePageBounds(id))));
    this.zoomToBounds(pageBounds, opts);
    return this;
  }
  /**
   * Set the zoom back to 100%.
   *
   * @example
   * ```ts
   * editor.resetZoom()
   * editor.resetZoom(editor.getViewportScreenCenter(), { animation: { duration: 200 } })
   * editor.resetZoom(editor.getViewportScreenCenter(), { animation: { duration: 200 } })
   * ```
   *
   * @param point - The screen point to zoom out on. Defaults to the viewport screen center.
   * @param opts - The camera move options.
   *
   * @public
   */
  resetZoom(point = this.getViewportScreenCenter(), opts) {
    const { isLocked, constraints } = this.getCameraOptions();
    if (isLocked && !(opts == null ? void 0 : opts.force)) return this;
    const currentCamera = this.getCamera();
    const { x: cx, y: cy, z: cz } = currentCamera;
    const { x, y } = point;
    let z = 1;
    if (constraints) {
      const initialZoom = this.getInitialZoom();
      if (cz !== initialZoom) {
        z = initialZoom;
      }
    }
    this.setCamera(
      new Vec(cx + (x / z - x) - (x / cz - x), cy + (y / z - y) - (y / cz - y), z),
      opts
    );
    return this;
  }
  /**
   * Zoom the camera in.
   *
   * @example
   * ```ts
   * editor.zoomIn()
   * editor.zoomIn(editor.getViewportScreenCenter(), { animation: { duration: 200 } })
   * editor.zoomIn(editor.inputs.getCurrentScreenPoint(), { animation: { duration: 200 } })
   * ```
   *
   * @param point - The screen point to zoom in on. Defaults to the screen center
   * @param opts - The camera move options.
   *
   * @public
   */
  zoomIn(point = this.getViewportScreenCenter(), opts) {
    const { isLocked } = this.getCameraOptions();
    if (isLocked && !(opts == null ? void 0 : opts.force)) return this;
    const { x: cx, y: cy, z: cz } = this.getCamera();
    const { zoomSteps } = this.getCameraOptions();
    if (zoomSteps !== null && zoomSteps.length > 1) {
      const baseZoom = this.getBaseZoom();
      let zoom = last(zoomSteps) * baseZoom;
      for (let i = 1; i < zoomSteps.length; i++) {
        const z1 = zoomSteps[i - 1] * baseZoom;
        const z2 = zoomSteps[i] * baseZoom;
        if (z2 - cz <= (z2 - z1) / 2) continue;
        zoom = z2;
        break;
      }
      this.setCamera(
        new Vec(
          cx + (point.x / zoom - point.x) - (point.x / cz - point.x),
          cy + (point.y / zoom - point.y) - (point.y / cz - point.y),
          zoom
        ),
        opts
      );
    }
    return this;
  }
  /**
   * Zoom the camera out.
   *
   * @example
   * ```ts
   * editor.zoomOut()
   * editor.zoomOut(editor.getViewportScreenCenter(), { animation: { duration: 120 } })
   * editor.zoomOut(editor.inputs.getCurrentScreenPoint(), { animation: { duration: 120 } })
   * ```
   *
   * @param point - The point to zoom out on. Defaults to the viewport screen center.
   * @param opts - The camera move options.
   *
   * @public
   */
  zoomOut(point = this.getViewportScreenCenter(), opts) {
    const { isLocked } = this.getCameraOptions();
    if (isLocked && !(opts == null ? void 0 : opts.force)) return this;
    const { zoomSteps } = this.getCameraOptions();
    if (zoomSteps !== null && zoomSteps.length > 1) {
      const baseZoom = this.getBaseZoom();
      const { x: cx, y: cy, z: cz } = this.getCamera();
      let zoom = zoomSteps[0] * baseZoom;
      for (let i = zoomSteps.length - 1; i > 0; i--) {
        const z1 = zoomSteps[i - 1] * baseZoom;
        const z2 = zoomSteps[i] * baseZoom;
        if (z2 - cz >= (z2 - z1) / 2) continue;
        zoom = z1;
        break;
      }
      this.setCamera(
        new Vec(
          cx + (point.x / zoom - point.x) - (point.x / cz - point.x),
          cy + (point.y / zoom - point.y) - (point.y / cz - point.y),
          zoom
        ),
        opts
      );
    }
    return this;
  }
  /**
   * Zoom the camera to fit the current selection in the viewport.
   *
   * @example
   * ```ts
   * editor.zoomToSelection()
   * editor.zoomToSelection({ animation: { duration: 200 } })
   * ```
   *
   * @param opts - The camera move options.
   *
   * @public
   */
  zoomToSelection(opts) {
    const { isLocked } = this.getCameraOptions();
    if (isLocked && !(opts == null ? void 0 : opts.force)) return this;
    const selectionPageBounds = this.getSelectionPageBounds();
    if (selectionPageBounds) {
      const currentZoom = this.getZoomLevel();
      if (Math.abs(currentZoom - 1) < 0.01) {
        this.zoomToBounds(selectionPageBounds, opts);
      } else {
        this.zoomToBounds(selectionPageBounds, {
          targetZoom: 1,
          ...opts
        });
      }
    }
    return this;
  }
  /**
   * Zoom the camera to the current selection if offscreen.
   *
   * @public
   */
  zoomToSelectionIfOffscreen(padding = 16, opts) {
    const selectionPageBounds = this.getSelectionPageBounds();
    const viewportPageBounds = this.getViewportPageBounds();
    if (selectionPageBounds && !viewportPageBounds.contains(selectionPageBounds)) {
      const eb = selectionPageBounds.clone().expandBy(padding / this.getZoomLevel()).expand(viewportPageBounds);
      const nextBounds = viewportPageBounds.clone().translate({
        x: (eb.center.x - viewportPageBounds.center.x) * 2,
        y: (eb.center.y - viewportPageBounds.center.y) * 2
      });
      this.zoomToBounds(nextBounds, opts);
    }
  }
  /**
   * Zoom the camera to fit a bounding box (in the current page space).
   *
   * @example
   * ```ts
   * editor.zoomToBounds(myBounds)
   * editor.zoomToBounds(myBounds, { animation: { duration: 200 } })
   * editor.zoomToBounds(myBounds, { animation: { duration: 200 }, inset: 0, targetZoom: 1 })
   * ```
   *
   * @param bounds - The bounding box.
   * @param opts - The camera move options, target zoom, or custom inset amount.
   *
   * @public
   */
  zoomToBounds(bounds, opts) {
    const cameraOptions = this._cameraOptions.__unsafe__getWithoutCapture();
    if (cameraOptions.isLocked && !(opts == null ? void 0 : opts.force)) return this;
    const viewportScreenBounds = this.getViewportScreenBounds();
    const inset = (opts == null ? void 0 : opts.inset) ?? Math.min(this.options.zoomToFitPadding, viewportScreenBounds.width * 0.28);
    const baseZoom = this.getBaseZoom();
    const zoomMin = cameraOptions.zoomSteps[0];
    const zoomMax = last(cameraOptions.zoomSteps);
    let zoom = clamp(
      Math.min(
        (viewportScreenBounds.width - inset) / bounds.w,
        (viewportScreenBounds.height - inset) / bounds.h
      ),
      zoomMin * baseZoom,
      zoomMax * baseZoom
    );
    if ((opts == null ? void 0 : opts.targetZoom) !== void 0) {
      zoom = Math.min(opts.targetZoom, zoom);
    }
    this.setCamera(
      new Vec(
        -bounds.x + (viewportScreenBounds.width - bounds.w * zoom) / 2 / zoom,
        -bounds.y + (viewportScreenBounds.height - bounds.h * zoom) / 2 / zoom,
        zoom
      ),
      opts
    );
    return this;
  }
  /**
   * Stop the current camera animation, if any.
   *
   * @example
   * ```ts
   * editor.stopCameraAnimation()
   * ```
   *
   * @public
   */
  stopCameraAnimation() {
    this.emit("stop-camera-animation");
    return this;
  }
  /** @internal */
  _animateViewport(ms) {
    if (!this._viewportAnimation) return;
    this._viewportAnimation.elapsed += ms;
    const { elapsed, easing, duration, start, end } = this._viewportAnimation;
    if (elapsed > duration) {
      this.off("tick", this._animateViewport);
      this._viewportAnimation = null;
      this._setCamera(new Vec(-end.x, -end.y, this.getViewportScreenBounds().width / end.width));
      return;
    }
    const remaining = duration - elapsed;
    const t2 = easing(1 - remaining / duration);
    const left = start.minX + (end.minX - start.minX) * t2;
    const top = start.minY + (end.minY - start.minY) * t2;
    const right = start.maxX + (end.maxX - start.maxX) * t2;
    this._setCamera(new Vec(-left, -top, this.getViewportScreenBounds().width / (right - left)), {
      force: true
    });
  }
  /** @internal */
  _animateToViewport(targetViewportPage, opts = { animation: DEFAULT_ANIMATION_OPTIONS }) {
    const { animation, ...rest } = opts;
    if (!animation) return;
    const { duration = 0, easing = EASINGS.easeInOutCubic } = animation;
    const animationSpeed = this.user.getAnimationSpeed();
    const viewportPageBounds = this.getViewportPageBounds();
    this.stopCameraAnimation();
    if (this.getInstanceState().followingUserId) {
      this.stopFollowingUser();
    }
    if (duration === 0 || animationSpeed === 0) {
      return this._setCamera(
        new Vec(
          -targetViewportPage.x,
          -targetViewportPage.y,
          this.getViewportScreenBounds().width / targetViewportPage.width
        ),
        { ...rest }
      );
    }
    this._viewportAnimation = {
      elapsed: 0,
      duration: duration / animationSpeed,
      easing,
      start: viewportPageBounds.clone(),
      end: targetViewportPage.clone()
    };
    this.once("stop-camera-animation", () => {
      this.off("tick", this._animateViewport);
      this._viewportAnimation = null;
    });
    this.on("tick", this._animateViewport);
    return this;
  }
  /**
   * Slide the camera in a certain direction.
   *
   * @example
   * ```ts
   * editor.slideCamera({ speed: 1, direction: { x: 1, y: 0 }, friction: 0.1 })
   * ```
   *
   * @param opts - Options for the slide
   * @public
   */
  slideCamera(opts = {}) {
    const { isLocked } = this.getCameraOptions();
    if (isLocked && !(opts == null ? void 0 : opts.force)) return this;
    const animationSpeed = this.user.getAnimationSpeed();
    if (animationSpeed === 0) return this;
    this.stopCameraAnimation();
    const {
      speed,
      friction = this.options.cameraSlideFriction,
      direction,
      speedThreshold = 0.01
    } = opts;
    let currentSpeed = Math.min(speed, 1);
    const cancel = () => {
      this.off("tick", moveCamera);
      this.off("stop-camera-animation", cancel);
    };
    this.once("stop-camera-animation", cancel);
    const moveCamera = (elapsed) => {
      const { x: cx, y: cy, z: cz } = this.getCamera();
      const movementVec = Vec.Mul(direction, currentSpeed * elapsed / cz);
      currentSpeed *= 1 - friction;
      if (currentSpeed < speedThreshold) {
        cancel();
      } else {
        this._setCamera(new Vec(cx + movementVec.x, cy + movementVec.y, cz));
      }
    };
    this.on("tick", moveCamera);
    return this;
  }
  /**
   * Animate the camera to a user's cursor position. This also briefly show the user's cursor if it's not currently visible.
   *
   * @example
   * ```ts
   * editor.zoomToUser(myUserId)
   * editor.zoomToUser(myUserId, { animation: { duration: 200 } })
   * ```
   *
   * @param userId - The id of the user to animate to.
   * @param opts - The camera move options.
   * @public
   */
  zoomToUser(userId, opts = { animation: { duration: 500 } }) {
    const presence = this.getCollaborators().find((c) => c.userId === userId);
    if (!presence) return this;
    const cursor = presence.cursor;
    if (!cursor) return this;
    this.run(() => {
      if (this.getInstanceState().followingUserId !== null) {
        this.stopFollowingUser();
      }
      const isOnSamePage = presence.currentPageId === this.getCurrentPageId();
      if (!isOnSamePage) {
        this.setCurrentPage(presence.currentPageId);
      }
      if (opts && opts.animation && !isOnSamePage) {
        opts.animation = void 0;
      }
      this.centerOnPoint(cursor, opts);
      const { highlightedUserIds } = this.getInstanceState();
      this.updateInstanceState({ highlightedUserIds: [...highlightedUserIds, userId] });
      this.timers.setTimeout(() => {
        const highlightedUserIds2 = [...this.getInstanceState().highlightedUserIds];
        const index2 = highlightedUserIds2.indexOf(userId);
        if (index2 < 0) return;
        highlightedUserIds2.splice(index2, 1);
        this.updateInstanceState({ highlightedUserIds: highlightedUserIds2 });
      }, this.options.collaboratorIdleTimeoutMs);
    });
    return this;
  }
  /**
   * Update the viewport. The viewport will measure the size and screen position of its container
   * element. This should be done whenever the container's position on the screen changes.
   *
   * @example
   * ```ts
   * editor.updateViewportScreenBounds(new Box(0, 0, 1280, 1024))
   * editor.updateViewportScreenBounds(new Box(0, 0, 1280, 1024), true)
   * ```
   *
   * @param screenBounds - The new screen bounds of the viewport.
   * @param center - Whether to preserve the viewport page center as the viewport changes.
   *
   * @public
   */
  updateViewportScreenBounds(screenBounds, center = false) {
    if (!(screenBounds instanceof Box)) {
      const rect = screenBounds.getBoundingClientRect();
      screenBounds = new Box(
        rect.left || rect.x,
        rect.top || rect.y,
        Math.max(rect.width, 1),
        Math.max(rect.height, 1)
      );
    } else {
      screenBounds.width = Math.max(screenBounds.width, 1);
      screenBounds.height = Math.max(screenBounds.height, 1);
    }
    const insets = [
      // top
      screenBounds.minY !== 0,
      // right
      !approximately(document.body.scrollWidth, screenBounds.maxX, 1),
      // bottom
      !approximately(document.body.scrollHeight, screenBounds.maxY, 1),
      // left
      screenBounds.minX !== 0
    ];
    const { _willSetInitialBounds } = this;
    this._willSetInitialBounds = false;
    const { screenBounds: prevScreenBounds, insets: prevInsets } = this.getInstanceState();
    if (screenBounds.equals(prevScreenBounds) && insets.every((v, i) => v === prevInsets[i])) {
      return this;
    }
    if (_willSetInitialBounds) {
      this.updateInstanceState({ screenBounds: screenBounds.toJson(), insets });
      this.emit("resize", screenBounds.toJson());
      this.setCamera(this.getCamera());
    } else {
      if (center && !this.getInstanceState().followingUserId) {
        const before = this.getViewportPageBounds().center;
        this.updateInstanceState({ screenBounds: screenBounds.toJson(), insets });
        this.emit("resize", screenBounds.toJson());
        this.centerOnPoint(before);
      } else {
        this.updateInstanceState({ screenBounds: screenBounds.toJson(), insets });
        this.emit("resize", screenBounds.toJson());
        this._setCamera(Vec.From({ ...this.getCamera() }));
      }
    }
    return this;
  }
  getViewportScreenBounds() {
    const { x, y, w, h: h2 } = this.getInstanceState().screenBounds;
    return new Box(x, y, w, h2);
  }
  getViewportScreenCenter() {
    const viewportScreenBounds = this.getViewportScreenBounds();
    return new Vec(viewportScreenBounds.w / 2, viewportScreenBounds.h / 2);
  }
  getViewportPageBounds() {
    const { w, h: h2 } = this.getViewportScreenBounds();
    const { x: cx, y: cy, z: cz } = this.getCamera();
    return new Box(-cx, -cy, w / cz, h2 / cz);
  }
  /**
   * Convert a point in screen space to a point in the current page space.
   *
   * @example
   * ```ts
   * editor.screenToPage({ x: 100, y: 100 })
   * ```
   *
   * @param point - The point in screen space.
   *
   * @public
   */
  screenToPage(point) {
    const { screenBounds } = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID);
    const { x: cx, y: cy, z: cz = 1 } = this.getCamera();
    return new Vec(
      (point.x - screenBounds.x) / cz - cx,
      (point.y - screenBounds.y) / cz - cy,
      point.z ?? 0.5
    );
  }
  /**
   * Convert a point in the current page space to a point in current screen space.
   *
   * @example
   * ```ts
   * editor.pageToScreen({ x: 100, y: 100 })
   * ```
   *
   * @param point - The point in page space.
   *
   * @public
   */
  pageToScreen(point) {
    const { screenBounds } = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID);
    const { x: cx, y: cy, z: cz = 1 } = this.getCamera();
    return new Vec(
      (point.x + cx) * cz + screenBounds.x,
      (point.y + cy) * cz + screenBounds.y,
      point.z ?? 0.5
    );
  }
  /**
   * Convert a point in the current page space to a point in current viewport space.
   *
   * @example
   * ```ts
   * editor.pageToViewport({ x: 100, y: 100 })
   * ```
   *
   * @param point - The point in page space.
   *
   * @public
   */
  pageToViewport(point) {
    const { x: cx, y: cy, z: cz = 1 } = this.getCamera();
    return new Vec((point.x + cx) * cz, (point.y + cy) * cz, point.z ?? 0.5);
  }
  _getCollaboratorsQuery() {
    return this.store.query.records("instance_presence", () => ({
      userId: { neq: this.user.getId() }
    }));
  }
  getCollaborators() {
    const allPresenceRecords = this._getCollaboratorsQuery().get();
    if (!allPresenceRecords.length) return EMPTY_ARRAY;
    const userIds = [...new Set(allPresenceRecords.map((c) => c.userId))].sort();
    return userIds.map((id) => {
      const latestPresence = maxBy(
        allPresenceRecords.filter((c) => c.userId === id),
        (p) => p.lastActivityTimestamp ?? 0
      );
      return latestPresence;
    });
  }
  getCollaboratorsOnCurrentPage() {
    const currentPageId = this.getCurrentPageId();
    return this.getCollaborators().filter((c) => c.currentPageId === currentPageId);
  }
  /**
   * Start viewport-following a user.
   *
   * @example
   * ```ts
   * editor.startFollowingUser(myUserId)
   * ```
   *
   * @param userId - The id of the user to follow.
   *
   * @public
   */
  startFollowingUser(userId) {
    this.stopFollowingUser();
    const thisUserId = this.user.getId();
    if (!thisUserId) {
      console.warn("You should set the userId for the current instance before following a user");
    }
    const leaderPresence = this._getFollowingPresence(userId);
    if (!leaderPresence) {
      return this;
    }
    const latestLeaderPresence = computed("latestLeaderPresence", () => {
      return this._getFollowingPresence(userId);
    });
    transact(() => {
      this.updateInstanceState({ followingUserId: userId }, { history: "ignore" });
      const dispose = react("update current page", () => {
        const leaderPresence2 = latestLeaderPresence.get();
        if (!leaderPresence2) {
          this.stopFollowingUser();
          return;
        }
        if (leaderPresence2.currentPageId !== this.getCurrentPageId() && this.getPage(leaderPresence2.currentPageId)) {
          this.run(
            () => {
              this.store.put([
                { ...this.getInstanceState(), currentPageId: leaderPresence2.currentPageId }
              ]);
              this._isLockedOnFollowingUser.set(true);
            },
            { history: "ignore" }
          );
        }
      });
      const cancel = () => {
        dispose();
        this._isLockedOnFollowingUser.set(false);
        this.off("frame", moveTowardsUser);
        this.off("stop-following", cancel);
      };
      const moveTowardsUser = () => {
        const leaderPresence2 = latestLeaderPresence.get();
        if (!leaderPresence2) {
          this.stopFollowingUser();
          return;
        }
        if (this._isLockedOnFollowingUser.get()) return;
        const animationSpeed = this.user.getAnimationSpeed();
        if (animationSpeed === 0) {
          this._isLockedOnFollowingUser.set(true);
          return;
        }
        const targetViewport = this.getViewportPageBoundsForFollowing();
        if (!targetViewport) {
          this.stopFollowingUser();
          return;
        }
        const currentViewport = this.getViewportPageBounds();
        const diffX = Math.abs(targetViewport.minX - currentViewport.minX) + Math.abs(targetViewport.maxX - currentViewport.maxX);
        const diffY = Math.abs(targetViewport.minY - currentViewport.minY) + Math.abs(targetViewport.maxY - currentViewport.maxY);
        if (diffX < this.options.followChaseViewportSnap && diffY < this.options.followChaseViewportSnap) {
          this._isLockedOnFollowingUser.set(true);
          return;
        }
        const t2 = clamp(animationSpeed * 0.5, 0.1, 0.8);
        const nextViewport = new Box(
          lerp(currentViewport.minX, targetViewport.minX, t2),
          lerp(currentViewport.minY, targetViewport.minY, t2),
          lerp(currentViewport.width, targetViewport.width, t2),
          lerp(currentViewport.height, targetViewport.height, t2)
        );
        const nextCamera = new Vec(
          -nextViewport.x,
          -nextViewport.y,
          this.getViewportScreenBounds().width / nextViewport.width
        );
        this.stopCameraAnimation();
        this._setCamera(nextCamera);
      };
      this.once("stop-following", cancel);
      this.addListener("frame", moveTowardsUser);
      moveTowardsUser();
    });
    return this;
  }
  /**
   * Stop viewport-following a user.
   *
   * @example
   * ```ts
   * editor.stopFollowingUser()
   * ```
   * @public
   */
  stopFollowingUser() {
    this.run(
      () => {
        this.store.put([this.getCamera()]);
        this._isLockedOnFollowingUser.set(false);
        this.updateInstanceState({ followingUserId: null });
        this.emit("stop-following");
      },
      { history: "ignore" }
    );
    return this;
  }
  /** @internal */
  getUnorderedRenderingShapes(useEditorState) {
    const renderingShapes = [];
    let nextIndex = this.options.maxShapesPerPage * 2;
    let nextBackgroundIndex = this.options.maxShapesPerPage;
    const erasingShapeIds = this.getErasingShapeIds();
    const addShapeById = (id, opacity, isAncestorErasing) => {
      const shape = this.getShape(id);
      if (!shape) return;
      if (this.isShapeHidden(shape)) {
        const isErasing = isAncestorErasing || erasingShapeIds.includes(id);
        for (const childId of this.getSortedChildIdsForParent(id)) {
          addShapeById(childId, opacity, isErasing);
        }
        return;
      }
      opacity *= shape.opacity;
      let isShapeErasing = false;
      const util = this.getShapeUtil(shape);
      if (useEditorState) {
        isShapeErasing = !isAncestorErasing && erasingShapeIds.includes(id);
        if (isShapeErasing) {
          opacity *= 0.32;
        }
      }
      renderingShapes.push({
        id,
        shape,
        util,
        index: nextIndex,
        backgroundIndex: nextBackgroundIndex,
        opacity
      });
      nextIndex += 1;
      nextBackgroundIndex += 1;
      const childIds = this.getSortedChildIdsForParent(id);
      if (!childIds.length) return;
      let backgroundIndexToRestore = null;
      if (util.providesBackgroundForChildren(shape)) {
        backgroundIndexToRestore = nextBackgroundIndex;
        nextBackgroundIndex = nextIndex;
        nextIndex += this.options.maxShapesPerPage;
      }
      for (const childId of childIds) {
        addShapeById(childId, opacity, isAncestorErasing || isShapeErasing);
      }
      if (backgroundIndexToRestore !== null) {
        nextBackgroundIndex = backgroundIndexToRestore;
      }
    };
    const pages = useEditorState ? [this.getCurrentPage()] : this.getPages();
    for (const page of pages) {
      for (const childId of this.getSortedChildIdsForParent(page.id)) {
        addShapeById(childId, 1, false);
      }
    }
    return renderingShapes;
  }
  _decayCameraStateTimeout(elapsed) {
    this._cameraStateTimeoutRemaining -= elapsed;
    if (this._cameraStateTimeoutRemaining > 0) return;
    this.off("tick", this._decayCameraStateTimeout);
    this._cameraState.set("idle");
  }
  _tickCameraState() {
    this._cameraStateTimeoutRemaining = this.options.cameraMovingTimeoutMs;
    if (this._cameraState.__unsafe__getWithoutCapture() !== "idle") return;
    this._cameraState.set("moving");
    this._debouncedZoomLevel.set(unsafe__withoutCapture(() => this.getCamera().z));
    this.on("tick", this._decayCameraStateTimeout);
  }
  /**
   * Whether the camera is moving or idle.
   *
   * @example
   * ```ts
   * editor.getCameraState()
   * ```
   *
   * @public
   */
  getCameraState() {
    return this._cameraState.get();
  }
  getRenderingShapes() {
    const renderingShapes = this.getUnorderedRenderingShapes(true);
    return renderingShapes.sort(sortById);
  }
  _getAllPagesQuery() {
    return this.store.query.records("page");
  }
  getPages() {
    return Array.from(this._getAllPagesQuery().get()).sort(sortByIndex);
  }
  /**
   * The current page.
   *
   * @example
   * ```ts
   * editor.getCurrentPage()
   * ```
   *
   * @public
   */
  getCurrentPage() {
    return this.getPage(this.getCurrentPageId());
  }
  getCurrentPageId() {
    return this.getInstanceState().currentPageId;
  }
  /**
   * Get a page.
   *
   * @example
   * ```ts
   * editor.getPage(myPage.id)
   * editor.getPage(myPage)
   * ```
   *
   * @param page - The page (or the page id) to get.
   *
   * @public
   */
  getPage(page) {
    return this.store.get(typeof page === "string" ? page : page.id);
  }
  /**
   * An array of all of the shapes on the current page.
   *
   * @example
   * ```ts
   * editor.getCurrentPageIds()
   * ```
   *
   * @public
   */
  getCurrentPageShapeIds() {
    return this._currentPageShapeIds.get();
  }
  getCurrentPageShapeIdsSorted() {
    return Array.from(this.getCurrentPageShapeIds()).sort();
  }
  /**
   * Get the ids of shapes on a page.
   *
   * @example
   * ```ts
   * const idsOnPage1 = editor.getPageShapeIds('page1')
   * const idsOnPage2 = editor.getPageShapeIds(myPage2)
   * ```
   *
   * @param page - The page (or the page id) to get the shape ids for.
   *
   * @public
   **/
  getPageShapeIds(page) {
    const pageId = typeof page === "string" ? page : page.id;
    const result = this.store.query.exec("shape", { parentId: { eq: pageId } });
    return this.getShapeAndDescendantIds(result.map((s) => s.id));
  }
  /**
   * Set the current page.
   *
   * @example
   * ```ts
   * editor.setCurrentPage('page1')
   * editor.setCurrentPage(myPage1)
   * ```
   *
   * @param page - The page (or the page id) to set as the current page.
   *
   * @public
   */
  setCurrentPage(page) {
    const pageId = typeof page === "string" ? page : page.id;
    if (!this.store.has(pageId)) {
      console.error("Tried to set the current page id to a page that doesn't exist.");
      return this;
    }
    this.stopFollowingUser();
    this.complete();
    return this.run(
      () => {
        this.store.put([{ ...this.getInstanceState(), currentPageId: pageId }]);
        this.setCamera(this.getCamera());
      },
      { history: "record-preserveRedoStack" }
    );
  }
  /**
   * Update a page.
   *
   * @example
   * ```ts
   * editor.updatePage({ id: 'page2', name: 'Page 2' })
   * ```
   *
   * @param partial - The partial of the shape to update.
   *
   * @public
   */
  updatePage(partial) {
    if (this.getIsReadonly()) return this;
    const prev = this.getPage(partial.id);
    if (!prev) return this;
    return this.run(() => this.store.update(partial.id, (page) => ({ ...page, ...partial })));
  }
  /**
   * Create a page whilst ensuring that the page name is unique.
   *
   * @example
   * ```ts
   * editor.createPage(myPage)
   * editor.createPage({ name: 'Page 2' })
   * ```
   *
   * @param page - The page (or page partial) to create.
   *
   * @public
   */
  createPage(page) {
    this.run(() => {
      if (this.getIsReadonly()) return;
      if (this.getPages().length >= this.options.maxPages) return;
      const pages = this.getPages();
      const name = getIncrementedName(
        page.name ?? "Page 1",
        pages.map((p) => p.name)
      );
      let index2 = page.index;
      if (!index2 || pages.some((p) => p.index === index2)) {
        index2 = getIndexAbove(pages[pages.length - 1].index);
      }
      const newPage = PageRecordType.create({
        meta: {},
        ...page,
        name,
        index: index2
      });
      this.store.put([newPage]);
    });
    return this;
  }
  /**
   * Delete a page.
   *
   * @example
   * ```ts
   * editor.deletePage('page1')
   * ```
   *
   * @param page - The page (or the page id) to delete.
   *
   * @public
   */
  deletePage(page) {
    const id = typeof page === "string" ? page : page.id;
    this.run(
      () => {
        if (this.getIsReadonly()) return;
        const pages = this.getPages();
        if (pages.length === 1) return;
        const deletedPage = this.getPage(id);
        if (!deletedPage) return;
        if (id === this.getCurrentPageId()) {
          const index2 = pages.findIndex((page2) => page2.id === id);
          const next = pages[index2 - 1] ?? pages[index2 + 1];
          this.setCurrentPage(next.id);
        }
        const shapes = this.getSortedChildIdsForParent(deletedPage.id);
        this.deleteShapes(shapes);
        this.store.remove([deletedPage.id]);
      },
      { ignoreShapeLock: true }
    );
    return this;
  }
  /**
   * Duplicate a page.
   *
   * @param page - The page (or the page id) to duplicate. Defaults to the current page.
   * @param createId - The id of the new page. Defaults to a new id.
   *
   * @public
   */
  duplicatePage(page, createId = PageRecordType.createId()) {
    if (this.getPages().length >= this.options.maxPages) return this;
    const id = typeof page === "string" ? page : page.id;
    const freshPage = this.getPage(id);
    if (!freshPage) return this;
    const prevCamera = { ...this.getCamera() };
    const content = this.getContentFromCurrentPage(this.getSortedChildIdsForParent(freshPage.id));
    this.run(() => {
      var _a6;
      const pages = this.getPages();
      const index2 = getIndexBetween(freshPage.index, (_a6 = pages[pages.indexOf(freshPage) + 1]) == null ? void 0 : _a6.index);
      this.createPage({ name: freshPage.name + " Copy", id: createId, index: index2 });
      this.setCurrentPage(createId);
      this.setCamera(prevCamera);
      if (content) {
        return this.putContentOntoCurrentPage(content);
      }
    });
    return this;
  }
  /**
   * Rename a page.
   *
   * @example
   * ```ts
   * editor.renamePage('page1', 'My Page')
   * ```
   *
   * @param page - The page (or the page id) to rename.
   * @param name - The new name.
   *
   * @public
   */
  renamePage(page, name) {
    const id = typeof page === "string" ? page : page.id;
    if (this.getIsReadonly()) return this;
    this.updatePage({ id, name });
    return this;
  }
  _getAllAssetsQuery() {
    return this.store.query.records("asset");
  }
  /**
   * Get all assets in the editor.
   *
   * @public
   */
  getAssets() {
    return this._getAllAssetsQuery().get();
  }
  /**
   * Create one or more assets.
   *
   * @example
   * ```ts
   * editor.createAssets([...myAssets])
   * ```
   *
   * @param assets - The assets to create.
   *
   * @public
   */
  createAssets(assets) {
    if (this.getIsReadonly()) return this;
    if (assets.length <= 0) return this;
    this.run(() => this.store.put(assets), { history: "ignore" });
    return this;
  }
  /**
   * Update one or more assets.
   *
   * @example
   * ```ts
   * editor.updateAssets([{ id: 'asset1', name: 'New name' }])
   * ```
   *
   * @param assets - The assets to update.
   *
   * @public
   */
  updateAssets(assets) {
    if (this.getIsReadonly()) return this;
    if (assets.length <= 0) return this;
    this.run(
      () => {
        this.store.put(
          assets.map((partial) => ({
            ...this.store.get(partial.id),
            ...partial
          }))
        );
      },
      { history: "ignore" }
    );
    return this;
  }
  /**
   * Delete one or more assets.
   *
   * @example
   * ```ts
   * editor.deleteAssets(['asset1', 'asset2'])
   * ```
   *
   * @param assets - The assets (or asset ids) to delete.
   *
   * @public
   */
  deleteAssets(assets) {
    if (this.getIsReadonly()) return this;
    const ids = typeof assets[0] === "string" ? assets : assets.map((a) => a.id);
    if (ids.length <= 0) return this;
    this.run(
      () => {
        var _a6, _b3;
        (_b3 = (_a6 = this.store.props.assets).remove) == null ? void 0 : _b3.call(_a6, ids);
        this.store.remove(ids);
      },
      { history: "ignore" }
    );
    return this;
  }
  /**
   * Get an asset by its id.
   *
   * @example
   * ```ts
   * editor.getAsset('asset1')
   * ```
   *
   * @param asset - The asset (or asset id) to get.
   *
   * @public
   */
  getAsset(asset) {
    return this.store.get(typeof asset === "string" ? asset : asset.id);
  }
  async resolveAssetUrl(assetId, context) {
    if (!assetId) return null;
    const asset = this.getAsset(assetId);
    if (!asset) return null;
    const {
      screenScale = 1,
      shouldResolveToOriginal = false,
      dpr = this.getInstanceState().devicePixelRatio
    } = context;
    const zoomStepFunction = (zoom) => Math.pow(2, Math.ceil(Math.log2(zoom)));
    const steppedScreenScale = zoomStepFunction(screenScale);
    const networkEffectiveType = "connection" in navigator ? navigator.connection.effectiveType : null;
    return await this.store.props.assets.resolve(asset, {
      screenScale: screenScale || 1,
      steppedScreenScale,
      dpr,
      networkEffectiveType,
      shouldResolveToOriginal
    });
  }
  /**
   * Upload an asset to the store's asset service, returning a URL that can be used to resolve the
   * asset.
   */
  async uploadAsset(asset, file, abortSignal) {
    return await this.store.props.assets.upload(asset, file, abortSignal);
  }
  /**
   * Get the geometry of a shape in shape-space.
   *
   * @example
   * ```ts
   * editor.getShapeGeometry(myShape)
   * editor.getShapeGeometry(myShapeId)
   * editor.getShapeGeometry(myShapeId, { context: "arrow" })
   * ```
   *
   * @param shape - The shape (or shape id) to get the geometry for.
   * @param opts - Additional options about the request for geometry. Passed to {@link ShapeUtil.getGeometry}.
   *
   * @public
   */
  getShapeGeometry(shape, opts) {
    const context = (opts == null ? void 0 : opts.context) ?? "none";
    if (!this._shapeGeometryCaches[context]) {
      this._shapeGeometryCaches[context] = this.store.createComputedCache(
        "bounds",
        (shape2) => {
          this.fonts.trackFontsForShape(shape2);
          return this.getShapeUtil(shape2).getGeometry(shape2, opts);
        },
        { areRecordsEqual: areShapesContentEqual }
      );
    }
    return this._shapeGeometryCaches[context].get(
      typeof shape === "string" ? shape : shape.id
    );
  }
  _getShapeHandlesCache() {
    return this.store.createComputedCache(
      "handles",
      (shape) => {
        var _a6, _b3;
        return (_b3 = (_a6 = this.getShapeUtil(shape)).getHandles) == null ? void 0 : _b3.call(_a6, shape);
      },
      {
        areRecordsEqual: areShapesContentEqual
      }
    );
  }
  /**
   * Get the handles (if any) for a shape.
   *
   * @example
   * ```ts
   * editor.getShapeHandles(myShape)
   * editor.getShapeHandles(myShapeId)
   * ```
   *
   * @param shape - The shape (or shape id) to get the handles for.
   * @public
   */
  getShapeHandles(shape) {
    return this._getShapeHandlesCache().get(typeof shape === "string" ? shape : shape.id);
  }
  /**
   * Get the local transform for a shape as a matrix model. This transform reflects both its
   * translation (x, y) from from either its parent's top left corner, if the shape's parent is
   * another shape, or else from the 0,0 of the page, if the shape's parent is the page; and the
   * shape's rotation.
   *
   * @example
   * ```ts
   * editor.getShapeLocalTransform(myShape)
   * ```
   *
   * @param shape - The shape to get the local transform for.
   *
   * @public
   */
  getShapeLocalTransform(shape) {
    const id = typeof shape === "string" ? shape : shape.id;
    const freshShape = this.getShape(id);
    if (!freshShape) throw Error("Editor.getTransform: shape not found");
    return Mat.Identity().translate(freshShape.x, freshShape.y).rotate(freshShape.rotation);
  }
  _getShapePageTransformCache() {
    return this.store.createComputedCache("pageTransformCache", (shape) => {
      if (isPageId(shape.parentId)) {
        return this.getShapeLocalTransform(shape);
      }
      const parentTransform = this._getShapePageTransformCache().get(shape.parentId) ?? Mat.Identity();
      return Mat.Compose(parentTransform, this.getShapeLocalTransform(shape));
    });
  }
  /**
   * Get the local transform of a shape's parent as a matrix model.
   *
   * @example
   * ```ts
   * editor.getShapeParentTransform(myShape)
   * ```
   *
   * @param shape - The shape (or shape id) to get the parent transform for.
   *
   * @public
   */
  getShapeParentTransform(shape) {
    const id = typeof shape === "string" ? shape : shape.id;
    const freshShape = this.getShape(id);
    if (!freshShape || isPageId(freshShape.parentId)) return Mat.Identity();
    return this._getShapePageTransformCache().get(freshShape.parentId) ?? Mat.Identity();
  }
  /**
   * Get the transform of a shape in the current page space.
   *
   * @example
   * ```ts
   * editor.getShapePageTransform(myShape)
   * editor.getShapePageTransform(myShapeId)
   * ```
   *
   * @param shape - The shape (or shape id) to get the page transform for.
   *
   * @public
   */
  getShapePageTransform(shape) {
    const id = typeof shape === "string" ? shape : shape.id;
    return this._getShapePageTransformCache().get(id) ?? Mat.Identity();
  }
  _getShapePageBoundsCache() {
    return this.store.createComputedCache("pageBoundsCache", (shape) => {
      const pageTransform = this.getShapePageTransform(shape);
      if (!pageTransform) return void 0;
      return Box.FromPoints(
        pageTransform.applyToPoints(this.getShapeGeometry(shape).boundsVertices)
      );
    });
  }
  /**
   * Get the bounds of a shape in the current page space.
   *
   * @example
   * ```ts
   * editor.getShapePageBounds(myShape)
   * editor.getShapePageBounds(myShapeId)
   * ```
   *
   * @param shape - The shape (or shape id) to get the bounds for.
   *
   * @public
   */
  getShapePageBounds(shape) {
    return this._getShapePageBoundsCache().get(typeof shape === "string" ? shape : shape.id);
  }
  _getShapeClipPathCache() {
    return this.store.createComputedCache("clipPathCache", (shape) => {
      const pageMask = this._getShapeMaskCache().get(shape.id);
      if (!pageMask) return void 0;
      if (pageMask.length === 0) {
        return `polygon(0px 0px, 0px 0px, 0px 0px)`;
      }
      const pageTransform = this._getShapePageTransformCache().get(shape.id);
      if (!pageTransform) return void 0;
      const localMask = Mat.applyToPoints(Mat.Inverse(pageTransform), pageMask);
      return `polygon(${localMask.map((p) => `${p.x}px ${p.y}px`).join(",")})`;
    });
  }
  /**
   * Get the clip path for a shape.
   *
   * @example
   * ```ts
   * const clipPath = editor.getShapeClipPath(shape)
   * const clipPath = editor.getShapeClipPath(shape.id)
   * ```
   *
   * @param shape - The shape (or shape id) to get the clip path for.
   *
   * @returns The clip path or undefined.
   *
   * @public
   */
  getShapeClipPath(shape) {
    return this._getShapeClipPathCache().get(typeof shape === "string" ? shape : shape.id);
  }
  _getShapeMaskCache() {
    return this.store.createComputedCache("pageMaskCache", (shape) => {
      var _a6, _b3;
      if (isPageId(shape.parentId)) return void 0;
      const clipPaths = [];
      for (const ancestor of this.getShapeAncestors(shape.id)) {
        const util = this.getShapeUtil(ancestor);
        const clipPath = (_a6 = util.getClipPath) == null ? void 0 : _a6.call(util, ancestor);
        if (!clipPath) continue;
        if (((_b3 = util.shouldClipChild) == null ? void 0 : _b3.call(util, shape)) === false) continue;
        const pageTransform = this.getShapePageTransform(ancestor.id);
        clipPaths.push(pageTransform.applyToPoints(clipPath));
      }
      if (clipPaths.length === 0) return void 0;
      const pageMask = clipPaths.reduce((acc, b) => {
        const intersection = intersectPolygonPolygon(acc, b);
        if (intersection) {
          return intersection.map(Vec.Cast);
        }
        return [];
      });
      return pageMask;
    });
  }
  /**
   * Get the mask (in the current page space) for a shape.
   *
   * @example
   * ```ts
   * const pageMask = editor.getShapeMask(shape.id)
   * ```
   *
   * @param shape - The shape (or the shape id) of the shape to get the mask for.
   *
   * @returns The mask for the shape.
   *
   * @public
   */
  getShapeMask(shape) {
    return this._getShapeMaskCache().get(typeof shape === "string" ? shape : shape.id);
  }
  /**
   * Get the bounds of a shape in the current page space, incorporating any masks. For example, if the
   * shape were the child of a frame and was half way out of the frame, the bounds would be the half
   * of the shape that was in the frame.
   *
   * @example
   * ```ts
   * editor.getShapeMaskedPageBounds(myShape)
   * editor.getShapeMaskedPageBounds(myShapeId)
   * ```
   *
   * @param shape - The shape to get the masked bounds for.
   *
   * @public
   */
  getShapeMaskedPageBounds(shape) {
    if (typeof shape !== "string") shape = shape.id;
    return this._getShapeMaskedPageBoundsCache().get(shape);
  }
  _getShapeMaskedPageBoundsCache() {
    return this.store.createComputedCache("shapeMaskedPageBoundsCache", (shape) => {
      const pageBounds = this._getShapePageBoundsCache().get(shape.id);
      if (!pageBounds) return;
      const pageMask = this._getShapeMaskCache().get(shape.id);
      if (pageMask) {
        if (pageMask.length === 0) return void 0;
        const { corners } = pageBounds;
        if (corners.every((p, i) => p && Vec.Equals(p, pageMask[i]))) return pageBounds.clone();
        const intersection = intersectPolygonPolygon(pageMask, corners);
        if (!intersection) return;
        return Box.FromPoints(intersection);
      }
      return pageBounds;
    });
  }
  /**
   * Get the ancestors of a shape.
   *
   * @example
   * ```ts
   * const ancestors = editor.getShapeAncestors(myShape)
   * const ancestors = editor.getShapeAncestors(myShapeId)
   * ```
   *
   * @param shape - The shape (or shape id) to get the ancestors for.
   * @param acc - The accumulator.
   *
   * @public
   */
  getShapeAncestors(shape, acc = []) {
    const id = typeof shape === "string" ? shape : shape.id;
    const freshShape = this.getShape(id);
    if (!freshShape) return acc;
    const parentId = freshShape.parentId;
    if (isPageId(parentId)) {
      acc.reverse();
      return acc;
    }
    const parent = this.store.get(parentId);
    if (!parent) return acc;
    acc.push(parent);
    return this.getShapeAncestors(parent, acc);
  }
  /**
   * Find the first ancestor matching the given predicate
   *
   * @example
   * ```ts
   * const ancestor = editor.findShapeAncestor(myShape)
   * const ancestor = editor.findShapeAncestor(myShape.id)
   * const ancestor = editor.findShapeAncestor(myShape.id, (shape) => shape.type === 'frame')
   * ```
   *
   * @param shape - The shape to check the ancestors for.
   * @param predicate - The predicate to match.
   *
   * @public
   */
  findShapeAncestor(shape, predicate) {
    const id = typeof shape === "string" ? shape : shape.id;
    const freshShape = this.getShape(id);
    if (!freshShape) return;
    const parentId = freshShape.parentId;
    if (isPageId(parentId)) return;
    const parent = this.getShape(parentId);
    if (!parent) return;
    return predicate(parent) ? parent : this.findShapeAncestor(parent, predicate);
  }
  /**
   * Returns true if the the given shape has the given ancestor.
   *
   * @param shape - The shape.
   * @param ancestorId - The id of the ancestor.
   *
   * @public
   */
  hasAncestor(shape, ancestorId) {
    const id = typeof shape === "string" ? shape : shape == null ? void 0 : shape.id;
    const freshShape = id && this.getShape(id);
    if (!freshShape) return false;
    if (freshShape.parentId === ancestorId) return true;
    return this.hasAncestor(this.getShapeParent(freshShape), ancestorId);
  }
  /**
   * Get the common ancestor of two or more shapes that matches a predicate.
   *
   * @param shapes - The shapes (or shape ids) to check.
   * @param predicate - The predicate to match.
   */
  findCommonAncestor(shapes, predicate) {
    var _a6;
    if (shapes.length === 0) {
      return;
    }
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    const freshShapes = compact(ids.map((id) => this.getShape(id)));
    if (freshShapes.length === 1) {
      const parentId = freshShapes[0].parentId;
      if (isPageId(parentId)) {
        return;
      }
      return predicate ? (_a6 = this.findShapeAncestor(freshShapes[0], predicate)) == null ? void 0 : _a6.id : parentId;
    }
    const [nodeA, ...others] = freshShapes;
    let ancestor = this.getShapeParent(nodeA);
    while (ancestor) {
      if (predicate && !predicate(ancestor)) {
        ancestor = this.getShapeParent(ancestor);
        continue;
      }
      if (others.every((shape) => this.hasAncestor(shape, ancestor.id))) {
        return ancestor.id;
      }
      ancestor = this.getShapeParent(ancestor);
    }
    return void 0;
  }
  /**
   * Check whether a shape or its parent is locked.
   *
   * @param shape - The shape (or shape id) to check.
   *
   * @public
   */
  isShapeOrAncestorLocked(shape) {
    const _shape = shape && this.getShape(shape);
    if (_shape === void 0) return false;
    if (_shape.isLocked) return true;
    return this.isShapeOrAncestorLocked(this.getShapeParent(_shape));
  }
  getNotVisibleShapes() {
    return this._notVisibleShapes.get();
  }
  getCulledShapes() {
    const notVisibleShapes2 = this.getNotVisibleShapes();
    const selectedShapeIds = this.getSelectedShapeIds();
    const editingId = this.getEditingShapeId();
    const culledShapes = new Set(notVisibleShapes2);
    if (editingId) {
      culledShapes.delete(editingId);
    }
    selectedShapeIds.forEach((id) => {
      culledShapes.delete(id);
    });
    return culledShapes;
  }
  getCurrentPageBounds() {
    let commonBounds;
    this.getCurrentPageShapeIdsSorted().forEach((shapeId) => {
      const bounds = this.getShapeMaskedPageBounds(shapeId);
      if (!bounds) return;
      if (!commonBounds) {
        commonBounds = bounds.clone();
      } else {
        commonBounds = commonBounds.expand(bounds);
      }
    });
    return commonBounds;
  }
  /**
   * Get the top-most selected shape at the given point, ignoring groups.
   *
   * @param point - The point to check.
   *
   * @returns The top-most selected shape at the given point, or undefined if there is no shape at the point.
   */
  getSelectedShapeAtPoint(point) {
    const selectedShapeIds = this.getSelectedShapeIds();
    return this.getCurrentPageShapesSorted().filter((shape) => shape.type !== "group" && selectedShapeIds.includes(shape.id)).reverse().find((shape) => this.isPointInShape(shape, point, { hitInside: true, margin: 0 }));
  }
  /**
   * Get the shape at the current point.
   *
   * @param point - The point to check.
   * @param opts - Options for the check: `hitInside` to check if the point is inside the shape, `margin` to check if the point is within a margin of the shape, `hitFrameInside` to check if the point is inside the frame, and `filter` to filter the shapes to check.
   *
   * @returns The shape at the given point, or undefined if there is no shape at the point.
   */
  getShapeAtPoint(point, opts = {}) {
    var _a6;
    const zoomLevel = this.getZoomLevel();
    const viewportPageBounds = this.getViewportPageBounds();
    const {
      filter: filter2,
      margin = 0,
      hitLocked = false,
      hitLabels = false,
      hitInside = false,
      hitFrameInside = false
    } = opts;
    const [innerMargin, outerMargin] = Array.isArray(margin) ? margin : [margin, margin];
    let inHollowSmallestArea = Infinity;
    let inHollowSmallestAreaHit = null;
    let inMarginClosestToEdgeDistance = Infinity;
    let inMarginClosestToEdgeHit = null;
    const shapesToCheck = (opts.renderingOnly ? this.getCurrentPageRenderingShapesSorted() : this.getCurrentPageShapesSorted()).filter((shape) => {
      if (shape.isLocked && !hitLocked || this.isShapeHidden(shape) || this.isShapeOfType(shape, "group"))
        return false;
      const pageMask = this.getShapeMask(shape);
      if (pageMask && !pointInPolygon(point, pageMask)) return false;
      if (filter2 && !filter2(shape)) return false;
      return true;
    });
    for (let i = shapesToCheck.length - 1; i >= 0; i--) {
      const shape = shapesToCheck[i];
      const geometry = this.getShapeGeometry(shape);
      const isGroup = geometry instanceof Group2d;
      const pointInShapeSpace = this.getPointInShapeSpace(shape, point);
      if (this.isShapeOfType(shape, "frame") || (this.isShapeOfType(shape, "note") || this.isShapeOfType(shape, "arrow") || this.isShapeOfType(shape, "geo") && shape.props.fill === "none") && ((_a6 = this.getShapeUtil(shape).getText(shape)) == null ? void 0 : _a6.trim())) {
        for (const childGeometry of geometry.children) {
          if (childGeometry.isLabel && childGeometry.isPointInBounds(pointInShapeSpace)) {
            return shape;
          }
        }
      }
      if (this.isShapeOfType(shape, "frame")) {
        const distance2 = geometry.distanceToPoint(pointInShapeSpace, hitFrameInside);
        if (hitFrameInside ? distance2 > 0 && distance2 <= outerMargin || distance2 <= 0 && distance2 > -innerMargin : distance2 > 0 && distance2 <= outerMargin) {
          return inMarginClosestToEdgeHit || shape;
        }
        if (geometry.hitTestPoint(pointInShapeSpace, 0, true)) {
          return inMarginClosestToEdgeHit || inHollowSmallestAreaHit || (hitFrameInside ? shape : void 0);
        }
        continue;
      }
      let distance;
      if (isGroup) {
        let minDistance = Infinity;
        for (const childGeometry of geometry.children) {
          if (childGeometry.isLabel && !hitLabels) continue;
          const tDistance = childGeometry.distanceToPoint(pointInShapeSpace, hitInside);
          if (tDistance < minDistance) {
            minDistance = tDistance;
          }
        }
        distance = minDistance;
      } else {
        if (outerMargin === 0 && (geometry.bounds.w < 1 || geometry.bounds.h < 1)) {
          distance = geometry.distanceToPoint(pointInShapeSpace, hitInside);
        } else {
          if (geometry.bounds.containsPoint(pointInShapeSpace, outerMargin)) {
            distance = geometry.distanceToPoint(pointInShapeSpace, hitInside);
          } else {
            distance = Infinity;
          }
        }
      }
      if (geometry.isClosed) {
        if (distance <= outerMargin || hitInside && distance <= 0 && distance > -innerMargin) {
          if (geometry.isFilled || isGroup && geometry.children[0].isFilled) {
            return inMarginClosestToEdgeHit || shape;
          } else {
            if (this.getShapePageBounds(shape).contains(viewportPageBounds)) continue;
            if (hitInside ? (
              // On hitInside, the distance will be negative for hits inside
              // If the distance is positive, check against the outer margin
              // If the distance is negative, check against the inner margin
              distance > 0 && distance <= outerMargin || distance <= 0 && distance > -innerMargin
            ) : (
              // If hitInside is false, then sadly _we do not know_ whether the
              // point is inside or outside of the shape, so we check against
              // the max of the two margins
              Math.abs(distance) <= Math.max(innerMargin, outerMargin)
            )) {
              if (Math.abs(distance) < inMarginClosestToEdgeDistance) {
                inMarginClosestToEdgeDistance = Math.abs(distance);
                inMarginClosestToEdgeHit = shape;
              }
            } else if (!inMarginClosestToEdgeHit) {
              const { area } = geometry;
              if (area < inHollowSmallestArea) {
                inHollowSmallestArea = area;
                inHollowSmallestAreaHit = shape;
              }
            }
          }
        }
      } else {
        if (distance < this.options.hitTestMargin / zoomLevel) {
          return shape;
        }
      }
    }
    return inMarginClosestToEdgeHit || inHollowSmallestAreaHit || void 0;
  }
  /**
   * Get the shapes, if any, at a given page point.
   *
   * @example
   * ```ts
   * editor.getShapesAtPoint({ x: 100, y: 100 })
   * editor.getShapesAtPoint({ x: 100, y: 100 }, { hitInside: true, margin: 8 })
   * ```
   *
   * @param point - The page point to test.
   * @param opts - The options for the hit point testing.
   *
   * @returns An array of shapes at the given point, sorted in reverse order of their absolute z-index (top-most shape first).
   *
   * @public
   */
  getShapesAtPoint(point, opts = {}) {
    return this.getCurrentPageShapesSorted().filter((shape) => !this.isShapeHidden(shape) && this.isPointInShape(shape, point, opts)).reverse();
  }
  /**
   * Test whether a point (in the current page space) will will a shape. This method takes into account masks,
   * such as when a shape is the child of a frame and is partially clipped by the frame.
   *
   * @example
   * ```ts
   * editor.isPointInShape({ x: 100, y: 100 }, myShape)
   * ```
   *
   * @param shape - The shape to test against.
   * @param point - The page point to test (in the current page space).
   * @param opts - The options for the hit point testing.
   *
   * @public
   */
  isPointInShape(shape, point, opts = {}) {
    const { hitInside = false, margin = 0 } = opts;
    const id = typeof shape === "string" ? shape : shape.id;
    const pageMask = this.getShapeMask(id);
    if (pageMask && !pointInPolygon(point, pageMask)) return false;
    return this.getShapeGeometry(id).hitTestPoint(
      this.getPointInShapeSpace(shape, point),
      margin,
      hitInside
    );
  }
  /**
   * Convert a point in the current page space to a point in the local space of a shape. For example, if a
   * shape's page point were `{ x: 100, y: 100 }`, a page point at `{ x: 110, y: 110 }` would be at
   * `{ x: 10, y: 10 }` in the shape's local space.
   *
   * @example
   * ```ts
   * editor.getPointInShapeSpace(myShape, { x: 100, y: 100 })
   * ```
   *
   * @param shape - The shape to get the point in the local space of.
   * @param point - The page point to get in the local space of the shape.
   *
   * @public
   */
  getPointInShapeSpace(shape, point) {
    const id = typeof shape === "string" ? shape : shape.id;
    return this._getShapePageTransformCache().get(id).clone().invert().applyToPoint(point);
  }
  /**
   * Convert a delta in the current page space to a point in the local space of a shape's parent.
   *
   * @example
   * ```ts
   * editor.getPointInParentSpace(myShape.id, { x: 100, y: 100 })
   * ```
   *
   * @param shape - The shape to get the point in the local space of.
   * @param point - The page point to get in the local space of the shape.
   *
   * @public
   */
  getPointInParentSpace(shape, point) {
    const id = typeof shape === "string" ? shape : shape.id;
    const freshShape = this.getShape(id);
    if (!freshShape) return new Vec(0, 0);
    if (isPageId(freshShape.parentId)) return Vec.From(point);
    const parentTransform = this.getShapePageTransform(freshShape.parentId);
    if (!parentTransform) return Vec.From(point);
    return parentTransform.clone().invert().applyToPoint(point);
  }
  getCurrentPageShapes() {
    return Array.from(this.getCurrentPageShapeIds(), (id) => this.store.get(id));
  }
  getCurrentPageShapesSorted() {
    const result = [];
    const topLevelShapes = this.getSortedChildIdsForParent(this.getCurrentPageId());
    for (let i = 0, n = topLevelShapes.length; i < n; i++) {
      pushShapeWithDescendants(this, topLevelShapes[i], result);
    }
    return result;
  }
  getCurrentPageRenderingShapesSorted() {
    const culledShapes = this.getCulledShapes();
    return this.getCurrentPageShapesSorted().filter(
      ({ id }) => !culledShapes.has(id) && !this.isShapeHidden(id)
    );
  }
  isShapeOfType(arg, type) {
    const shape = typeof arg === "string" ? this.getShape(arg) : arg;
    if (!shape) return false;
    return shape.type === type;
  }
  /**
   * Get a shape by its id.
   *
   * @example
   * ```ts
   * editor.getShape('box1')
   * ```
   *
   * @param shape - The shape (or the id of the shape) to get.
   *
   * @public
   */
  getShape(shape) {
    const id = typeof shape === "string" ? shape : shape.id;
    if (!isShapeId(id)) return void 0;
    return this.store.get(id);
  }
  /**
   * Get the parent shape for a given shape. Returns undefined if the shape is the direct child of
   * the page.
   *
   * @example
   * ```ts
   * editor.getShapeParent(myShape)
   * ```
   *
   * @public
   */
  getShapeParent(shape) {
    const id = typeof shape === "string" ? shape : shape == null ? void 0 : shape.id;
    if (!id) return void 0;
    const freshShape = this.getShape(id);
    if (freshShape === void 0 || !isShapeId(freshShape.parentId)) return void 0;
    return this.getShape(freshShape.parentId);
  }
  /**
   * If siblingShape and targetShape are siblings, this returns targetShape. If targetShape has an
   * ancestor who is a sibling of siblingShape, this returns that ancestor. Otherwise, this returns
   * undefined.
   *
   * @internal
   */
  getShapeNearestSibling(siblingShape, targetShape) {
    if (!targetShape) {
      return void 0;
    }
    if (targetShape.parentId === siblingShape.parentId) {
      return targetShape;
    }
    const ancestor = this.findShapeAncestor(
      targetShape,
      (ancestor2) => ancestor2.parentId === siblingShape.parentId
    );
    return ancestor;
  }
  /**
   * Get whether the given shape is the descendant of the given page.
   *
   * @example
   * ```ts
   * editor.isShapeInPage(myShape)
   * editor.isShapeInPage(myShape, 'page1')
   * ```
   *
   * @param shape - The shape to check.
   * @param pageId - The id of the page to check against. Defaults to the current page.
   *
   * @public
   */
  isShapeInPage(shape, pageId = this.getCurrentPageId()) {
    const id = typeof shape === "string" ? shape : shape.id;
    const shapeToCheck = this.getShape(id);
    if (!shapeToCheck) return false;
    let shapeIsInPage = false;
    if (shapeToCheck.parentId === pageId) {
      shapeIsInPage = true;
    } else {
      let parent = this.getShape(shapeToCheck.parentId);
      isInPageSearch: while (parent) {
        if (parent.parentId === pageId) {
          shapeIsInPage = true;
          break isInPageSearch;
        }
        parent = this.getShape(parent.parentId);
      }
    }
    return shapeIsInPage;
  }
  /**
   * Get the id of the containing page for a given shape.
   *
   * @param shape - The shape to get the page id for.
   *
   * @returns The id of the page that contains the shape, or undefined if the shape is undefined.
   *
   * @public
   */
  getAncestorPageId(shape) {
    const id = typeof shape === "string" ? shape : shape == null ? void 0 : shape.id;
    const _shape = id && this.getShape(id);
    if (!_shape) return void 0;
    if (isPageId(_shape.parentId)) {
      return _shape.parentId;
    } else {
      return this.getAncestorPageId(this.getShape(_shape.parentId));
    }
  }
  /**
   * Reparent shapes to a new parent. This operation preserves the shape's current page positions /
   * rotations.
   *
   * @example
   * ```ts
   * editor.reparentShapes([box1, box2], 'frame1')
   * editor.reparentShapes([box1.id, box2.id], 'frame1')
   * editor.reparentShapes([box1.id, box2.id], 'frame1', 4)
   * ```
   *
   * @param shapes - The shapes (or shape ids) of the shapes to reparent.
   * @param parentId - The id of the new parent shape.
   * @param insertIndex - The index to insert the children.
   *
   * @public
   */
  reparentShapes(shapes, parentId, insertIndex) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    if (ids.length === 0) return this;
    const changes = [];
    const parentTransform = isPageId(parentId) ? Mat.Identity() : this.getShapePageTransform(parentId);
    const parentPageRotation = parentTransform.rotation();
    let indices = [];
    const sibs = compact(this.getSortedChildIdsForParent(parentId).map((id) => this.getShape(id)));
    if (insertIndex) {
      const sibWithInsertIndex = sibs.find((s) => s.index === insertIndex);
      if (sibWithInsertIndex) {
        const sibAbove = sibs[sibs.indexOf(sibWithInsertIndex) + 1];
        if (sibAbove) {
          indices = getIndicesBetween(insertIndex, sibAbove.index, ids.length);
        } else {
          indices = getIndicesAbove(insertIndex, ids.length);
        }
      } else {
        const sibAbove = sibs.sort(sortByIndex).find((s) => s.index > insertIndex);
        if (sibAbove) {
          indices = getIndicesBetween(insertIndex, sibAbove.index, ids.length);
        } else {
          indices = getIndicesAbove(insertIndex, ids.length);
        }
      }
    } else {
      const sib = sibs.length && sibs[sibs.length - 1];
      indices = sib ? getIndicesAbove(sib.index, ids.length) : getIndices(ids.length);
    }
    const invertedParentTransform = parentTransform.clone().invert();
    const shapesToReparent = compact(ids.map((id) => this.getShape(id))).sort(sortByIndex);
    this.run(
      () => {
        for (let i = 0; i < shapesToReparent.length; i++) {
          const shape = shapesToReparent[i];
          const pageTransform = this.getShapePageTransform(shape);
          if (!pageTransform) continue;
          const pagePoint = pageTransform.point();
          if (!pagePoint) continue;
          const newPoint = invertedParentTransform.applyToPoint(pagePoint);
          const newRotation = pageTransform.rotation() - parentPageRotation;
          if (shape.id === parentId) {
            throw Error("Attempted to reparent a shape to itself!");
          }
          changes.push({
            id: shape.id,
            type: shape.type,
            parentId,
            x: newPoint.x,
            y: newPoint.y,
            rotation: newRotation,
            index: indices[i]
          });
        }
        this.updateShapes(changes);
      },
      { ignoreShapeLock: true }
    );
    return this;
  }
  /**
   * Get the index above the highest child of a given parent.
   *
   * @param parent - The parent (or the id) of the parent.
   *
   * @returns The index.
   *
   * @public
   */
  getHighestIndexForParent(parent) {
    const parentId = typeof parent === "string" ? parent : parent.id;
    const children = this._parentIdsToChildIds.get()[parentId];
    if (!children || children.length === 0) {
      return getIndexAbove(ZERO_INDEX_KEY);
    }
    const shape = this.getShape(children[children.length - 1]);
    return getIndexAbove(shape.index);
  }
  /**
   * Get an array of all the children of a shape.
   *
   * @example
   * ```ts
   * editor.getSortedChildIdsForParent('frame1')
   * ```
   *
   * @param parent - The parent (or the id) of the parent shape.
   *
   * @public
   */
  getSortedChildIdsForParent(parent) {
    const parentId = typeof parent === "string" ? parent : parent.id;
    const ids = this._parentIdsToChildIds.get()[parentId];
    if (!ids) return EMPTY_ARRAY;
    return ids;
  }
  /**
   * Run a visitor function for all descendants of a shape.
   *
   * @example
   * ```ts
   * editor.visitDescendants('frame1', myCallback)
   * ```
   *
   * @param parent - The parent (or the id) of the parent shape.
   * @param visitor - The visitor function.
   *
   * @public
   */
  visitDescendants(parent, visitor) {
    const children = this.getSortedChildIdsForParent(parent);
    for (const id of children) {
      if (visitor(id) === false) continue;
      this.visitDescendants(id, visitor);
    }
    return this;
  }
  /**
   * Get the shape ids of all descendants of the given shapes (including the shapes themselves). IDs are returned in z-index order.
   *
   * @param ids - The ids of the shapes to get descendants of.
   *
   * @returns The descendant ids.
   *
   * @public
   */
  getShapeAndDescendantIds(ids) {
    const shapeIds = /* @__PURE__ */ new Set();
    for (const shape of ids.map((id) => this.getShape(id)).sort(sortByIndex)) {
      shapeIds.add(shape.id);
      this.visitDescendants(shape, (descendantId) => {
        shapeIds.add(descendantId);
      });
    }
    return shapeIds;
  }
  /**
   * Get the shape that some shapes should be dropped on at a given point.
   *
   * @param point - The point to find the parent for.
   * @param droppingShapes - The shapes that are being dropped.
   *
   * @returns The shape to drop on.
   *
   * @public
   */
  getDraggingOverShape(point, droppingShapes) {
    const draggingShapes = compact(droppingShapes.map((s) => this.getShape(s))).filter(
      (s) => !s.isLocked && !this.isShapeHidden(s)
    );
    const maybeDraggingOverShapes = this.getShapesAtPoint(point, {
      hitInside: true,
      margin: 0
    }).filter(
      (s) => !droppingShapes.includes(s) && !s.isLocked && !this.isShapeHidden(s) && !draggingShapes.includes(s)
    );
    for (const maybeDraggingOverShape of maybeDraggingOverShapes) {
      const shapeUtil = this.getShapeUtil(maybeDraggingOverShape);
      if (shapeUtil.onDragShapesOver || shapeUtil.onDragShapesIn || shapeUtil.onDragShapesOut || shapeUtil.onDropShapesOver) {
        return maybeDraggingOverShape;
      }
    }
  }
  /**
   * Get the shape that should be selected when you click on a given shape, assuming there is
   * nothing already selected. It will not return anything higher than or including the current
   * focus layer.
   *
   * @param shape - The shape to get the outermost selectable shape for.
   * @param filter - A function to filter the selectable shapes.
   *
   * @returns The outermost selectable shape.
   *
   * @public
   */
  getOutermostSelectableShape(shape, filter2) {
    const id = typeof shape === "string" ? shape : shape.id;
    const freshShape = this.getShape(id);
    let match = freshShape;
    let node = freshShape;
    const focusedGroup = this.getFocusedGroup();
    while (node) {
      if (this.isShapeOfType(node, "group") && (focusedGroup == null ? void 0 : focusedGroup.id) !== node.id && !this.hasAncestor(focusedGroup, node.id) && ((filter2 == null ? void 0 : filter2(node)) ?? true)) {
        match = node;
      } else if ((focusedGroup == null ? void 0 : focusedGroup.id) === node.id) {
        break;
      }
      node = this.getShapeParent(node);
    }
    return match;
  }
  _getBindingsIndexCache() {
    const index2 = bindingsIndex(this);
    return this.store.createComputedCache(
      "bindingsIndex",
      (shape) => {
        return index2.get().get(shape.id);
      },
      // we can ignore the shape equality check here because the index is
      // computed incrementally based on what bindings are in the store
      { areRecordsEqual: () => true }
    );
  }
  /**
   * Get a binding from the store by its ID if it exists.
   */
  getBinding(id) {
    return this.store.get(id);
  }
  getBindingsFromShape(shape, type) {
    const id = typeof shape === "string" ? shape : shape.id;
    return this.getBindingsInvolvingShape(id).filter(
      (b) => b.fromId === id && b.type === type
    );
  }
  getBindingsToShape(shape, type) {
    const id = typeof shape === "string" ? shape : shape.id;
    return this.getBindingsInvolvingShape(id).filter(
      (b) => b.toId === id && b.type === type
    );
  }
  getBindingsInvolvingShape(shape, type) {
    const id = typeof shape === "string" ? shape : shape.id;
    const result = this._getBindingsIndexCache().get(id) ?? EMPTY_ARRAY;
    if (!type) return result;
    return result.filter((b) => b.type === type);
  }
  /**
   * Create bindings from a list of partial bindings. You can omit the ID and most props of a
   * binding, but the `type`, `toId`, and `fromId` must all be provided.
   */
  createBindings(partials) {
    const bindings = [];
    for (const partial of partials) {
      const fromShape = this.getShape(partial.fromId);
      const toShape = this.getShape(partial.toId);
      if (!fromShape || !toShape) continue;
      if (!this.canBindShapes({ fromShape, toShape, binding: partial })) continue;
      const util = this.getBindingUtil(partial.type);
      const defaultProps = util.getDefaultProps();
      const binding = this.store.schema.types.binding.create({
        ...partial,
        id: partial.id ?? createBindingId(),
        props: {
          ...defaultProps,
          ...partial.props
        }
      });
      bindings.push(binding);
    }
    this.store.put(bindings);
    return this;
  }
  /**
   * Create a single binding from a partial. You can omit the ID and most props of a binding, but
   * the `type`, `toId`, and `fromId` must all be provided.
   */
  createBinding(partial) {
    return this.createBindings([partial]);
  }
  /**
   * Update bindings from a list of partial bindings. Each partial must include an ID, which will
   * be used to match the binding to it's existing record. If there is no existing record, that
   * binding is skipped. The changes from the partial are merged into the existing record.
   */
  updateBindings(partials) {
    const updated = [];
    for (const partial of partials) {
      if (!partial) continue;
      const current = this.getBinding(partial.id);
      if (!current) continue;
      const updatedBinding = applyPartialToRecordWithProps(current, partial);
      if (updatedBinding === current) continue;
      const fromShape = this.getShape(updatedBinding.fromId);
      const toShape = this.getShape(updatedBinding.toId);
      if (!fromShape || !toShape) continue;
      if (!this.canBindShapes({ fromShape, toShape, binding: updatedBinding })) continue;
      updated.push(updatedBinding);
    }
    this.store.put(updated);
    return this;
  }
  /**
   * Update a binding from a partial binding. Each partial must include an ID, which will be used
   * to match the binding to it's existing record. If there is no existing record, that binding is
   * skipped. The changes from the partial are merged into the existing record.
   */
  updateBinding(partial) {
    return this.updateBindings([partial]);
  }
  /**
   * Delete several bindings by their IDs. If a binding ID doesn't exist, it's ignored.
   */
  deleteBindings(bindings, { isolateShapes = false } = {}) {
    const ids = bindings.map((binding) => typeof binding === "string" ? binding : binding.id);
    if (isolateShapes) {
      this.store.atomic(() => {
        var _a6, _b3;
        for (const id of ids) {
          const binding = this.getBinding(id);
          if (!binding) continue;
          const util = this.getBindingUtil(binding);
          (_a6 = util.onBeforeIsolateFromShape) == null ? void 0 : _a6.call(util, { binding, removedShape: this.getShape(binding.toId) });
          (_b3 = util.onBeforeIsolateToShape) == null ? void 0 : _b3.call(util, { binding, removedShape: this.getShape(binding.fromId) });
          this.store.remove([id]);
        }
      });
    } else {
      this.store.remove(ids);
    }
    return this;
  }
  /**
   * Delete a binding by its ID. If the binding doesn't exist, it's ignored.
   */
  deleteBinding(binding, opts) {
    return this.deleteBindings([binding], opts);
  }
  canBindShapes({
    fromShape,
    toShape,
    binding
  }) {
    const fromShapeType = typeof fromShape === "string" ? fromShape : fromShape.type;
    const toShapeType = typeof toShape === "string" ? toShape : toShape.type;
    const bindingType = typeof binding === "string" ? binding : binding.type;
    const canBindOpts = { fromShapeType, toShapeType, bindingType };
    if (fromShapeType === toShapeType) {
      return this.getShapeUtil(fromShapeType).canBind(canBindOpts);
    }
    return this.getShapeUtil(fromShapeType).canBind(canBindOpts) && this.getShapeUtil(toShapeType).canBind(canBindOpts);
  }
  /* -------------------- Commands -------------------- */
  /**
   * Rotate shapes by a delta in radians.
   *
   * @example
   * ```ts
   * editor.rotateShapesBy(editor.getSelectedShapeIds(), Math.PI)
   * editor.rotateShapesBy(editor.getSelectedShapeIds(), Math.PI / 2)
   * ```
   *
   * @param shapes - The shapes (or shape ids) of the shapes to move.
   * @param delta - The delta in radians to apply to the selection rotation.
   * @param opts - The options for the rotation.
   */
  rotateShapesBy(shapes, delta, opts) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    if (ids.length <= 0) return this;
    const snapshot = getRotationSnapshot({ editor: this, ids });
    if (!snapshot) return this;
    applyRotationToSnapshotShapes({
      delta,
      snapshot,
      editor: this,
      stage: "one-off",
      centerOverride: opts == null ? void 0 : opts.center
    });
    return this;
  }
  // Gets a shape partial that includes life cycle changes: on translate start, on translate, on translate end
  getChangesToTranslateShape(initialShape, newShapeCoords) {
    var _a6, _b3, _c;
    let workingShape = initialShape;
    const util = this.getShapeUtil(initialShape);
    const afterTranslateStart = (_a6 = util.onTranslateStart) == null ? void 0 : _a6.call(util, workingShape);
    if (afterTranslateStart) {
      workingShape = applyPartialToRecordWithProps(workingShape, afterTranslateStart);
    }
    workingShape = applyPartialToRecordWithProps(workingShape, {
      id: initialShape.id,
      type: initialShape.type,
      x: newShapeCoords.x,
      y: newShapeCoords.y
    });
    const afterTranslate = (_b3 = util.onTranslate) == null ? void 0 : _b3.call(util, initialShape, workingShape);
    if (afterTranslate) {
      workingShape = applyPartialToRecordWithProps(workingShape, afterTranslate);
    }
    const afterTranslateEnd = (_c = util.onTranslateEnd) == null ? void 0 : _c.call(util, initialShape, workingShape);
    if (afterTranslateEnd) {
      workingShape = applyPartialToRecordWithProps(workingShape, afterTranslateEnd);
    }
    return workingShape;
  }
  /**
   * Move shapes by a delta.
   *
   * @example
   * ```ts
   * editor.nudgeShapes(['box1', 'box2'], { x: 8, y: 8 })
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   * @param offset - The offset to apply to the shapes.
   */
  nudgeShapes(shapes, offset4) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    if (ids.length <= 0) return this;
    const changes = [];
    for (const id of ids) {
      const shape = this.getShape(id);
      const localDelta = Vec.From(offset4);
      const parentTransform = this.getShapeParentTransform(shape);
      if (parentTransform) localDelta.rot(-parentTransform.rotation());
      changes.push(this.getChangesToTranslateShape(shape, localDelta.add(shape)));
    }
    this.updateShapes(changes);
    return this;
  }
  /**
   * Duplicate shapes.
   *
   * @example
   * ```ts
   * editor.duplicateShapes(['box1', 'box2'], { x: 8, y: 8 })
   * editor.duplicateShapes(editor.getSelectedShapes(), { x: 8, y: 8 })
   * ```
   *
   * @param shapes - The shapes (or shape ids) to duplicate.
   * @param offset - The offset (in pixels) to apply to the duplicated shapes.
   *
   * @public
   */
  duplicateShapes(shapes, offset4) {
    this.run(() => {
      const _ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
      const ids = this._shouldIgnoreShapeLock ? _ids : this._getUnlockedShapeIds(_ids);
      if (ids.length <= 0) return this;
      const initialIds = new Set(ids);
      const shapeIdSet = this.getShapeAndDescendantIds(ids);
      const orderedShapeIds = [...shapeIdSet].reverse();
      const shapeIds = /* @__PURE__ */ new Map();
      for (const shapeId of shapeIdSet) {
        shapeIds.set(shapeId, createShapeId());
      }
      const { shapesToCreateWithOriginals, bindingsToCreate } = withIsolatedShapes(
        this,
        shapeIdSet,
        (bindingIdsToMaintain) => {
          const bindingsToCreate2 = [];
          for (const originalId of bindingIdsToMaintain) {
            const originalBinding = this.getBinding(originalId);
            if (!originalBinding) continue;
            const duplicatedId = createBindingId();
            bindingsToCreate2.push({
              ...originalBinding,
              id: duplicatedId,
              fromId: assertExists(shapeIds.get(originalBinding.fromId)),
              toId: assertExists(shapeIds.get(originalBinding.toId))
            });
          }
          const shapesToCreateWithOriginals2 = [];
          for (const originalId of orderedShapeIds) {
            const duplicatedId = assertExists(shapeIds.get(originalId));
            const originalShape = this.getShape(originalId);
            if (!originalShape) continue;
            let ox = 0;
            let oy = 0;
            if (offset4 && initialIds.has(originalId)) {
              const parentTransform = this.getShapeParentTransform(originalShape);
              const vec = new Vec(offset4.x, offset4.y).rot(-parentTransform.rotation());
              ox = vec.x;
              oy = vec.y;
            }
            shapesToCreateWithOriginals2.push({
              shape: {
                ...originalShape,
                id: duplicatedId,
                x: originalShape.x + ox,
                y: originalShape.y + oy,
                // Use a dummy index for now, it will get updated outside of the `withIsolatedShapes`
                index: "a1",
                parentId: shapeIds.get(originalShape.parentId) ?? originalShape.parentId
              },
              originalShape
            });
          }
          return { shapesToCreateWithOriginals: shapesToCreateWithOriginals2, bindingsToCreate: bindingsToCreate2 };
        }
      );
      shapesToCreateWithOriginals.forEach(({ shape, originalShape }) => {
        const parentId = originalShape.parentId;
        const siblings = this.getSortedChildIdsForParent(parentId);
        const currentIndex = siblings.indexOf(originalShape.id);
        const siblingAboveId = siblings[currentIndex + 1];
        const siblingAbove = siblingAboveId ? this.getShape(siblingAboveId) : void 0;
        const index2 = getIndexBetween(originalShape.index, siblingAbove == null ? void 0 : siblingAbove.index);
        shape.index = index2;
      });
      const shapesToCreate = shapesToCreateWithOriginals.map(({ shape }) => shape);
      if (!this.canCreateShapes(shapesToCreate)) {
        alertMaxShapes(this);
        return;
      }
      this.createShapes(shapesToCreate);
      this.createBindings(bindingsToCreate);
      this.setSelectedShapes(
        compact(
          ids.map((oldId) => {
            const newId = shapeIds.get(oldId);
            if (!newId) return null;
            if (!this.getShape(newId)) return null;
            return newId;
          })
        )
      );
      if (offset4 !== void 0) {
        const selectionPageBounds = this.getSelectionPageBounds();
        const viewportPageBounds = this.getViewportPageBounds();
        if (selectionPageBounds && !viewportPageBounds.contains(selectionPageBounds)) {
          this.centerOnPoint(selectionPageBounds.center, {
            animation: { duration: this.options.animationMediumMs }
          });
        }
      }
    });
    return this;
  }
  /**
   * Move shapes to page.
   *
   * @example
   * ```ts
   * editor.moveShapesToPage(['box1', 'box2'], 'page1')
   * ```
   *
   * @param shapes - The shapes (or shape ids) of the shapes to move.
   * @param pageId - The id of the page where the shapes will be moved.
   *
   * @public
   */
  moveShapesToPage(shapes, pageId) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    if (ids.length === 0) return this;
    if (this.getIsReadonly()) return this;
    const currentPageId = this.getCurrentPageId();
    if (pageId === currentPageId) return this;
    if (!this.store.has(pageId)) return this;
    const content = this.getContentFromCurrentPage(ids);
    if (!content) return this;
    if (this.getPageShapeIds(pageId).size + content.shapes.length > this.options.maxShapesPerPage) {
      alertMaxShapes(this, pageId);
      return this;
    }
    const fromPageZ = this.getCamera().z;
    this.run(() => {
      this.deleteShapes(ids);
      this.setCurrentPage(pageId);
      this.setFocusedGroup(null);
      this.selectNone();
      this.putContentOntoCurrentPage(content, {
        select: true,
        preserveIds: true,
        preservePosition: true
      });
      this.setCamera({ ...this.getCamera(), z: fromPageZ });
      this.centerOnPoint(this.getSelectionRotatedPageBounds().center);
    });
    return this;
  }
  /**
   * Toggle the lock state of one or more shapes. If there is a mix of locked and unlocked shapes, all shapes will be locked.
   *
   * @param shapes - The shapes (or shape ids) to toggle.
   *
   * @public
   */
  toggleLock(shapes) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    if (this.getIsReadonly() || ids.length === 0) return this;
    let allLocked = true, allUnlocked = true;
    const shapesToToggle = [];
    for (const id of ids) {
      const shape = this.getShape(id);
      if (shape) {
        shapesToToggle.push(shape);
        if (shape.isLocked) {
          allUnlocked = false;
        } else {
          allLocked = false;
        }
      }
    }
    this.run(() => {
      if (allUnlocked) {
        this.updateShapes(
          shapesToToggle.map((shape) => ({ id: shape.id, type: shape.type, isLocked: true }))
        );
        this.setSelectedShapes([]);
      } else if (allLocked) {
        this.updateShapes(
          shapesToToggle.map((shape) => ({ id: shape.id, type: shape.type, isLocked: false }))
        );
      } else {
        this.updateShapes(
          shapesToToggle.map((shape) => ({ id: shape.id, type: shape.type, isLocked: true }))
        );
      }
    });
    return this;
  }
  /**
   * Send shapes to the back of the page's object list.
   *
   * @example
   * ```ts
   * editor.sendToBack(['id1', 'id2'])
   * editor.sendToBack(box1, box2)
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   *
   * @public
   */
  sendToBack(shapes) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    const changes = getReorderingShapesChanges(this, "toBack", ids, {
      considerAllShapes: true
    });
    if (changes) this.updateShapes(changes);
    return this;
  }
  /**
   * Send shapes backward in the page's object list.
   *
   * @example
   * ```ts
   * editor.sendBackward(['id1', 'id2'])
   * editor.sendBackward([box1, box2])
   * ```
   *
   * By default, the operation will only consider overlapping shapes.
   * To consider all shapes, pass `{ considerAllShapes: true }` in the options.
   *
   * @example
   * ```ts
   * editor.sendBackward(['id1', 'id2'], { considerAllShapes: true })
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   * @param opts - The options for the backward operation.
   *
   * @public
   */
  sendBackward(shapes, opts = {}) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    const changes = getReorderingShapesChanges(this, "backward", ids, opts);
    if (changes) this.updateShapes(changes);
    return this;
  }
  /**
   * Bring shapes forward in the page's object list.
   *
   * @example
   * ```ts
   * editor.bringForward(['id1', 'id2'])
   * editor.bringForward(box1,  box2)
   * ```
   *
   * By default, the operation will only consider overlapping shapes.
   * To consider all shapes, pass `{ considerAllShapes: true }` in the options.
   *
   * @example
   * ```ts
   * editor.bringForward(['id1', 'id2'], { considerAllShapes: true })
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   * @param opts - The options for the forward operation.
   *
   * @public
   */
  bringForward(shapes, opts = {}) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    const changes = getReorderingShapesChanges(this, "forward", ids, opts);
    if (changes) this.updateShapes(changes);
    return this;
  }
  /**
   * Bring shapes to the front of the page's object list.
   *
   * @example
   * ```ts
   * editor.bringToFront(['id1', 'id2'])
   * editor.bringToFront([box1, box2])
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   *
   * @public
   */
  bringToFront(shapes) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    const changes = getReorderingShapesChanges(this, "toFront", ids);
    if (changes) this.updateShapes(changes);
    return this;
  }
  /**
   * @internal
   */
  collectShapesViaArrowBindings(info) {
    const { initialShapes, resultShapes, resultBounds, bindings, visited } = info;
    for (const binding of bindings) {
      for (const id of [binding.fromId, binding.toId]) {
        if (!visited.has(id)) {
          const aligningShape = initialShapes.find((s) => s.id === id);
          if (aligningShape && !visited.has(aligningShape.id)) {
            visited.add(aligningShape.id);
            const shapePageBounds = this.getShapePageBounds(aligningShape);
            if (!shapePageBounds) continue;
            resultShapes.push(aligningShape);
            resultBounds.push(shapePageBounds);
            this.collectShapesViaArrowBindings({
              ...info,
              bindings: this.getBindingsInvolvingShape(aligningShape, "arrow")
            });
          }
        }
      }
    }
  }
  /**
   * Flip shape positions.
   *
   * @example
   * ```ts
   * editor.flipShapes([box1, box2], 'horizontal', 32)
   * editor.flipShapes(editor.getSelectedShapeIds(), 'horizontal', 32)
   * ```
   *
   * @param shapes - The ids of the shapes to flip.
   * @param operation - Whether to flip horizontally or vertically.
   *
   * @public
   */
  flipShapes(shapes, operation) {
    if (this.getIsReadonly()) return this;
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    const shapesToFlipFirstPass = compact(ids.map((id) => this.getShape(id)));
    for (const shape of shapesToFlipFirstPass) {
      if (this.isShapeOfType(shape, "group")) {
        const childrenOfGroups = compact(
          this.getSortedChildIdsForParent(shape.id).map((id) => this.getShape(id))
        );
        shapesToFlipFirstPass.push(...childrenOfGroups);
      }
    }
    const shapesToFlip = [];
    const allBounds = [];
    for (const shape of shapesToFlipFirstPass) {
      const util = this.getShapeUtil(shape);
      if (!util.canBeLaidOut(shape, {
        type: "flip",
        shapes: shapesToFlipFirstPass
      })) {
        continue;
      }
      const pageBounds = this.getShapePageBounds(shape);
      const localBounds = this.getShapeGeometry(shape).bounds;
      const pageTransform = this.getShapePageTransform(shape.id);
      if (!(pageBounds && localBounds && pageTransform)) continue;
      shapesToFlip.push({
        shape,
        localBounds,
        pageTransform,
        isAspectRatioLocked: util.isAspectRatioLocked(shape)
      });
      allBounds.push(pageBounds);
    }
    if (!shapesToFlip.length) return this;
    const scaleOriginPage = Box.Common(allBounds).center;
    this.run(() => {
      for (const { shape, localBounds, pageTransform, isAspectRatioLocked } of shapesToFlip) {
        this.resizeShape(
          shape.id,
          { x: operation === "horizontal" ? -1 : 1, y: operation === "vertical" ? -1 : 1 },
          {
            initialBounds: localBounds,
            initialPageTransform: pageTransform,
            initialShape: shape,
            isAspectRatioLocked,
            mode: "scale_shape",
            scaleOrigin: scaleOriginPage,
            scaleAxisRotation: 0
          }
        );
      }
    });
    return this;
  }
  /**
   * Stack shape.
   *
   * @example
   * ```ts
   * editor.stackShapes([box1, box2], 'horizontal')
   * editor.stackShapes(editor.getSelectedShapeIds(), 'horizontal')
   * ```
   *
   * @param shapes - The shapes (or shape ids) to stack.
   * @param operation - Whether to stack horizontally or vertically.
   * @param gap - The gap to leave between shapes. By default, uses the editor's `adjacentShapeMargin` option.
   *
   * @public
   */
  stackShapes(shapes, operation, gap) {
    var _a6, _b3;
    const _gap = gap ?? this.options.adjacentShapeMargin;
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    if (this.getIsReadonly()) return this;
    const shapesToStackFirstPass = compact(ids.map((id) => this.getShape(id)));
    const shapeClustersToStack = [];
    const allBounds = [];
    const visited = /* @__PURE__ */ new Set();
    for (const shape of shapesToStackFirstPass) {
      if (visited.has(shape.id)) continue;
      visited.add(shape.id);
      const shapePageBounds = this.getShapePageBounds(shape);
      if (!shapePageBounds) continue;
      if (!((_b3 = (_a6 = this.getShapeUtil(shape)).canBeLaidOut) == null ? void 0 : _b3.call(_a6, shape, {
        type: "stack",
        shapes: shapesToStackFirstPass
      }))) {
        continue;
      }
      const shapesMovingTogether = [shape];
      const boundsOfShapesMovingTogether = [shapePageBounds];
      this.collectShapesViaArrowBindings({
        bindings: this.getBindingsToShape(shape.id, "arrow"),
        initialShapes: shapesToStackFirstPass,
        resultShapes: shapesMovingTogether,
        resultBounds: boundsOfShapesMovingTogether,
        visited
      });
      const commonPageBounds = Box.Common(boundsOfShapesMovingTogether);
      if (!commonPageBounds) continue;
      shapeClustersToStack.push({
        shapes: shapesMovingTogether,
        pageBounds: commonPageBounds
      });
      allBounds.push(commonPageBounds);
    }
    const len = shapeClustersToStack.length;
    if (_gap === 0 && len < 3 || len < 2) return this;
    let val;
    let min3;
    let max2;
    let dim;
    if (operation === "horizontal") {
      val = "x";
      min3 = "minX";
      max2 = "maxX";
      dim = "width";
    } else {
      val = "y";
      min3 = "minY";
      max2 = "maxY";
      dim = "height";
    }
    let shapeGap = 0;
    if (_gap === 0) {
      const gaps = {};
      shapeClustersToStack.sort((a, b) => a.pageBounds[min3] - b.pageBounds[min3]);
      for (let i = 0; i < len - 1; i++) {
        const currCluster = shapeClustersToStack[i];
        const nextCluster = shapeClustersToStack[i + 1];
        const gap2 = nextCluster.pageBounds[min3] - currCluster.pageBounds[max2];
        if (!gaps[gap2]) {
          gaps[gap2] = 0;
        }
        gaps[gap2]++;
      }
      let maxCount = 1;
      for (const [gap2, count3] of Object.entries(gaps)) {
        if (count3 > maxCount) {
          maxCount = count3;
          shapeGap = parseFloat(gap2);
        }
      }
      if (maxCount === 1) {
        let totalCount = 0;
        for (const [gap2, count3] of Object.entries(gaps)) {
          shapeGap += parseFloat(gap2) * count3;
          totalCount += count3;
        }
        shapeGap /= totalCount;
      }
    } else {
      shapeGap = _gap;
    }
    const changes = [];
    let v = shapeClustersToStack[0].pageBounds[max2];
    for (let i = 1; i < shapeClustersToStack.length; i++) {
      const { shapes: shapes2, pageBounds } = shapeClustersToStack[i];
      const delta = new Vec();
      delta[val] = v + shapeGap - pageBounds[val];
      for (const shape of shapes2) {
        const shapeDelta = delta.clone();
        const parent = this.getShapeParent(shape);
        if (parent) {
          const parentTransform = this.getShapePageTransform(parent);
          if (parentTransform) shapeDelta.rot(-parentTransform.rotation());
        }
        shapeDelta.add(shape);
        changes.push(this.getChangesToTranslateShape(shape, shapeDelta));
      }
      v += pageBounds[dim] + shapeGap;
    }
    this.updateShapes(changes);
    return this;
  }
  /**
   * Pack shapes into a grid centered on their current position. Based on potpack (https://github.com/mapbox/potpack).
   *
   * @example
   * ```ts
   * editor.packShapes([box1, box2])
   * editor.packShapes(editor.getSelectedShapeIds(), 32)
   * ```
   *
   *
   * @param shapes - The shapes (or shape ids) to pack.
   * @param gap - The padding to apply to the packed shapes. Defaults to the editor's `adjacentShapeMargin` option.
   */
  packShapes(shapes, _gap) {
    var _a6, _b3;
    if (this.getIsReadonly()) return this;
    const gap = _gap ?? this.options.adjacentShapeMargin;
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    const shapesToPackFirstPass = compact(ids.map((id) => this.getShape(id)));
    const shapeClustersToPack = [];
    const allBounds = [];
    const visited = /* @__PURE__ */ new Set();
    for (const shape of shapesToPackFirstPass) {
      if (visited.has(shape.id)) continue;
      visited.add(shape.id);
      const shapePageBounds = this.getShapePageBounds(shape);
      if (!shapePageBounds) continue;
      if (!((_b3 = (_a6 = this.getShapeUtil(shape)).canBeLaidOut) == null ? void 0 : _b3.call(_a6, shape, {
        type: "pack",
        shapes: shapesToPackFirstPass
      }))) {
        continue;
      }
      const shapesMovingTogether = [shape];
      const boundsOfShapesMovingTogether = [shapePageBounds];
      this.collectShapesViaArrowBindings({
        bindings: this.getBindingsToShape(shape.id, "arrow"),
        initialShapes: shapesToPackFirstPass,
        resultShapes: shapesMovingTogether,
        resultBounds: boundsOfShapesMovingTogether,
        visited
      });
      const commonPageBounds = Box.Common(boundsOfShapesMovingTogether);
      if (!commonPageBounds) continue;
      shapeClustersToPack.push({
        shapes: shapesMovingTogether,
        pageBounds: commonPageBounds,
        nextPageBounds: commonPageBounds.clone()
      });
      allBounds.push(commonPageBounds);
    }
    if (shapeClustersToPack.length < 2) return this;
    let area = 0;
    for (const { pageBounds } of shapeClustersToPack) {
      area += pageBounds.width * pageBounds.height;
    }
    const commonBounds = Box.Common(allBounds);
    const maxWidth = commonBounds.width;
    shapeClustersToPack.sort((a, b) => a.pageBounds.width - b.pageBounds.width).sort((a, b) => a.pageBounds.height - b.pageBounds.height);
    const startWidth = Math.max(Math.ceil(Math.sqrt(area / 0.95)), maxWidth);
    const spaces = [new Box(commonBounds.x, commonBounds.y, startWidth, Infinity)];
    let width = 0;
    let height = 0;
    let space;
    let last2;
    for (const { nextPageBounds } of shapeClustersToPack) {
      for (let i = spaces.length - 1; i >= 0; i--) {
        space = spaces[i];
        if (nextPageBounds.width > space.width || nextPageBounds.height > space.height) continue;
        nextPageBounds.x = space.x;
        nextPageBounds.y = space.y;
        height = Math.max(height, nextPageBounds.maxY);
        width = Math.max(width, nextPageBounds.maxX);
        if (nextPageBounds.width === space.width && nextPageBounds.height === space.height) {
          last2 = spaces.pop();
          if (i < spaces.length) spaces[i] = last2;
        } else if (nextPageBounds.height === space.height) {
          space.x += nextPageBounds.width + gap;
          space.width -= nextPageBounds.width + gap;
        } else if (nextPageBounds.width === space.width) {
          space.y += nextPageBounds.height + gap;
          space.height -= nextPageBounds.height + gap;
        } else {
          spaces.push(
            new Box(
              space.x + (nextPageBounds.width + gap),
              space.y,
              space.width - (nextPageBounds.width + gap),
              nextPageBounds.height
            )
          );
          space.y += nextPageBounds.height + gap;
          space.height -= nextPageBounds.height + gap;
        }
        break;
      }
    }
    const commonAfter = Box.Common(shapeClustersToPack.map((s) => s.nextPageBounds));
    const centerDelta = Vec.Sub(commonBounds.center, commonAfter.center);
    const changes = [];
    for (const { shapes: shapes2, pageBounds, nextPageBounds } of shapeClustersToPack) {
      const delta = Vec.Sub(nextPageBounds.point, pageBounds.point).add(centerDelta);
      for (const shape of shapes2) {
        const shapeDelta = delta.clone();
        const parent = this.getShapeParent(shape);
        if (parent) {
          const parentTransform = this.getShapeParentTransform(shape);
          if (parentTransform) shapeDelta.rot(-parentTransform.rotation());
        }
        shapeDelta.add(shape);
        changes.push(this.getChangesToTranslateShape(shape, shapeDelta));
      }
    }
    if (changes.length) {
      this.updateShapes(changes);
    }
    return this;
  }
  /**
   * Align shape positions.
   *
   * @example
   * ```ts
   * editor.alignShapes([box1, box2], 'left')
   * editor.alignShapes(editor.getSelectedShapeIds(), 'left')
   * ```
   *
   * @param shapes - The shapes (or shape ids) to align.
   * @param operation - The align operation to apply.
   *
   * @public
   */
  alignShapes(shapes, operation) {
    var _a6, _b3;
    if (this.getIsReadonly()) return this;
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    const shapesToAlignFirstPass = compact(ids.map((id) => this.getShape(id)));
    const shapeClustersToAlign = [];
    const allBounds = [];
    const visited = /* @__PURE__ */ new Set();
    for (const shape of shapesToAlignFirstPass) {
      if (visited.has(shape.id)) continue;
      visited.add(shape.id);
      const shapePageBounds = this.getShapePageBounds(shape);
      if (!shapePageBounds) continue;
      if (!((_b3 = (_a6 = this.getShapeUtil(shape)).canBeLaidOut) == null ? void 0 : _b3.call(_a6, shape, {
        type: "align",
        shapes: shapesToAlignFirstPass
      }))) {
        continue;
      }
      const shapesMovingTogether = [shape];
      const boundsOfShapesMovingTogether = [shapePageBounds];
      this.collectShapesViaArrowBindings({
        bindings: this.getBindingsToShape(shape.id, "arrow"),
        initialShapes: shapesToAlignFirstPass,
        resultShapes: shapesMovingTogether,
        resultBounds: boundsOfShapesMovingTogether,
        visited
      });
      const commonPageBounds = Box.Common(boundsOfShapesMovingTogether);
      if (!commonPageBounds) continue;
      shapeClustersToAlign.push({
        shapes: shapesMovingTogether,
        pageBounds: commonPageBounds
      });
      allBounds.push(commonPageBounds);
    }
    if (shapeClustersToAlign.length < 2) return this;
    const commonBounds = Box.Common(allBounds);
    const changes = [];
    shapeClustersToAlign.forEach(({ shapes: shapes2, pageBounds }) => {
      const delta = new Vec();
      switch (operation) {
        case "top": {
          delta.y = commonBounds.minY - pageBounds.minY;
          break;
        }
        case "center-vertical": {
          delta.y = commonBounds.midY - pageBounds.minY - pageBounds.height / 2;
          break;
        }
        case "bottom": {
          delta.y = commonBounds.maxY - pageBounds.minY - pageBounds.height;
          break;
        }
        case "left": {
          delta.x = commonBounds.minX - pageBounds.minX;
          break;
        }
        case "center-horizontal": {
          delta.x = commonBounds.midX - pageBounds.minX - pageBounds.width / 2;
          break;
        }
        case "right": {
          delta.x = commonBounds.maxX - pageBounds.minX - pageBounds.width;
          break;
        }
      }
      for (const shape of shapes2) {
        const shapeDelta = delta.clone();
        const parent = this.getShapeParent(shape);
        if (parent) {
          const parentTransform = this.getShapePageTransform(parent);
          if (parentTransform) shapeDelta.rot(-parentTransform.rotation());
        }
        shapeDelta.add(shape);
        changes.push(this.getChangesToTranslateShape(shape, shapeDelta));
      }
    });
    this.updateShapes(changes);
    return this;
  }
  /**
   * Distribute shape positions.
   *
   * @example
   * ```ts
   * editor.distributeShapes([box1, box2], 'horizontal')
   * editor.distributeShapes(editor.getSelectedShapeIds(), 'horizontal')
   * ```
   *
   * @param shapes - The shapes (or shape ids) to distribute.
   * @param operation - Whether to distribute shapes horizontally or vertically.
   *
   * @public
   */
  distributeShapes(shapes, operation) {
    var _a6, _b3;
    if (this.getIsReadonly()) return this;
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    const shapesToDistributeFirstPass = compact(ids.map((id) => this.getShape(id)));
    const shapeClustersToDistribute = [];
    const allBounds = [];
    const visited = /* @__PURE__ */ new Set();
    for (const shape of shapesToDistributeFirstPass) {
      if (visited.has(shape.id)) continue;
      visited.add(shape.id);
      const shapePageBounds = this.getShapePageBounds(shape);
      if (!shapePageBounds) continue;
      if (!((_b3 = (_a6 = this.getShapeUtil(shape)).canBeLaidOut) == null ? void 0 : _b3.call(_a6, shape, {
        type: "distribute",
        shapes: shapesToDistributeFirstPass
      }))) {
        continue;
      }
      const shapesMovingTogether = [shape];
      const boundsOfShapesMovingTogether = [shapePageBounds];
      this.collectShapesViaArrowBindings({
        bindings: this.getBindingsToShape(shape.id, "arrow"),
        initialShapes: shapesToDistributeFirstPass,
        resultShapes: shapesMovingTogether,
        resultBounds: boundsOfShapesMovingTogether,
        visited
      });
      const commonPageBounds = Box.Common(boundsOfShapesMovingTogether);
      if (!commonPageBounds) continue;
      shapeClustersToDistribute.push({
        shapes: shapesMovingTogether,
        pageBounds: commonPageBounds
      });
      allBounds.push(commonPageBounds);
    }
    if (shapeClustersToDistribute.length < 3) return this;
    let val;
    let min3;
    let max2;
    let dim;
    if (operation === "horizontal") {
      val = "x";
      min3 = "minX";
      max2 = "maxX";
      dim = "width";
    } else {
      val = "y";
      min3 = "minY";
      max2 = "maxY";
      dim = "height";
    }
    const changes = [];
    const first2 = shapeClustersToDistribute.sort((a, b) => a.pageBounds[min3] - b.pageBounds[min3])[0];
    const last2 = shapeClustersToDistribute.sort((a, b) => b.pageBounds[max2] - a.pageBounds[max2])[0];
    if (first2 === last2) {
      const excludedShapeIds = new Set(first2.shapes.map((s) => s.id));
      return this.distributeShapes(
        ids.filter((id) => !excludedShapeIds.has(id)),
        operation
      );
    }
    const shapeClustersToMove = shapeClustersToDistribute.filter((shape) => shape !== first2 && shape !== last2).sort((a, b) => {
      if (a.pageBounds[min3] === b.pageBounds[min3]) {
        return a.shapes[0].id < b.shapes[0].id ? -1 : 1;
      }
      return a.pageBounds[min3] - b.pageBounds[min3];
    });
    const maxFirst = first2.pageBounds[max2];
    const range = last2.pageBounds[min3] - maxFirst;
    const summedShapeDimensions = shapeClustersToMove.reduce((acc, s) => acc + s.pageBounds[dim], 0);
    const gap = (range - summedShapeDimensions) / (shapeClustersToMove.length + 1);
    for (let v = maxFirst + gap, i = 0; i < shapeClustersToMove.length; i++) {
      const { shapes: shapes2, pageBounds } = shapeClustersToMove[i];
      const delta = new Vec();
      delta[val] = v - pageBounds[val];
      if (v + pageBounds[dim] > last2.pageBounds[max2] - 1) {
        delta[val] = last2.pageBounds[max2] - pageBounds[max2] - 1;
      }
      for (const shape of shapes2) {
        const shapeDelta = delta.clone();
        const parent = this.getShapeParent(shape);
        if (parent) {
          const parentTransform = this.getShapePageTransform(parent);
          if (parentTransform) shapeDelta.rot(-parentTransform.rotation());
        }
        shapeDelta.add(shape);
        changes.push(this.getChangesToTranslateShape(shape, shapeDelta));
      }
      v += pageBounds[dim] + gap;
    }
    this.updateShapes(changes);
    return this;
  }
  /**
   * Stretch shape sizes and positions to fill their common bounding box.
   *
   * @example
   * ```ts
   * editor.stretchShapes([box1, box2], 'horizontal')
   * editor.stretchShapes(editor.getSelectedShapeIds(), 'horizontal')
   * ```
   *
   * @param shapes - The shapes (or shape ids) to stretch.
   * @param operation - Whether to stretch shapes horizontally or vertically.
   *
   * @public
   */
  stretchShapes(shapes, operation) {
    var _a6, _b3;
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    if (this.getIsReadonly()) return this;
    const shapesToStretchFirstPass = compact(ids.map((id) => this.getShape(id))).filter(
      (s) => {
        var _a7;
        return ((_a7 = this.getShapePageTransform(s)) == null ? void 0 : _a7.rotation()) % (PI / 2) === 0;
      }
    );
    const shapeClustersToStretch = [];
    const allBounds = [];
    const visited = /* @__PURE__ */ new Set();
    for (const shape of shapesToStretchFirstPass) {
      if (visited.has(shape.id)) continue;
      visited.add(shape.id);
      const shapePageBounds = this.getShapePageBounds(shape);
      if (!shapePageBounds) continue;
      const shapesMovingTogether = [shape];
      const boundsOfShapesMovingTogether = [shapePageBounds];
      if (!((_b3 = (_a6 = this.getShapeUtil(shape)).canBeLaidOut) == null ? void 0 : _b3.call(_a6, shape, {
        type: "stretch"
      }))) {
        continue;
      }
      this.collectShapesViaArrowBindings({
        bindings: this.getBindingsToShape(shape.id, "arrow"),
        initialShapes: shapesToStretchFirstPass,
        resultShapes: shapesMovingTogether,
        resultBounds: boundsOfShapesMovingTogether,
        visited
      });
      const commonPageBounds = Box.Common(boundsOfShapesMovingTogether);
      if (!commonPageBounds) continue;
      shapeClustersToStretch.push({
        shapes: shapesMovingTogether,
        pageBounds: commonPageBounds
      });
      allBounds.push(commonPageBounds);
    }
    if (shapeClustersToStretch.length < 2) return this;
    const commonBounds = Box.Common(allBounds);
    let val;
    let min3;
    let dim;
    if (operation === "horizontal") {
      val = "x";
      min3 = "minX";
      dim = "width";
    } else {
      val = "y";
      min3 = "minY";
      dim = "height";
    }
    this.run(() => {
      shapeClustersToStretch.forEach(({ shapes: shapes2, pageBounds }) => {
        const localOffset = new Vec();
        localOffset[val] = commonBounds[min3] - pageBounds[min3];
        const scaleOrigin = pageBounds.center.clone();
        scaleOrigin[val] = commonBounds[min3];
        const scale = new Vec(1, 1);
        scale[val] = commonBounds[dim] / pageBounds[dim];
        for (const shape of shapes2) {
          const shapeLocalOffset = localOffset.clone();
          const parentTransform = this.getShapeParentTransform(shape);
          if (parentTransform) localOffset.rot(-parentTransform.rotation());
          shapeLocalOffset.add(shape);
          const changes = this.getChangesToTranslateShape(shape, shapeLocalOffset);
          this.updateShape(changes);
          this.resizeShape(shape.id, scale, {
            initialBounds: this.getShapeGeometry(shape).bounds,
            scaleOrigin,
            isAspectRatioLocked: this.getShapeUtil(shape).isAspectRatioLocked(shape),
            scaleAxisRotation: 0
          });
        }
      });
    });
    return this;
  }
  /**
   * Resize a shape.
   *
   * @param shape - The shape (or the shape id of the shape) to resize.
   * @param scale - The scale factor to apply to the shape.
   * @param opts - Additional options.
   *
   * @public
   */
  resizeShape(shape, scale, opts = {}) {
    var _a6, _b3, _c;
    const id = typeof shape === "string" ? shape : shape.id;
    if (this.getIsReadonly()) return this;
    if (!Number.isFinite(scale.x)) scale = new Vec(1, scale.y);
    if (!Number.isFinite(scale.y)) scale = new Vec(scale.x, 1);
    const initialShape = opts.initialShape ?? this.getShape(id);
    if (!initialShape) return this;
    const scaleOrigin = opts.scaleOrigin ?? ((_a6 = this.getShapePageBounds(id)) == null ? void 0 : _a6.center);
    if (!scaleOrigin) return this;
    const pageTransform = opts.initialPageTransform ? Mat.Cast(opts.initialPageTransform) : this.getShapePageTransform(id);
    if (!pageTransform) return this;
    const pageRotation = pageTransform.rotation();
    if (pageRotation == null) return this;
    const scaleAxisRotation = opts.scaleAxisRotation ?? pageRotation;
    const initialBounds = opts.initialBounds ?? this.getShapeGeometry(id).bounds;
    if (!initialBounds) return this;
    const isAspectRatioLocked = opts.isAspectRatioLocked ?? this.getShapeUtil(initialShape).isAspectRatioLocked(initialShape);
    if (!areAnglesCompatible(pageRotation, scaleAxisRotation)) {
      return this._resizeUnalignedShape(id, scale, {
        ...opts,
        initialBounds,
        scaleOrigin,
        scaleAxisRotation,
        initialPageTransform: pageTransform,
        isAspectRatioLocked,
        initialShape
      });
    }
    const util = this.getShapeUtil(initialShape);
    if (isAspectRatioLocked) {
      if (Math.abs(scale.x) > Math.abs(scale.y)) {
        scale = new Vec(scale.x, Math.sign(scale.y) * Math.abs(scale.x));
      } else {
        scale = new Vec(Math.sign(scale.x) * Math.abs(scale.y), scale.y);
      }
    }
    let didResize = false;
    if (util.onResize && util.canResize(initialShape)) {
      const newPagePoint = this._scalePagePoint(
        Mat.applyToPoint(pageTransform, new Vec(0, 0)),
        scaleOrigin,
        scale,
        scaleAxisRotation
      );
      const newLocalPoint = this.getPointInParentSpace(initialShape.id, newPagePoint);
      const myScale = new Vec(scale.x, scale.y);
      const areWidthAndHeightAlignedWithCorrectAxis = approximately(
        (pageRotation - scaleAxisRotation) % Math.PI,
        0
      );
      myScale.x = areWidthAndHeightAlignedWithCorrectAxis ? scale.x : scale.y;
      myScale.y = areWidthAndHeightAlignedWithCorrectAxis ? scale.y : scale.x;
      const initialPagePoint = Mat.applyToPoint(pageTransform, new Vec());
      const { x, y } = this.getPointInParentSpace(initialShape.id, initialPagePoint);
      let workingShape = initialShape;
      if (!opts.skipStartAndEndCallbacks) {
        workingShape = applyPartialToRecordWithProps(
          initialShape,
          ((_b3 = util.onResizeStart) == null ? void 0 : _b3.call(util, initialShape)) ?? void 0
        );
      }
      const resizedShape = util.onResize(
        { ...initialShape, x, y },
        {
          newPoint: newLocalPoint,
          handle: opts.dragHandle ?? "bottom_right",
          // don't set isSingle to true for children
          mode: opts.mode ?? "scale_shape",
          scaleX: myScale.x,
          scaleY: myScale.y,
          initialBounds,
          initialShape
        }
      );
      if (resizedShape) {
        didResize = true;
      }
      workingShape = applyPartialToRecordWithProps(workingShape, {
        id,
        type: initialShape.type,
        x: newLocalPoint.x,
        y: newLocalPoint.y,
        ...resizedShape
      });
      if (!opts.skipStartAndEndCallbacks) {
        workingShape = applyPartialToRecordWithProps(
          workingShape,
          ((_c = util.onResizeEnd) == null ? void 0 : _c.call(util, initialShape, workingShape)) ?? void 0
        );
      }
      this.updateShapes([workingShape]);
    }
    if (!didResize) {
      const initialPageCenter = Mat.applyToPoint(pageTransform, initialBounds.center);
      const newPageCenter = this._scalePagePoint(
        initialPageCenter,
        scaleOrigin,
        scale,
        scaleAxisRotation
      );
      const initialPageCenterInParentSpace = this.getPointInParentSpace(
        initialShape.id,
        initialPageCenter
      );
      const newPageCenterInParentSpace = this.getPointInParentSpace(initialShape.id, newPageCenter);
      const delta = Vec.Sub(newPageCenterInParentSpace, initialPageCenterInParentSpace);
      this.updateShapes([
        {
          id,
          type: initialShape.type,
          x: initialShape.x + delta.x,
          y: initialShape.y + delta.y
        }
      ]);
    }
    return this;
  }
  /** @internal */
  _scalePagePoint(point, scaleOrigin, scale, scaleAxisRotation) {
    const relativePoint = Vec.RotWith(point, scaleOrigin, -scaleAxisRotation).sub(scaleOrigin);
    const newRelativePagePoint = Vec.MulV(relativePoint, scale);
    const destination = Vec.Add(newRelativePagePoint, scaleOrigin).rotWith(
      scaleOrigin,
      scaleAxisRotation
    );
    return destination;
  }
  /** @internal */
  _resizeUnalignedShape(id, scale, options2) {
    const { type } = options2.initialShape;
    const shapeScale = new Vec(scale.x, scale.y);
    if (Math.abs(scale.x) > Math.abs(scale.y)) {
      shapeScale.x = Math.sign(scale.x) * Math.abs(scale.y);
    } else {
      shapeScale.y = Math.sign(scale.y) * Math.abs(scale.x);
    }
    this.resizeShape(id, shapeScale, {
      initialShape: options2.initialShape,
      initialBounds: options2.initialBounds,
      isAspectRatioLocked: options2.isAspectRatioLocked
    });
    if (Math.sign(scale.x) * Math.sign(scale.y) < 0) {
      const parentRotation = this.getShapeParentTransform(id).rotation();
      const rotation = -options2.initialShape.rotation - 2 * parentRotation;
      this.updateShapes([{ id, type, rotation }]);
    }
    const preScaleShapePageCenter = Mat.applyToPoint(
      options2.initialPageTransform,
      options2.initialBounds.center
    );
    const postScaleShapePageCenter = this._scalePagePoint(
      preScaleShapePageCenter,
      options2.scaleOrigin,
      scale,
      options2.scaleAxisRotation
    );
    const pageTransform = this.getShapePageTransform(id);
    const currentLocalBounds = this.getShapeGeometry(id).bounds;
    const currentPageCenter = Mat.applyToPoint(pageTransform, currentLocalBounds.center);
    const shapePageTransformOrigin = pageTransform.point();
    if (!currentPageCenter || !shapePageTransformOrigin) return this;
    const pageDelta = Vec.Sub(postScaleShapePageCenter, currentPageCenter);
    const postScaleShapePagePoint = Vec.Add(shapePageTransformOrigin, pageDelta);
    const { x, y } = this.getPointInParentSpace(id, postScaleShapePagePoint);
    this.updateShapes([{ id, type, x, y }]);
    return this;
  }
  /**
   * Get the initial meta value for a shape.
   *
   * @example
   * ```ts
   * editor.getInitialMetaForShape = (shape) => {
   *   if (shape.type === 'note') {
   *     return { createdBy: myCurrentUser.id }
   *   }
   * }
   * ```
   *
   * @param shape - The shape to get the initial meta for.
   *
   * @public
   */
  getInitialMetaForShape(_shape) {
    return {};
  }
  /**
   * Get whether the provided shape can be created.
   *
   * @param shape - The shape or shape IDs to check.
   *
   * @public
   */
  canCreateShape(shape) {
    return this.canCreateShapes([shape]);
  }
  /**
   * Get whether the provided shapes can be created.
   *
   * @param shapes - The shapes or shape IDs to create.
   *
   * @public
   */
  canCreateShapes(shapes) {
    return shapes.length + this.getCurrentPageShapeIds().size <= this.options.maxShapesPerPage;
  }
  /**
   * Create a single shape.
   *
   * @example
   * ```ts
   * editor.createShape(myShape)
   * editor.createShape({ id: 'box1', type: 'text', props: { richText: toRichText("ok") } })
   * ```
   *
   * @param shape - The shape (or shape partial) to create.
   *
   * @public
   */
  createShape(shape) {
    this.createShapes([shape]);
    return this;
  }
  /**
   * Create shapes.
   *
   * @example
   * ```ts
   * editor.createShapes([myShape])
   * editor.createShapes([{ id: 'box1', type: 'text', props: { richText: toRichText("ok") } }])
   * ```
   *
   * @param shapes - The shapes (or shape partials) to create.
   *
   * @public
   */
  createShapes(shapes) {
    if (!Array.isArray(shapes)) {
      throw Error("Editor.createShapes: must provide an array of shapes or shape partials");
    }
    if (this.getIsReadonly()) return this;
    if (shapes.length <= 0) return this;
    const currentPageShapeIds = this.getCurrentPageShapeIds();
    const maxShapesReached = shapes.length + currentPageShapeIds.size > this.options.maxShapesPerPage;
    if (maxShapesReached) {
      alertMaxShapes(this);
      return this;
    }
    const focusedGroupId = this.getFocusedGroupId();
    this.run(() => {
      var _a6, _b3;
      const currentPageShapesSorted = this.getCurrentPageShapesSorted();
      const partials = shapes.map((partial) => {
        if (!partial.id) {
          partial = { id: createShapeId(), ...partial };
        }
        if (!partial.parentId || !(this.store.has(partial.parentId) || shapes.some((p) => p.id === partial.parentId))) {
          let parentId = this.getFocusedGroupId();
          const isPositioned = partial.x !== void 0 && partial.y !== void 0;
          if (isPositioned) {
            for (let i = currentPageShapesSorted.length - 1; i >= 0; i--) {
              const parent = currentPageShapesSorted[i];
              const util = this.getShapeUtil(parent);
              if (util.canReceiveNewChildrenOfType(parent, partial.type) && !this.isShapeHidden(parent) && this.isPointInShape(
                parent,
                // If no parent is provided, then we can treat the
                // shape's provided x/y as being in the page's space.
                { x: partial.x ?? 0, y: partial.y ?? 0 },
                {
                  margin: 0,
                  hitInside: true
                }
              )) {
                parentId = parent.id;
                break;
              }
            }
          }
          const prevParentId = partial.parentId;
          if (parentId === partial.id) {
            parentId = focusedGroupId;
          }
          if (parentId !== prevParentId) {
            partial = { ...partial };
            partial.parentId = parentId;
            if (isShapeId(parentId)) {
              const point = this.getPointInShapeSpace(this.getShape(parentId), {
                x: partial.x ?? 0,
                y: partial.y ?? 0
              });
              partial.x = point.x;
              partial.y = point.y;
              partial.rotation = -this.getShapePageTransform(parentId).rotation() + (partial.rotation ?? 0);
            }
          }
        }
        return partial;
      });
      const parentIndices = /* @__PURE__ */ new Map();
      const shapeRecordsToCreate = [];
      const { opacityForNextShape } = this.getInstanceState();
      for (const partial of partials) {
        const util = this.getShapeUtil(partial);
        let index2 = partial.index;
        if (!index2) {
          const parentId = partial.parentId ?? focusedGroupId;
          if (!parentIndices.has(parentId)) {
            parentIndices.set(parentId, this.getHighestIndexForParent(parentId));
          }
          index2 = parentIndices.get(parentId);
          parentIndices.set(parentId, getIndexAbove(index2));
        }
        const initialProps = util.getDefaultProps();
        for (const [style2, propKey] of this.styleProps[partial.type]) {
          ;
          initialProps[propKey] = this.getStyleForNextShape(style2);
        }
        let shapeRecordToCreate = this.store.schema.types.shape.create({
          ...partial,
          index: index2,
          opacity: partial.opacity ?? opacityForNextShape,
          parentId: partial.parentId ?? focusedGroupId,
          props: "props" in partial ? { ...initialProps, ...partial.props } : initialProps
        });
        if (shapeRecordToCreate.index === void 0) {
          throw Error("no index!");
        }
        const next = (_b3 = (_a6 = this.getShapeUtil(shapeRecordToCreate)).onBeforeCreate) == null ? void 0 : _b3.call(_a6, shapeRecordToCreate);
        if (next) {
          shapeRecordToCreate = next;
        }
        shapeRecordsToCreate.push(shapeRecordToCreate);
      }
      shapeRecordsToCreate.forEach((shape) => {
        shape.meta = {
          ...this.getInitialMetaForShape(shape),
          ...shape.meta
        };
      });
      this.emit("created-shapes", shapeRecordsToCreate);
      this.emit("edit");
      this.store.put(shapeRecordsToCreate);
    });
    return this;
  }
  /**
   * Animate a shape.
   *
   * @example
   * ```ts
   * editor.animateShape({ id: 'box1', type: 'box', x: 100, y: 100 })
   * editor.animateShape({ id: 'box1', type: 'box', x: 100, y: 100 }, { animation: { duration: 100, ease: t => t*t } })
   * ```
   *
   * @param partial - The shape partial to update.
   * @param opts - The animation's options.
   *
   * @public
   */
  animateShape(partial, opts = { animation: DEFAULT_ANIMATION_OPTIONS }) {
    return this.animateShapes([partial], opts);
  }
  /**
   * Animate shapes.
   *
   * @example
   * ```ts
   * editor.animateShapes([{ id: 'box1', type: 'box', x: 100, y: 100 }])
   * editor.animateShapes([{ id: 'box1', type: 'box', x: 100, y: 100 }], { animation: { duration: 100, ease: t => t*t } })
   * ```
   *
   * @param partials - The shape partials to update.
   * @param opts - The animation's options.
   *
   * @public
   */
  animateShapes(partials, opts = { animation: DEFAULT_ANIMATION_OPTIONS }) {
    if (!opts.animation) return this;
    const { duration = 500, easing = EASINGS.linear } = opts.animation;
    const animationId = uniqueId();
    let remaining = duration;
    let t2;
    const animations = [];
    let partial, result;
    for (let i = 0, n = partials.length; i < n; i++) {
      partial = partials[i];
      if (!partial) continue;
      const shape = this.getShape(partial.id);
      if (!shape) continue;
      result = {
        start: structuredClone(shape),
        end: applyPartialToRecordWithProps(structuredClone(shape), partial)
      };
      animations.push(result);
      this.animatingShapes.set(shape.id, animationId);
    }
    const handleTick = (elapsed) => {
      var _a6, _b3;
      remaining -= elapsed;
      if (remaining < 0) {
        const { animatingShapes: animatingShapes2 } = this;
        const partialsToUpdate = partials.filter(
          (p) => p && animatingShapes2.get(p.id) === animationId
        );
        if (partialsToUpdate.length) {
          this.updateShapes(partialsToUpdate);
        }
        this.off("tick", handleTick);
        return;
      }
      t2 = easing(1 - remaining / duration);
      const { animatingShapes } = this;
      const updates = [];
      let animationIdForShape;
      for (let i = 0, n = animations.length; i < n; i++) {
        const { start, end } = animations[i];
        animationIdForShape = animatingShapes.get(start.id);
        if (animationIdForShape !== animationId) continue;
        updates.push({
          ...end,
          x: start.x + (end.x - start.x) * t2,
          y: start.y + (end.y - start.y) * t2,
          opacity: start.opacity + (end.opacity - start.opacity) * t2,
          rotation: start.rotation + (end.rotation - start.rotation) * t2,
          props: ((_b3 = (_a6 = this.getShapeUtil(end)).getInterpolatedProps) == null ? void 0 : _b3.call(_a6, start, end, t2)) ?? end.props
        });
      }
      this._updateShapes(updates);
    };
    this.on("tick", handleTick);
    return this;
  }
  groupShapes(shapes, opts = {}) {
    var _a6;
    const { groupId = createShapeId(), select = true } = opts;
    if (!Array.isArray(shapes)) {
      throw Error("Editor.groupShapes: must provide an array of shapes or shape ids");
    }
    if (this.getIsReadonly()) return this;
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    if (ids.length <= 1) return this;
    const shapesToGroup = compact(
      (this._shouldIgnoreShapeLock ? ids : this._getUnlockedShapeIds(ids)).map(
        (id) => this.getShape(id)
      )
    );
    const sortedShapeIds = shapesToGroup.sort(sortByIndex).map((s) => s.id);
    const childBounds = compact(shapesToGroup.map((shape) => this.getShapePageBounds(shape)));
    const pageBounds = Box.Common(childBounds);
    if (!pageBounds.isValid()) {
      throw Error(`Editor.groupShapes: group bounds are invalid (NaN).`);
    }
    const { x, y } = pageBounds.point;
    const parentId = this.findCommonAncestor(shapesToGroup) ?? this.getCurrentPageId();
    if (this.getCurrentToolId() !== "select") return this;
    if (!this.isIn("select.idle")) {
      this.cancel();
    }
    const shapesWithRootParent = shapesToGroup.filter((shape) => shape.parentId === parentId).sort(sortByIndex);
    const highestIndex = (_a6 = shapesWithRootParent[shapesWithRootParent.length - 1]) == null ? void 0 : _a6.index;
    this.run(() => {
      this.createShapes([
        {
          id: groupId,
          type: "group",
          parentId,
          index: highestIndex,
          x,
          y,
          opacity: 1,
          props: {}
        }
      ]);
      this.reparentShapes(sortedShapeIds, groupId);
      if (select) {
        this.select(groupId);
      }
    });
    return this;
  }
  ungroupShapes(shapes, opts = {}) {
    if (this.getIsReadonly()) return this;
    const { select = true } = opts;
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    const shapesToUngroup = compact(
      (this._shouldIgnoreShapeLock ? ids : this._getUnlockedShapeIds(ids)).map(
        (id) => this.getShape(id)
      )
    );
    if (shapesToUngroup.length === 0) return this;
    if (this.getCurrentToolId() !== "select") return this;
    if (!this.isIn("select.idle")) {
      this.cancel();
    }
    const idsToSelect = /* @__PURE__ */ new Set();
    const groups = [];
    shapesToUngroup.forEach((shape) => {
      if (this.isShapeOfType(shape, "group")) {
        groups.push(shape);
      } else {
        idsToSelect.add(shape.id);
      }
    });
    if (groups.length === 0) return this;
    this.run(() => {
      let group;
      for (let i = 0, n = groups.length; i < n; i++) {
        group = groups[i];
        const childIds = this.getSortedChildIdsForParent(group.id);
        for (let j = 0, n2 = childIds.length; j < n2; j++) {
          idsToSelect.add(childIds[j]);
        }
        this.reparentShapes(childIds, group.parentId, group.index);
      }
      this.deleteShapes(groups.map((group2) => group2.id));
      if (select) {
        this.select(...idsToSelect);
      }
    });
    return this;
  }
  /**
   * Update a shape using a partial of the shape.
   *
   * @example
   * ```ts
   * editor.updateShape({ id: 'box1', type: 'geo', props: { w: 100, h: 100 } })
   * ```
   *
   * @param partial - The shape partial to update.
   *
   * @public
   */
  updateShape(partial) {
    this.updateShapes([partial]);
    return this;
  }
  /**
   * Update shapes using partials of each shape.
   *
   * @example
   * ```ts
   * editor.updateShapes([{ id: 'box1', type: 'geo', props: { w: 100, h: 100 } }])
   * ```
   *
   * @param partials - The shape partials to update.
   *
   * @public
   */
  updateShapes(partials) {
    const compactedPartials = Array(partials.length);
    for (let i = 0, n = partials.length; i < n; i++) {
      const partial = partials[i];
      if (!partial) continue;
      const shape = this.getShape(partial.id);
      if (!shape) continue;
      if (!this._shouldIgnoreShapeLock) {
        if (shape.isLocked) {
          if (!(Object.hasOwn(partial, "isLocked") && !partial.isLocked)) {
            continue;
          }
        } else if (this.isShapeOrAncestorLocked(shape)) {
          continue;
        }
      }
      this.animatingShapes.delete(partial.id);
      compactedPartials.push(partial);
    }
    this._updateShapes(compactedPartials);
    return this;
  }
  /** @internal */
  _updateShapes(_partials) {
    if (this.getIsReadonly()) return;
    this.run(() => {
      var _a6, _b3;
      const updates = [];
      let shape;
      let updated;
      for (let i = 0, n = _partials.length; i < n; i++) {
        const partial = _partials[i];
        if (!partial) continue;
        shape = this.getShape(partial.id);
        if (!shape) continue;
        updated = applyPartialToRecordWithProps(shape, partial);
        if (updated === shape) continue;
        updated = ((_b3 = (_a6 = this.getShapeUtil(shape)).onBeforeUpdate) == null ? void 0 : _b3.call(_a6, shape, updated)) ?? updated;
        updates.push(updated);
      }
      this.emit("edited-shapes", updates);
      this.emit("edit");
      this.store.put(updates);
    });
  }
  /** @internal */
  _getUnlockedShapeIds(ids) {
    return ids.filter((id) => {
      var _a6;
      return !((_a6 = this.getShape(id)) == null ? void 0 : _a6.isLocked);
    });
  }
  deleteShapes(_ids) {
    if (this.getIsReadonly()) return this;
    if (!Array.isArray(_ids)) {
      throw Error("Editor.deleteShapes: must provide an array of shapes or shapeIds");
    }
    const shapeIds = typeof _ids[0] === "string" ? _ids : _ids.map((s) => s.id);
    const shapeIdsToDelete = this._shouldIgnoreShapeLock ? shapeIds : this._getUnlockedShapeIds(shapeIds);
    if (shapeIdsToDelete.length === 0) return this;
    const allShapeIdsToDelete = new Set(shapeIdsToDelete);
    for (const id of shapeIdsToDelete) {
      this.visitDescendants(id, (childId) => {
        allShapeIdsToDelete.add(childId);
      });
    }
    this.emit("deleted-shapes", [...allShapeIdsToDelete]);
    this.emit("edit");
    return this.run(() => this.store.remove([...allShapeIdsToDelete]));
  }
  deleteShape(_id) {
    this.deleteShapes([typeof _id === "string" ? _id : _id.id]);
    return this;
  }
  /* --------------------- Styles --------------------- */
  /**
   * Get all the current styles among the users selected shapes
   *
   * @internal
   */
  _extractSharedStyles(shape, sharedStyleMap) {
    if (this.isShapeOfType(shape, "group")) {
      const childIds = this._parentIdsToChildIds.get()[shape.id];
      if (!childIds) return;
      for (let i = 0, n = childIds.length; i < n; i++) {
        this._extractSharedStyles(this.getShape(childIds[i]), sharedStyleMap);
      }
    } else {
      for (const [style2, propKey] of this.styleProps[shape.type]) {
        sharedStyleMap.applyValue(style2, getOwnProperty(shape.props, propKey));
      }
    }
  }
  _getSelectionSharedStyles() {
    const selectedShapes = this.getSelectedShapes();
    const sharedStyles = new SharedStyleMap();
    for (const selectedShape of selectedShapes) {
      this._extractSharedStyles(selectedShape, sharedStyles);
    }
    return sharedStyles;
  }
  /**
   * Get the style for the next shape.
   *
   * @example
   * ```ts
   * const color = editor.getStyleForNextShape(DefaultColorStyle)
   * ```
   *
   * @param style - The style to get.
   *
   * @public */
  getStyleForNextShape(style2) {
    const value = this.getInstanceState().stylesForNextShape[style2.id];
    return value === void 0 ? style2.defaultValue : value;
  }
  getShapeStyleIfExists(shape, style2) {
    const styleKey = this.styleProps[shape.type].get(style2);
    if (styleKey === void 0) return void 0;
    return getOwnProperty(shape.props, styleKey);
  }
  getSharedStyles() {
    if (this.isIn("select") && this.getSelectedShapeIds().length > 0) {
      return this._getSelectionSharedStyles();
    }
    const currentTool = this.root.getCurrent();
    const styles = new SharedStyleMap();
    if (!currentTool) return styles;
    if (currentTool.shapeType) {
      if (currentTool.shapeType === "frame" && !this.getShapeUtil("frame").options.showColors) {
        for (const style2 of this.styleProps[currentTool.shapeType].keys()) {
          if (style2.id === "tldraw:color") continue;
          styles.applyValue(style2, this.getStyleForNextShape(style2));
        }
      } else {
        for (const style2 of this.styleProps[currentTool.shapeType].keys()) {
          styles.applyValue(style2, this.getStyleForNextShape(style2));
        }
      }
    }
    return styles;
  }
  getSharedOpacity() {
    if (this.isIn("select") && this.getSelectedShapeIds().length > 0) {
      const shapesToCheck = [];
      const addShape = (shapeId) => {
        const shape = this.getShape(shapeId);
        if (!shape) return;
        if (this.isShapeOfType(shape, "group")) {
          for (const childId of this.getSortedChildIdsForParent(shape.id)) {
            addShape(childId);
          }
        } else {
          shapesToCheck.push(shape);
        }
      };
      for (const shapeId of this.getSelectedShapeIds()) {
        addShape(shapeId);
      }
      let opacity = null;
      for (const shape of shapesToCheck) {
        if (opacity === null) {
          opacity = shape.opacity;
        } else if (opacity !== shape.opacity) {
          return { type: "mixed" };
        }
      }
      if (opacity !== null) return { type: "shared", value: opacity };
    }
    return { type: "shared", value: this.getInstanceState().opacityForNextShape };
  }
  /**
   * Set the opacity for the next shapes. This will effect subsequently created shapes.
   *
   * @example
   * ```ts
   * editor.setOpacityForNextShapes(0.5)
   * ```
   *
   * @param opacity - The opacity to set. Must be a number between 0 and 1 inclusive.
   * @param historyOptions - The history options for the change.
   */
  setOpacityForNextShapes(opacity, historyOptions) {
    this.updateInstanceState({ opacityForNextShape: opacity }, historyOptions);
    return this;
  }
  /**
   * Set the current opacity. This will effect any selected shapes.
   *
   * @example
   * ```ts
   * editor.setOpacityForSelectedShapes(0.5)
   * ```
   *
   * @param opacity - The opacity to set. Must be a number between 0 and 1 inclusive.
   */
  setOpacityForSelectedShapes(opacity) {
    const selectedShapes = this.getSelectedShapes();
    if (selectedShapes.length > 0) {
      const shapesToUpdate = [];
      const addShapeById = (shape) => {
        if (this.isShapeOfType(shape, "group")) {
          const childIds = this.getSortedChildIdsForParent(shape);
          for (const childId of childIds) {
            addShapeById(this.getShape(childId));
          }
        } else {
          shapesToUpdate.push(shape);
        }
      };
      for (const id of selectedShapes) {
        addShapeById(id);
      }
      this.updateShapes(
        shapesToUpdate.map((shape) => {
          return {
            id: shape.id,
            type: shape.type,
            opacity
          };
        })
      );
    }
    return this;
  }
  /**
   * Set the value of a {@link @tldraw/tlschema#StyleProp} for the next shapes. This change will be applied to subsequently created shapes.
   *
   * @example
   * ```ts
   * editor.setStyleForNextShapes(DefaultColorStyle, 'red')
   * editor.setStyleForNextShapes(DefaultColorStyle, 'red', { ephemeral: true })
   * ```
   *
   * @param style - The style to set.
   * @param value - The value to set.
   * @param historyOptions - The history options for the change.
   *
   * @public
   */
  setStyleForNextShapes(style2, value, historyOptions) {
    const stylesForNextShape = this.getInstanceState().stylesForNextShape;
    this.updateInstanceState(
      { stylesForNextShape: { ...stylesForNextShape, [style2.id]: value } },
      historyOptions
    );
    return this;
  }
  /**
   * Set the value of a {@link @tldraw/tlschema#StyleProp}. This change will be applied to the currently selected shapes.
   *
   * @example
   * ```ts
   * editor.setStyleForSelectedShapes(DefaultColorStyle, 'red')
   * ```
   *
   * @param style - The style to set.
   * @param value - The value to set.
   *
   * @public
   */
  setStyleForSelectedShapes(style2, value) {
    const selectedShapes = this.getSelectedShapes();
    if (selectedShapes.length > 0) {
      const updates = [];
      const addShapeById = (shape) => {
        if (this.isShapeOfType(shape, "group")) {
          const childIds = this.getSortedChildIdsForParent(shape.id);
          for (const childId of childIds) {
            addShapeById(this.getShape(childId));
          }
        } else {
          const util = this.getShapeUtil(shape);
          const stylePropKey = this.styleProps[shape.type].get(style2);
          if (stylePropKey) {
            const shapePartial = {
              id: shape.id,
              type: shape.type,
              props: { [stylePropKey]: value }
            };
            updates.push({
              util,
              originalShape: shape,
              updatePartial: shapePartial
            });
          }
        }
      };
      for (const shape of selectedShapes) {
        addShapeById(shape);
      }
      this.updateShapes(updates.map(({ updatePartial }) => updatePartial));
    }
    return this;
  }
  /**
   * Register an external asset handler. This handler will be called when the editor needs to
   * create an asset for some external content, like an image/video file or a bookmark URL. For
   * example, the 'file' type handler will be called when a user drops an image onto the canvas.
   *
   * The handler should extract any relevant metadata for the asset, upload it to blob storage
   * using {@link Editor.uploadAsset} if needed, and return the asset with the metadata & uploaded
   * URL.
   *
   * @example
   * ```ts
   * editor.registerExternalAssetHandler('file', myHandler)
   * ```
   *
   * @param type - The type of external content.
   * @param handler - The handler to use for this content type.
   *
   * @public
   */
  registerExternalAssetHandler(type, handler) {
    this.externalAssetContentHandlers[type] = handler;
    return this;
  }
  /**
   * Register a temporary preview of an asset. This is useful for showing a ghost image of
   * something that is being uploaded. Retrieve the placeholder with
   * {@link Editor.getTemporaryAssetPreview}. Placeholders last for 3 minutes by default, but this
   * can be configured using
   *
   * @example
   * ```ts
   * editor.createTemporaryAssetPreview(assetId, file)
   * ```
   *
   * @param assetId - The asset's id.
   * @param file - The raw file.
   *
   * @public
   */
  createTemporaryAssetPreview(assetId, file) {
    if (this.temporaryAssetPreview.has(assetId)) {
      return this.temporaryAssetPreview.get(assetId);
    }
    const objectUrl = URL.createObjectURL(file);
    this.temporaryAssetPreview.set(assetId, objectUrl);
    setTimeout(() => {
      this.temporaryAssetPreview.delete(assetId);
      URL.revokeObjectURL(objectUrl);
    }, this.options.temporaryAssetPreviewLifetimeMs);
    return objectUrl;
  }
  /**
   * Get temporary preview of an asset. This is useful for showing a ghost
   * image of something that is being uploaded.
   *
   * @example
   * ```ts
   * editor.getTemporaryAssetPreview('someId')
   * ```
   *
   * @param assetId - The asset's id.
   *
   * @public
   */
  getTemporaryAssetPreview(assetId) {
    return this.temporaryAssetPreview.get(assetId);
  }
  /**
   * Get an asset for an external asset content type.
   *
   * @example
   * ```ts
   * const asset = await editor.getAssetForExternalContent({ type: 'file', file: myFile })
   * const asset = await editor.getAssetForExternalContent({ type: 'url', url: myUrl })
   * ```
   *
   * @param info - Info about the external content.
   * @returns The asset.
   */
  async getAssetForExternalContent(info) {
    var _a6, _b3;
    return await ((_b3 = (_a6 = this.externalAssetContentHandlers)[info.type]) == null ? void 0 : _b3.call(_a6, info));
  }
  hasExternalAssetHandler(type) {
    return !!this.externalAssetContentHandlers[type];
  }
  /**
   * Register an external content handler. This handler will be called when the editor receives
   * external content of the provided type. For example, the 'image' type handler will be called
   * when a user drops an image onto the canvas.
   *
   * @example
   * ```ts
   * editor.registerExternalContentHandler('text', myHandler)
   * ```
   * @example
   * ```ts
   * editor.registerExternalContentHandler<'embed', MyEmbedType>('embed', myHandler)
   * ```
   *
   * @param type - The type of external content.
   * @param handler - The handler to use for this content type.
   *
   * @public
   */
  registerExternalContentHandler(type, handler) {
    this.externalContentHandlers[type] = handler;
    return this;
  }
  /**
   * Handle external content, such as files, urls, embeds, or plain text which has been put into the app, for example by pasting external text or dropping external images onto canvas.
   *
   * @param info - Info about the external content.
   * @param opts - Options for handling external content, including force flag to bypass readonly checks.
   */
  async putExternalContent(info, opts = {}) {
    var _a6, _b3;
    if (!opts.force && this.getIsReadonly()) return;
    return (_b3 = (_a6 = this.externalContentHandlers)[info.type]) == null ? void 0 : _b3.call(_a6, info);
  }
  /**
   * Handle replacing external content.
   *
   * @param info - Info about the external content.
   * @param opts - Options for handling external content, including force flag to bypass readonly checks.
   */
  async replaceExternalContent(info, opts = {}) {
    var _a6, _b3;
    if (!opts.force && this.getIsReadonly()) return;
    return (_b3 = (_a6 = this.externalContentHandlers)[info.type]) == null ? void 0 : _b3.call(_a6, info);
  }
  /**
   * Get content that can be exported for the given shape ids.
   *
   * @param shapes - The shapes (or shape ids) to get content for.
   *
   * @returns The exported content.
   *
   * @public
   */
  getContentFromCurrentPage(shapes) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    if (!ids) return;
    if (ids.length === 0) return;
    const shapeIds = this.getShapeAndDescendantIds(ids);
    return withIsolatedShapes(this, shapeIds, (bindingIdsToKeep) => {
      const bindings = [];
      for (const id of bindingIdsToKeep) {
        const binding = this.getBinding(id);
        if (!binding) continue;
        bindings.push(binding);
      }
      const rootShapeIds = [];
      const shapes2 = [];
      for (const shapeId of shapeIds) {
        const shape = this.getShape(shapeId);
        if (!shape) continue;
        const isRootShape = !shapeIds.has(shape.parentId);
        if (isRootShape) {
          const pageTransform = this.getShapePageTransform(shape.id);
          const pagePoint = pageTransform.point();
          shapes2.push({
            ...shape,
            x: pagePoint.x,
            y: pagePoint.y,
            rotation: pageTransform.rotation(),
            parentId: this.getCurrentPageId()
          });
          rootShapeIds.push(shape.id);
        } else {
          shapes2.push(shape);
        }
      }
      const assets = [];
      const seenAssetIds = /* @__PURE__ */ new Set();
      for (const shape of shapes2) {
        if (!("assetId" in shape.props)) continue;
        const assetId = shape.props.assetId;
        if (!assetId || seenAssetIds.has(assetId)) continue;
        seenAssetIds.add(assetId);
        const asset = this.getAsset(assetId);
        if (!asset) continue;
        assets.push(asset);
      }
      return {
        schema: this.store.schema.serialize(),
        shapes: shapes2,
        rootShapeIds,
        bindings,
        assets
      };
    });
  }
  async resolveAssetsInContent(content) {
    if (!content) return void 0;
    const assets = [];
    await Promise.allSettled(
      content.assets.map(async (asset) => {
        var _a6, _b3, _c;
        if ((asset.type === "image" || asset.type === "video") && !((_a6 = asset.props.src) == null ? void 0 : _a6.startsWith("data:image")) && !((_b3 = asset.props.src) == null ? void 0 : _b3.startsWith("data:video")) && !((_c = asset.props.src) == null ? void 0 : _c.startsWith("http"))) {
          const assetWithDataUrl = structuredClone(asset);
          const objectUrl = await this.store.props.assets.resolve(asset, {
            screenScale: 1,
            steppedScreenScale: 1,
            dpr: 1,
            networkEffectiveType: null,
            shouldResolveToOriginal: true
          });
          assetWithDataUrl.props.src = await FileHelpers.blobToDataUrl(
            await fetch2(objectUrl).then((r) => r.blob())
          );
          assets.push(assetWithDataUrl);
        } else {
          assets.push(asset);
        }
      })
    );
    content.assets = assets;
    return content;
  }
  /**
   * Place content into the editor.
   *
   * @param content - The content.
   * @param opts - Options for placing the content.
   *
   * @public
   */
  putContentOntoCurrentPage(content, opts = {}) {
    var _a6, _b3, _c;
    if (this.getIsReadonly()) return this;
    if (!content.schema) {
      throw Error("Could not put content:\ncontent is missing a schema.");
    }
    const { select = false, preserveIds = false, preservePosition = false } = opts;
    let { point = void 0 } = opts;
    const currentPageId = this.getCurrentPageId();
    const { rootShapeIds } = content;
    const assets = [];
    const shapes = [];
    const bindings = [];
    const store = {
      store: {
        ...Object.fromEntries(content.assets.map((asset) => [asset.id, asset])),
        ...Object.fromEntries(content.shapes.map((shape) => [shape.id, shape])),
        ...Object.fromEntries(
          ((_a6 = content.bindings) == null ? void 0 : _a6.map((bindings2) => [bindings2.id, bindings2])) ?? []
        )
      },
      schema: content.schema
    };
    const result = this.store.schema.migrateStoreSnapshot(store);
    if (result.type === "error") {
      throw Error("Could not put content: could not migrate content");
    }
    for (const record of Object.values(result.value)) {
      switch (record.typeName) {
        case "asset": {
          assets.push(record);
          break;
        }
        case "shape": {
          shapes.push(record);
          break;
        }
        case "binding": {
          bindings.push(record);
          break;
        }
      }
    }
    const shapeIdMap = new Map(
      preserveIds ? shapes.map((shape) => [shape.id, shape.id]) : shapes.map((shape) => [shape.id, createShapeId()])
    );
    const bindingIdMap = new Map(
      preserveIds ? bindings.map((binding) => [binding.id, binding.id]) : bindings.map((binding) => [binding.id, createBindingId()])
    );
    let pasteParentId = this.getCurrentPageId();
    let lowestDepth = Infinity;
    let lowestAncestors = [];
    for (const shape of this.getSelectedShapes()) {
      if (lowestDepth === 0) break;
      const isFrame = this.isShapeOfType(shape, "frame");
      const ancestors = this.getShapeAncestors(shape);
      if (isFrame) ancestors.push(shape);
      const depth = isFrame ? ancestors.length + 1 : ancestors.length;
      if (depth < lowestDepth) {
        lowestDepth = depth;
        lowestAncestors = ancestors;
        pasteParentId = isFrame ? shape.id : shape.parentId;
      } else if (depth === lowestDepth) {
        if (lowestAncestors.length !== ancestors.length) {
          throw Error(`Ancestors: ${lowestAncestors.length} !== ${ancestors.length}`);
        }
        if (lowestAncestors.length === 0) {
          pasteParentId = currentPageId;
          break;
        } else {
          pasteParentId = currentPageId;
          for (let i = 0; i < lowestAncestors.length; i++) {
            if (ancestors[i] !== lowestAncestors[i]) break;
            pasteParentId = ancestors[i].id;
          }
        }
      }
    }
    if (point) {
      const shapesById = new Map(shapes.map((shape) => [shape.id, shape]));
      const rootShapesFromContent = compact(rootShapeIds.map((id) => shapesById.get(id)));
      if (rootShapesFromContent.length > 0) {
        const targetParent = this.getShapeAtPoint(point, {
          hitInside: true,
          hitFrameInside: true,
          hitLocked: true,
          filter: (shape) => {
            const util = this.getShapeUtil(shape);
            if (!util.canReceiveNewChildrenOfType) return false;
            return rootShapesFromContent.every(
              (rootShape) => util.canReceiveNewChildrenOfType(shape, rootShape.type)
            );
          }
        });
        pasteParentId = targetParent ? targetParent.id : currentPageId;
      }
    }
    let isDuplicating = false;
    if (!isPageId(pasteParentId)) {
      const parent = this.getShape(pasteParentId);
      if (parent) {
        if (!this.getViewportPageBounds().includes(this.getShapePageBounds(parent))) {
          pasteParentId = currentPageId;
        } else {
          if (rootShapeIds.length === 1) {
            const rootShape = shapes.find((s) => s.id === rootShapeIds[0]);
            if (this.isShapeOfType(parent, "frame") && this.isShapeOfType(rootShape, "frame") && rootShape.props.w === (parent == null ? void 0 : parent.props.w) && rootShape.props.h === (parent == null ? void 0 : parent.props.h)) {
              isDuplicating = true;
            }
          }
        }
      } else {
        pasteParentId = currentPageId;
      }
    }
    if (!isDuplicating) {
      isDuplicating = shapeIdMap.has(pasteParentId);
    }
    if (isDuplicating) {
      pasteParentId = this.getShape(pasteParentId).parentId;
    }
    let index2 = this.getHighestIndexForParent(pasteParentId);
    const rootShapes = [];
    const newShapes = shapes.map((oldShape) => {
      const newId = shapeIdMap.get(oldShape.id);
      const newShape = { ...oldShape, id: newId };
      if (rootShapeIds.includes(oldShape.id)) {
        newShape.parentId = currentPageId;
        rootShapes.push(newShape);
      }
      if (shapeIdMap.has(newShape.parentId)) {
        newShape.parentId = shapeIdMap.get(oldShape.parentId);
      } else {
        rootShapeIds.push(newShape.id);
        newShape.index = index2;
        index2 = getIndexAbove(index2);
      }
      return newShape;
    });
    if (newShapes.length + this.getCurrentPageShapeIds().size > this.options.maxShapesPerPage) {
      alertMaxShapes(this);
      return this;
    }
    const newBindings = bindings.map(
      (oldBinding) => ({
        ...oldBinding,
        id: assertExists(bindingIdMap.get(oldBinding.id)),
        fromId: assertExists(shapeIdMap.get(oldBinding.fromId)),
        toId: assertExists(shapeIdMap.get(oldBinding.toId))
      })
    );
    const assetsToCreate = [];
    const assetsToUpdate = [];
    for (const asset of assets) {
      if (this.store.has(asset.id)) {
        continue;
      }
      if (asset.type === "image" && ((_b3 = asset.props.src) == null ? void 0 : _b3.startsWith("data:image")) || asset.type === "video" && ((_c = asset.props.src) == null ? void 0 : _c.startsWith("data:video"))) {
        assetsToUpdate.push(structuredClone(asset));
        asset.props.src = null;
      }
      assetsToCreate.push(asset);
    }
    Promise.allSettled(
      assetsToUpdate.map(async (asset) => {
        const file = await dataUrlToFile(
          asset.props.src,
          asset.props.name,
          asset.props.mimeType ?? "image/png"
        );
        const newAsset = await this.getAssetForExternalContent({
          type: "file",
          file,
          assetId: asset.id
        });
        if (!newAsset) {
          this.deleteAssets([asset.id]);
          return;
        }
        this.updateAssets([{ ...newAsset, id: asset.id }]);
      })
    );
    this.run(() => {
      if (assetsToCreate.length > 0) {
        this.createAssets(assetsToCreate);
      }
      this.createShapes(newShapes);
      this.createBindings(newBindings);
      if (select) {
        this.select(...rootShapes.map((s) => s.id));
      }
      if (pasteParentId !== currentPageId) {
        this.reparentShapes(
          rootShapes.map((s) => s.id),
          pasteParentId
        );
      }
      const newCreatedShapes = newShapes.map((s) => this.getShape(s.id));
      const bounds = Box.Common(newCreatedShapes.map((s) => this.getShapePageBounds(s)));
      if (point === void 0) {
        if (!isPageId(pasteParentId)) {
          const shape = this.getShape(pasteParentId);
          point = Mat.applyToPoint(
            this.getShapePageTransform(shape),
            this.getShapeGeometry(shape).bounds.center
          );
        } else {
          const viewportPageBounds = this.getViewportPageBounds();
          if (preservePosition || viewportPageBounds.includes(Box.From(bounds))) {
            point = bounds.center;
          } else {
            point = viewportPageBounds.center;
          }
        }
      }
      if (rootShapes.length === 1) {
        const onlyRoot = rootShapes[0];
        if (this.isShapeOfType(onlyRoot, "frame")) {
          while (this.getShapesAtPoint(point).some(
            (shape) => this.isShapeOfType(shape, "frame") && shape.props.w === onlyRoot.props.w && shape.props.h === onlyRoot.props.h
          )) {
            point.x += bounds.w + 16;
          }
        }
      }
      const pageCenter = Box.Common(
        compact(rootShapes.map(({ id }) => this.getShapePageBounds(id)))
      ).center;
      const offset4 = Vec.Sub(point, pageCenter);
      this.updateShapes(
        rootShapes.map(({ id }) => {
          const s = this.getShape(id);
          const localRotation = this.getShapeParentTransform(id).decompose().rotation;
          const localDelta = Vec.Rot(offset4, -localRotation);
          return { id: s.id, type: s.type, x: s.x + localDelta.x, y: s.y + localDelta.y };
        })
      );
    });
    return this;
  }
  /**
   * Get an exported SVG element of the given shapes.
   *
   * @param shapes - The shapes (or shape ids) to export.
   * @param opts - Options for the export.
   *
   * @returns The SVG element.
   *
   * @public
   */
  async getSvgElement(shapes, opts = {}) {
    const ids = shapes.length === 0 ? this.getCurrentPageShapeIdsSorted() : typeof shapes[0] === "string" ? shapes : shapes.map((s) => s.id);
    if (ids.length === 0) return void 0;
    return exportToSvg(this, ids, opts);
  }
  /**
   * Get an exported SVG string of the given shapes.
   *
   * @param shapes - The shapes (or shape ids) to export.
   * @param opts - Options for the export.
   *
   * @returns The SVG element.
   *
   * @public
   */
  async getSvgString(shapes, opts = {}) {
    const result = await this.getSvgElement(shapes, opts);
    if (!result) return void 0;
    const serializer = new XMLSerializer();
    return {
      svg: serializer.serializeToString(result.svg),
      width: result.width,
      height: result.height
    };
  }
  /**
   * Get an exported image of the given shapes.
   *
   * @param shapes - The shapes (or shape ids) to export.
   * @param opts - Options for the export.
   *
   * @returns A blob of the image.
   * @public
   */
  async toImage(shapes, opts = {}) {
    const withDefaults = {
      format: "png",
      scale: 1,
      pixelRatio: opts.format === "svg" ? void 0 : 2,
      ...opts
    };
    const result = await this.getSvgString(shapes, withDefaults);
    if (!result) throw new Error("Could not create SVG");
    switch (withDefaults.format) {
      case "svg":
        return {
          blob: new Blob([result.svg], { type: "image/svg+xml" }),
          width: result.width,
          height: result.height
        };
      case "jpeg":
      case "png":
      case "webp": {
        const blob = await getSvgAsImage(result.svg, {
          type: withDefaults.format,
          quality: withDefaults.quality,
          pixelRatio: withDefaults.pixelRatio,
          width: result.width,
          height: result.height
        });
        if (!blob) {
          throw new Error("Could not construct image.");
        }
        return {
          blob,
          width: result.width,
          height: result.height
        };
      }
      default: {
        exhaustiveSwitchError(withDefaults.format);
      }
    }
  }
  /**
   * Get an exported image of the given shapes as a data URL.
   *
   * @param shapes - The shapes (or shape ids) to export.
   * @param opts - Options for the export.
   *
   * @returns A data URL of the image.
   * @public
   */
  async toImageDataUrl(shapes, opts = {}) {
    const { blob, width, height } = await this.toImage(shapes, opts);
    return {
      url: await FileHelpers.blobToDataUrl(blob),
      width,
      height
    };
  }
  /* --------------------- Events --------------------- */
  /**
   * Dispatch a cancel event.
   *
   * @example
   * ```ts
   * editor.cancel()
   * ```
   *
   * @public
   */
  cancel() {
    this.dispatch({ type: "misc", name: "cancel" });
    return this;
  }
  /**
   * Dispatch an interrupt event.
   *
   * @example
   * ```ts
   * editor.interrupt()
   * ```
   *
   * @public
   */
  interrupt() {
    this.dispatch({ type: "misc", name: "interrupt" });
    return this;
  }
  /**
   * Dispatch a complete event.
   *
   * @example
   * ```ts
   * editor.complete()
   * ```
   *
   * @public
   */
  complete() {
    this.dispatch({ type: "misc", name: "complete" });
    return this;
  }
  /**
   * Dispatch a pointer move event in the current position of the pointer. This is useful when
   * external circumstances have changed (e.g. the camera moved or a shape was moved) and you want
   * the current interaction to respond to that change.
   *
   * @example
   * ```ts
   * editor.updatePointer()
   * ```
   *
   * @param options - The options for updating the pointer.
   * @returns The editor instance.
   * @public
   */
  updatePointer(options2) {
    const event = {
      type: "pointer",
      target: "canvas",
      name: "pointer_move",
      point: (options2 == null ? void 0 : options2.point) ?? // weird but true: what `inputs` calls screen-space is actually viewport space. so
      // we need to convert back into true screen space first. we should fix this...
      Vec.Add(
        this.inputs.getCurrentScreenPoint(),
        this.store.unsafeGetWithoutCapture(TLINSTANCE_ID).screenBounds
      ),
      pointerId: (options2 == null ? void 0 : options2.pointerId) ?? 0,
      button: (options2 == null ? void 0 : options2.button) ?? 0,
      isPen: (options2 == null ? void 0 : options2.isPen) ?? this.inputs.getIsPen(),
      shiftKey: (options2 == null ? void 0 : options2.shiftKey) ?? this.inputs.getShiftKey(),
      altKey: (options2 == null ? void 0 : options2.altKey) ?? this.inputs.getAltKey(),
      ctrlKey: (options2 == null ? void 0 : options2.ctrlKey) ?? this.inputs.getCtrlKey(),
      metaKey: (options2 == null ? void 0 : options2.metaKey) ?? this.inputs.getMetaKey(),
      accelKey: false
    };
    event.accelKey = (options2 == null ? void 0 : options2.accelKey) ?? this.inputs.getAccelKey();
    if (options2 == null ? void 0 : options2.immediate) {
      this._flushEventForTick(event);
    } else {
      this.dispatch(event);
    }
    return this;
  }
  /**
   * Puts the editor into focused mode.
   *
   * This makes the editor eligible to receive keyboard events and some pointer events (move, wheel).
   *
   * @example
   * ```ts
   * editor.focus()
   * ```
   *
   * By default this also dispatches a 'focus' event to the container element. To prevent this, pass `focusContainer: false`.
   *
   * @example
   * ```ts
   * editor.focus({ focusContainer: false })
   * ```
   *
   * @public
   */
  focus({ focusContainer = true } = {}) {
    if (this.getIsFocused()) return this;
    if (focusContainer) this.focusManager.focus();
    this.updateInstanceState({ isFocused: true });
    return this;
  }
  /**
   * Switches off the editor's focused mode.
   *
   * This makes the editor ignore keyboard events and some pointer events (move, wheel).
   *
   * @example
   * ```ts
   * editor.blur()
   * ```
   * By default this also dispatches a 'blur' event to the container element. To prevent this, pass `blurContainer: false`.
   *
   * @example
   * ```ts
   * editor.blur({ blurContainer: false })
   * ```
   *
   * @public
   */
  blur({ blurContainer = true } = {}) {
    if (!this.getIsFocused()) return this;
    if (blurContainer) {
      this.focusManager.blur();
    } else {
      this.complete();
    }
    this.updateInstanceState({ isFocused: false });
    return this;
  }
  getIsFocused() {
    return this.getInstanceState().isFocused;
  }
  getIsReadonly() {
    return this.getInstanceState().isReadonly;
  }
  /**
   * @public
   * @returns a snapshot of the store's UI and document state
   */
  getSnapshot() {
    return getSnapshot(this.store);
  }
  /**
   * Loads a snapshot into the editor.
   * @param snapshot - The snapshot to load.
   * @param opts - The options for loading the snapshot.
   * @returns
   */
  loadSnapshot(snapshot, opts) {
    loadSnapshot(this.store, snapshot, opts);
    return this;
  }
  _zoomToFitPageContentAt100Percent() {
    const bounds = this.getCurrentPageBounds();
    if (bounds) {
      this.zoomToBounds(bounds, { immediate: true, targetZoom: this.getBaseZoom() });
    }
  }
  _navigateToDeepLink(deepLink) {
    this.run(() => {
      switch (deepLink.type) {
        case "page": {
          const page = this.getPage(deepLink.pageId);
          if (page) {
            this.setCurrentPage(page);
          }
          this._zoomToFitPageContentAt100Percent();
          return;
        }
        case "shapes": {
          const allShapes = compact(deepLink.shapeIds.map((id) => this.getShape(id)));
          const byPage = {};
          for (const shape of allShapes) {
            const pageId2 = this.getAncestorPageId(shape);
            if (!pageId2) continue;
            byPage[pageId2] ?? (byPage[pageId2] = []);
            byPage[pageId2].push(shape);
          }
          const [pageId, shapes] = Object.entries(byPage).sort(
            ([_, a], [__, b]) => b.length - a.length
          )[0] ?? ["", []];
          if (!pageId || !shapes.length) {
            this._zoomToFitPageContentAt100Percent();
          } else {
            this.setCurrentPage(pageId);
            const bounds = Box.Common(shapes.map((s) => this.getShapePageBounds(s)));
            this.zoomToBounds(bounds, { immediate: true, targetZoom: this.getBaseZoom() });
          }
          return;
        }
        case "viewport": {
          if (deepLink.pageId) {
            if (!this.getPage(deepLink.pageId)) {
              this._zoomToFitPageContentAt100Percent();
              return;
            }
            this.setCurrentPage(deepLink.pageId);
          }
          this.zoomToBounds(deepLink.bounds, { immediate: true, inset: 0 });
          return;
        }
        default:
          exhaustiveSwitchError(deepLink);
      }
    });
  }
  /**
   * Handles navigating to the content specified by the query param in the given URL.
   *
   * Use {@link Editor.createDeepLink} to create a URL with a deep link query param.
   *
   * If no URL is provided, it will look for the param in the current `window.location.href`.
   *
   * @example
   * ```ts
   * editor.navigateToDeepLink()
   * ```
   *
   * The default parameter name is 'd'. You can override this by providing the `param` option.
   *
   * @example
   * ```ts
   * // disable page parameter and change viewport parameter to 'c'
   * editor.navigateToDeepLink({
   *   param: 'x',
   *   url: 'https://my-app.com/my-document?x=200.12.454.23.xyz123',
   * })
   * ```
   *
   * @param opts - Options for loading the state from the URL.
   */
  navigateToDeepLink(opts) {
    if (opts && "type" in opts) {
      this._navigateToDeepLink(opts);
      return this;
    }
    const url = new URL((opts == null ? void 0 : opts.url) ?? window.location.href);
    const deepLinkString = url.searchParams.get((opts == null ? void 0 : opts.param) ?? "d");
    if (!deepLinkString) {
      this._zoomToFitPageContentAt100Percent();
      return this;
    }
    try {
      this._navigateToDeepLink(parseDeepLinkString(deepLinkString));
    } catch (e) {
      console.warn(e);
      this._zoomToFitPageContentAt100Percent();
    }
    return this;
  }
  /**
   * Turns the given URL into a deep link by adding a query parameter.
   *
   * e.g. `https://my-app.com/my-document?d=100.100.200.200.xyz123`
   *
   * If no URL is provided, it will use the current `window.location.href`.
   *
   * @example
   * ```ts
   * // create a deep link to the current page + viewport
   * navigator.clipboard.writeText(editor.createDeepLink())
   * ```
   *
   * You can link to a particular set of shapes by providing a `to` parameter.
   *
   * @example
   * ```ts
   * // create a deep link to the set of currently selected shapes
   * navigator.clipboard.writeText(editor.createDeepLink({
   *   to: { type: 'selection', shapeIds: editor.getSelectedShapeIds() }
   * }))
   * ```
   *
   * The default query param is 'd'. You can override this by providing a `param` parameter.
   *
   * @example
   * ```ts
   * // Use `x` as the param name instead
   * editor.createDeepLink({ param: 'x' })
   * ```
   *
   * @param opts - Options for adding the state to the URL.
   * @returns the updated URL
   */
  createDeepLink(opts) {
    const url = new URL((opts == null ? void 0 : opts.url) ?? window.location.href);
    url.searchParams.set(
      (opts == null ? void 0 : opts.param) ?? "d",
      createDeepLinkString(
        (opts == null ? void 0 : opts.to) ?? {
          type: "viewport",
          pageId: this.options.maxPages === 1 ? void 0 : this.getCurrentPageId(),
          bounds: this.getViewportPageBounds()
        }
      )
    );
    return url;
  }
  /**
   * Register a listener for changes to a deep link for the current document.
   *
   * You'll typically want to use this indirectly via the {@link TldrawEditorBaseProps.deepLinks} prop on the `<Tldraw />` component.
   *
   * By default this will update `window.location` in place, but you can provide a custom callback
   * to handle state changes on your own.
   *
   * @example
   * ```ts
   * editor.registerDeepLinkListener({
   *   onChange(url) {
   *     window.history.replaceState({}, document.title, url.toString())
   *   }
   * })
   * ```
   *
   * You can also provide a custom URL to update, in which case you must also provide `onChange`.
   *
   * @example
   * ```ts
   * editor.registerDeepLinkListener({
   *   getUrl: () => `https://my-app.com/my-document`,
   *   onChange(url) {
   *     setShareUrl(url.toString())
   *   }
   * })
   * ```
   *
   * By default this will update with a debounce interval of 500ms, but you can provide a custom interval.
   *
   * @example
   * ```ts
   * editor.registerDeepLinkListener({ debounceMs: 1000 })
   * ```
   * The default parameter name is `d`. You can override this by providing a `param` option.
   *
   * @example
   * ```ts
   * editor.registerDeepLinkListener({ param: 'x' })
   * ```
   * @param opts - Options for setting up the listener.
   * @returns a function that will stop the listener.
   */
  registerDeepLinkListener(opts) {
    if ((opts == null ? void 0 : opts.getUrl) && !(opts == null ? void 0 : opts.onChange)) {
      throw Error(
        "[tldraw:urlStateSync] If you specify getUrl, you must also specify the onChange callback."
      );
    }
    const url$ = computed("url with state", () => {
      var _a6, _b3;
      const url = ((_a6 = opts == null ? void 0 : opts.getUrl) == null ? void 0 : _a6.call(opts, this)) ?? window.location.href;
      const urlWithState = this.createDeepLink({
        param: opts == null ? void 0 : opts.param,
        url,
        to: (_b3 = opts == null ? void 0 : opts.getTarget) == null ? void 0 : _b3.call(opts, this)
      });
      return urlWithState.toString();
    });
    const announceChange = (opts == null ? void 0 : opts.onChange) ?? (() => {
      var _a6;
      const url = this.createDeepLink({
        param: opts == null ? void 0 : opts.param,
        to: (_a6 = opts == null ? void 0 : opts.getTarget) == null ? void 0 : _a6.call(opts, this)
      });
      window.history.replaceState({}, document.title, url.toString());
    });
    const scheduleEffect = debounce((execute) => execute(), (opts == null ? void 0 : opts.debounceMs) ?? 500);
    const unlisten = react(
      "update url on state change",
      () => announceChange(new URL(url$.get()), this),
      { scheduleEffect }
    );
    return () => {
      unlisten();
      scheduleEffect.cancel();
    };
  }
  /**
   * Prevent a double click event from firing the next time the user clicks
   *
   * @public
   */
  cancelDoubleClick() {
    this._clickManager.cancelDoubleClickTimeout();
  }
  _setShiftKeyTimeout() {
    this.inputs.setShiftKey(false);
    this.dispatch({
      type: "keyboard",
      name: "key_up",
      key: "Shift",
      shiftKey: this.inputs.getShiftKey(),
      ctrlKey: this.inputs.getCtrlKey(),
      altKey: this.inputs.getAltKey(),
      metaKey: this.inputs.getMetaKey(),
      accelKey: this.inputs.getAccelKey(),
      code: "ShiftLeft"
    });
  }
  _setAltKeyTimeout() {
    this.inputs.setAltKey(false);
    this.dispatch({
      type: "keyboard",
      name: "key_up",
      key: "Alt",
      shiftKey: this.inputs.getShiftKey(),
      ctrlKey: this.inputs.getCtrlKey(),
      altKey: this.inputs.getAltKey(),
      metaKey: this.inputs.getMetaKey(),
      accelKey: this.inputs.getAccelKey(),
      code: "AltLeft"
    });
  }
  _setCtrlKeyTimeout() {
    this.inputs.setCtrlKey(false);
    this.dispatch({
      type: "keyboard",
      name: "key_up",
      key: "Ctrl",
      shiftKey: this.inputs.getShiftKey(),
      ctrlKey: this.inputs.getCtrlKey(),
      altKey: this.inputs.getAltKey(),
      metaKey: this.inputs.getMetaKey(),
      accelKey: this.inputs.getAccelKey(),
      code: "ControlLeft"
    });
  }
  _setMetaKeyTimeout() {
    this.inputs.setMetaKey(false);
    this.dispatch({
      type: "keyboard",
      name: "key_up",
      key: "Meta",
      shiftKey: this.inputs.getShiftKey(),
      ctrlKey: this.inputs.getCtrlKey(),
      altKey: this.inputs.getAltKey(),
      metaKey: this.inputs.getMetaKey(),
      accelKey: this.inputs.getAccelKey(),
      code: "MetaLeft"
    });
  }
  /**
   * In tldraw, events are sometimes handled by multiple components. For example, the shapes might
   * have events, but the canvas handles events too. The way that the canvas handles events can
   * interfere with the with the shapes event handlers - for example, it calls `.preventDefault()`
   * on `pointerDown`, which also prevents `click` events from firing on the shapes.
   *
   * You can use `.stopPropagation()` to prevent the event from propagating to the rest of the
   * DOM, but that can impact non-tldraw event handlers set up elsewhere. By using
   * `markEventAsHandled`, you'll stop other parts of tldraw from handling the event without
   * impacting other, non-tldraw event handlers. See also {@link Editor.wasEventAlreadyHandled}.
   *
   * @public
   */
  markEventAsHandled(e) {
    const nativeEvent = "nativeEvent" in e ? e.nativeEvent : e;
    this.handledEvents.add(nativeEvent);
  }
  /**
   * Checks if an event has already been handled. See {@link Editor.markEventAsHandled}.
   *
   * @public
   */
  wasEventAlreadyHandled(e) {
    const nativeEvent = "nativeEvent" in e ? e.nativeEvent : e;
    return this.handledEvents.has(nativeEvent);
  }
  /**
   * Dispatch an event to the editor.
   *
   * @example
   * ```ts
   * editor.dispatch(myPointerEvent)
   * ```
   *
   * @param info - The event info.
   *
   * @public
   */
  dispatch(info) {
    this._pendingEventsForNextTick.push(info);
    if (!(info.type === "pointer" && info.name === "pointer_move" || info.type === "wheel" || info.type === "pinch")) {
      this._flushEventsForTick(0);
    }
    return this;
  }
  _flushEventsForTick(elapsed) {
    this.run(() => {
      if (this._pendingEventsForNextTick.length > 0) {
        const events = [...this._pendingEventsForNextTick];
        this._pendingEventsForNextTick.length = 0;
        for (const info of events) {
          this._flushEventForTick(info);
        }
      }
      if (elapsed > 0) {
        this.root.handleEvent({ type: "misc", name: "tick", elapsed });
      }
      this.scribbles.tick(elapsed);
    });
  }
  _flushEventForTick(info) {
    if (this.getCrashingError()) return this;
    this.emit("before-event", info);
    const { inputs } = this;
    const { type } = info;
    if (info.type === "misc") {
      if (info.name === "cancel" || info.name === "complete") {
        this.inputs.setIsDragging(false);
        if (this.inputs.getIsPanning()) {
          this.inputs.setIsPanning(false);
          this.inputs.setIsSpacebarPanning(false);
          this.setCursor({ type: this._prevCursor, rotation: 0 });
        }
      }
      this.root.handleEvent(info);
      this.emit("event", info);
      return;
    }
    if (info.shiftKey) {
      clearTimeout(this._shiftKeyTimeout);
      this._shiftKeyTimeout = -1;
      inputs.setShiftKey(true);
    } else if (!info.shiftKey && inputs.getShiftKey() && this._shiftKeyTimeout === -1) {
      this._shiftKeyTimeout = this.timers.setTimeout(this._setShiftKeyTimeout, 150);
    }
    if (info.altKey) {
      clearTimeout(this._altKeyTimeout);
      this._altKeyTimeout = -1;
      inputs.setAltKey(true);
    } else if (!info.altKey && inputs.getAltKey() && this._altKeyTimeout === -1) {
      this._altKeyTimeout = this.timers.setTimeout(this._setAltKeyTimeout, 150);
    }
    if (info.ctrlKey) {
      clearTimeout(this._ctrlKeyTimeout);
      this._ctrlKeyTimeout = -1;
      inputs.setCtrlKey(true);
    } else if (!info.ctrlKey && inputs.getCtrlKey() && this._ctrlKeyTimeout === -1) {
      this._ctrlKeyTimeout = this.timers.setTimeout(this._setCtrlKeyTimeout, 150);
    }
    if (info.metaKey) {
      clearTimeout(this._metaKeyTimeout);
      this._metaKeyTimeout = -1;
      inputs.setMetaKey(true);
    } else if (!info.metaKey && inputs.getMetaKey() && this._metaKeyTimeout === -1) {
      this._metaKeyTimeout = this.timers.setTimeout(this._setMetaKeyTimeout, 150);
    }
    if (!inputs.getIsPointing()) {
      inputs.setIsDragging(false);
    }
    const instanceState = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID);
    const pageState = this.store.get(this._getCurrentPageStateId());
    const cameraOptions = this._cameraOptions.__unsafe__getWithoutCapture();
    switch (type) {
      case "pinch": {
        if (cameraOptions.isLocked) return;
        clearTimeout(this._longPressTimeout);
        this.inputs.updateFromEvent(info);
        switch (info.name) {
          case "pinch_start": {
            if (inputs.getIsPinching()) return;
            if (!inputs.getIsEditing()) {
              if (!this._selectedShapeIdsAtPointerDown.length) {
                this._selectedShapeIdsAtPointerDown = [...pageState.selectedShapeIds];
              }
              this._didPinch = true;
              inputs.setIsPinching(true);
              this.interrupt();
            }
            this.emit("event", info);
            return;
          }
          case "pinch": {
            if (!inputs.getIsPinching()) return;
            const {
              point: { z = 1 },
              delta: { x: dx, y: dy }
            } = info;
            const { x, y } = Vec.SubXY(
              info.point,
              instanceState.screenBounds.x,
              instanceState.screenBounds.y
            );
            this.stopCameraAnimation();
            if (instanceState.followingUserId) {
              this.stopFollowingUser();
            }
            const { x: cx, y: cy, z: cz } = unsafe__withoutCapture(() => this.getCamera());
            const { panSpeed } = cameraOptions;
            this._setCamera(
              new Vec(
                cx + dx * panSpeed / cz - x / cz + x / z,
                cy + dy * panSpeed / cz - y / cz + y / z,
                z
              ),
              { immediate: true }
            );
            this.emit("event", info);
            return;
          }
          case "pinch_end": {
            if (!inputs.getIsPinching()) return this;
            inputs.setIsPinching(false);
            const { _selectedShapeIdsAtPointerDown: shapesToReselect } = this;
            this.setSelectedShapes(this._selectedShapeIdsAtPointerDown);
            this._selectedShapeIdsAtPointerDown = [];
            if (this._didPinch) {
              this._didPinch = false;
              if (shapesToReselect.length > 0) {
                this.once("tick", () => {
                  if (!this._didPinch) {
                    this.setSelectedShapes(shapesToReselect);
                  }
                });
              }
            }
            this.emit("event", info);
            return;
          }
        }
      }
      case "wheel": {
        if (cameraOptions.isLocked) return;
        this.inputs.updateFromEvent(info);
        const { panSpeed, zoomSpeed } = cameraOptions;
        let wheelBehavior = cameraOptions.wheelBehavior;
        const inputMode = this.user.getUserPreferences().inputMode;
        if (inputMode !== null) {
          wheelBehavior = inputMode === "trackpad" ? "pan" : "zoom";
        }
        if (wheelBehavior !== "none") {
          this.stopCameraAnimation();
          if (instanceState.followingUserId) {
            this.stopFollowingUser();
          }
          const { x: cx, y: cy, z: cz } = unsafe__withoutCapture(() => this.getCamera());
          const { x: dx, y: dy, z: dz = 0 } = info.delta;
          let behavior = wheelBehavior;
          if (info.ctrlKey) behavior = wheelBehavior === "pan" ? "zoom" : "pan";
          switch (behavior) {
            case "zoom": {
              const { x, y } = this.inputs.getCurrentScreenPoint();
              let delta = dz;
              if (wheelBehavior === "zoom") {
                if (Math.abs(dy) > 10) {
                  delta = 10 * Math.sign(dy) / 100;
                } else {
                  delta = dy / 100;
                }
              }
              const zoom = cz + (delta ?? 0) * zoomSpeed * cz;
              this._setCamera(new Vec(cx + x / zoom - x / cz, cy + y / zoom - y / cz, zoom), {
                immediate: true
              });
              this.maybeTrackPerformance("Zooming");
              this.root.handleEvent(info);
              this.emit("event", info);
              return;
            }
            case "pan": {
              this._setCamera(new Vec(cx + dx * panSpeed / cz, cy + dy * panSpeed / cz, cz), {
                immediate: true
              });
              this.maybeTrackPerformance("Panning");
              this.root.handleEvent(info);
              this.emit("event", info);
              return;
            }
          }
        }
        break;
      }
      case "pointer": {
        if (inputs.getIsPinching()) return;
        this.inputs.updateFromEvent(info);
        const { isPen } = info;
        const { isPenMode } = instanceState;
        switch (info.name) {
          case "pointer_down": {
            if (isPenMode && !isPen) return;
            if (!this.inputs.getIsPanning()) {
              this._longPressTimeout = this.timers.setTimeout(() => {
                const vsb = this.getViewportScreenBounds();
                this.dispatch({
                  ...info,
                  // important! non-obvious!! the screenpoint was adjusted using the
                  // viewport bounds, and will be again when this event is handled...
                  // so we need to counter-adjust from the stored value so that the
                  // new value is set correctly.
                  point: this.inputs.getOriginScreenPoint().clone().addXY(vsb.x, vsb.y),
                  name: "long_press"
                });
              }, this.options.longPressDurationMs);
            }
            this._selectedShapeIdsAtPointerDown = this.getSelectedShapeIds();
            if (info.button === LEFT_MOUSE_BUTTON) this.capturedPointerId = info.pointerId;
            inputs.buttons.add(info.button);
            inputs.setIsPointing(true);
            inputs.setIsDragging(false);
            if (!isPenMode && isPen) this.updateInstanceState({ isPenMode: true });
            if (info.button === STYLUS_ERASER_BUTTON) {
              this._restoreToolId = this.getCurrentToolId();
              this.complete();
              this.setCurrentTool("eraser");
            } else if (info.button === MIDDLE_MOUSE_BUTTON) {
              if (!this.inputs.getIsPanning()) {
                this._prevCursor = this.getInstanceState().cursor.type;
              }
              this.inputs.setIsPanning(true);
              clearTimeout(this._longPressTimeout);
            }
            if (this.inputs.getIsPanning()) {
              this.stopCameraAnimation();
              this.setCursor({ type: "grabbing", rotation: 0 });
              return this;
            }
            break;
          }
          case "pointer_move": {
            if (!isPen && isPenMode) return;
            const { x: cx, y: cy, z: cz } = unsafe__withoutCapture(() => this.getCamera());
            if (this.inputs.getIsPanning() && this.inputs.getIsPointing()) {
              const currentScreenPoint = this.inputs.getCurrentScreenPoint();
              const previousScreenPoint = this.inputs.getPreviousScreenPoint();
              const offset4 = Vec.Sub(currentScreenPoint, previousScreenPoint);
              this.setCamera(new Vec(cx + offset4.x / cz, cy + offset4.y / cz, cz), {
                immediate: true
              });
              this.maybeTrackPerformance("Panning");
              return;
            }
            if (inputs.getIsPointing() && !inputs.getIsDragging() && Vec.Dist2(inputs.getOriginPagePoint(), inputs.getCurrentPagePoint()) * this.getZoomLevel() > (instanceState.isCoarsePointer ? this.options.coarseDragDistanceSquared : this.options.dragDistanceSquared) / cz) {
              inputs.setIsDragging(true);
              clearTimeout(this._longPressTimeout);
            }
            break;
          }
          case "pointer_up": {
            inputs.setIsDragging(false);
            inputs.setIsPointing(false);
            clearTimeout(this._longPressTimeout);
            inputs.buttons.delete(info.button);
            if (instanceState.isPenMode && !isPen) return;
            if (this.capturedPointerId === info.pointerId) {
              this.capturedPointerId = null;
              info.button = 0;
            }
            if (inputs.getIsPanning()) {
              if (!inputs.keys.has("Space")) {
                inputs.setIsPanning(false);
                inputs.setIsSpacebarPanning(false);
              }
              const slideDirection = this.inputs.getPointerVelocity();
              const slideSpeed = Math.min(2, slideDirection.len());
              switch (info.button) {
                case LEFT_MOUSE_BUTTON: {
                  this.setCursor({ type: "grab", rotation: 0 });
                  break;
                }
                case MIDDLE_MOUSE_BUTTON: {
                  if (this.inputs.keys.has(" ")) {
                    this.setCursor({ type: "grab", rotation: 0 });
                  } else {
                    this.setCursor({ type: this._prevCursor, rotation: 0 });
                  }
                }
              }
              if (slideSpeed > 0) {
                this.slideCamera({ speed: slideSpeed, direction: slideDirection });
              }
            } else {
              if (info.button === STYLUS_ERASER_BUTTON) {
                this.complete();
                this.setCurrentTool(this._restoreToolId);
              }
            }
            break;
          }
        }
        break;
      }
      case "keyboard": {
        if (info.key === "ShiftRight") info.key = "ShiftLeft";
        if (info.key === "AltRight") info.key = "AltLeft";
        if (info.code === "ControlRight") info.code = "ControlLeft";
        if (info.code === "MetaRight") info.code = "MetaLeft";
        switch (info.name) {
          case "key_down": {
            inputs.keys.add(info.code);
            if (this.options.spacebarPanning) {
              if (info.code === "Space" && !info.ctrlKey) {
                if (!this.inputs.getIsPanning()) {
                  this._prevCursor = instanceState.cursor.type;
                }
                this.inputs.setIsPanning(true);
                this.inputs.setIsSpacebarPanning(true);
                clearTimeout(this._longPressTimeout);
                this.setCursor({
                  type: this.inputs.getIsPointing() ? "grabbing" : "grab",
                  rotation: 0
                });
              }
              if (this.inputs.getIsSpacebarPanning()) {
                let offset4;
                switch (info.code) {
                  case "ArrowUp": {
                    offset4 = new Vec(0, -1);
                    break;
                  }
                  case "ArrowRight": {
                    offset4 = new Vec(1, 0);
                    break;
                  }
                  case "ArrowDown": {
                    offset4 = new Vec(0, 1);
                    break;
                  }
                  case "ArrowLeft": {
                    offset4 = new Vec(-1, 0);
                    break;
                  }
                }
                if (offset4) {
                  const bounds = this.getViewportPageBounds();
                  const next = bounds.clone().translate(offset4.mulV({ x: bounds.w, y: bounds.h }));
                  this._animateToViewport(next, { animation: { duration: 320 } });
                }
              }
            }
            break;
          }
          case "key_up": {
            inputs.keys.delete(info.code);
            if (this.options.spacebarPanning) {
              if (info.code === "Space") {
                if (this.inputs.buttons.has(MIDDLE_MOUSE_BUTTON)) {
                } else {
                  this.inputs.setIsPanning(false);
                  this.inputs.setIsSpacebarPanning(false);
                  this.setCursor({ type: this._prevCursor, rotation: 0 });
                }
              }
            }
            break;
          }
          case "key_repeat": {
            break;
          }
        }
        break;
      }
    }
    if (info.type === "pointer") {
      if (info.button === MIDDLE_MOUSE_BUTTON) {
        info.name = "middle_click";
      } else if (info.button === RIGHT_MOUSE_BUTTON) {
        info.name = "right_click";
      }
      const { isPenMode } = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID);
      if (info.isPen === isPenMode) {
        const clickInfo = this._clickManager.handlePointerEvent(info);
        if (info.name !== clickInfo.name) {
          this.root.handleEvent(info);
          this.emit("event", info);
          this.root.handleEvent(clickInfo);
          this.emit("event", clickInfo);
          return;
        }
      }
    }
    this.root.handleEvent(info);
    this.emit("event", info);
    if (info.type === "pointer" && info.name === "pointer_down") {
      this.menus.clearOpenMenus();
    }
    return this;
  }
  /** @internal */
  maybeTrackPerformance(name) {
    if (debugFlags.measurePerformance.get()) {
      if (this.performanceTracker.isStarted()) {
        clearTimeout(this.performanceTrackerTimeout);
      } else {
        this.performanceTracker.start(name);
      }
      this.performanceTrackerTimeout = this.timers.setTimeout(() => {
        this.performanceTracker.stop();
      }, 50);
    }
  }
};
_init10 = __decoratorStart10(_a3);
__decorateElement10(_init10, 1, "getIsShapeHiddenCache", _getIsShapeHiddenCache_dec, Editor);
__decorateElement10(_init10, 1, "canUndo", _canUndo_dec, Editor);
__decorateElement10(_init10, 1, "canRedo", _canRedo_dec, Editor);
__decorateElement10(_init10, 1, "getPath", _getPath_dec, Editor);
__decorateElement10(_init10, 1, "getCurrentTool", _getCurrentTool_dec, Editor);
__decorateElement10(_init10, 1, "getCurrentToolId", _getCurrentToolId_dec, Editor);
__decorateElement10(_init10, 1, "getDocumentSettings", _getDocumentSettings_dec, Editor);
__decorateElement10(_init10, 1, "getInstanceState", _getInstanceState_dec, Editor);
__decorateElement10(_init10, 1, "getPageStates", _getPageStates_dec, Editor);
__decorateElement10(_init10, 1, "_getPageStatesQuery", __getPageStatesQuery_dec, Editor);
__decorateElement10(_init10, 1, "getCurrentPageState", _getCurrentPageState_dec, Editor);
__decorateElement10(_init10, 1, "_getCurrentPageStateId", __getCurrentPageStateId_dec, Editor);
__decorateElement10(_init10, 1, "getSelectedShapeIds", _getSelectedShapeIds_dec, Editor);
__decorateElement10(_init10, 1, "getSelectedShapes", _getSelectedShapes_dec, Editor);
__decorateElement10(_init10, 1, "getCurrentPageShapesInReadingOrder", _getCurrentPageShapesInReadingOrder_dec, Editor);
__decorateElement10(_init10, 1, "getOnlySelectedShapeId", _getOnlySelectedShapeId_dec, Editor);
__decorateElement10(_init10, 1, "getOnlySelectedShape", _getOnlySelectedShape_dec, Editor);
__decorateElement10(_init10, 1, "getSelectionPageBounds", _getSelectionPageBounds_dec, Editor);
__decorateElement10(_init10, 1, "getSelectionRotation", _getSelectionRotation_dec, Editor);
__decorateElement10(_init10, 1, "getSelectionRotatedPageBounds", _getSelectionRotatedPageBounds_dec, Editor);
__decorateElement10(_init10, 1, "getSelectionRotatedScreenBounds", _getSelectionRotatedScreenBounds_dec, Editor);
__decorateElement10(_init10, 1, "getFocusedGroupId", _getFocusedGroupId_dec, Editor);
__decorateElement10(_init10, 1, "getFocusedGroup", _getFocusedGroup_dec, Editor);
__decorateElement10(_init10, 1, "getEditingShapeId", _getEditingShapeId_dec, Editor);
__decorateElement10(_init10, 1, "getEditingShape", _getEditingShape_dec, Editor);
__decorateElement10(_init10, 1, "getRichTextEditor", _getRichTextEditor_dec, Editor);
__decorateElement10(_init10, 1, "getHoveredShapeId", _getHoveredShapeId_dec, Editor);
__decorateElement10(_init10, 1, "getHoveredShape", _getHoveredShape_dec, Editor);
__decorateElement10(_init10, 1, "getHintingShapeIds", _getHintingShapeIds_dec, Editor);
__decorateElement10(_init10, 1, "getHintingShape", _getHintingShape_dec, Editor);
__decorateElement10(_init10, 1, "getErasingShapeIds", _getErasingShapeIds_dec, Editor);
__decorateElement10(_init10, 1, "getErasingShapes", _getErasingShapes_dec, Editor);
__decorateElement10(_init10, 1, "_unsafe_getCameraId", __unsafe_getCameraId_dec, Editor);
__decorateElement10(_init10, 1, "getCamera", _getCamera_dec, Editor);
__decorateElement10(_init10, 1, "getViewportPageBoundsForFollowing", _getViewportPageBoundsForFollowing_dec, Editor);
__decorateElement10(_init10, 1, "getCameraForFollowing", _getCameraForFollowing_dec, Editor);
__decorateElement10(_init10, 1, "getZoomLevel", _getZoomLevel_dec, Editor);
__decorateElement10(_init10, 1, "getDebouncedZoomLevel", _getDebouncedZoomLevel_dec, Editor);
__decorateElement10(_init10, 1, "_getAboveDebouncedZoomThreshold", __getAboveDebouncedZoomThreshold_dec, Editor);
__decorateElement10(_init10, 1, "getEfficientZoomLevel", _getEfficientZoomLevel_dec, Editor);
__decorateElement10(_init10, 1, "getViewportScreenBounds", _getViewportScreenBounds_dec, Editor);
__decorateElement10(_init10, 1, "getViewportScreenCenter", _getViewportScreenCenter_dec, Editor);
__decorateElement10(_init10, 1, "getViewportPageBounds", _getViewportPageBounds_dec, Editor);
__decorateElement10(_init10, 1, "_getCollaboratorsQuery", __getCollaboratorsQuery_dec, Editor);
__decorateElement10(_init10, 1, "getCollaborators", _getCollaborators_dec, Editor);
__decorateElement10(_init10, 1, "getCollaboratorsOnCurrentPage", _getCollaboratorsOnCurrentPage_dec, Editor);
__decorateElement10(_init10, 1, "getRenderingShapes", _getRenderingShapes_dec, Editor);
__decorateElement10(_init10, 1, "_getAllPagesQuery", __getAllPagesQuery_dec, Editor);
__decorateElement10(_init10, 1, "getPages", _getPages_dec, Editor);
__decorateElement10(_init10, 1, "getCurrentPageId", _getCurrentPageId_dec, Editor);
__decorateElement10(_init10, 1, "getCurrentPageShapeIdsSorted", _getCurrentPageShapeIdsSorted_dec, Editor);
__decorateElement10(_init10, 1, "_getAllAssetsQuery", __getAllAssetsQuery_dec, Editor);
__decorateElement10(_init10, 1, "_getShapeHandlesCache", __getShapeHandlesCache_dec, Editor);
__decorateElement10(_init10, 1, "_getShapePageTransformCache", __getShapePageTransformCache_dec, Editor);
__decorateElement10(_init10, 1, "_getShapePageBoundsCache", __getShapePageBoundsCache_dec, Editor);
__decorateElement10(_init10, 1, "_getShapeClipPathCache", __getShapeClipPathCache_dec, Editor);
__decorateElement10(_init10, 1, "_getShapeMaskCache", __getShapeMaskCache_dec, Editor);
__decorateElement10(_init10, 1, "_getShapeMaskedPageBoundsCache", __getShapeMaskedPageBoundsCache_dec, Editor);
__decorateElement10(_init10, 1, "getNotVisibleShapes", _getNotVisibleShapes_dec, Editor);
__decorateElement10(_init10, 1, "getCulledShapes", _getCulledShapes_dec, Editor);
__decorateElement10(_init10, 1, "getCurrentPageBounds", _getCurrentPageBounds_dec, Editor);
__decorateElement10(_init10, 1, "getCurrentPageShapes", _getCurrentPageShapes_dec, Editor);
__decorateElement10(_init10, 1, "getCurrentPageShapesSorted", _getCurrentPageShapesSorted_dec, Editor);
__decorateElement10(_init10, 1, "getCurrentPageRenderingShapesSorted", _getCurrentPageRenderingShapesSorted_dec, Editor);
__decorateElement10(_init10, 1, "_getBindingsIndexCache", __getBindingsIndexCache_dec, Editor);
__decorateElement10(_init10, 1, "_getSelectionSharedStyles", __getSelectionSharedStyles_dec, Editor);
__decorateElement10(_init10, 1, "getSharedStyles", _getSharedStyles_dec, Editor);
__decorateElement10(_init10, 1, "getSharedOpacity", _getSharedOpacity_dec, Editor);
__decorateElement10(_init10, 1, "getIsFocused", _getIsFocused_dec, Editor);
__decorateElement10(_init10, 1, "getIsReadonly", _getIsReadonly_dec, Editor);
__decorateElement10(_init10, 1, "_setShiftKeyTimeout", __setShiftKeyTimeout_dec, Editor);
__decorateElement10(_init10, 1, "_setAltKeyTimeout", __setAltKeyTimeout_dec, Editor);
__decorateElement10(_init10, 1, "_setCtrlKeyTimeout", __setCtrlKeyTimeout_dec, Editor);
__decorateElement10(_init10, 1, "_setMetaKeyTimeout", __setMetaKeyTimeout_dec, Editor);
__decoratorMetadata10(_init10, Editor);
function alertMaxShapes(editor, pageId = editor.getCurrentPageId()) {
  const name = editor.getPage(pageId).name;
  editor.emit("max-shapes", { name, pageId, count: editor.options.maxShapesPerPage });
}
function applyPartialToRecordWithProps(prev, partial) {
  if (!partial) return prev;
  let next = null;
  const entries = Object.entries(partial);
  for (let i = 0, n = entries.length; i < n; i++) {
    const [k, v] = entries[i];
    if (v === void 0) continue;
    if (k === "id" || k === "type" || k === "typeName") continue;
    if (v === prev[k]) continue;
    if (!next) next = { ...prev };
    if (k === "props" || k === "meta") {
      next[k] = { ...prev[k] };
      for (const [nextKey, nextValue] of Object.entries(v)) {
        ;
        next[k][nextKey] = nextValue;
      }
      continue;
    }
    ;
    next[k] = v;
  }
  if (!next) return prev;
  return next;
}
function pushShapeWithDescendants(editor, id, result) {
  const shape = editor.getShape(id);
  if (!shape) return;
  result.push(shape);
  const childIds = editor.getSortedChildIdsForParent(id);
  for (let i = 0, n = childIds.length; i < n; i++) {
    pushShapeWithDescendants(editor, childIds[i], result);
  }
}
function withIsolatedShapes(editor, shapeIds, callback) {
  let result;
  editor.run(
    () => {
      const changes = editor.store.extractingChanges(() => {
        const bindingsWithBoth = /* @__PURE__ */ new Set();
        const bindingsToRemove = /* @__PURE__ */ new Set();
        for (const shapeId of shapeIds) {
          const shape = editor.getShape(shapeId);
          if (!shape) continue;
          for (const binding of editor.getBindingsInvolvingShape(shapeId)) {
            const hasFrom = shapeIds.has(binding.fromId);
            const hasTo = shapeIds.has(binding.toId);
            if (hasFrom && hasTo) {
              bindingsWithBoth.add(binding.id);
              continue;
            }
            if (!hasFrom || !hasTo) {
              bindingsToRemove.add(binding.id);
            }
          }
        }
        editor.deleteBindings([...bindingsToRemove], { isolateShapes: true });
        try {
          result = Result.ok(callback(bindingsWithBoth));
        } catch (error) {
          result = Result.err(error);
        }
      });
      editor.store.applyDiff(reverseRecordsDiff(changes), { runCallbacks: false });
    },
    { history: "ignore" }
  );
  if (result.ok) {
    return result.value;
  } else {
    throw result.error;
  }
}
function getCameraFitXFitY(editor, cameraOptions) {
  if (!cameraOptions.constraints) throw Error("Should have constraints here");
  const {
    padding: { x: px, y: py }
  } = cameraOptions.constraints;
  const vsb = editor.getViewportScreenBounds();
  const bounds = Box.From(cameraOptions.constraints.bounds);
  const zx = (vsb.w - px * 2) / bounds.w;
  const zy = (vsb.h - py * 2) / bounds.h;
  return { zx, zy };
}

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/useIsDarkMode.mjs
function useIsDarkMode() {
  const editor = useEditor();
  const exportContext = useSvgExportContext();
  return useValue("isDarkMode", () => (exportContext == null ? void 0 : exportContext.isDarkMode) ?? editor.user.getIsDarkMode(), [
    exportContext,
    editor
  ]);
}

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/useCursor.mjs
var CORNER_SVG = `<path d='m19.7432 17.0869-4.072 4.068 2.829 2.828-8.473-.013-.013-8.47 2.841 2.842 4.075-4.068 1.414-1.415-2.844-2.842h8.486v8.484l-2.83-2.827z' fill='%23fff'/><path d='m18.6826 16.7334-4.427 4.424 1.828 1.828-5.056-.016-.014-5.054 1.842 1.841 4.428-4.422 2.474-2.475-1.844-1.843h5.073v5.071l-1.83-1.828z' fill='%23000'/>`;
var EDGE_SVG = `<path d='m9 17.9907v.005l5.997 5.996.001-3.999h1.999 2.02v4l5.98-6.001-5.98-5.999.001 4.019-2.021.002h-2l.001-4.022zm1.411.003 3.587-3.588-.001 2.587h3.5 2.521v-2.585l3.565 3.586-3.564 3.585-.001-2.585h-2.521l-3.499-.001-.001 2.586z' fill='%23fff'/><path d='m17.4971 18.9932h2.521v2.586l3.565-3.586-3.565-3.585v2.605h-2.521-3.5v-2.607l-3.586 3.587 3.586 3.586v-2.587z' fill='%23000'/>`;
var ROTATE_CORNER_SVG = `<path d="M22.4789 9.45728L25.9935 12.9942L22.4789 16.5283V14.1032C18.126 14.1502 14.6071 17.6737 14.5675 22.0283H17.05L13.513 25.543L9.97889 22.0283H12.5674C12.6071 16.5691 17.0214 12.1503 22.4789 12.1031L22.4789 9.45728Z" fill="black"/><path fill-rule="evenodd" clip-rule="evenodd" d="M21.4789 7.03223L27.4035 12.9945L21.4789 18.9521V15.1868C18.4798 15.6549 16.1113 18.0273 15.649 21.0284H19.475L13.5128 26.953L7.55519 21.0284H11.6189C12.1243 15.8155 16.2679 11.6677 21.4789 11.1559L21.4789 7.03223ZM22.4789 12.1031C17.0214 12.1503 12.6071 16.5691 12.5674 22.0284H9.97889L13.513 25.543L17.05 22.0284H14.5675C14.5705 21.6896 14.5947 21.3558 14.6386 21.0284C15.1157 17.4741 17.9266 14.6592 21.4789 14.1761C21.8063 14.1316 22.1401 14.1069 22.4789 14.1032V16.5284L25.9935 12.9942L22.4789 9.45729L22.4789 12.1031Z" fill="white"/>`;
function getCursorCss(svg, r, tr2, f, color, hotspotX = 16, hotspotY = 16) {
  const a = (-tr2 - r) * (PI / 180);
  const s = Math.sin(a);
  const c = Math.cos(a);
  const dx = 1 * c - 1 * s;
  const dy = 1 * s + 1 * c;
  return `url("data:image/svg+xml,<svg height='32' width='32' viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg' style='color: ${color};'><defs><filter id='shadow' y='-40%' x='-40%' width='180px' height='180%' color-interpolation-filters='sRGB'><feDropShadow dx='${dx}' dy='${dy}' stdDeviation='1.2' flood-opacity='.5'/></filter></defs><g fill='none' transform='rotate(${r + tr2} 16 16)${f ? ` scale(-1,-1) translate(0, -32)` : ""}' filter='url(%23shadow)'>` + svg.replaceAll(`"`, `'`) + `</g></svg>") ${hotspotX} ${hotspotY}, pointer`;
}
var STATIC_CURSORS = [
  "default",
  "pointer",
  "cross",
  "move",
  "grab",
  "grabbing",
  "text",
  "zoom-in",
  "zoom-out"
];
var CURSORS = {
  none: () => "none",
  "ew-resize": (r, f, c) => getCursorCss(EDGE_SVG, r, 0, f, c),
  "ns-resize": (r, f, c) => getCursorCss(EDGE_SVG, r, 90, f, c),
  "nesw-resize": (r, f, c) => getCursorCss(CORNER_SVG, r, 0, f, c),
  "nwse-resize": (r, f, c) => getCursorCss(CORNER_SVG, r, 90, f, c),
  "nwse-rotate": (r, f, c) => getCursorCss(ROTATE_CORNER_SVG, r, 0, f, c),
  "nesw-rotate": (r, f, c) => getCursorCss(ROTATE_CORNER_SVG, r, 90, f, c),
  "senw-rotate": (r, f, c) => getCursorCss(ROTATE_CORNER_SVG, r, 180, f, c),
  "swne-rotate": (r, f, c) => getCursorCss(ROTATE_CORNER_SVG, r, 270, f, c)
};
function getCursor(cursor, rotation = 0, color = "black") {
  return CURSORS[cursor](radiansToDegrees(rotation), false, color);
}
function useCursor() {
  const editor = useEditor();
  const container = useContainer();
  const isDarkMode = useIsDarkMode();
  useQuickReactor(
    "useCursor",
    () => {
      const { type, rotation } = editor.getInstanceState().cursor;
      if (STATIC_CURSORS.includes(type)) {
        container.style.setProperty("--tl-cursor", `var(--tl-cursor-${type})`);
        return;
      }
      container.style.setProperty(
        "--tl-cursor",
        getCursor(type, rotation, isDarkMode ? "white" : "black")
      );
    },
    [editor, container, isDarkMode]
  );
}

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/useDarkMode.mjs
var import_react25 = __toESM(require_react(), 1);
function useDarkMode() {
  const editor = useEditor();
  const container = useContainer();
  const isDarkMode = useIsDarkMode();
  const forceSrgb = useValue(debugFlags.forceSrgb);
  import_react25.default.useEffect(() => {
    if (isDarkMode) {
      container.setAttribute("data-color-mode", "dark");
      container.classList.remove("tl-theme__light");
      container.classList.add("tl-theme__dark");
    } else {
      container.setAttribute("data-color-mode", "light");
      container.classList.remove("tl-theme__dark");
      container.classList.add("tl-theme__light");
    }
    if (forceSrgb) {
      container.classList.add("tl-theme__force-sRGB");
    } else {
      container.classList.remove("tl-theme__force-sRGB");
    }
  }, [editor, container, forceSrgb, isDarkMode]);
}

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/useForceUpdate.mjs
var import_react26 = __toESM(require_react(), 1);
function useForceUpdate() {
  const [_, ss] = (0, import_react26.useState)(0);
  (0, import_react26.useEffect)(() => ss((s) => s + 1), []);
}

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/useLocalStore.mjs
var import_react28 = __toESM(require_react(), 1);

// ../node_modules/@tldraw/editor/dist-esm/lib/config/createTLStore.mjs
var defaultAssetResolve = (asset) => asset.props.src;
var inlineBase64AssetStore = {
  upload: async (_, file) => {
    return { src: await FileHelpers.blobToDataUrl(file) };
  }
};
function createTLSchemaFromUtils(opts) {
  if ("schema" in opts && opts.schema) return opts.schema;
  return createTLSchema({
    shapes: "shapeUtils" in opts && opts.shapeUtils ? utilsToMap(checkShapesAndAddCore(opts.shapeUtils)) : void 0,
    bindings: "bindingUtils" in opts && opts.bindingUtils ? utilsToMap(checkBindings(opts.bindingUtils)) : void 0,
    migrations: "migrations" in opts ? opts.migrations : void 0
  });
}
function createTLStore({
  initialData,
  defaultName = "",
  id,
  assets = inlineBase64AssetStore,
  onMount,
  collaboration,
  ...rest
} = {}) {
  const schema = createTLSchemaFromUtils(rest);
  const store = new Store({
    id,
    schema,
    initialData,
    props: {
      defaultName,
      assets: {
        upload: assets.upload,
        resolve: assets.resolve ?? defaultAssetResolve,
        remove: assets.remove ?? (() => Promise.resolve())
      },
      onMount: (editor) => {
        assert(editor instanceof Editor);
        onMount == null ? void 0 : onMount(editor);
      },
      collaboration
    }
  });
  if (rest.snapshot) {
    if (initialData) throw new Error("Cannot provide both initialData and snapshot");
    loadSnapshot(store, rest.snapshot, { forceOverwriteSessionState: true });
  }
  return store;
}
function utilsToMap(utils) {
  return Object.fromEntries(
    utils.map((s) => [
      s.type,
      {
        props: s.props,
        migrations: s.migrations
      }
    ])
  );
}

// ../node_modules/idb/build/wrap-idb-value.js
var instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);
var idbProxyableTypes;
var cursorAdvanceMethods;
function getIdbProxyableTypes() {
  return idbProxyableTypes || (idbProxyableTypes = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function getCursorAdvanceMethods() {
  return cursorAdvanceMethods || (cursorAdvanceMethods = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
var cursorRequestMap = /* @__PURE__ */ new WeakMap();
var transactionDoneMap = /* @__PURE__ */ new WeakMap();
var transactionStoreNamesMap = /* @__PURE__ */ new WeakMap();
var transformCache = /* @__PURE__ */ new WeakMap();
var reverseTransformCache = /* @__PURE__ */ new WeakMap();
function promisifyRequest(request) {
  const promise = new Promise((resolve, reject) => {
    const unlisten = () => {
      request.removeEventListener("success", success);
      request.removeEventListener("error", error);
    };
    const success = () => {
      resolve(wrap(request.result));
      unlisten();
    };
    const error = () => {
      reject(request.error);
      unlisten();
    };
    request.addEventListener("success", success);
    request.addEventListener("error", error);
  });
  promise.then((value) => {
    if (value instanceof IDBCursor) {
      cursorRequestMap.set(value, request);
    }
  }).catch(() => {
  });
  reverseTransformCache.set(promise, request);
  return promise;
}
function cacheDonePromiseForTransaction(tx) {
  if (transactionDoneMap.has(tx))
    return;
  const done = new Promise((resolve, reject) => {
    const unlisten = () => {
      tx.removeEventListener("complete", complete);
      tx.removeEventListener("error", error);
      tx.removeEventListener("abort", error);
    };
    const complete = () => {
      resolve();
      unlisten();
    };
    const error = () => {
      reject(tx.error || new DOMException("AbortError", "AbortError"));
      unlisten();
    };
    tx.addEventListener("complete", complete);
    tx.addEventListener("error", error);
    tx.addEventListener("abort", error);
  });
  transactionDoneMap.set(tx, done);
}
var idbProxyTraps = {
  get(target, prop, receiver) {
    if (target instanceof IDBTransaction) {
      if (prop === "done")
        return transactionDoneMap.get(target);
      if (prop === "objectStoreNames") {
        return target.objectStoreNames || transactionStoreNamesMap.get(target);
      }
      if (prop === "store") {
        return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
      }
    }
    return wrap(target[prop]);
  },
  set(target, prop, value) {
    target[prop] = value;
    return true;
  },
  has(target, prop) {
    if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
      return true;
    }
    return prop in target;
  }
};
function replaceTraps(callback) {
  idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
  if (func === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype)) {
    return function(storeNames, ...args) {
      const tx = func.call(unwrap(this), storeNames, ...args);
      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
      return wrap(tx);
    };
  }
  if (getCursorAdvanceMethods().includes(func)) {
    return function(...args) {
      func.apply(unwrap(this), args);
      return wrap(cursorRequestMap.get(this));
    };
  }
  return function(...args) {
    return wrap(func.apply(unwrap(this), args));
  };
}
function transformCachableValue(value) {
  if (typeof value === "function")
    return wrapFunction(value);
  if (value instanceof IDBTransaction)
    cacheDonePromiseForTransaction(value);
  if (instanceOfAny(value, getIdbProxyableTypes()))
    return new Proxy(value, idbProxyTraps);
  return value;
}
function wrap(value) {
  if (value instanceof IDBRequest)
    return promisifyRequest(value);
  if (transformCache.has(value))
    return transformCache.get(value);
  const newValue = transformCachableValue(value);
  if (newValue !== value) {
    transformCache.set(value, newValue);
    reverseTransformCache.set(newValue, value);
  }
  return newValue;
}
var unwrap = (value) => reverseTransformCache.get(value);

// ../node_modules/idb/build/index.js
function openDB(name, version2, { blocked, upgrade, blocking, terminated } = {}) {
  const request = indexedDB.open(name, version2);
  const openPromise = wrap(request);
  if (upgrade) {
    request.addEventListener("upgradeneeded", (event) => {
      upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
    });
  }
  if (blocked) {
    request.addEventListener("blocked", (event) => blocked(
      // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
      event.oldVersion,
      event.newVersion,
      event
    ));
  }
  openPromise.then((db) => {
    if (terminated)
      db.addEventListener("close", () => terminated());
    if (blocking) {
      db.addEventListener("versionchange", (event) => blocking(event.oldVersion, event.newVersion, event));
    }
  }).catch(() => {
  });
  return openPromise;
}
function deleteDB(name, { blocked } = {}) {
  const request = indexedDB.deleteDatabase(name);
  if (blocked) {
    request.addEventListener("blocked", (event) => blocked(
      // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
      event.oldVersion,
      event
    ));
  }
  return wrap(request).then(() => void 0);
}
var readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
var writeMethods = ["put", "add", "delete", "clear"];
var cachedMethods = /* @__PURE__ */ new Map();
function getMethod(target, prop) {
  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
    return;
  }
  if (cachedMethods.get(prop))
    return cachedMethods.get(prop);
  const targetFuncName = prop.replace(/FromIndex$/, "");
  const useIndex = prop !== targetFuncName;
  const isWrite = writeMethods.includes(targetFuncName);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))
  ) {
    return;
  }
  const method = async function(storeName, ...args) {
    const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
    let target2 = tx.store;
    if (useIndex)
      target2 = target2.index(args.shift());
    return (await Promise.all([
      target2[targetFuncName](...args),
      isWrite && tx.done
    ]))[0];
  };
  cachedMethods.set(prop, method);
  return method;
}
replaceTraps((oldTraps) => ({
  ...oldTraps,
  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
}));

// ../node_modules/@tldraw/editor/dist-esm/lib/utils/sync/LocalIndexedDb.mjs
var STORE_PREFIX = "TLDRAW_DOCUMENT_v2";
var LEGACY_ASSET_STORE_PREFIX = "TLDRAW_ASSET_STORE_v1";
var dbNameIndexKey = "TLDRAW_DB_NAME_INDEX_v2";
var Table = {
  Records: "records",
  Schema: "schema",
  SessionState: "session_state",
  Assets: "assets"
};
async function openLocalDb(persistenceKey) {
  const storeId = STORE_PREFIX + persistenceKey;
  addDbName(storeId);
  return await openDB(storeId, 4, {
    upgrade(database) {
      if (!database.objectStoreNames.contains(Table.Records)) {
        database.createObjectStore(Table.Records);
      }
      if (!database.objectStoreNames.contains(Table.Schema)) {
        database.createObjectStore(Table.Schema);
      }
      if (!database.objectStoreNames.contains(Table.SessionState)) {
        database.createObjectStore(Table.SessionState);
      }
      if (!database.objectStoreNames.contains(Table.Assets)) {
        database.createObjectStore(Table.Assets);
      }
    }
  });
}
async function migrateLegacyAssetDbIfNeeded(persistenceKey) {
  const databases = window.indexedDB.databases ? (await window.indexedDB.databases()).map((db) => db.name) : getAllIndexDbNames();
  const oldStoreId = LEGACY_ASSET_STORE_PREFIX + persistenceKey;
  const existing = databases.find((dbName) => dbName === oldStoreId);
  if (!existing) return;
  const oldAssetDb = await openDB(oldStoreId, 1, {
    upgrade(database) {
      if (!database.objectStoreNames.contains("assets")) {
        database.createObjectStore("assets");
      }
    }
  });
  if (!oldAssetDb.objectStoreNames.contains("assets")) return;
  const oldTx = oldAssetDb.transaction(["assets"], "readonly");
  const oldAssetStore = oldTx.objectStore("assets");
  const oldAssetsKeys = await oldAssetStore.getAllKeys();
  const oldAssets = await Promise.all(
    oldAssetsKeys.map(async (key) => [key, await oldAssetStore.get(key)])
  );
  await oldTx.done;
  const newDb = await openLocalDb(persistenceKey);
  const newTx = newDb.transaction([Table.Assets], "readwrite");
  const newAssetTable = newTx.objectStore(Table.Assets);
  for (const [key, value] of oldAssets) {
    newAssetTable.put(value, key);
  }
  await newTx.done;
  oldAssetDb.close();
  newDb.close();
  await deleteDB(oldStoreId);
}
var _LocalIndexedDb = class _LocalIndexedDb {
  constructor(persistenceKey) {
    __publicField(this, "getDbPromise");
    __publicField(this, "isClosed", false);
    __publicField(this, "pendingTransactionSet", /* @__PURE__ */ new Set());
    _LocalIndexedDb.connectedInstances.add(this);
    this.getDbPromise = (async () => {
      await migrateLegacyAssetDbIfNeeded(persistenceKey);
      return await openLocalDb(persistenceKey);
    })();
  }
  getDb() {
    return this.getDbPromise;
  }
  /**
   * Wait for any pending transactions to be completed. Useful for tests.
   *
   * @internal
   */
  pending() {
    return Promise.allSettled([this.getDbPromise, ...this.pendingTransactionSet]).then(noop);
  }
  async close() {
    if (this.isClosed) return;
    this.isClosed = true;
    await this.pending();
    (await this.getDb()).close();
    _LocalIndexedDb.connectedInstances.delete(this);
  }
  tx(mode, names, cb) {
    const txPromise = (async () => {
      assert(!this.isClosed, "db is closed");
      const db = await this.getDb();
      const tx = db.transaction(names, mode);
      const done = tx.done.catch((e) => {
        if (!this.isClosed) {
          throw e;
        }
      });
      try {
        return await cb(tx);
      } finally {
        if (!this.isClosed) {
          await done;
        } else {
          tx.abort();
        }
      }
    })();
    this.pendingTransactionSet.add(txPromise);
    txPromise.finally(() => this.pendingTransactionSet.delete(txPromise));
    return txPromise;
  }
  async load({ sessionId } = {}) {
    return await this.tx(
      "readonly",
      [Table.Records, Table.Schema, Table.SessionState],
      async (tx) => {
        var _a6, _b3;
        const recordsStore = tx.objectStore(Table.Records);
        const schemaStore = tx.objectStore(Table.Schema);
        const sessionStateStore = tx.objectStore(Table.SessionState);
        let sessionStateSnapshot = sessionId ? (_a6 = await sessionStateStore.get(sessionId)) == null ? void 0 : _a6.snapshot : null;
        if (!sessionStateSnapshot) {
          const all = await sessionStateStore.getAll();
          sessionStateSnapshot = (_b3 = all.sort((a, b) => a.updatedAt - b.updatedAt).pop()) == null ? void 0 : _b3.snapshot;
        }
        const result = {
          records: await recordsStore.getAll(),
          schema: await schemaStore.get(Table.Schema),
          sessionStateSnapshot
        };
        return result;
      }
    );
  }
  async storeChanges({
    schema,
    changes,
    sessionId,
    sessionStateSnapshot
  }) {
    await this.tx("readwrite", [Table.Records, Table.Schema, Table.SessionState], async (tx) => {
      const recordsStore = tx.objectStore(Table.Records);
      const schemaStore = tx.objectStore(Table.Schema);
      const sessionStateStore = tx.objectStore(Table.SessionState);
      for (const [id, record] of Object.entries(changes.added)) {
        await recordsStore.put(record, id);
      }
      for (const [_prev, updated] of Object.values(changes.updated)) {
        await recordsStore.put(updated, updated.id);
      }
      for (const id of Object.keys(changes.removed)) {
        await recordsStore.delete(id);
      }
      schemaStore.put(schema.serialize(), Table.Schema);
      if (sessionStateSnapshot && sessionId) {
        sessionStateStore.put(
          {
            snapshot: sessionStateSnapshot,
            updatedAt: Date.now(),
            id: sessionId
          },
          sessionId
        );
      } else if (sessionStateSnapshot || sessionId) {
        console.error("sessionStateSnapshot and instanceId must be provided together");
      }
    });
  }
  async storeSnapshot({
    schema,
    snapshot,
    sessionId,
    sessionStateSnapshot
  }) {
    await this.tx("readwrite", [Table.Records, Table.Schema, Table.SessionState], async (tx) => {
      const recordsStore = tx.objectStore(Table.Records);
      const schemaStore = tx.objectStore(Table.Schema);
      const sessionStateStore = tx.objectStore(Table.SessionState);
      await recordsStore.clear();
      for (const [id, record] of Object.entries(snapshot)) {
        await recordsStore.put(record, id);
      }
      schemaStore.put(schema.serialize(), Table.Schema);
      if (sessionStateSnapshot && sessionId) {
        sessionStateStore.put(
          {
            snapshot: sessionStateSnapshot,
            updatedAt: Date.now(),
            id: sessionId
          },
          sessionId
        );
      } else if (sessionStateSnapshot || sessionId) {
        console.error("sessionStateSnapshot and instanceId must be provided together");
      }
    });
  }
  async pruneSessions() {
    await this.tx("readwrite", [Table.SessionState], async (tx) => {
      const sessionStateStore = tx.objectStore(Table.SessionState);
      const all = (await sessionStateStore.getAll()).sort((a, b) => a.updatedAt - b.updatedAt);
      if (all.length < 10) {
        await tx.done;
        return;
      }
      const toDelete = all.slice(0, all.length - 10);
      for (const { id } of toDelete) {
        await sessionStateStore.delete(id);
      }
    });
  }
  async getAsset(assetId) {
    return await this.tx("readonly", [Table.Assets], async (tx) => {
      const assetsStore = tx.objectStore(Table.Assets);
      return await assetsStore.get(assetId);
    });
  }
  async storeAsset(assetId, blob) {
    await this.tx("readwrite", [Table.Assets], async (tx) => {
      const assetsStore = tx.objectStore(Table.Assets);
      await assetsStore.put(blob, assetId);
    });
  }
  async removeAssets(assetId) {
    await this.tx("readwrite", [Table.Assets], async (tx) => {
      const assetsStore = tx.objectStore(Table.Assets);
      for (const id of assetId) {
        await assetsStore.delete(id);
      }
    });
  }
};
/** @internal */
__publicField(_LocalIndexedDb, "connectedInstances", /* @__PURE__ */ new Set());
var LocalIndexedDb = _LocalIndexedDb;
function getAllIndexDbNames() {
  const result = JSON.parse(getFromLocalStorage(dbNameIndexKey) || "[]") ?? [];
  if (!Array.isArray(result)) {
    return [];
  }
  return result;
}
function addDbName(name) {
  const all = new Set(getAllIndexDbNames());
  all.add(name);
  setInLocalStorage(dbNameIndexKey, JSON.stringify([...all]));
}

// ../node_modules/@tldraw/editor/dist-esm/lib/utils/sync/alerts.mjs
function showCantWriteToIndexDbAlert() {
  window.alert(
    `Oops! We could not save changes to your browser's storage. We now need to reload the page and try again.

Keep seeing this message?
• If you're using tldraw in a private or "incognito" window, try loading tldraw in a regular window or in a different browser.
• If your hard disk is full, try clearing up some space and then reload the page.`
  );
}
function showCantReadFromIndexDbAlert() {
  window.alert(
    `Oops! We could not access your browser's storage—and the app won't work correctly without that. We now need to reload the page and try again.

Keep seeing this message?
• If you're using tldraw in a private or "incognito" window, try loading tldraw in a regular window or in a different browser.`
  );
}

// ../node_modules/@tldraw/editor/dist-esm/lib/utils/sync/TLLocalSyncClient.mjs
var PERSIST_THROTTLE_MS = 350;
var PERSIST_RETRY_THROTTLE_MS = 1e4;
var UPDATE_INSTANCE_STATE = Symbol("UPDATE_INSTANCE_STATE");
var msg = (msg2) => msg2;
var BroadcastChannelMock = class {
  constructor(_name) {
    __publicField(this, "onmessage");
  }
  postMessage(_msg) {
  }
  close() {
  }
};
var BC = typeof BroadcastChannel === "undefined" ? BroadcastChannelMock : BroadcastChannel;
var TLLocalSyncClient = class {
  constructor(store, {
    persistenceKey,
    sessionId = TAB_ID,
    onLoad,
    onLoadError
  }, channel2 = new BC(`tldraw-tab-sync-${persistenceKey}`)) {
    __publicField(this, "disposables", /* @__PURE__ */ new Set());
    __publicField(this, "diffQueue", []);
    __publicField(this, "didDispose", false);
    __publicField(this, "shouldDoFullDBWrite", true);
    __publicField(this, "isReloading", false);
    __publicField(this, "persistenceKey");
    __publicField(this, "sessionId");
    __publicField(this, "serializedSchema");
    __publicField(this, "isDebugging", false);
    __publicField(this, "documentTypes");
    __publicField(this, "$sessionStateSnapshot");
    /** @internal */
    __publicField(this, "db");
    __publicField(this, "initTime", Date.now());
    __publicField(this, "isPersisting", false);
    __publicField(this, "didLastWriteError", false);
    __publicField(this, "scheduledPersistTimeout", null);
    this.store = store;
    this.channel = channel2;
    if (typeof window !== "undefined") {
      ;
      window.tlsync = this;
    }
    this.persistenceKey = persistenceKey;
    this.sessionId = sessionId;
    this.db = new LocalIndexedDb(persistenceKey);
    this.disposables.add(() => this.db.close());
    this.serializedSchema = this.store.schema.serialize();
    this.$sessionStateSnapshot = createSessionStateSnapshotSignal(this.store);
    this.disposables.add(
      // Set up a subscription to changes from the store: When
      // the store changes (and if the change was made by the user)
      // then immediately send the diff to other tabs via postMessage
      // and schedule a persist.
      store.listen(
        ({ changes }) => {
          this.diffQueue.push(changes);
          this.channel.postMessage(
            msg({
              type: "diff",
              storeId: this.store.id,
              changes,
              schema: this.serializedSchema
            })
          );
          this.schedulePersist();
        },
        { source: "user", scope: "document" }
      )
    );
    this.disposables.add(
      store.listen(
        () => {
          this.diffQueue.push(UPDATE_INSTANCE_STATE);
          this.schedulePersist();
        },
        { scope: "session" }
      )
    );
    this.connect(onLoad, onLoadError);
    this.documentTypes = new Set(
      Object.values(this.store.schema.types).filter((t2) => t2.scope === "document").map((t2) => t2.typeName)
    );
  }
  debug(...args) {
    if (this.isDebugging) {
      console.debug(...args);
    }
  }
  async connect(onLoad, onLoadError) {
    this.debug("connecting");
    let data;
    try {
      data = await this.db.load({ sessionId: this.sessionId });
    } catch (error) {
      onLoadError(error);
      showCantReadFromIndexDbAlert();
      return;
    }
    this.debug("loaded data from store", data, "didDispose", this.didDispose);
    if (this.didDispose) return;
    try {
      if (data) {
        const documentSnapshot = Object.fromEntries(data.records.map((r) => [r.id, r]));
        const sessionStateSnapshot = data.sessionStateSnapshot ?? extractSessionStateFromLegacySnapshot(documentSnapshot);
        const migrationResult = this.store.schema.migrateStoreSnapshot({
          store: documentSnapshot,
          // eslint-disable-next-line @typescript-eslint/no-deprecated
          schema: data.schema ?? this.store.schema.serializeEarliestVersion()
        });
        if (migrationResult.type === "error") {
          console.error("failed to migrate store", migrationResult);
          onLoadError(new Error(`Failed to migrate store: ${migrationResult.reason}`));
          return;
        }
        const records = Object.values(migrationResult.value).filter(
          (r) => this.documentTypes.has(r.typeName)
        );
        if (records.length > 0) {
          this.store.mergeRemoteChanges(() => {
            this.store.put(records, "initialize");
          });
        }
        if (sessionStateSnapshot) {
          loadSessionStateSnapshotIntoStore(this.store, sessionStateSnapshot, {
            forceOverwrite: true
          });
        }
      }
      this.channel.onmessage = ({ data: data2 }) => {
        var _a6, _b3;
        this.debug("got message", data2);
        const msg2 = data2;
        const res = this.store.schema.getMigrationsSince(msg2.schema);
        if (!res.ok) {
          const timeSinceInit = Date.now() - this.initTime;
          if (timeSinceInit < 5e3) {
            onLoadError(new Error("Schema mismatch, please close other tabs and reload the page"));
            return;
          }
          this.debug("reloading");
          this.isReloading = true;
          (_b3 = (_a6 = window == null ? void 0 : window.location) == null ? void 0 : _a6.reload) == null ? void 0 : _b3.call(_a6);
          return;
        } else if (res.value.length > 0) {
          this.debug("telling them to reload");
          this.channel.postMessage({ type: "announce", schema: this.serializedSchema });
          this.shouldDoFullDBWrite = true;
          this.persistIfNeeded();
          return;
        }
        if (msg2.type === "diff") {
          this.debug("applying diff");
          transact(() => {
            this.store.mergeRemoteChanges(() => {
              this.store.applyDiff(msg2.changes);
            });
          });
        }
      };
      this.channel.postMessage({ type: "announce", schema: this.serializedSchema });
      this.disposables.add(() => {
        this.channel.close();
      });
      onLoad(this);
    } catch (e) {
      this.debug("error loading data from store", e);
      if (this.didDispose) return;
      onLoadError(e);
      return;
    }
  }
  close() {
    this.debug("closing");
    this.didDispose = true;
    this.disposables.forEach((d) => d());
  }
  /**
   * Schedule a persist. Persists don't happen immediately: they are throttled to avoid writing too
   * often, and will retry if failed.
   *
   * @internal
   */
  schedulePersist() {
    this.debug("schedulePersist", this.scheduledPersistTimeout);
    if (this.scheduledPersistTimeout) return;
    this.scheduledPersistTimeout = setTimeout(
      () => {
        this.scheduledPersistTimeout = null;
        this.persistIfNeeded();
      },
      this.didLastWriteError ? PERSIST_RETRY_THROTTLE_MS : PERSIST_THROTTLE_MS
    );
  }
  /**
   * Persist to IndexedDB only under certain circumstances:
   *
   * - If we're not already persisting
   * - If we're not reloading the page
   * - And we have something to persist (a full db write scheduled or changes in the diff queue)
   *
   * @internal
   */
  persistIfNeeded() {
    this.debug("persistIfNeeded", {
      isPersisting: this.isPersisting,
      isReloading: this.isReloading,
      shouldDoFullDBWrite: this.shouldDoFullDBWrite,
      diffQueueLength: this.diffQueue.length,
      storeIsPossiblyCorrupt: this.store.isPossiblyCorrupted()
    });
    if (this.scheduledPersistTimeout) {
      clearTimeout(this.scheduledPersistTimeout);
      this.scheduledPersistTimeout = null;
    }
    if (this.isPersisting) return;
    if (this.isReloading) return;
    if (this.store.isPossiblyCorrupted()) return;
    if (this.shouldDoFullDBWrite || this.diffQueue.length > 0) {
      this.doPersist();
    }
  }
  /**
   * Actually persist to IndexedDB. If the write fails, then we'll retry with a full db write after
   * a short delay.
   */
  async doPersist() {
    assert(!this.isPersisting, "persist already in progress");
    if (this.didDispose) return;
    this.isPersisting = true;
    this.debug("doPersist start");
    const diffQueue = this.diffQueue;
    this.diffQueue = [];
    try {
      if (this.shouldDoFullDBWrite) {
        this.shouldDoFullDBWrite = false;
        await this.db.storeSnapshot({
          schema: this.store.schema,
          snapshot: this.store.serialize(),
          sessionId: this.sessionId,
          sessionStateSnapshot: this.$sessionStateSnapshot.get()
        });
      } else {
        const diffs = squashRecordDiffs(
          diffQueue.filter((d) => d !== UPDATE_INSTANCE_STATE)
        );
        await this.db.storeChanges({
          changes: diffs,
          schema: this.store.schema,
          sessionId: this.sessionId,
          sessionStateSnapshot: this.$sessionStateSnapshot.get()
        });
      }
      this.didLastWriteError = false;
    } catch (e) {
      this.shouldDoFullDBWrite = true;
      this.didLastWriteError = true;
      console.error("failed to store changes in indexed db", e);
      showCantWriteToIndexDbAlert();
      if (typeof window !== "undefined") {
        window.location.reload();
      }
    }
    this.isPersisting = false;
    this.debug("doPersist end");
    this.schedulePersist();
  }
};

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/useRefState.mjs
var import_react27 = __toESM(require_react(), 1);
function useRefState(initialValue) {
  const ref = (0, import_react27.useRef)(initialValue);
  const [state, setState] = (0, import_react27.useState)(initialValue);
  if (state !== ref.current) {
    setState(ref.current);
  }
  const update = (0, import_react27.useCallback)((value) => {
    if (typeof value === "function") {
      ref.current = value(ref.current);
    } else {
      ref.current = value;
    }
    setState(ref.current);
  }, []);
  return [state, update];
}

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/useLocalStore.mjs
function useLocalStore(options2) {
  const [state, setState] = useRefState({ status: "loading" });
  options2 = useShallowObjectIdentity(options2);
  (0, import_react28.useEffect)(() => {
    const { persistenceKey, sessionId, ...rest } = options2;
    if (!persistenceKey) {
      setState({
        status: "not-synced",
        store: createTLStore(rest)
      });
      return;
    }
    setState({ status: "loading" });
    const objectURLCache = new WeakCache();
    const assets = {
      upload: async (asset, file) => {
        await client.db.storeAsset(asset.id, file);
        return { src: asset.id };
      },
      resolve: async (asset) => {
        if (!asset.props.src) return null;
        if (asset.props.src.startsWith("asset:")) {
          return await objectURLCache.get(asset, async () => {
            const blob = await client.db.getAsset(asset.id);
            if (!blob) return null;
            return URL.createObjectURL(blob);
          });
        }
        return asset.props.src;
      },
      remove: async (assetIds) => {
        await client.db.removeAssets(assetIds);
      },
      ...rest.assets
    };
    const store = createTLStore({ ...rest, assets });
    let isClosed = false;
    const client = new TLLocalSyncClient(store, {
      sessionId,
      persistenceKey,
      onLoad() {
        if (isClosed) return;
        setState({ store, status: "synced-local" });
      },
      onLoadError(err) {
        if (isClosed) return;
        setState({ status: "error", error: err });
      }
    });
    return () => {
      isClosed = true;
      client.close();
    };
  }, [options2, setState]);
  return state;
}

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/useStateAttribute.mjs
var import_react29 = __toESM(require_react(), 1);
function useStateAttribute() {
  const editor = useEditor();
  (0, import_react29.useLayoutEffect)(() => {
    return react("stateAttribute", () => {
      const container = editor.getContainer();
      const instanceState = editor.getInstanceState();
      container.setAttribute("data-state", editor.getPath());
      container.setAttribute("data-coarse", String(instanceState.isCoarsePointer));
    });
  }, [editor]);
}

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/useZoomCss.mjs
var React5 = __toESM(require_react(), 1);
function useZoomCss() {
  const editor = useEditor();
  const container = useContainer();
  React5.useEffect(() => {
    const setScale = (s) => container.style.setProperty("--tl-zoom", s.toString());
    const setScaleDebounced = debounce(setScale, 100);
    const scheduler = new EffectScheduler(
      "useZoomCss",
      () => setScale(editor.getEfficientZoomLevel())
    );
    scheduler.attach();
    scheduler.execute();
    return () => {
      scheduler.detach();
      setScaleDebounced.cancel();
    };
  }, [editor, container]);
}

// ../node_modules/@tldraw/editor/dist-esm/lib/license/LicenseProvider.mjs
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var import_react30 = __toESM(require_react(), 1);

// ../node_modules/@tldraw/editor/dist-esm/lib/utils/licensing.mjs
function str2ab(str) {
  const buf = new ArrayBuffer(str.length);
  const bufView = new Uint8Array(buf);
  for (let i = 0, strLen = str.length; i < strLen; i++) {
    bufView[i] = str.charCodeAt(i);
  }
  return buf;
}
function importPublicKey(pemContents) {
  const binaryDerString = atob(pemContents);
  const binaryDer = str2ab(binaryDerString);
  return crypto.subtle.importKey(
    "spki",
    new Uint8Array(binaryDer),
    {
      name: "ECDSA",
      namedCurve: "P-256"
    },
    true,
    ["verify"]
  );
}

// ../node_modules/@tldraw/editor/dist-esm/lib/license/LicenseManager.mjs
var GRACE_PERIOD_DAYS = 30;
var FLAGS = {
  // -- MUTUALLY EXCLUSIVE FLAGS --
  // Annual means the license expires after a time period, usually 1 year.
  ANNUAL_LICENSE: 1,
  // Perpetual means the license never expires up to the max supported version.
  PERPETUAL_LICENSE: 1 << 1,
  // -- ADDITIVE FLAGS --
  // Internal means the license is for internal use only.
  INTERNAL_LICENSE: 1 << 2,
  // Watermark means the product is watermarked.
  WITH_WATERMARK: 1 << 3,
  // Evaluation means the license is for evaluation purposes only.
  EVALUATION_LICENSE: 1 << 4,
  // Native means the license is for native apps which switches
  // on special-case logic.
  NATIVE_LICENSE: 1 << 5
};
var HIGHEST_FLAG = Math.max(...Object.values(FLAGS));
var PROPERTIES = {
  ID: 0,
  HOSTS: 1,
  FLAGS: 2,
  EXPIRY_DATE: 3
};
var NUMBER_OF_KNOWN_PROPERTIES = Object.keys(PROPERTIES).length;
var LICENSE_EMAIL = "sales@tldraw.com";
var WATERMARK_TRACK_SRC = `${getDefaultCdnBaseUrl()}/watermarks/watermark-track.svg`;
var LicenseManager = class {
  constructor(licenseKey, testPublicKey) {
    __publicField(this, "publicKey", "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEHJh0uUfxHtCGyerXmmatE368Hd9rI6LH9oPDQihnaCryRFWEVeOvf9U/SPbyxX74LFyJs5tYeAHq5Nc0Ax25LQ");
    __publicField(this, "isDevelopment");
    __publicField(this, "isTest");
    __publicField(this, "isCryptoAvailable");
    __publicField(this, "state", atom("license state", "pending"));
    __publicField(this, "verbose", true);
    this.isTest = false;
    this.isDevelopment = this.getIsDevelopment();
    this.publicKey = testPublicKey || this.publicKey;
    this.isCryptoAvailable = !!crypto.subtle;
    this.getLicenseFromKey(licenseKey).then((result) => {
      const licenseState = getLicenseState(
        result,
        (messages) => this.outputMessages(messages),
        this.isDevelopment
      );
      this.maybeTrack(result, licenseState);
      this.state.set(licenseState);
    }).catch((error) => {
      console.error("License validation failed:", error);
      this.state.set("unlicensed");
    });
  }
  getIsDevelopment() {
    return !["https:", "vscode-webview:"].includes(window.location.protocol) || window.location.hostname === "localhost" || true;
  }
  getTrackType(result, licenseState) {
    if (licenseState === "unlicensed-production") {
      return "unlicensed";
    }
    if (this.isDevelopment) {
      return null;
    }
    if (!result.isLicenseParseable) {
      return null;
    }
    if (result.isEvaluationLicense) {
      return "evaluation";
    }
    if (licenseState === "licensed-with-watermark") {
      return "with_watermark";
    }
    return null;
  }
  maybeTrack(result, licenseState) {
    const trackType = this.getTrackType(result, licenseState);
    if (!trackType) {
      return;
    }
    const url = new URL(WATERMARK_TRACK_SRC);
    url.searchParams.set("version", version);
    url.searchParams.set("license_type", trackType);
    if ("license" in result) {
      url.searchParams.set("license_id", result.license.id);
      const sku = this.isFlagEnabled(result.license.flags, FLAGS.EVALUATION_LICENSE) ? "evaluation" : this.isFlagEnabled(result.license.flags, FLAGS.ANNUAL_LICENSE) ? "annual" : this.isFlagEnabled(result.license.flags, FLAGS.PERPETUAL_LICENSE) ? "perpetual" : "unknown";
      url.searchParams.set("sku", sku);
    }
    url.searchParams.set("url", window.location.href);
    if ("development") {
      url.searchParams.set("environment", "development");
    }
    fetch(url.toString());
  }
  async extractLicenseKey(licenseKey) {
    const [data, signature] = licenseKey.split(".");
    const [prefix, encodedData] = data.split("/");
    if (!prefix.startsWith("tldraw-")) {
      throw new Error(`Unsupported prefix '${prefix}'`);
    }
    const publicCryptoKey = await importPublicKey(this.publicKey);
    let isVerified;
    try {
      isVerified = await crypto.subtle.verify(
        {
          name: "ECDSA",
          hash: { name: "SHA-256" }
        },
        publicCryptoKey,
        new Uint8Array(str2ab(atob(signature))),
        new Uint8Array(str2ab(atob(encodedData)))
      );
    } catch (e) {
      console.error(e);
      throw new Error("Could not perform signature validation");
    }
    if (!isVerified) {
      throw new Error("Invalid signature");
    }
    let decodedData;
    try {
      decodedData = JSON.parse(atob(encodedData));
    } catch {
      throw new Error("Could not parse object");
    }
    if (decodedData.length > NUMBER_OF_KNOWN_PROPERTIES) {
      this.outputMessages([
        "License key contains some unknown properties.",
        "You may want to update tldraw packages to a newer version to get access to new functionality."
      ]);
    }
    return {
      id: decodedData[PROPERTIES.ID],
      hosts: decodedData[PROPERTIES.HOSTS],
      flags: decodedData[PROPERTIES.FLAGS],
      expiryDate: decodedData[PROPERTIES.EXPIRY_DATE]
    };
  }
  async getLicenseFromKey(licenseKey) {
    if (!licenseKey) {
      if (!this.isDevelopment) {
        this.outputNoLicenseKeyProvided();
      }
      return { isLicenseParseable: false, reason: "no-key-provided" };
    }
    if (this.isDevelopment && !this.isCryptoAvailable) {
      if (this.verbose) {
        console.log(
          "tldraw: you seem to be in a development environment that does not support crypto. License not verified."
        );
        console.log("You should check that this works in production separately.");
      }
      return { isLicenseParseable: false, reason: "has-key-development-mode" };
    }
    let cleanedLicenseKey = licenseKey.replace(/[\u200B-\u200D\uFEFF]/g, "");
    cleanedLicenseKey = cleanedLicenseKey.replace(/\r?\n|\r/g, "");
    try {
      const licenseInfo = await this.extractLicenseKey(cleanedLicenseKey);
      const expiryDate = new Date(licenseInfo.expiryDate);
      const isAnnualLicense = this.isFlagEnabled(licenseInfo.flags, FLAGS.ANNUAL_LICENSE);
      const isPerpetualLicense = this.isFlagEnabled(licenseInfo.flags, FLAGS.PERPETUAL_LICENSE);
      const isEvaluationLicense = this.isFlagEnabled(licenseInfo.flags, FLAGS.EVALUATION_LICENSE);
      const daysSinceExpiry = this.getDaysSinceExpiry(expiryDate);
      const result = {
        license: licenseInfo,
        isLicenseParseable: true,
        isDevelopment: this.isDevelopment,
        isDomainValid: this.isDomainValid(licenseInfo),
        expiryDate,
        isAnnualLicense,
        isAnnualLicenseExpired: isAnnualLicense && this.isAnnualLicenseExpired(expiryDate),
        isPerpetualLicense,
        isPerpetualLicenseExpired: isPerpetualLicense && this.isPerpetualLicenseExpired(expiryDate),
        isInternalLicense: this.isFlagEnabled(licenseInfo.flags, FLAGS.INTERNAL_LICENSE),
        isNativeLicense: this.isNativeLicense(licenseInfo),
        isLicensedWithWatermark: this.isFlagEnabled(licenseInfo.flags, FLAGS.WITH_WATERMARK),
        isEvaluationLicense,
        isEvaluationLicenseExpired: isEvaluationLicense && this.isEvaluationLicenseExpired(expiryDate),
        daysSinceExpiry
      };
      this.outputLicenseInfoIfNeeded(result);
      return result;
    } catch (e) {
      this.outputInvalidLicenseKey(e.message);
      return { isLicenseParseable: false, reason: "invalid-license-key" };
    }
  }
  isDomainValid(licenseInfo) {
    const currentHostname = window.location.hostname.toLowerCase();
    return licenseInfo.hosts.some((host) => {
      const normalizedHostOrUrlRegex = host.toLowerCase().trim();
      if (normalizedHostOrUrlRegex === currentHostname || `www.${normalizedHostOrUrlRegex}` === currentHostname || normalizedHostOrUrlRegex === `www.${currentHostname}`) {
        return true;
      }
      if (host === "*") {
        return true;
      }
      if (this.isNativeLicense(licenseInfo)) {
        return new RegExp(normalizedHostOrUrlRegex).test(window.location.href);
      }
      if (host.includes("*")) {
        const globToRegex = new RegExp(host.replace(/\*/g, ".*?"));
        return globToRegex.test(currentHostname) || globToRegex.test(`www.${currentHostname}`);
      }
      if (window.location.protocol === "vscode-webview:") {
        const currentUrl = new URL(window.location.href);
        const extensionId = currentUrl.searchParams.get("extensionId");
        if (normalizedHostOrUrlRegex === extensionId) {
          return true;
        }
      }
      return false;
    });
  }
  isNativeLicense(licenseInfo) {
    return this.isFlagEnabled(licenseInfo.flags, FLAGS.NATIVE_LICENSE);
  }
  getExpirationDateWithoutGracePeriod(expiryDate) {
    return new Date(expiryDate.getFullYear(), expiryDate.getMonth(), expiryDate.getDate());
  }
  getExpirationDateWithGracePeriod(expiryDate) {
    return new Date(
      expiryDate.getFullYear(),
      expiryDate.getMonth(),
      expiryDate.getDate() + GRACE_PERIOD_DAYS + 1
      // Add 1 day to include the expiration day
    );
  }
  isAnnualLicenseExpired(expiryDate) {
    const expiration = this.getExpirationDateWithGracePeriod(expiryDate);
    return /* @__PURE__ */ new Date() >= expiration;
  }
  isPerpetualLicenseExpired(expiryDate) {
    const expiration = this.getExpirationDateWithGracePeriod(expiryDate);
    const dates = {
      major: new Date(publishDates.major),
      minor: new Date(publishDates.minor)
    };
    return dates.major >= expiration || dates.minor >= expiration;
  }
  getDaysSinceExpiry(expiryDate) {
    const now = /* @__PURE__ */ new Date();
    const expiration = this.getExpirationDateWithoutGracePeriod(expiryDate);
    const diffTime = now.getTime() - expiration.getTime();
    const diffDays = Math.floor(diffTime / (1e3 * 60 * 60 * 24));
    return Math.max(0, diffDays);
  }
  isEvaluationLicenseExpired(expiryDate) {
    const now = /* @__PURE__ */ new Date();
    const expiration = this.getExpirationDateWithoutGracePeriod(expiryDate);
    return now >= expiration;
  }
  isFlagEnabled(flags, flag) {
    return (flags & flag) === flag;
  }
  outputNoLicenseKeyProvided() {
  }
  outputInvalidLicenseKey(msg2) {
    this.outputMessages(["Invalid tldraw license key", `Reason: ${msg2}`]);
  }
  outputLicenseInfoIfNeeded(result) {
    if (result.license.flags >= HIGHEST_FLAG * 2) {
      this.outputMessages(
        [
          "Warning: This tldraw license contains some unknown flags.",
          "This will still work, however, you may want to update tldraw packages to a newer version to get access to new functionality."
        ],
        "warning"
      );
    }
  }
  outputMessages(messages, type = "error") {
    if (this.isTest) return;
    if (this.verbose) {
      this.outputDelimiter();
      for (const message of messages) {
        const color = type === "warning" ? "orange" : "crimson";
        const bgColor = type === "warning" ? "orange" : "crimson";
        console.log(
          `%c${message}`,
          `color: ${color}; background: ${bgColor}; padding: 2px; border-radius: 3px;`
        );
      }
      this.outputDelimiter();
    }
  }
  outputDelimiter() {
    console.log(
      "%c-------------------------------------------------------------------",
      `color: white; background: crimson; padding: 2px; border-radius: 3px;`
    );
  }
};
__publicField(LicenseManager, "className", "tl-watermark_SEE-LICENSE");
function getLicenseState(result, outputMessages, isDevelopment) {
  if (!result.isLicenseParseable) {
    if (isDevelopment) {
      return "unlicensed";
    }
    if (result.reason === "no-key-provided") {
      outputMessages([
        "No tldraw license key provided!",
        "A license is required for production deployments.",
        `Please reach out to ${LICENSE_EMAIL} to purchase a license.`
      ]);
    } else {
      outputMessages([
        "Invalid license key. tldraw requires a valid license for production use.",
        `Please reach out to ${LICENSE_EMAIL} to purchase a license.`
      ]);
    }
    return "unlicensed-production";
  }
  if (!result.isDomainValid && !result.isDevelopment) {
    outputMessages([
      "License key is not valid for this domain.",
      "A license is required for production deployments.",
      `Please reach out to ${LICENSE_EMAIL} to purchase a license.`
    ]);
    return "unlicensed-production";
  }
  if (result.isEvaluationLicense) {
    if (result.isEvaluationLicenseExpired) {
      outputMessages([
        "Your tldraw evaluation license has expired!",
        `Please reach out to ${LICENSE_EMAIL} to purchase a full license.`
      ]);
      return "expired";
    } else {
      return "licensed";
    }
  }
  if (result.isPerpetualLicenseExpired || result.isAnnualLicenseExpired) {
    outputMessages([
      "Your tldraw license has been expired for more than 30 days!",
      `Please reach out to ${LICENSE_EMAIL} to renew your license.`
    ]);
    return "expired";
  }
  const daysSinceExpiry = result.daysSinceExpiry;
  if (daysSinceExpiry > 0 && !result.isEvaluationLicense) {
    outputMessages([
      "Your tldraw license has expired.",
      `License expired ${daysSinceExpiry} days ago.`,
      `Please reach out to ${LICENSE_EMAIL} to renew your license.`
    ]);
    return "licensed";
  }
  if (result.isLicensedWithWatermark) {
    return "licensed-with-watermark";
  }
  return "licensed";
}

// ../node_modules/@tldraw/editor/dist-esm/lib/license/LicenseProvider.mjs
var LicenseContext = (0, import_react30.createContext)({});
var useLicenseContext = () => (0, import_react30.useContext)(LicenseContext);
function shouldHideEditorAfterDelay(licenseState) {
  return licenseState === "expired" || licenseState === "unlicensed-production";
}
var LICENSE_TIMEOUT = 5e3;
function LicenseProvider({
  licenseKey = getLicenseKeyFromEnv() ?? void 0,
  children
}) {
  const [licenseManager] = (0, import_react30.useState)(() => new LicenseManager(licenseKey));
  const licenseState = useValue(licenseManager.state);
  const [showEditor, setShowEditor] = (0, import_react30.useState)(true);
  (0, import_react30.useEffect)(() => {
    if (shouldHideEditorAfterDelay(licenseState) && showEditor) {
      const timer = setTimeout(() => {
        setShowEditor(false);
      }, LICENSE_TIMEOUT);
      return () => clearTimeout(timer);
    }
  }, [licenseState, showEditor]);
  if (shouldHideEditorAfterDelay(licenseState) && !showEditor) {
    return (0, import_jsx_runtime19.jsx)(LicenseGate, {});
  }
  return (0, import_jsx_runtime19.jsx)(LicenseContext.Provider, { value: licenseManager, children });
}
function LicenseGate() {
  return (0, import_jsx_runtime19.jsx)("div", { "data-testid": "tl-license-expired", style: { display: "none" } });
}
var envLicenseKey = void 0;
function getLicenseKeyFromEnv() {
  if (envLicenseKey !== void 0) {
    return envLicenseKey;
  }
  envLicenseKey = getEnv(() => process.env.TLDRAW_LICENSE_KEY) || getEnv(() => process.env.NEXT_PUBLIC_TLDRAW_LICENSE_KEY) || getEnv(() => process.env.REACT_APP_TLDRAW_LICENSE_KEY) || getEnv(() => process.env.GATSBY_TLDRAW_LICENSE_KEY) || getEnv(() => process.env.VITE_TLDRAW_LICENSE_KEY) || getEnv(() => process.env.PUBLIC_TLDRAW_LICENSE_KEY) || getEnv(() => import.meta.env.TLDRAW_LICENSE_KEY) || getEnv(() => import.meta.env.NEXT_PUBLIC_TLDRAW_LICENSE_KEY) || getEnv(() => import.meta.env.REACT_APP_TLDRAW_LICENSE_KEY) || getEnv(() => import.meta.env.GATSBY_TLDRAW_LICENSE_KEY) || getEnv(() => import.meta.env.VITE_TLDRAW_LICENSE_KEY) || getEnv(() => import.meta.env.PUBLIC_TLDRAW_LICENSE_KEY) || null;
  return envLicenseKey;
}
function getEnv(cb) {
  try {
    return cb();
  } catch {
    return void 0;
  }
}

// ../node_modules/@tldraw/editor/dist-esm/lib/license/Watermark.mjs
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
var import_react32 = __toESM(require_react(), 1);

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/usePassThroughWheelEvents.mjs
var import_react31 = __toESM(require_react(), 1);
function usePassThroughWheelEvents(ref) {
  if (!ref) throw Error("usePassThroughWheelEvents must be passed a ref");
  const container = useContainer();
  const editor = useMaybeEditor();
  (0, import_react31.useEffect)(() => {
    function onWheel(e) {
      if (!(editor == null ? void 0 : editor.getInstanceState().isFocused)) return;
      if (e.isSpecialRedispatchedEvent) return;
      const elm2 = ref.current;
      if (elm2 && elm2.scrollHeight > elm2.clientHeight) {
        return;
      }
      preventDefault(e);
      const cvs = container.querySelector(".tl-canvas");
      if (!cvs) return;
      const newEvent = new WheelEvent("wheel", e);
      newEvent.isSpecialRedispatchedEvent = true;
      cvs.dispatchEvent(newEvent);
    }
    const elm = ref.current;
    if (!elm) return;
    elm.addEventListener("wheel", onWheel, { passive: false });
    return () => {
      elm.removeEventListener("wheel", onWheel);
    };
  }, [container, editor, ref]);
}

// ../node_modules/@tldraw/editor/dist-esm/lib/watermarks.mjs
var watermarkDesktopSvg = '<svg xmlns="http://www.w3.org/2000/svg" width="3001" height="1000" fill="none"><path fill="#000" d="M590.656 300.449c0 49.706-40.294 90-90 90-49.705 0-90-40.294-90-90 0-49.705 40.295-90 90-90 49.706 0 90 40.295 90 90M569.431 719.011c-15.247 32.821-56.006 91.589-98.338 91.438-32.004-.115-38.642-30.904-17.414-50.856 17.381-16.337 28.246-48.075 31.995-72.719.415-2.728-1.556-5.197-4.272-5.679-39.666-7.04-70.746-40.877-70.746-83.417 0-48.23 38.983-87.329 87.07-87.329 39.936 0 70.172 22.237 83.369 52.397 18.839 43.055 7.117 115.733-11.664 156.165M2613.29 385.681V239.319c0-11.363 9.22-20.569 20.59-20.569h8.26c11.37 0 20.59 9.206 20.59 20.569v36.911c0 8.629 7 15.625 15.63 15.625h35.25c8.63 0 15.63-6.996 15.63-15.625v-36.911c0-11.363 9.22-20.569 20.59-20.569h8.17c11.37 0 20.59 9.206 20.59 20.569v146.362c0 11.363-9.22 20.569-20.59 20.569h-8.17c-11.37 0-20.59-9.206-20.59-20.569v-36.999c0-8.63-7-15.625-15.63-15.625h-35.25c-8.63 0-15.63 6.995-15.63 15.625v36.999c0 11.363-9.22 20.569-20.59 20.569h-8.26c-11.37 0-20.59-9.206-20.59-20.569M2391.97 239.319v146.362c0 11.348-9.16 20.569-20.49 20.569h-8.2c-11.33 0-20.49-9.221-20.49-20.569V239.319c0-11.348 9.16-20.569 20.49-20.569h8.2c11.33 0 20.49 9.221 20.49 20.569M2098.23 391.43l-42.69-146.361c-3.85-13.171 6.06-26.319 19.79-26.319h10.6c9.59 0 17.93 6.611 20.08 15.952l17.01 73.045c1.48 6.348 10.47 6.478 12.14.176l19.47-73.838c2.38-9.04 10.57-15.335 19.93-15.335h12.1c9.37 0 17.56 6.3 19.94 15.346l19.49 74.067c1.66 6.305 10.65 6.178 12.13-.171l17.09-73.294c2.15-9.339 10.49-15.948 20.08-15.948h10.53c13.72 0 23.63 13.141 19.79 26.31l-42.63 146.361c-2.56 8.789-10.63 14.829-19.79 14.829h-15.68c-9.12 0-17.16-5.98-19.76-14.709l-21.17-71.059c-1.77-5.948-10.19-5.957-11.97-.012l-21.33 71.071c-2.6 8.729-10.64 14.709-19.76 14.709h-15.59c-9.17 0-17.23-6.035-19.8-14.82M2443.23 218.75h118.59c11.38 0 20.62 9.195 20.62 20.557s-9.24 20.556-20.62 20.556h-24.79c-5.53 0-10 4.477-10 10v115.818c0 11.368-9.25 20.569-20.63 20.569h-7.65c-11.39 0-20.63-9.201-20.63-20.569V269.863c0-5.523-4.48-10-10-10h-24.89c-11.37 0-20.61-9.195-20.61-20.556s9.24-20.557 20.61-20.557M1174.15 218.75h24.64c8.35 0 15.88 5.042 19.04 12.764l34.61 83.942c2.13 5.161 9.44 5.155 11.56-.01l34.43-83.932a20.58 20.58 0 0 1 19.04-12.764h24.64c11.37 0 20.58 9.208 20.58 20.569v146.362c0 11.361-9.21 20.569-20.58 20.569h-7.09c-11.36 0-20.58-9.208-20.58-20.569l-.12-50.645c-.01-6.888-9.53-8.688-12.06-2.283l-23.46 59.332a20.57 20.57 0 0 1-19.14 13.009h-3.03a20.57 20.57 0 0 1-19.15-13.046l-23.47-59.68c-2.52-6.416-12.05-4.623-12.06 2.271l-.13 51.042c0 11.361-9.21 20.569-20.57 20.569h-7.1c-11.36 0-20.57-9.208-20.57-20.569V239.319c0-11.361 9.21-20.569 20.57-20.569"/><path fill="#000" fill-rule="evenodd" d="m1449.94 391.836 6.12-19.392a6.255 6.255 0 0 1 5.96-4.369l50.22-.061a6.24 6.24 0 0 1 5.96 4.348l6.23 19.486c2.71 8.581 10.71 14.402 19.74 14.402h9.34c14.13 0 24.15-13.791 19.61-27.151l-49.74-146.361c-2.85-8.37-10.74-13.988-19.61-13.988h-33.16c-8.87 0-16.77 5.618-19.61 13.988l-49.74 146.361c-4.54 13.36 5.48 27.151 19.61 27.151h9.32c9.04 0 17.04-5.827 19.75-14.414m31.1-98.858c1.85-5.807 10.08-5.796 11.91.016l8.83 27.916c1.28 4.028-1.73 8.134-5.96 8.134h-17.74c-4.23 0-7.24-4.119-5.95-8.151zM1681.81 406.25c18.91 0 35.39-3.686 49.36-11.168 13.97-7.544 24.73-18.394 32.24-32.489 7.56-14.105 11.29-30.866 11.29-50.182 0-19.256-3.73-35.957-11.29-50.004-7.57-14.094-18.35-24.912-32.32-32.397-13.91-7.545-30.4-11.26-49.37-11.26h-49.5c-11.38 0-20.63 9.201-20.63 20.569v146.362c0 11.368 9.25 20.569 20.63 20.569zm23.13-47.701c-6.62 3.215-14.85 4.886-24.79 4.886-10.49 0-19-8.507-19-19v-64.34c0-10.149 8.23-18.376 18.38-18.376 10.18 0 18.56 1.703 25.23 4.974 6.59 3.149 11.63 8.315 15.08 15.633 3.45 7.269 5.28 17.268 5.28 30.162 0 12.891-1.82 22.951-5.28 30.347-3.39 7.319-8.36 12.509-14.9 15.714" clip-rule="evenodd"/><path fill="#000" d="M1804.21 385.681V239.319c0-11.361 9.21-20.569 20.58-20.569h91.28c11.36 0 20.57 9.202 20.57 20.557s-9.21 20.556-20.57 20.556h-54.64a7.807 7.807 0 0 0-7.81 7.813v16.366a7.806 7.806 0 0 0 7.81 7.812h48.13c11.37 0 20.58 9.246 20.58 20.602s-9.21 20.601-20.58 20.601h-48.13a7.806 7.806 0 0 0-7.81 7.812v16.455a7.807 7.807 0 0 0 7.81 7.813h54.64c11.36 0 20.57 9.202 20.57 20.556s-9.21 20.557-20.57 20.557h-91.28c-11.37 0-20.58-9.208-20.58-20.569"/><path fill="#000" fill-rule="evenodd" d="M2875.5 68.75h-2750c-31.066 0-56.25 25.184-56.25 56.25v750c0 31.066 25.184 56.25 56.25 56.25h2750c31.07 0 56.25-25.184 56.25-56.25V125c0-31.066-25.18-56.25-56.25-56.25M125.5 0C56.464 0 .5 55.964.5 125v750c0 69.036 55.965 125 125 125h2750c69.04 0 125-55.964 125-125V125c0-69.036-55.96-125-125-125z" clip-rule="evenodd"/><path fill="#000" d="M2476.06 804.813c-10.54 0-19.82-6.947-22.81-17.068L2390.79 575.7c-4.49-15.248 6.92-30.534 22.8-30.534h27.75c11.1 0 20.72 7.686 23.18 18.52L2489 671.402c2.07 9.093 14.93 9.321 17.32.308l28.83-108.844c2.76-10.435 12.19-17.7 22.98-17.7h25.17c10.8 0 20.25 7.293 22.99 17.755l28.27 107.739c2.36 9.001 15.18 8.829 17.3-.232l25.01-106.888c2.51-10.763 12.1-18.374 23.14-18.374h27.87c15.88 0 27.29 15.286 22.8 30.534l-62.46 212.045a23.78 23.78 0 0 1-22.81 17.068h-32.12c-10.39 0-19.58-6.763-22.69-16.696l-32.08-102.694c-2.62-8.397-14.51-8.331-17.04.095l-30.74 102.346c-3.02 10.061-12.27 16.949-22.76 16.949zM1742.44 804.813h-75.81c-13.09 0-23.71-10.656-23.71-23.801V568.967c0-13.145 10.62-23.801 23.71-23.801h74.8c26.6 0 49.59 5.198 68.95 15.594 19.45 10.312 34.44 25.187 44.96 44.627 10.61 19.355 15.91 42.556 15.91 69.602q0 40.57-15.78 69.73c-10.53 19.355-25.43 34.231-44.71 44.627-19.28 10.311-42.05 15.467-68.32 15.467m-29.3-83.642c0 13.145 10.61 23.801 23.71 23.801h3.06c12.8 0 23.7-2.07 32.71-6.212 9.09-4.141 16-11.283 20.71-21.426q7.2-15.213 7.2-42.345 0-27.13-7.32-42.344c-4.8-10.143-11.87-17.285-21.22-21.426-9.26-4.142-20.63-6.212-34.1-6.212h-1.04c-13.1 0-23.71 10.656-23.71 23.801zM1460.86 804.813c-13.12 0-23.76-10.656-23.76-23.801V568.967c0-13.145 10.64-23.801 23.76-23.801h22.84c13.13 0 23.76 10.656 23.76 23.801v155.247c0 13.145 10.64 23.801 23.76 23.801h57.27c13.12 0 23.76 10.656 23.76 23.801v9.196c0 13.145-10.64 23.801-23.76 23.801zM1204.45 601.964c-13.13 0-23.77-10.656-23.77-23.801v-9.196c0-13.145 10.64-23.801 23.77-23.801h177.89c13.13 0 23.78 10.656 23.78 23.801v9.196c0 13.145-10.65 23.801-23.78 23.801h-39.38c-8.21 0-14.86 6.66-14.86 14.875v164.173c0 13.145-10.64 23.801-23.78 23.801h-21.85c-13.13 0-23.78-10.656-23.78-23.801V616.839c0-8.215-6.65-14.875-14.86-14.875z"/><path fill="#000" fill-rule="evenodd" d="M2223.05 787.891c-3.02 10.047-12.27 16.922-22.74 16.922h-25.43c-16.19 0-27.64-15.862-22.57-31.261l69.88-212.045c3.21-9.753 12.31-16.341 22.56-16.341h61.84c10.25 0 19.35 6.588 22.56 16.341l69.87 212.045c5.08 15.399-6.37 31.261-22.56 31.261h-25.43c-10.48 0-19.72-6.875-22.74-16.922l-6.7-22.2a14.84 14.84 0 0 0-14.21-10.576h-63.42c-6.55 0-12.32 4.296-14.22 10.576zm76.13-96.945-14.13-48.436c-2.46-8.451-14.36-8.602-17.04-.217l-15.46 48.436c-1.84 5.759 2.45 11.645 8.48 11.645h29.6c5.94 0 10.22-5.715 8.55-11.428" clip-rule="evenodd"/><path fill="#000" d="M1939.6 804.813c-13.13 0-23.77-10.656-23.77-23.801V568.967c0-13.145 10.64-23.801 23.77-23.801h88.13c19.24 0 36.08 3.508 50.51 10.523s25.65 17.115 33.67 30.3q12.03 19.779 12.03 47.416c0 18.595-4.14 34.273-12.41 47.036-7.64 11.913-18.18 21.101-31.63 27.564-16.98 8.159-36 11.104-54.7 11.104h-43.07c-76.56 0 4.08-135.84 4.08-84.706v7.996c0 12.117 9.81 21.941 21.91 21.941 8.12 0 16.3-.345 24.04-3.043 5.91-2.113 10.43-5.451 13.55-10.015 3.2-4.565 4.81-10.523 4.81-17.877 0-7.437-1.61-13.481-4.81-18.129-3.12-4.733-7.64-8.199-13.55-10.396-7.05-2.766-14.67-3.423-22.18-3.423-13.13 0-23.77 10.656-23.77 23.801v47.71c0 11.825 11.14 16.003 19.91 20.752 12.31 6.671 7.58 25.389-6.42 25.389-7.45 0-13.49 6.048-13.49 13.508v48.395c0 13.145-10.63 23.801-23.76 23.801zm134.89-106.758 5.41 9.95 33.51 61.622c8.62 15.86-2.84 35.186-20.87 35.186h-22.27c-8.74 0-16.77-4.798-20.92-12.496l-35.05-65.04a15.52 15.52 0 0 0-13.66-8.168c-42.24 0 40.62-82.154 73.85-21.054M931.652 0h68.748v1000h-68.748z"/></svg>';
var watermarkMobileSvg = '<svg xmlns="http://www.w3.org/2000/svg" width="400" height="1601" fill="none"><path fill="#000" d="M72 1319.8c0-10.73 7.071-20.18 17.372-23.22l215.823-63.62c15.519-4.57 31.078 7.05 31.078 23.22v28.26c0 11.31-7.824 21.1-18.85 23.61l-109.636 24.94c-9.254 2.1-9.487 15.2-.313 17.63l110.784 29.37a24.21 24.21 0 0 1 18.015 23.4v25.64c0 11-7.423 20.62-18.071 23.41l-109.659 28.79c-9.162 2.41-8.986 15.47.236 17.63l108.792 25.46c10.955 2.56 18.702 12.33 18.702 23.57v28.39c0 16.17-15.559 27.79-31.078 23.22l-215.823-63.62c-10.3-3.04-17.372-12.49-17.372-23.22v-32.72c0-10.59 6.883-19.95 16.994-23.11l104.523-32.67c8.547-2.67 8.479-14.79-.096-17.36l-104.17-31.3C79.01 1372.42 72 1363 72 1352.31zM72 572.638V495.43c0-13.336 10.846-24.147 24.225-24.147h215.823c13.379 0 24.225 10.811 24.225 24.147v76.179q0 40.645-15.872 70.228-15.743 29.712-45.422 45.79-29.55 16.206-70.843 16.206-41.292 0-70.971-16.078-29.55-16.077-45.422-45.532Q72 612.767 72 572.638m85.132-29.84c-13.379 0-24.225 10.81-24.225 24.146v3.122q0 19.55 6.323 33.313 6.323 13.89 21.807 21.094 15.485 7.332 43.099 7.331t43.1-7.46q15.484-7.33 21.807-21.608 6.323-14.15 6.323-34.728v-1.064c0-13.336-10.846-24.146-24.225-24.146zM72 285.858c0-13.363 10.846-24.197 24.225-24.197h215.823c13.379 0 24.225 10.834 24.225 24.197v23.27c0 13.364-10.846 24.197-24.225 24.197H154.035c-13.379 0-24.225 10.834-24.225 24.197v58.328c0 13.364-10.846 24.197-24.225 24.197h-9.36C82.845 440.047 72 429.214 72 415.85zM278.463 24.72c0-13.374 10.846-24.216 24.225-24.216h9.36c13.379 0 24.225 10.842 24.225 24.216v181.174c0 13.374-10.846 24.216-24.225 24.216h-9.36c-13.379 0-24.225-10.842-24.225-24.216v-40.108c0-8.359-6.779-15.135-15.141-15.135H96.225c-13.38 0-24.225-10.842-24.225-24.216v-22.256c0-13.374 10.846-24.216 24.225-24.216h167.097c8.362 0 15.141-6.776 15.141-15.135z"/><path fill="#000" fill-rule="evenodd" d="M89.224 1062.13C78.997 1059.04 72 1049.63 72 1038.96v-25.9c0-16.486 16.145-28.147 31.818-22.979l215.823 71.169a24.19 24.19 0 0 1 16.632 22.98v62.97c0 10.45-6.706 19.71-16.632 22.98l-215.823 71.17C88.145 1246.51 72 1234.86 72 1218.37v-25.9c0-10.67 6.997-20.08 17.224-23.17l22.595-6.81a15.13 15.13 0 0 0 10.765-14.48v-64.59a15.13 15.13 0 0 0-10.765-14.48zm98.672 77.53 49.299-14.39c8.601-2.51 8.755-14.62.22-17.35l-49.299-15.75c-5.861-1.88-11.852 2.49-11.852 8.64v30.14c0 6.05 5.817 10.41 11.632 8.71" clip-rule="evenodd"/><path fill="#000" d="M72 773.439c0-13.367 10.846-24.203 24.225-24.203h215.823c13.379 0 24.225 10.836 24.225 24.203v89.762q0 29.395-10.711 51.439-10.71 22.046-30.84 34.293t-48.261 12.248q-28.388 0-47.873-12.635-18.187-11.672-28.056-32.218c-8.303-17.289-11.301-36.661-11.301-55.705v-43.867c0-77.976 138.26 4.16 86.215 4.16h-8.138c-12.334 0-22.332 9.989-22.332 22.311 0 8.269.351 16.6 3.097 24.487q3.225 9.024 10.194 13.794 6.968 4.899 18.194 4.899 11.356 0 18.453-4.899 7.226-4.77 10.581-13.794c2.815-7.188 3.484-14.944 3.484-22.596 0-13.366-10.846-24.202-24.225-24.202h-48.56c-12.036 0-16.288 11.345-21.122 20.272-6.79 12.539-25.841 7.72-25.841-6.536 0-7.586-6.156-13.736-13.749-13.736H96.225C82.845 820.916 72 810.08 72 796.714zm108.66 137.378-10.128 5.511-62.72 34.131C91.67 959.243 72 947.569 72 929.205V906.52a24.2 24.2 0 0 1 12.719-21.299l66.199-35.696a15.82 15.82 0 0 0 8.313-13.921c0-43.012 83.618 41.371 21.429 75.213"/></svg>';

// ../node_modules/@tldraw/editor/dist-esm/lib/license/useLicenseManagerState.mjs
function useLicenseManagerState(licenseManager) {
  return useValue("watermarkState", () => licenseManager.state.get(), [licenseManager]);
}

// ../node_modules/@tldraw/editor/dist-esm/lib/license/Watermark.mjs
var WATERMARK_DESKTOP_LOCAL_SRC = `data:image/svg+xml;utf8,${encodeURIComponent(watermarkDesktopSvg)}`;
var WATERMARK_MOBILE_LOCAL_SRC = `data:image/svg+xml;utf8,${encodeURIComponent(watermarkMobileSvg)}`;
var Watermark = (0, import_react32.memo)(function Watermark2() {
  const licenseManager = useLicenseContext();
  const editor = useEditor();
  const isMobile = useValue("is mobile", () => editor.getViewportScreenBounds().width < 700, [
    editor
  ]);
  const licenseManagerState = useLicenseManagerState(licenseManager);
  if (!["licensed-with-watermark", "unlicensed"].includes(licenseManagerState)) return null;
  return (0, import_jsx_runtime20.jsxs)(import_jsx_runtime20.Fragment, { children: [
    (0, import_jsx_runtime20.jsx)(LicenseStyles, {}),
    (0, import_jsx_runtime20.jsx)(
      WatermarkInner,
      {
        src: isMobile ? WATERMARK_MOBILE_LOCAL_SRC : WATERMARK_DESKTOP_LOCAL_SRC,
        isUnlicensed: licenseManagerState === "unlicensed"
      }
    )
  ] });
});
var UnlicensedWatermark = (0, import_react32.memo)(function UnlicensedWatermark2({
  isDebugMode,
  isMobile
}) {
  const editor = useEditor();
  const events = useCanvasEvents();
  const ref = (0, import_react32.useRef)(null);
  usePassThroughWheelEvents(ref);
  const url = "https://tldraw.dev/pricing?utm_source=sdk&utm_medium=organic&utm_campaign=watermark";
  return (0, import_jsx_runtime20.jsx)(
    "div",
    {
      ref,
      className: LicenseManager.className,
      "data-debug": isDebugMode,
      "data-mobile": isMobile,
      "data-unlicensed": true,
      "data-testid": "tl-watermark-unlicensed",
      draggable: false,
      ...events,
      children: (0, import_jsx_runtime20.jsx)(
        "button",
        {
          draggable: false,
          role: "button",
          onPointerDown: (e) => {
            editor.markEventAsHandled(e);
            preventDefault(e);
          },
          title: "The tldraw SDK requires a license key to work in production. You can get a free 100-day trial license at tldraw.dev/pricing.",
          onClick: () => {
            runtime.openWindow(url, "_blank", true);
          },
          children: "Get a license for production"
        }
      )
    }
  );
});
var WatermarkInner = (0, import_react32.memo)(function WatermarkInner2({
  src,
  isUnlicensed
}) {
  const editor = useEditor();
  const isDebugMode = useValue("debug mode", () => editor.getInstanceState().isDebugMode, [editor]);
  const isMobile = useValue("is mobile", () => editor.getViewportScreenBounds().width < 700, [
    editor
  ]);
  const events = useCanvasEvents();
  const ref = (0, import_react32.useRef)(null);
  usePassThroughWheelEvents(ref);
  const maskCss = `url('${src}') center 100% / 100% no-repeat`;
  const url = "https://tldraw.dev/?utm_source=sdk&utm_medium=organic&utm_campaign=watermark";
  if (isUnlicensed) {
    return (0, import_jsx_runtime20.jsx)(UnlicensedWatermark, { isDebugMode, isMobile });
  }
  return (0, import_jsx_runtime20.jsx)(
    "div",
    {
      ref,
      className: LicenseManager.className,
      "data-debug": isDebugMode,
      "data-mobile": isMobile,
      "data-testid": "tl-watermark-licensed",
      draggable: false,
      ...events,
      children: (0, import_jsx_runtime20.jsx)(
        "button",
        {
          draggable: false,
          role: "button",
          onPointerDown: (e) => {
            editor.markEventAsHandled(e);
            preventDefault(e);
          },
          title: "Build infinite canvas applications with the tldraw SDK. Learn more at https://tldraw.dev.",
          onClick: () => {
            runtime.openWindow(url, "_blank");
          },
          style: { mask: maskCss, WebkitMask: maskCss }
        }
      )
    }
  );
});
var LicenseStyles = (0, import_react32.memo)(function LicenseStyles2() {
  const editor = useEditor();
  const className = LicenseManager.className;
  const CSS2 = `
/* ------------------- SEE LICENSE -------------------
The tldraw watermark is part of tldraw's license. It is shown for unlicensed
or "licensed-with-watermark" users. By using this library, you agree to
preserve the watermark's behavior, keeping it visible, unobscured, and
available to user-interaction.

To remove the watermark, please purchase a license at tldraw.dev.
*/

.${className} {
	position: absolute;
	bottom: max(var(--tl-space-2), env(safe-area-inset-bottom));
	right: max(var(--tl-space-2), env(safe-area-inset-right));
	width: 96px;
	height: 32px;
	display: flex;
	align-items: center;
	justify-content: center;
	z-index: var(--tl-layer-watermark) !important;
	background-color: color-mix(in srgb, var(--tl-color-background) 62%, transparent);
	opacity: 1;
	border-radius: 5px;
	pointer-events: all;
	padding: 2px;
	box-sizing: content-box;
}

.${className} > button {
	position: absolute;
	width: 96px;
	height: 32px;
	pointer-events: all;
	cursor: inherit;
	color: var(--tl-color-text);
	opacity: .38;
	border: 0;
	padding: 0;
	background-color: currentColor;
}

.${className}[data-debug='true'] {
	bottom: max(46px, env(safe-area-inset-bottom));
}

.${className}[data-mobile='true'] {
	border-radius: 4px 0px 0px 4px;
	right: max(-2px, calc(env(safe-area-inset-right) - 2px));
	width: 8px;
	height: 48px;
}

.${className}[data-mobile='true'] > button {
	width: 8px;
	height: 32px;
}

.${className}[data-unlicensed='true'] > button {
	font-size: 100px;
	position: absolute;
	pointer-events: all;
	cursor: pointer;
	color: var(--tl-color-text);
	opacity: 0.8;
	border: 0;
	padding: 0;
	background-color: transparent;
	font-size: 11px;
	font-weight: 600;
	text-align: center;
}

.${className}[data-mobile='true'][data-unlicensed='true'] > button {
	display: none;
}

@media (hover: hover) {
	.${className} > button {
		pointer-events: none;
	}

	.${className}:hover {
		background-color: var(--tl-color-background);
		transition: background-color 0.2s ease-in-out;
		transition-delay: 0.32s;
	}

	.${className}:hover > button {
		animation: ${className}_delayed_link 0.2s forwards ease-in-out;
		animation-delay: 0.32s;
	}

	.${className} > button:focus-visible {
		opacity: 1;
	}
}

@keyframes ${className}_delayed_link {
	0% {
		cursor: inherit;
		opacity: .38;
		pointer-events: none;
	}
	100% {
		cursor: pointer;
		opacity: 1;
		pointer-events: all;
	}
}`;
  return (0, import_jsx_runtime20.jsx)("style", { nonce: editor.options.nonce, children: CSS2 });
});

// ../node_modules/@tldraw/editor/dist-esm/lib/TldrawEditor.mjs
var EMPTY_SHAPE_UTILS_ARRAY = [];
var EMPTY_BINDING_UTILS_ARRAY = [];
var EMPTY_TOOLS_ARRAY = [];
var TL_CONTAINER_CLASS = "tl-container";
var TldrawEditor = (0, import_react33.memo)(function TldrawEditor2({
  store,
  components,
  className,
  user: _user,
  options: _options,
  ...rest
}) {
  const [container, setContainer] = (0, import_react33.useState)(null);
  const user = (0, import_react33.useMemo)(() => _user ?? createTLUser(), [_user]);
  const ErrorFallback = (components == null ? void 0 : components.ErrorFallback) === void 0 ? DefaultErrorFallback : components == null ? void 0 : components.ErrorFallback;
  const withDefaults = {
    ...rest,
    shapeUtils: rest.shapeUtils ?? EMPTY_SHAPE_UTILS_ARRAY,
    bindingUtils: rest.bindingUtils ?? EMPTY_BINDING_UTILS_ARRAY,
    tools: rest.tools ?? EMPTY_TOOLS_ARRAY,
    components,
    options: useShallowObjectIdentity(_options)
  };
  return (0, import_jsx_runtime21.jsx)(
    "div",
    {
      ref: setContainer,
      "data-tldraw": version,
      draggable: false,
      className: (0, import_classnames6.default)(`${TL_CONTAINER_CLASS} tl-theme__light`, className),
      tabIndex: -1,
      role: "application",
      "aria-label": (_options == null ? void 0 : _options.branding) ?? "tldraw",
      children: (0, import_jsx_runtime21.jsx)(
        OptionalErrorBoundary,
        {
          fallback: ErrorFallback,
          onError: (error) => annotateError(error, { tags: { origin: "react.tldraw-before-app" } }),
          children: container && (0, import_jsx_runtime21.jsx)(LicenseProvider, { licenseKey: rest.licenseKey, children: (0, import_jsx_runtime21.jsx)(ContainerProvider, { container, children: (0, import_jsx_runtime21.jsx)(EditorComponentsProvider, { overrides: components, children: store ? store instanceof Store ? (
            // Store is ready to go, whether externally synced or not
            (0, import_jsx_runtime21.jsx)(TldrawEditorWithReadyStore, { ...withDefaults, store, user })
          ) : (
            // Store is a synced store, so handle syncing stages internally
            (0, import_jsx_runtime21.jsx)(TldrawEditorWithLoadingStore, { ...withDefaults, store, user })
          ) : (
            // We have no store (it's undefined) so create one and possibly sync it
            (0, import_jsx_runtime21.jsx)(TldrawEditorWithOwnStore, { ...withDefaults, store, user })
          ) }) }) })
        }
      )
    }
  );
});
function TldrawEditorWithOwnStore(props) {
  const {
    defaultName,
    snapshot,
    initialData,
    shapeUtils,
    bindingUtils,
    persistenceKey,
    sessionId,
    user,
    assets,
    migrations
  } = props;
  const syncedStore = useLocalStore({
    shapeUtils,
    bindingUtils,
    initialData,
    persistenceKey,
    sessionId,
    defaultName,
    snapshot,
    assets,
    migrations
  });
  return (0, import_jsx_runtime21.jsx)(TldrawEditorWithLoadingStore, { ...props, store: syncedStore, user });
}
var TldrawEditorWithLoadingStore = (0, import_react33.memo)(function TldrawEditorBeforeLoading({
  store,
  user,
  ...rest
}) {
  const container = useContainer();
  (0, import_react33.useLayoutEffect)(() => {
    if (user.userPreferences.get().colorScheme === "dark") {
      container.classList.remove("tl-theme__light");
      container.classList.add("tl-theme__dark");
    }
  }, [container, user]);
  const { LoadingScreen: LoadingScreen22 } = useEditorComponents();
  switch (store.status) {
    case "error": {
      throw store.error;
    }
    case "loading": {
      return LoadingScreen22 ? (0, import_jsx_runtime21.jsx)(LoadingScreen22, {}) : null;
    }
    case "not-synced": {
      break;
    }
    case "synced-local": {
      break;
    }
    case "synced-remote": {
      break;
    }
  }
  return (0, import_jsx_runtime21.jsx)(TldrawEditorWithReadyStore, { ...rest, store: store.store, user });
});
var noAutoFocus = () => document.location.search.includes("tldraw_preserve_focus");
function TldrawEditorWithReadyStore({
  onMount,
  children,
  store,
  tools,
  shapeUtils,
  bindingUtils,
  user,
  initialState: initialState2,
  autoFocus = true,
  inferDarkMode,
  cameraOptions,
  textOptions,
  options: options2,
  licenseKey,
  deepLinks: _deepLinks,
  getShapeVisibility,
  assetUrls
}) {
  const { ErrorFallback } = useEditorComponents();
  const container = useContainer();
  const [editor, setEditor] = useRefState(null);
  const canvasRef = (0, import_react33.useRef)(null);
  const deepLinks = useShallowObjectIdentity(_deepLinks === true ? {} : _deepLinks);
  const editorOptionsRef = (0, import_react33.useRef)({
    // for these, it's because they're only used when the editor first mounts:
    autoFocus: autoFocus && !noAutoFocus(),
    inferDarkMode,
    initialState: initialState2,
    // for these, it's because we keep them up to date in a separate effect:
    cameraOptions,
    deepLinks
  });
  (0, import_react33.useLayoutEffect)(() => {
    editorOptionsRef.current = {
      autoFocus: autoFocus && !noAutoFocus(),
      inferDarkMode,
      initialState: initialState2,
      cameraOptions,
      deepLinks
    };
  }, [autoFocus, inferDarkMode, initialState2, cameraOptions, deepLinks]);
  (0, import_react33.useLayoutEffect)(
    () => {
      const { autoFocus: autoFocus2, inferDarkMode: inferDarkMode2, initialState: initialState22, cameraOptions: cameraOptions2, deepLinks: deepLinks2 } = editorOptionsRef.current;
      const editor2 = new Editor({
        store,
        shapeUtils,
        bindingUtils,
        tools,
        getContainer: () => container,
        user,
        initialState: initialState22,
        // we should check for some kind of query parameter that turns off autofocus
        autoFocus: autoFocus2,
        inferDarkMode: inferDarkMode2,
        cameraOptions: cameraOptions2,
        textOptions,
        options: options2,
        licenseKey,
        getShapeVisibility,
        fontAssetUrls: assetUrls == null ? void 0 : assetUrls.fonts
      });
      editor2.updateViewportScreenBounds(canvasRef.current ?? container);
      if (deepLinks2) {
        if (!(deepLinks2 == null ? void 0 : deepLinks2.getUrl)) {
          editor2.navigateToDeepLink(deepLinks2);
        } else {
          editor2.navigateToDeepLink({ ...deepLinks2, url: deepLinks2.getUrl(editor2) });
        }
      }
      setEditor(editor2);
      return () => {
        editor2.dispose();
      };
    },
    // if any of these change, we need to recreate the editor.
    [
      bindingUtils,
      container,
      options2,
      shapeUtils,
      store,
      tools,
      user,
      setEditor,
      licenseKey,
      getShapeVisibility,
      textOptions,
      assetUrls
    ]
  );
  (0, import_react33.useLayoutEffect)(() => {
    if (!editor) return;
    if (deepLinks) {
      return editor.registerDeepLinkListener(deepLinks);
    }
  }, [editor, deepLinks]);
  (0, import_react33.useLayoutEffect)(() => {
    if (editor && cameraOptions) {
      editor.setCameraOptions(cameraOptions);
    }
  }, [editor, cameraOptions]);
  const crashingError = (0, import_react33.useSyncExternalStore)(
    (0, import_react33.useCallback)(
      (onStoreChange) => {
        if (editor) {
          editor.on("crash", onStoreChange);
          return () => editor.off("crash", onStoreChange);
        }
        return () => {
        };
      },
      [editor]
    ),
    () => (editor == null ? void 0 : editor.getCrashingError()) ?? null
  );
  (0, import_react33.useEffect)(
    function handleFocusOnPointerDownForPreserveFocusMode() {
      if (!editor) return;
      function handleFocusOnPointerDown() {
        if (!editor) return;
        editor.focus();
      }
      function handleBlurOnPointerDown() {
        if (!editor) return;
        editor.blur();
      }
      if (autoFocus && noAutoFocus()) {
        editor.getContainer().addEventListener("pointerdown", handleFocusOnPointerDown);
        document.body.addEventListener("pointerdown", handleBlurOnPointerDown);
        return () => {
          var _a6;
          (_a6 = editor.getContainer()) == null ? void 0 : _a6.removeEventListener("pointerdown", handleFocusOnPointerDown);
          document.body.removeEventListener("pointerdown", handleBlurOnPointerDown);
        };
      }
    },
    [editor, autoFocus]
  );
  const [_fontLoadingState, setFontLoadingState] = (0, import_react33.useState)(null);
  let fontLoadingState = _fontLoadingState;
  if (editor !== (fontLoadingState == null ? void 0 : fontLoadingState.editor)) {
    fontLoadingState = null;
  }
  (0, import_react33.useLayoutEffect)(() => {
    if (!editor) return;
    if (editor.options.maxFontsToLoadBeforeRender === 0) {
      setFontLoadingState({ editor, isLoaded: true });
      return;
    }
    let isCancelled = false;
    setFontLoadingState({ editor, isLoaded: false });
    editor.fonts.loadRequiredFontsForCurrentPage(editor.options.maxFontsToLoadBeforeRender).finally(() => {
      if (isCancelled) return;
      setFontLoadingState({ editor, isLoaded: true });
    });
    return () => {
      isCancelled = true;
    };
  }, [editor]);
  const { Canvas, LoadingScreen: LoadingScreen22 } = useEditorComponents();
  if (!editor || !(fontLoadingState == null ? void 0 : fontLoadingState.isLoaded)) {
    return (0, import_jsx_runtime21.jsxs)(import_jsx_runtime21.Fragment, { children: [
      LoadingScreen22 && (0, import_jsx_runtime21.jsx)(LoadingScreen22, {}),
      (0, import_jsx_runtime21.jsx)("div", { className: "tl-canvas", ref: canvasRef })
    ] });
  }
  return (
    // the top-level tldraw component also renders an error boundary almost
    // identical to this one. the reason we have two is because this one has
    // access to `App`, which means that here we can enrich errors with data
    // from app for reporting, and also still attempt to render the user's
    // document in the event of an error to reassure them that their work is
    // not lost.
    (0, import_jsx_runtime21.jsx)(OptionalErrorBoundary, {
      fallback: ErrorFallback,
      onError: (error) => editor.annotateError(error, { origin: "react.tldraw", willCrashApp: true }),
      children: crashingError ? (0, import_jsx_runtime21.jsx)(Crash, { crashingError }) : (0, import_jsx_runtime21.jsx)(EditorProvider, { editor, children: (0, import_jsx_runtime21.jsxs)(Layout, { onMount, children: [
        children ?? (Canvas ? (0, import_jsx_runtime21.jsx)(Canvas, {}, editor.contextId) : null),
        (0, import_jsx_runtime21.jsx)(Watermark, {})
      ] }) })
    })
  );
}
function Layout({ children, onMount }) {
  useZoomCss();
  useCursor();
  useDarkMode();
  useForceUpdate();
  useStateAttribute();
  useOnMount((editor) => {
    const teardownStore = editor.store.props.onMount(editor);
    const teardownCallback = onMount == null ? void 0 : onMount(editor);
    return () => {
      teardownStore == null ? void 0 : teardownStore();
      teardownCallback == null ? void 0 : teardownCallback();
    };
  });
  return children;
}
function Crash({ crashingError }) {
  throw crashingError;
}
function LoadingScreen({ children }) {
  return (0, import_jsx_runtime21.jsx)("div", { className: "tl-loading", "aria-busy": "true", tabIndex: 0, children });
}
function ErrorScreen({ children }) {
  return (0, import_jsx_runtime21.jsx)("div", { className: "tl-loading", children });
}
function useOnMount(onMount) {
  const editor = useEditor();
  const onMountEvent = useEvent((editor2) => {
    let teardown = void 0;
    editor2.run(
      () => {
        teardown = onMount == null ? void 0 : onMount(editor2);
        editor2.emit("mount");
      },
      { history: "ignore" }
    );
    window.tldrawReady = true;
    return teardown;
  });
  import_react33.default.useLayoutEffect(() => {
    if (editor) return onMountEvent == null ? void 0 : onMountEvent(editor);
  }, [editor, onMountEvent]);
}

// ../node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultLoadingScreen.mjs
var DefaultLoadingScreen = () => {
  const { Spinner: Spinner2 } = useEditorComponents();
  return (0, import_jsx_runtime22.jsx)(LoadingScreen, { children: Spinner2 ? (0, import_jsx_runtime22.jsx)(Spinner2, {}) : null });
};

// ../node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultScribble.mjs
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
var import_classnames7 = __toESM(require_classnames(), 1);

// ../node_modules/@tldraw/editor/dist-esm/lib/utils/getSvgPathFromPoints.mjs
function getSvgPathFromPoints(points, closed = true) {
  const len = points.length;
  if (len < 2) {
    return "";
  }
  let a = points[0];
  let b = points[1];
  if (len === 2) {
    return `M${precise(a)}L${precise(b)}`;
  }
  let result = "";
  for (let i = 2, max2 = len - 1; i < max2; i++) {
    a = points[i];
    b = points[i + 1];
    result += average(a, b);
  }
  if (closed) {
    return `M${average(points[0], points[1])}Q${precise(points[1])}${average(
      points[1],
      points[2]
    )}T${result}${average(points[len - 1], points[0])}${average(points[0], points[1])}Z`;
  } else {
    return `M${precise(points[0])}Q${precise(points[1])}${average(points[1], points[2])}${points.length > 3 ? "T" : ""}${result}L${precise(points[len - 1])}`;
  }
}

// ../node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultScribble.mjs
function DefaultScribble({ scribble, zoom, color, opacity, className }) {
  if (!scribble.points.length) return null;
  return (0, import_jsx_runtime23.jsx)("svg", { className: className ? (0, import_classnames7.default)("tl-overlays__item", className) : className, children: (0, import_jsx_runtime23.jsx)(
    "path",
    {
      className: "tl-scribble",
      d: getSvgPathFromPoints(scribble.points, false),
      stroke: color ?? `var(--tl-color-${scribble.color})`,
      fill: "none",
      strokeWidth: 8 / zoom,
      opacity: opacity ?? scribble.opacity
    }
  ) });
}

// ../node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultSelectionForeground.mjs
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
var import_classnames8 = __toESM(require_classnames(), 1);
var import_react34 = __toESM(require_react(), 1);
function DefaultSelectionForeground({ bounds, rotation }) {
  const editor = useEditor();
  const rSvg = (0, import_react34.useRef)(null);
  const onlyShape = useValue("only selected shape", () => editor.getOnlySelectedShape(), [editor]);
  const expandOutlineBy = onlyShape ? editor.getShapeUtil(onlyShape).expandSelectionOutlinePx(onlyShape) : 0;
  useTransform(rSvg, bounds == null ? void 0 : bounds.x, bounds == null ? void 0 : bounds.y, 1, rotation, {
    x: -expandOutlineBy,
    y: -expandOutlineBy
  });
  bounds = expandOutlineBy instanceof Box ? bounds.clone().expand(expandOutlineBy).zeroFix() : bounds.clone().expandBy(expandOutlineBy).zeroFix();
  return (0, import_jsx_runtime24.jsx)(
    "svg",
    {
      ref: rSvg,
      className: "tl-overlays__item tl-selection__fg",
      "data-testid": "selection-foreground",
      children: (0, import_jsx_runtime24.jsx)(
        "rect",
        {
          className: (0, import_classnames8.default)("tl-selection__fg__outline"),
          width: toDomPrecision(bounds.width),
          height: toDomPrecision(bounds.height)
        }
      )
    }
  );
}

// ../node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultShapeErrorFallback.mjs
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
var DefaultShapeErrorFallback = () => {
  return (0, import_jsx_runtime25.jsx)("div", { className: "tl-shape-error-boundary" });
};

// ../node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultShapeIndicator.mjs
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
var import_classnames9 = __toESM(require_classnames(), 1);
var import_react35 = __toESM(require_react(), 1);
var EvenInnererIndicator = (0, import_react35.memo)(
  ({ shape, util }) => {
    return useStateTracking(
      "Indicator: " + shape.type,
      () => (
        // always fetch the latest shape from the store even if the props/meta have not changed, to avoid
        // calling the render method with stale data.
        util.indicator(util.editor.store.unsafeGetWithoutCapture(shape.id))
      )
    );
  },
  (prevProps, nextProps) => {
    return prevProps.shape.props === nextProps.shape.props && prevProps.shape.meta === nextProps.shape.meta;
  }
);
var InnerIndicator = (0, import_react35.memo)(({ editor, id }) => {
  const shape = useValue("shape for indicator", () => editor.store.get(id), [editor, id]);
  const { ShapeIndicatorErrorFallback } = useEditorComponents();
  if (!shape || shape.isLocked) return null;
  return (0, import_jsx_runtime26.jsx)(
    OptionalErrorBoundary,
    {
      fallback: ShapeIndicatorErrorFallback,
      onError: (error) => editor.annotateError(error, { origin: "react.shapeIndicator", willCrashApp: false }),
      children: (0, import_jsx_runtime26.jsx)(EvenInnererIndicator, { shape, util: editor.getShapeUtil(shape) }, shape.id)
    }
  );
});
var DefaultShapeIndicator = (0, import_react35.memo)(function DefaultShapeIndicator2({
  shapeId,
  className,
  color,
  hidden,
  opacity
}) {
  const editor = useEditor();
  const rIndicator = (0, import_react35.useRef)(null);
  useQuickReactor(
    "indicator transform",
    () => {
      if (hidden) return;
      const elm = rIndicator.current;
      if (!elm) return;
      const pageTransform = editor.getShapePageTransform(shapeId);
      if (!pageTransform) return;
      elm.style.setProperty("transform", pageTransform.toCssString());
    },
    [editor, shapeId, hidden]
  );
  (0, import_react35.useLayoutEffect)(() => {
    const elm = rIndicator.current;
    if (!elm) return;
    elm.style.setProperty("display", hidden ? "none" : "block");
  }, [hidden]);
  return (0, import_jsx_runtime26.jsx)("svg", { ref: rIndicator, className: (0, import_classnames9.default)("tl-overlays__item", className), "aria-hidden": "true", children: (0, import_jsx_runtime26.jsx)(
    "g",
    {
      className: "tl-shape-indicator",
      stroke: color ?? "var(--tl-color-selected)",
      opacity,
      children: (0, import_jsx_runtime26.jsx)(InnerIndicator, { editor, id: shapeId })
    }
  ) });
});

// ../node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultShapeIndicatorErrorFallback.mjs
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
var DefaultShapeIndicatorErrorFallback = () => {
  return (0, import_jsx_runtime27.jsx)("circle", { cx: 4, cy: 4, r: 8, strokeWidth: "1", stroke: "red" });
};

// ../node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultShapeIndicators.mjs
var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
var import_react36 = __toESM(require_react(), 1);
var DefaultShapeIndicators = (0, import_react36.memo)(function DefaultShapeIndicators2({
  hideAll,
  showAll
}) {
  const editor = useEditor();
  if (hideAll && showAll)
    throw Error("You cannot set both hideAll and showAll props to true, cmon now");
  const rPreviousSelectedShapeIds = (0, import_react36.useRef)(/* @__PURE__ */ new Set());
  const idsToDisplay = useValue(
    "should display selected ids",
    () => {
      const prev = rPreviousSelectedShapeIds.current;
      const next = /* @__PURE__ */ new Set();
      const instanceState = editor.getInstanceState();
      const isChangingStyle = instanceState.isChangingStyle;
      const isIdleOrEditing = editor.isInAny("select.idle", "select.editing_shape");
      const isInSelectState = editor.isInAny(
        "select.brushing",
        "select.scribble_brushing",
        "select.pointing_shape",
        "select.pointing_selection",
        "select.pointing_handle"
      );
      if (isChangingStyle || !(isIdleOrEditing || isInSelectState)) {
        rPreviousSelectedShapeIds.current = next;
        return next;
      }
      for (const id of editor.getSelectedShapeIds()) {
        next.add(id);
      }
      if (isIdleOrEditing && instanceState.isHoveringCanvas && !instanceState.isCoarsePointer) {
        const hovered = editor.getHoveredShapeId();
        if (hovered) next.add(hovered);
      }
      if (prev.size !== next.size) {
        rPreviousSelectedShapeIds.current = next;
        return next;
      }
      for (const id of next) {
        if (!prev.has(id)) {
          rPreviousSelectedShapeIds.current = next;
          return next;
        }
      }
      return prev;
    },
    [editor]
  );
  const renderingShapes = useValue("rendering shapes", () => editor.getRenderingShapes(), [editor]);
  const { ShapeIndicator } = useEditorComponents();
  if (!ShapeIndicator) return null;
  return renderingShapes.map(({ id }) => (0, import_jsx_runtime28.jsx)(
    ShapeIndicator,
    {
      shapeId: id,
      hidden: !showAll && (hideAll || !idsToDisplay.has(id))
    },
    id + "_indicator"
  ));
});

// ../node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultShapeWrapper.mjs
var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);
var import_classnames10 = __toESM(require_classnames(), 1);
var import_react37 = __toESM(require_react(), 1);
var DefaultShapeWrapper = (0, import_react37.forwardRef)(function DefaultShapeWrapper2({ children, shape, isBackground, ...props }, ref) {
  const isFilledShape = "fill" in shape.props && shape.props.fill !== "none";
  return (0, import_jsx_runtime29.jsx)(
    "div",
    {
      ref,
      "data-shape-type": shape.type,
      "data-shape-is-filled": isBackground ? void 0 : isFilledShape,
      "data-shape-id": shape.id,
      draggable: false,
      ...props,
      className: (0, import_classnames10.default)("tl-shape", isBackground && "tl-shape-background", props.className),
      children
    }
  );
});

// ../node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultSnapIndictor.mjs
var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);
var import_classnames11 = __toESM(require_classnames(), 1);
var React7 = __toESM(require_react(), 1);
function PointsSnapIndicator({ points, zoom }) {
  const l = 2.5 / zoom;
  const minX = points.reduce((acc, p) => Math.min(acc, p.x), Infinity);
  const maxX = points.reduce((acc, p) => Math.max(acc, p.x), -Infinity);
  const minY = points.reduce((acc, p) => Math.min(acc, p.y), Infinity);
  const maxY = points.reduce((acc, p) => Math.max(acc, p.y), -Infinity);
  const useNWtoSEdireciton = points.some((p) => p.x === minX && p.y === minY);
  let firstX, firstY, secondX, secondY;
  if (useNWtoSEdireciton) {
    firstX = minX;
    firstY = minY;
    secondX = maxX;
    secondY = maxY;
  } else {
    firstX = minX;
    firstY = maxY;
    secondX = maxX;
    secondY = minY;
  }
  return (0, import_jsx_runtime30.jsxs)("g", { className: "tl-snap-indicator", stroke: "lime", children: [
    (0, import_jsx_runtime30.jsx)("line", { x1: firstX, y1: firstY, x2: secondX, y2: secondY }),
    points.map((p, i) => (0, import_jsx_runtime30.jsx)("g", { transform: `translate(${p.x},${p.y})`, children: (0, import_jsx_runtime30.jsx)(
      "path",
      {
        className: "tl-snap-point",
        d: `M ${-l},${-l} L ${l},${l} M ${-l},${l} L ${l},${-l}`
      }
    ) }, i))
  ] });
}
function GapsSnapIndicator({ gaps, direction, zoom }) {
  const l = 3.5 / zoom;
  let edgeIntersection = [-Infinity, Infinity];
  let nextEdgeIntersection = null;
  const horizontal = direction === "horizontal";
  for (const gap of gaps) {
    nextEdgeIntersection = rangeIntersection(
      edgeIntersection[0],
      edgeIntersection[1],
      horizontal ? gap.startEdge[0].y : gap.startEdge[0].x,
      horizontal ? gap.startEdge[1].y : gap.startEdge[1].x
    );
    if (nextEdgeIntersection) {
      edgeIntersection = nextEdgeIntersection;
    } else {
      continue;
    }
    nextEdgeIntersection = rangeIntersection(
      edgeIntersection[0],
      edgeIntersection[1],
      horizontal ? gap.endEdge[0].y : gap.endEdge[0].x,
      horizontal ? gap.endEdge[1].y : gap.endEdge[1].x
    );
    if (nextEdgeIntersection) {
      edgeIntersection = nextEdgeIntersection;
    } else {
      continue;
    }
  }
  if (edgeIntersection === null) {
    return null;
  }
  const midPoint = (edgeIntersection[0] + edgeIntersection[1]) / 2;
  return (0, import_jsx_runtime30.jsx)("g", { className: "tl-snap-indicator", stroke: "cyan", children: gaps.map(({ startEdge, endEdge }, i) => (0, import_jsx_runtime30.jsx)(React7.Fragment, { children: horizontal ? (
    // horizontal gap
    (0, import_jsx_runtime30.jsxs)(import_jsx_runtime30.Fragment, { children: [
      (0, import_jsx_runtime30.jsx)(
        "line",
        {
          x1: startEdge[0].x,
          y1: midPoint - 2 * l,
          x2: startEdge[1].x,
          y2: midPoint + 2 * l
        }
      ),
      (0, import_jsx_runtime30.jsx)(
        "line",
        {
          x1: endEdge[0].x,
          y1: midPoint - 2 * l,
          x2: endEdge[1].x,
          y2: midPoint + 2 * l
        }
      ),
      (0, import_jsx_runtime30.jsx)("line", { x1: startEdge[0].x, y1: midPoint, x2: endEdge[0].x, y2: midPoint }),
      (0, import_jsx_runtime30.jsx)(
        "line",
        {
          x1: (startEdge[0].x + endEdge[0].x) / 2,
          y1: midPoint - l,
          x2: (startEdge[0].x + endEdge[0].x) / 2,
          y2: midPoint + l
        }
      )
    ] })
  ) : (
    // vertical gap
    (0, import_jsx_runtime30.jsxs)(import_jsx_runtime30.Fragment, { children: [
      (0, import_jsx_runtime30.jsx)(
        "line",
        {
          x1: midPoint - 2 * l,
          y1: startEdge[0].y,
          x2: midPoint + 2 * l,
          y2: startEdge[1].y
        }
      ),
      (0, import_jsx_runtime30.jsx)(
        "line",
        {
          x1: midPoint - 2 * l,
          y1: endEdge[0].y,
          x2: midPoint + 2 * l,
          y2: endEdge[1].y
        }
      ),
      (0, import_jsx_runtime30.jsx)("line", { x1: midPoint, y1: startEdge[0].y, x2: midPoint, y2: endEdge[0].y }),
      (0, import_jsx_runtime30.jsx)(
        "line",
        {
          x1: midPoint - l,
          y1: (startEdge[0].y + endEdge[0].y) / 2,
          x2: midPoint + l,
          y2: (startEdge[0].y + endEdge[0].y) / 2
        }
      )
    ] })
  ) }, i)) });
}
function DefaultSnapIndicator({ className, line, zoom }) {
  return (0, import_jsx_runtime30.jsx)("svg", { className: (0, import_classnames11.default)("tl-overlays__item", className), "aria-hidden": "true", children: line.type === "points" ? (0, import_jsx_runtime30.jsx)(PointsSnapIndicator, { ...line, zoom }) : line.type === "gaps" ? (0, import_jsx_runtime30.jsx)(GapsSnapIndicator, { ...line, zoom }) : null });
}

// ../node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultSpinner.mjs
var import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);
var import_classnames12 = __toESM(require_classnames(), 1);
function DefaultSpinner(props) {
  return (0, import_jsx_runtime31.jsx)(
    "svg",
    {
      width: 16,
      height: 16,
      viewBox: "0 0 16 16",
      "aria-hidden": "false",
      ...props,
      className: (0, import_classnames12.default)("tl-spinner", props.className),
      children: (0, import_jsx_runtime31.jsxs)("g", { strokeWidth: 2, fill: "none", fillRule: "evenodd", children: [
        (0, import_jsx_runtime31.jsx)("circle", { strokeOpacity: 0.25, cx: 8, cy: 8, r: 7, stroke: "currentColor" }),
        (0, import_jsx_runtime31.jsx)("path", { strokeLinecap: "round", d: "M15 8c0-4.5-4.5-7-7-7", stroke: "currentColor" })
      ] })
    }
  );
}

// ../node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultSvgDefs.mjs
var DefaultSvgDefs = () => {
  return null;
};

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/useEditorComponents.mjs
var EditorComponentsContext = (0, import_react38.createContext)(null);
function EditorComponentsProvider({
  overrides = {},
  children
}) {
  const _overrides = useShallowObjectIdentity(overrides);
  const value = (0, import_react38.useMemo)(
    () => ({
      Background: DefaultBackground,
      Brush: DefaultBrush,
      Canvas: DefaultCanvas,
      CollaboratorBrush: DefaultBrush,
      CollaboratorCursor: DefaultCursor,
      CollaboratorHint: DefaultCollaboratorHint,
      CollaboratorScribble: DefaultScribble,
      CollaboratorShapeIndicator: DefaultShapeIndicator,
      Cursor: DefaultCursor,
      Grid: DefaultGrid,
      Handle: DefaultHandle,
      Handles: DefaultHandles,
      InFrontOfTheCanvas: null,
      LoadingScreen: DefaultLoadingScreen,
      OnTheCanvas: null,
      Overlays: null,
      Scribble: DefaultScribble,
      SelectionBackground: null,
      SelectionForeground: DefaultSelectionForeground,
      ShapeIndicator: DefaultShapeIndicator,
      ShapeIndicators: DefaultShapeIndicators,
      ShapeWrapper: DefaultShapeWrapper,
      SnapIndicator: DefaultSnapIndicator,
      Spinner: DefaultSpinner,
      SvgDefs: DefaultSvgDefs,
      ZoomBrush: DefaultBrush,
      ErrorFallback: DefaultErrorFallback,
      ShapeErrorFallback: DefaultShapeErrorFallback,
      ShapeIndicatorErrorFallback: DefaultShapeIndicatorErrorFallback,
      ..._overrides
    }),
    [_overrides]
  );
  return (0, import_jsx_runtime32.jsx)(EditorComponentsContext.Provider, { value, children });
}
function useEditorComponents() {
  const components = (0, import_react38.useContext)(EditorComponentsContext);
  if (!components) {
    throw new Error("useEditorComponents must be used inside of <EditorComponentsProvider />");
  }
  return components;
}

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/useFixSafariDoubleTapZoomPencilEvents.mjs
var import_react39 = __toESM(require_react(), 1);
var IGNORED_TAGS = ["textarea", "input"];
function useFixSafariDoubleTapZoomPencilEvents(ref) {
  const editor = useEditor();
  (0, import_react39.useEffect)(() => {
    const elm = ref.current;
    if (!elm) return;
    const handleEvent = (e) => {
      var _a6;
      if (e instanceof PointerEvent && e.pointerType === "pen") {
        editor.markEventAsHandled(e);
        const { target } = e;
        if (IGNORED_TAGS.includes((_a6 = target.tagName) == null ? void 0 : _a6.toLocaleLowerCase()) || target.isContentEditable || editor.isIn("select.editing_shape")) {
          return;
        }
        preventDefault(e);
      }
    };
    elm.addEventListener("touchstart", handleEvent);
    elm.addEventListener("touchend", handleEvent);
    return () => {
      elm.removeEventListener("touchstart", handleEvent);
      elm.removeEventListener("touchend", handleEvent);
    };
  }, [editor, ref]);
}

// ../node_modules/@use-gesture/core/dist/maths-0ab39ae9.esm.js
function clamp2(v, min3, max2) {
  return Math.max(min3, Math.min(v, max2));
}
var V = {
  toVector(v, fallback) {
    if (v === void 0) v = fallback;
    return Array.isArray(v) ? v : [v, v];
  },
  add(v1, v2) {
    return [v1[0] + v2[0], v1[1] + v2[1]];
  },
  sub(v1, v2) {
    return [v1[0] - v2[0], v1[1] - v2[1]];
  },
  addTo(v1, v2) {
    v1[0] += v2[0];
    v1[1] += v2[1];
  },
  subTo(v1, v2) {
    v1[0] -= v2[0];
    v1[1] -= v2[1];
  }
};
function rubberband(distance, dimension, constant) {
  if (dimension === 0 || Math.abs(dimension) === Infinity) return Math.pow(distance, constant * 5);
  return distance * dimension * constant / (dimension + constant * distance);
}
function rubberbandIfOutOfBounds(position, min3, max2, constant = 0.15) {
  if (constant === 0) return clamp2(position, min3, max2);
  if (position < min3) return -rubberband(min3 - position, max2 - min3, constant) + min3;
  if (position > max2) return +rubberband(position - max2, max2 - min3, constant) + max2;
  return position;
}
function computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {
  const [[X0, X1], [Y0, Y1]] = bounds;
  return [rubberbandIfOutOfBounds(Vx, X0, X1, Rx), rubberbandIfOutOfBounds(Vy, Y0, Y1, Ry)];
}

// ../node_modules/@use-gesture/core/dist/actions-fe213e88.esm.js
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys(e, r) {
  var t2 = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t2 = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t2), true).forEach(function(r2) {
      _defineProperty(e, r2, t2[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t2, r2));
    });
  }
  return e;
}
var EVENT_TYPE_MAP = {
  pointer: {
    start: "down",
    change: "move",
    end: "up"
  },
  mouse: {
    start: "down",
    change: "move",
    end: "up"
  },
  touch: {
    start: "start",
    change: "move",
    end: "end"
  },
  gesture: {
    start: "start",
    change: "change",
    end: "end"
  }
};
function capitalize(string) {
  if (!string) return "";
  return string[0].toUpperCase() + string.slice(1);
}
var actionsWithoutCaptureSupported = ["enter", "leave"];
function hasCapture(capture = false, actionKey) {
  return capture && !actionsWithoutCaptureSupported.includes(actionKey);
}
function toHandlerProp(device, action = "", capture = false) {
  const deviceProps = EVENT_TYPE_MAP[device];
  const actionKey = deviceProps ? deviceProps[action] || action : action;
  return "on" + capitalize(device) + capitalize(actionKey) + (hasCapture(capture, actionKey) ? "Capture" : "");
}
var pointerCaptureEvents = ["gotpointercapture", "lostpointercapture"];
function parseProp(prop) {
  let eventKey = prop.substring(2).toLowerCase();
  const passive = !!~eventKey.indexOf("passive");
  if (passive) eventKey = eventKey.replace("passive", "");
  const captureKey = pointerCaptureEvents.includes(eventKey) ? "capturecapture" : "capture";
  const capture = !!~eventKey.indexOf(captureKey);
  if (capture) eventKey = eventKey.replace("capture", "");
  return {
    device: eventKey,
    capture,
    passive
  };
}
function toDomEventType(device, action = "") {
  const deviceProps = EVENT_TYPE_MAP[device];
  const actionKey = deviceProps ? deviceProps[action] || action : action;
  return device + actionKey;
}
function isTouch(event) {
  return "touches" in event;
}
function getPointerType(event) {
  if (isTouch(event)) return "touch";
  if ("pointerType" in event) return event.pointerType;
  return "mouse";
}
function getCurrentTargetTouchList(event) {
  return Array.from(event.touches).filter((e) => {
    var _event$currentTarget, _event$currentTarget$;
    return e.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 || (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e.target));
  });
}
function distanceAngle(P1, P2) {
  try {
    const dx = P2.clientX - P1.clientX;
    const dy = P2.clientY - P1.clientY;
    const cx = (P2.clientX + P1.clientX) / 2;
    const cy = (P2.clientY + P1.clientY) / 2;
    const distance = Math.hypot(dx, dy);
    const angle = -(Math.atan2(dx, dy) * 180) / Math.PI;
    const origin = [cx, cy];
    return {
      angle,
      distance,
      origin
    };
  } catch (_unused) {
  }
  return null;
}
function touchIds(event) {
  return getCurrentTargetTouchList(event).map((touch) => touch.identifier);
}
function touchDistanceAngle(event, ids) {
  const [P1, P2] = Array.from(event.touches).filter((touch) => ids.includes(touch.identifier));
  return distanceAngle(P1, P2);
}
var LINE_HEIGHT = 40;
var PAGE_HEIGHT = 800;
function wheelValues(event) {
  let {
    deltaX,
    deltaY,
    deltaMode
  } = event;
  if (deltaMode === 1) {
    deltaX *= LINE_HEIGHT;
    deltaY *= LINE_HEIGHT;
  } else if (deltaMode === 2) {
    deltaX *= PAGE_HEIGHT;
    deltaY *= PAGE_HEIGHT;
  }
  return [deltaX, deltaY];
}
function getEventDetails(event) {
  const payload = {};
  if ("buttons" in event) payload.buttons = event.buttons;
  if ("shiftKey" in event) {
    const {
      shiftKey,
      altKey: altKey2,
      metaKey,
      ctrlKey: ctrlKey2
    } = event;
    Object.assign(payload, {
      shiftKey,
      altKey: altKey2,
      metaKey,
      ctrlKey: ctrlKey2
    });
  }
  return payload;
}
function call(v, ...args) {
  if (typeof v === "function") {
    return v(...args);
  } else {
    return v;
  }
}
function noop2() {
}
function chain(...fns) {
  if (fns.length === 0) return noop2;
  if (fns.length === 1) return fns[0];
  return function() {
    let result;
    for (const fn of fns) {
      result = fn.apply(this, arguments) || result;
    }
    return result;
  };
}
function assignDefault(value, fallback) {
  return Object.assign({}, fallback, value || {});
}
var BEFORE_LAST_KINEMATICS_DELAY = 32;
var Engine = class {
  constructor(ctrl, args, key) {
    this.ctrl = ctrl;
    this.args = args;
    this.key = key;
    if (!this.state) {
      this.state = {};
      this.computeValues([0, 0]);
      this.computeInitial();
      if (this.init) this.init();
      this.reset();
    }
  }
  get state() {
    return this.ctrl.state[this.key];
  }
  set state(state) {
    this.ctrl.state[this.key] = state;
  }
  get shared() {
    return this.ctrl.state.shared;
  }
  get eventStore() {
    return this.ctrl.gestureEventStores[this.key];
  }
  get timeoutStore() {
    return this.ctrl.gestureTimeoutStores[this.key];
  }
  get config() {
    return this.ctrl.config[this.key];
  }
  get sharedConfig() {
    return this.ctrl.config.shared;
  }
  get handler() {
    return this.ctrl.handlers[this.key];
  }
  reset() {
    const {
      state,
      shared,
      ingKey,
      args
    } = this;
    shared[ingKey] = state._active = state.active = state._blocked = state._force = false;
    state._step = [false, false];
    state.intentional = false;
    state._movement = [0, 0];
    state._distance = [0, 0];
    state._direction = [0, 0];
    state._delta = [0, 0];
    state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];
    state.args = args;
    state.axis = void 0;
    state.memo = void 0;
    state.elapsedTime = state.timeDelta = 0;
    state.direction = [0, 0];
    state.distance = [0, 0];
    state.overflow = [0, 0];
    state._movementBound = [false, false];
    state.velocity = [0, 0];
    state.movement = [0, 0];
    state.delta = [0, 0];
    state.timeStamp = 0;
  }
  start(event) {
    const state = this.state;
    const config = this.config;
    if (!state._active) {
      this.reset();
      this.computeInitial();
      state._active = true;
      state.target = event.target;
      state.currentTarget = event.currentTarget;
      state.lastOffset = config.from ? call(config.from, state) : state.offset;
      state.offset = state.lastOffset;
      state.startTime = state.timeStamp = event.timeStamp;
    }
  }
  computeValues(values) {
    const state = this.state;
    state._values = values;
    state.values = this.config.transform(values);
  }
  computeInitial() {
    const state = this.state;
    state._initial = state._values;
    state.initial = state.values;
  }
  compute(event) {
    const {
      state,
      config,
      shared
    } = this;
    state.args = this.args;
    let dt = 0;
    if (event) {
      state.event = event;
      if (config.preventDefault && event.cancelable) state.event.preventDefault();
      state.type = event.type;
      shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;
      shared.locked = !!document.pointerLockElement;
      Object.assign(shared, getEventDetails(event));
      shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;
      dt = event.timeStamp - state.timeStamp;
      state.timeStamp = event.timeStamp;
      state.elapsedTime = state.timeStamp - state.startTime;
    }
    if (state._active) {
      const _absoluteDelta = state._delta.map(Math.abs);
      V.addTo(state._distance, _absoluteDelta);
    }
    if (this.axisIntent) this.axisIntent(event);
    const [_m0, _m1] = state._movement;
    const [t0, t1] = config.threshold;
    const {
      _step,
      values
    } = state;
    if (config.hasCustomTransform) {
      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && values[0];
      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && values[1];
    } else {
      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;
      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;
    }
    state.intentional = _step[0] !== false || _step[1] !== false;
    if (!state.intentional) return;
    const movement = [0, 0];
    if (config.hasCustomTransform) {
      const [v0, v1] = values;
      movement[0] = _step[0] !== false ? v0 - _step[0] : 0;
      movement[1] = _step[1] !== false ? v1 - _step[1] : 0;
    } else {
      movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;
      movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;
    }
    if (this.restrictToAxis && !state._blocked) this.restrictToAxis(movement);
    const previousOffset = state.offset;
    const gestureIsActive = state._active && !state._blocked || state.active;
    if (gestureIsActive) {
      state.first = state._active && !state.active;
      state.last = !state._active && state.active;
      state.active = shared[this.ingKey] = state._active;
      if (event) {
        if (state.first) {
          if ("bounds" in config) state._bounds = call(config.bounds, state);
          if (this.setup) this.setup();
        }
        state.movement = movement;
        this.computeOffset();
      }
    }
    const [ox, oy] = state.offset;
    const [[x0, x1], [y0, y1]] = state._bounds;
    state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];
    state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;
    state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;
    const rubberband2 = state._active ? config.rubberband || [0, 0] : [0, 0];
    state.offset = computeRubberband(state._bounds, state.offset, rubberband2);
    state.delta = V.sub(state.offset, previousOffset);
    this.computeMovement();
    if (gestureIsActive && (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY)) {
      state.delta = V.sub(state.offset, previousOffset);
      const absoluteDelta = state.delta.map(Math.abs);
      V.addTo(state.distance, absoluteDelta);
      state.direction = state.delta.map(Math.sign);
      state._direction = state._delta.map(Math.sign);
      if (!state.first && dt > 0) {
        state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];
        state.timeDelta = dt;
      }
    }
  }
  emit() {
    const state = this.state;
    const shared = this.shared;
    const config = this.config;
    if (!state._active) this.clean();
    if ((state._blocked || !state.intentional) && !state._force && !config.triggerAllEvents) return;
    const memo35 = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, shared), state), {}, {
      [this.aliasKey]: state.values
    }));
    if (memo35 !== void 0) state.memo = memo35;
  }
  clean() {
    this.eventStore.clean();
    this.timeoutStore.clean();
  }
};
function selectAxis([dx, dy], threshold) {
  const absDx = Math.abs(dx);
  const absDy = Math.abs(dy);
  if (absDx > absDy && absDx > threshold) {
    return "x";
  }
  if (absDy > absDx && absDy > threshold) {
    return "y";
  }
  return void 0;
}
var CoordinatesEngine = class extends Engine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "aliasKey", "xy");
  }
  reset() {
    super.reset();
    this.state.axis = void 0;
  }
  init() {
    this.state.offset = [0, 0];
    this.state.lastOffset = [0, 0];
  }
  computeOffset() {
    this.state.offset = V.add(this.state.lastOffset, this.state.movement);
  }
  computeMovement() {
    this.state.movement = V.sub(this.state.offset, this.state.lastOffset);
  }
  axisIntent(event) {
    const state = this.state;
    const config = this.config;
    if (!state.axis && event) {
      const threshold = typeof config.axisThreshold === "object" ? config.axisThreshold[getPointerType(event)] : config.axisThreshold;
      state.axis = selectAxis(state._movement, threshold);
    }
    state._blocked = (config.lockDirection || !!config.axis) && !state.axis || !!config.axis && config.axis !== state.axis;
  }
  restrictToAxis(v) {
    if (this.config.axis || this.config.lockDirection) {
      switch (this.state.axis) {
        case "x":
          v[1] = 0;
          break;
        case "y":
          v[0] = 0;
          break;
      }
    }
  }
};
var identity = (v) => v;
var DEFAULT_RUBBERBAND = 0.15;
var commonConfigResolver = {
  enabled(value = true) {
    return value;
  },
  eventOptions(value, _k, config) {
    return _objectSpread2(_objectSpread2({}, config.shared.eventOptions), value);
  },
  preventDefault(value = false) {
    return value;
  },
  triggerAllEvents(value = false) {
    return value;
  },
  rubberband(value = 0) {
    switch (value) {
      case true:
        return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];
      case false:
        return [0, 0];
      default:
        return V.toVector(value);
    }
  },
  from(value) {
    if (typeof value === "function") return value;
    if (value != null) return V.toVector(value);
  },
  transform(value, _k, config) {
    const transform = value || config.shared.transform;
    this.hasCustomTransform = !!transform;
    if (true) {
      const originalTransform = transform || identity;
      return (v) => {
        const r = originalTransform(v);
        if (!isFinite(r[0]) || !isFinite(r[1])) {
          console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${r[0]},${[1]}]`);
        }
        return r;
      };
    }
    return transform || identity;
  },
  threshold(value) {
    return V.toVector(value, 0);
  }
};
if (true) {
  Object.assign(commonConfigResolver, {
    domTarget(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`);
      }
      return NaN;
    },
    lockDirection(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`lockDirection\` option has been merged with \`axis\`. Use it as in \`{ axis: 'lock' }\``);
      }
      return NaN;
    },
    initial(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`initial\` option has been renamed to \`from\`.`);
      }
      return NaN;
    }
  });
}
var DEFAULT_AXIS_THRESHOLD = 0;
var coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
  axis(_v, _k, {
    axis
  }) {
    this.lockDirection = axis === "lock";
    if (!this.lockDirection) return axis;
  },
  axisThreshold(value = DEFAULT_AXIS_THRESHOLD) {
    return value;
  },
  bounds(value = {}) {
    if (typeof value === "function") {
      return (state) => coordinatesConfigResolver.bounds(value(state));
    }
    if ("current" in value) {
      return () => value.current;
    }
    if (typeof HTMLElement === "function" && value instanceof HTMLElement) {
      return value;
    }
    const {
      left = -Infinity,
      right = Infinity,
      top = -Infinity,
      bottom = Infinity
    } = value;
    return [[left, right], [top, bottom]];
  }
});
var isBrowser = typeof window !== "undefined" && window.document && window.document.createElement;
function supportsTouchEvents() {
  return isBrowser && "ontouchstart" in window;
}
function isTouchScreen() {
  return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;
}
function supportsPointerEvents() {
  return isBrowser && "onpointerdown" in window;
}
function supportsPointerLock() {
  return isBrowser && "exitPointerLock" in window.document;
}
function supportsGestureEvents() {
  try {
    return "constructor" in GestureEvent;
  } catch (e) {
    return false;
  }
}
var SUPPORT = {
  isBrowser,
  gesture: supportsGestureEvents(),
  touch: supportsTouchEvents(),
  touchscreen: isTouchScreen(),
  pointer: supportsPointerEvents(),
  pointerLock: supportsPointerLock()
};
var DEFAULT_PREVENT_SCROLL_DELAY = 250;
var DEFAULT_DRAG_DELAY = 180;
var DEFAULT_SWIPE_VELOCITY = 0.5;
var DEFAULT_SWIPE_DISTANCE = 50;
var DEFAULT_SWIPE_DURATION = 250;
var DEFAULT_KEYBOARD_DISPLACEMENT = 10;
var DEFAULT_DRAG_AXIS_THRESHOLD = {
  mouse: 0,
  touch: 0,
  pen: 8
};
var dragConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  device(_v, _k, {
    pointer: {
      touch = false,
      lock = false,
      mouse = false
    } = {}
  }) {
    this.pointerLock = lock && SUPPORT.pointerLock;
    if (SUPPORT.touch && touch) return "touch";
    if (this.pointerLock) return "mouse";
    if (SUPPORT.pointer && !mouse) return "pointer";
    if (SUPPORT.touch) return "touch";
    return "mouse";
  },
  preventScrollAxis(value, _k, {
    preventScroll
  }) {
    this.preventScrollDelay = typeof preventScroll === "number" ? preventScroll : preventScroll || preventScroll === void 0 && value ? DEFAULT_PREVENT_SCROLL_DELAY : void 0;
    if (!SUPPORT.touchscreen || preventScroll === false) return void 0;
    return value ? value : preventScroll !== void 0 ? "y" : void 0;
  },
  pointerCapture(_v, _k, {
    pointer: {
      capture = true,
      buttons = 1,
      keys: keys3 = true
    } = {}
  }) {
    this.pointerButtons = buttons;
    this.keys = keys3;
    return !this.pointerLock && this.device === "pointer" && capture;
  },
  threshold(value, _k, {
    filterTaps = false,
    tapsThreshold = 3,
    axis = void 0
  }) {
    const threshold = V.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);
    this.filterTaps = filterTaps;
    this.tapsThreshold = tapsThreshold;
    return threshold;
  },
  swipe({
    velocity = DEFAULT_SWIPE_VELOCITY,
    distance = DEFAULT_SWIPE_DISTANCE,
    duration = DEFAULT_SWIPE_DURATION
  } = {}) {
    return {
      velocity: this.transform(V.toVector(velocity)),
      distance: this.transform(V.toVector(distance)),
      duration
    };
  },
  delay(value = 0) {
    switch (value) {
      case true:
        return DEFAULT_DRAG_DELAY;
      case false:
        return 0;
      default:
        return value;
    }
  },
  axisThreshold(value) {
    if (!value) return DEFAULT_DRAG_AXIS_THRESHOLD;
    return _objectSpread2(_objectSpread2({}, DEFAULT_DRAG_AXIS_THRESHOLD), value);
  },
  keyboardDisplacement(value = DEFAULT_KEYBOARD_DISPLACEMENT) {
    return value;
  }
});
if (true) {
  Object.assign(dragConfigResolver, {
    useTouch(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`useTouch\` option has been renamed to \`pointer.touch\`. Use it as in \`{ pointer: { touch: true } }\`.`);
      }
      return NaN;
    },
    experimental_preventWindowScrollY(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`experimental_preventWindowScrollY\` option has been renamed to \`preventScroll\`.`);
      }
      return NaN;
    },
    swipeVelocity(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`swipeVelocity\` option has been renamed to \`swipe.velocity\`. Use it as in \`{ swipe: { velocity: 0.5 } }\`.`);
      }
      return NaN;
    },
    swipeDistance(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`swipeDistance\` option has been renamed to \`swipe.distance\`. Use it as in \`{ swipe: { distance: 50 } }\`.`);
      }
      return NaN;
    },
    swipeDuration(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`swipeDuration\` option has been renamed to \`swipe.duration\`. Use it as in \`{ swipe: { duration: 250 } }\`.`);
      }
      return NaN;
    }
  });
}
function clampStateInternalMovementToBounds(state) {
  const [ox, oy] = state.overflow;
  const [dx, dy] = state._delta;
  const [dirx, diry] = state._direction;
  if (ox < 0 && dx > 0 && dirx < 0 || ox > 0 && dx < 0 && dirx > 0) {
    state._movement[0] = state._movementBound[0];
  }
  if (oy < 0 && dy > 0 && diry < 0 || oy > 0 && dy < 0 && diry > 0) {
    state._movement[1] = state._movementBound[1];
  }
}
var SCALE_ANGLE_RATIO_INTENT_DEG = 30;
var PINCH_WHEEL_RATIO = 100;
var PinchEngine = class extends Engine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "pinching");
    _defineProperty(this, "aliasKey", "da");
  }
  init() {
    this.state.offset = [1, 0];
    this.state.lastOffset = [1, 0];
    this.state._pointerEvents = /* @__PURE__ */ new Map();
  }
  reset() {
    super.reset();
    const state = this.state;
    state._touchIds = [];
    state.canceled = false;
    state.cancel = this.cancel.bind(this);
    state.turns = 0;
  }
  computeOffset() {
    const {
      type,
      movement,
      lastOffset
    } = this.state;
    if (type === "wheel") {
      this.state.offset = V.add(movement, lastOffset);
    } else {
      this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];
    }
  }
  computeMovement() {
    const {
      offset: offset4,
      lastOffset
    } = this.state;
    this.state.movement = [offset4[0] / lastOffset[0], offset4[1] - lastOffset[1]];
  }
  axisIntent() {
    const state = this.state;
    const [_m0, _m1] = state._movement;
    if (!state.axis) {
      const axisMovementDifference = Math.abs(_m0) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(_m1);
      if (axisMovementDifference < 0) state.axis = "angle";
      else if (axisMovementDifference > 0) state.axis = "scale";
    }
  }
  restrictToAxis(v) {
    if (this.config.lockDirection) {
      if (this.state.axis === "scale") v[1] = 0;
      else if (this.state.axis === "angle") v[0] = 0;
    }
  }
  cancel() {
    const state = this.state;
    if (state.canceled) return;
    setTimeout(() => {
      state.canceled = true;
      state._active = false;
      this.compute();
      this.emit();
    }, 0);
  }
  touchStart(event) {
    this.ctrl.setEventIds(event);
    const state = this.state;
    const ctrlTouchIds = this.ctrl.touchIds;
    if (state._active) {
      if (state._touchIds.every((id) => ctrlTouchIds.has(id))) return;
    }
    if (ctrlTouchIds.size < 2) return;
    this.start(event);
    state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);
    const payload = touchDistanceAngle(event, state._touchIds);
    if (!payload) return;
    this.pinchStart(event, payload);
  }
  pointerStart(event) {
    if (event.buttons != null && event.buttons % 2 !== 1) return;
    this.ctrl.setEventIds(event);
    event.target.setPointerCapture(event.pointerId);
    const state = this.state;
    const _pointerEvents = state._pointerEvents;
    const ctrlPointerIds = this.ctrl.pointerIds;
    if (state._active) {
      if (Array.from(_pointerEvents.keys()).every((id) => ctrlPointerIds.has(id))) return;
    }
    if (_pointerEvents.size < 2) {
      _pointerEvents.set(event.pointerId, event);
    }
    if (state._pointerEvents.size < 2) return;
    this.start(event);
    const payload = distanceAngle(...Array.from(_pointerEvents.values()));
    if (!payload) return;
    this.pinchStart(event, payload);
  }
  pinchStart(event, payload) {
    const state = this.state;
    state.origin = payload.origin;
    this.computeValues([payload.distance, payload.angle]);
    this.computeInitial();
    this.compute(event);
    this.emit();
  }
  touchMove(event) {
    if (!this.state._active) return;
    const payload = touchDistanceAngle(event, this.state._touchIds);
    if (!payload) return;
    this.pinchMove(event, payload);
  }
  pointerMove(event) {
    const _pointerEvents = this.state._pointerEvents;
    if (_pointerEvents.has(event.pointerId)) {
      _pointerEvents.set(event.pointerId, event);
    }
    if (!this.state._active) return;
    const payload = distanceAngle(...Array.from(_pointerEvents.values()));
    if (!payload) return;
    this.pinchMove(event, payload);
  }
  pinchMove(event, payload) {
    const state = this.state;
    const prev_a = state._values[1];
    const delta_a = payload.angle - prev_a;
    let delta_turns = 0;
    if (Math.abs(delta_a) > 270) delta_turns += Math.sign(delta_a);
    this.computeValues([payload.distance, payload.angle - 360 * delta_turns]);
    state.origin = payload.origin;
    state.turns = delta_turns;
    state._movement = [state._values[0] / state._initial[0] - 1, state._values[1] - state._initial[1]];
    this.compute(event);
    this.emit();
  }
  touchEnd(event) {
    this.ctrl.setEventIds(event);
    if (!this.state._active) return;
    if (this.state._touchIds.some((id) => !this.ctrl.touchIds.has(id))) {
      this.state._active = false;
      this.compute(event);
      this.emit();
    }
  }
  pointerEnd(event) {
    const state = this.state;
    this.ctrl.setEventIds(event);
    try {
      event.target.releasePointerCapture(event.pointerId);
    } catch (_unused) {
    }
    if (state._pointerEvents.has(event.pointerId)) {
      state._pointerEvents.delete(event.pointerId);
    }
    if (!state._active) return;
    if (state._pointerEvents.size < 2) {
      state._active = false;
      this.compute(event);
      this.emit();
    }
  }
  gestureStart(event) {
    if (event.cancelable) event.preventDefault();
    const state = this.state;
    if (state._active) return;
    this.start(event);
    this.computeValues([event.scale, event.rotation]);
    state.origin = [event.clientX, event.clientY];
    this.compute(event);
    this.emit();
  }
  gestureMove(event) {
    if (event.cancelable) event.preventDefault();
    if (!this.state._active) return;
    const state = this.state;
    this.computeValues([event.scale, event.rotation]);
    state.origin = [event.clientX, event.clientY];
    const _previousMovement = state._movement;
    state._movement = [event.scale - 1, event.rotation];
    state._delta = V.sub(state._movement, _previousMovement);
    this.compute(event);
    this.emit();
  }
  gestureEnd(event) {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute(event);
    this.emit();
  }
  wheel(event) {
    const modifierKey = this.config.modifierKey;
    if (modifierKey && (Array.isArray(modifierKey) ? !modifierKey.find((k) => event[k]) : !event[modifierKey])) return;
    if (!this.state._active) this.wheelStart(event);
    else this.wheelChange(event);
    this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelStart(event) {
    this.start(event);
    this.wheelChange(event);
  }
  wheelChange(event) {
    const isR3f = "uv" in event;
    if (!isR3f) {
      if (event.cancelable) {
        event.preventDefault();
      }
      if (!event.defaultPrevented) {
        console.warn(`[@use-gesture]: To properly support zoom on trackpads, try using the \`target\` option.

This message will only appear in development mode.`);
      }
    }
    const state = this.state;
    state._delta = [-wheelValues(event)[1] / PINCH_WHEEL_RATIO * state.offset[0], 0];
    V.addTo(state._movement, state._delta);
    clampStateInternalMovementToBounds(state);
    this.state.origin = [event.clientX, event.clientY];
    this.compute(event);
    this.emit();
  }
  wheelEnd() {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    const device = this.config.device;
    if (!!device) {
      bindFunction(device, "start", this[device + "Start"].bind(this));
      bindFunction(device, "change", this[device + "Move"].bind(this));
      bindFunction(device, "end", this[device + "End"].bind(this));
      bindFunction(device, "cancel", this[device + "End"].bind(this));
      bindFunction("lostPointerCapture", "", this[device + "End"].bind(this));
    }
    if (this.config.pinchOnWheel) {
      bindFunction("wheel", "", this.wheel.bind(this), {
        passive: false
      });
    }
  }
};
var pinchConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
  device(_v, _k, {
    shared,
    pointer: {
      touch = false
    } = {}
  }) {
    const sharedConfig = shared;
    if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture) return "gesture";
    if (SUPPORT.touch && touch) return "touch";
    if (SUPPORT.touchscreen) {
      if (SUPPORT.pointer) return "pointer";
      if (SUPPORT.touch) return "touch";
    }
  },
  bounds(_v, _k, {
    scaleBounds = {},
    angleBounds = {}
  }) {
    const _scaleBounds = (state) => {
      const D = assignDefault(call(scaleBounds, state), {
        min: -Infinity,
        max: Infinity
      });
      return [D.min, D.max];
    };
    const _angleBounds = (state) => {
      const A = assignDefault(call(angleBounds, state), {
        min: -Infinity,
        max: Infinity
      });
      return [A.min, A.max];
    };
    if (typeof scaleBounds !== "function" && typeof angleBounds !== "function") return [_scaleBounds(), _angleBounds()];
    return (state) => [_scaleBounds(state), _angleBounds(state)];
  },
  threshold(value, _k, config) {
    this.lockDirection = config.axis === "lock";
    const threshold = V.toVector(value, this.lockDirection ? [0.1, 3] : 0);
    return threshold;
  },
  modifierKey(value) {
    if (value === void 0) return "ctrlKey";
    return value;
  },
  pinchOnWheel(value = true) {
    return value;
  }
});
var moveConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  mouseOnly: (value = true) => value
});
var WheelEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "wheeling");
  }
  wheel(event) {
    if (!this.state._active) this.start(event);
    this.wheelChange(event);
    this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelChange(event) {
    const state = this.state;
    state._delta = wheelValues(event);
    V.addTo(state._movement, state._delta);
    clampStateInternalMovementToBounds(state);
    this.compute(event);
    this.emit();
  }
  wheelEnd() {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("wheel", "", this.wheel.bind(this));
  }
};
var wheelConfigResolver = coordinatesConfigResolver;
var hoverConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  mouseOnly: (value = true) => value
});
var EngineMap = /* @__PURE__ */ new Map();
var ConfigResolverMap = /* @__PURE__ */ new Map();
function registerAction(action) {
  EngineMap.set(action.key, action.engine);
  ConfigResolverMap.set(action.key, action.resolver);
}
var pinchAction = {
  key: "pinch",
  engine: PinchEngine,
  resolver: pinchConfigResolver
};
var wheelAction = {
  key: "wheel",
  engine: WheelEngine,
  resolver: wheelConfigResolver
};

// ../node_modules/@use-gesture/react/dist/use-gesture-react.esm.js
var import_react40 = __toESM(require_react());

// ../node_modules/@use-gesture/core/dist/use-gesture-core.esm.js
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
var sharedConfigResolver = {
  target(value) {
    if (value) {
      return () => "current" in value ? value.current : value;
    }
    return void 0;
  },
  enabled(value = true) {
    return value;
  },
  window(value = SUPPORT.isBrowser ? window : void 0) {
    return value;
  },
  eventOptions({
    passive = true,
    capture = false
  } = {}) {
    return {
      passive,
      capture
    };
  },
  transform(value) {
    return value;
  }
};
var _excluded = ["target", "eventOptions", "window", "enabled", "transform"];
function resolveWith(config = {}, resolvers) {
  const result = {};
  for (const [key, resolver] of Object.entries(resolvers)) {
    switch (typeof resolver) {
      case "function":
        if (true) {
          const r = resolver.call(result, config[key], key, config);
          if (!Number.isNaN(r)) result[key] = r;
        } else {
          result[key] = resolver.call(result, config[key], key, config);
        }
        break;
      case "object":
        result[key] = resolveWith(config[key], resolver);
        break;
      case "boolean":
        if (resolver) result[key] = config[key];
        break;
    }
  }
  return result;
}
function parse(newConfig, gestureKey, _config = {}) {
  const _ref = newConfig, {
    target,
    eventOptions,
    window: window3,
    enabled,
    transform
  } = _ref, rest = _objectWithoutProperties(_ref, _excluded);
  _config.shared = resolveWith({
    target,
    eventOptions,
    window: window3,
    enabled,
    transform
  }, sharedConfigResolver);
  if (gestureKey) {
    const resolver = ConfigResolverMap.get(gestureKey);
    _config[gestureKey] = resolveWith(_objectSpread2({
      shared: _config.shared
    }, rest), resolver);
  } else {
    for (const key in rest) {
      const resolver = ConfigResolverMap.get(key);
      if (resolver) {
        _config[key] = resolveWith(_objectSpread2({
          shared: _config.shared
        }, rest[key]), resolver);
      } else if (true) {
        if (!["drag", "pinch", "scroll", "wheel", "move", "hover"].includes(key)) {
          if (key === "domTarget") {
            throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`);
          }
          console.warn(`[@use-gesture]: Unknown config key \`${key}\` was used. Please read the documentation for further information.`);
        }
      }
    }
  }
  return _config;
}
var EventStore = class {
  constructor(ctrl, gestureKey) {
    _defineProperty(this, "_listeners", /* @__PURE__ */ new Set());
    this._ctrl = ctrl;
    this._gestureKey = gestureKey;
  }
  add(element, device, action, handler, options2) {
    const listeners = this._listeners;
    const type = toDomEventType(device, action);
    const _options = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {};
    const eventOptions = _objectSpread2(_objectSpread2({}, _options), options2);
    element.addEventListener(type, handler, eventOptions);
    const remove2 = () => {
      element.removeEventListener(type, handler, eventOptions);
      listeners.delete(remove2);
    };
    listeners.add(remove2);
    return remove2;
  }
  clean() {
    this._listeners.forEach((remove2) => remove2());
    this._listeners.clear();
  }
};
var TimeoutStore = class {
  constructor() {
    _defineProperty(this, "_timeouts", /* @__PURE__ */ new Map());
  }
  add(key, callback, ms = 140, ...args) {
    this.remove(key);
    this._timeouts.set(key, window.setTimeout(callback, ms, ...args));
  }
  remove(key) {
    const timeout = this._timeouts.get(key);
    if (timeout) window.clearTimeout(timeout);
  }
  clean() {
    this._timeouts.forEach((timeout) => void window.clearTimeout(timeout));
    this._timeouts.clear();
  }
};
var Controller = class {
  constructor(handlers2) {
    _defineProperty(this, "gestures", /* @__PURE__ */ new Set());
    _defineProperty(this, "_targetEventStore", new EventStore(this));
    _defineProperty(this, "gestureEventStores", {});
    _defineProperty(this, "gestureTimeoutStores", {});
    _defineProperty(this, "handlers", {});
    _defineProperty(this, "config", {});
    _defineProperty(this, "pointerIds", /* @__PURE__ */ new Set());
    _defineProperty(this, "touchIds", /* @__PURE__ */ new Set());
    _defineProperty(this, "state", {
      shared: {
        shiftKey: false,
        metaKey: false,
        ctrlKey: false,
        altKey: false
      }
    });
    resolveGestures(this, handlers2);
  }
  setEventIds(event) {
    if (isTouch(event)) {
      this.touchIds = new Set(touchIds(event));
      return this.touchIds;
    } else if ("pointerId" in event) {
      if (event.type === "pointerup" || event.type === "pointercancel") this.pointerIds.delete(event.pointerId);
      else if (event.type === "pointerdown") this.pointerIds.add(event.pointerId);
      return this.pointerIds;
    }
  }
  applyHandlers(handlers2, nativeHandlers) {
    this.handlers = handlers2;
    this.nativeHandlers = nativeHandlers;
  }
  applyConfig(config, gestureKey) {
    this.config = parse(config, gestureKey, this.config);
  }
  clean() {
    this._targetEventStore.clean();
    for (const key of this.gestures) {
      this.gestureEventStores[key].clean();
      this.gestureTimeoutStores[key].clean();
    }
  }
  effect() {
    if (this.config.shared.target) this.bind();
    return () => this._targetEventStore.clean();
  }
  bind(...args) {
    const sharedConfig = this.config.shared;
    const props = {};
    let target;
    if (sharedConfig.target) {
      target = sharedConfig.target();
      if (!target) return;
    }
    if (sharedConfig.enabled) {
      for (const gestureKey of this.gestures) {
        const gestureConfig = this.config[gestureKey];
        const bindFunction = bindToProps(props, gestureConfig.eventOptions, !!target);
        if (gestureConfig.enabled) {
          const Engine2 = EngineMap.get(gestureKey);
          new Engine2(this, args, gestureKey).bind(bindFunction);
        }
      }
      const nativeBindFunction = bindToProps(props, sharedConfig.eventOptions, !!target);
      for (const eventKey in this.nativeHandlers) {
        nativeBindFunction(eventKey, "", (event) => this.nativeHandlers[eventKey](_objectSpread2(_objectSpread2({}, this.state.shared), {}, {
          event,
          args
        })), void 0, true);
      }
    }
    for (const handlerProp in props) {
      props[handlerProp] = chain(...props[handlerProp]);
    }
    if (!target) return props;
    for (const handlerProp in props) {
      const {
        device,
        capture,
        passive
      } = parseProp(handlerProp);
      this._targetEventStore.add(target, device, "", props[handlerProp], {
        capture,
        passive
      });
    }
  }
};
function setupGesture(ctrl, gestureKey) {
  ctrl.gestures.add(gestureKey);
  ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl, gestureKey);
  ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();
}
function resolveGestures(ctrl, internalHandlers) {
  if (internalHandlers.drag) setupGesture(ctrl, "drag");
  if (internalHandlers.wheel) setupGesture(ctrl, "wheel");
  if (internalHandlers.scroll) setupGesture(ctrl, "scroll");
  if (internalHandlers.move) setupGesture(ctrl, "move");
  if (internalHandlers.pinch) setupGesture(ctrl, "pinch");
  if (internalHandlers.hover) setupGesture(ctrl, "hover");
}
var bindToProps = (props, eventOptions, withPassiveOption) => (device, action, handler, options2 = {}, isNative = false) => {
  var _options$capture, _options$passive;
  const capture = (_options$capture = options2.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;
  const passive = (_options$passive = options2.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;
  let handlerProp = isNative ? device : toHandlerProp(device, action, capture);
  if (withPassiveOption && passive) handlerProp += "Passive";
  props[handlerProp] = props[handlerProp] || [];
  props[handlerProp].push(handler);
};
var RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;
function sortHandlers(_handlers2) {
  const native = {};
  const handlers2 = {};
  const actions = /* @__PURE__ */ new Set();
  for (let key in _handlers2) {
    if (RE_NOT_NATIVE.test(key)) {
      actions.add(RegExp.lastMatch);
      handlers2[key] = _handlers2[key];
    } else {
      native[key] = _handlers2[key];
    }
  }
  return [handlers2, native, actions];
}
function registerGesture(actions, handlers2, handlerKey, key, internalHandlers, config) {
  if (!actions.has(handlerKey)) return;
  if (!EngineMap.has(key)) {
    if (true) {
      console.warn(`[@use-gesture]: You've created a custom handler that that uses the \`${key}\` gesture but isn't properly configured.

Please add \`${key}Action\` when creating your handler.`);
    }
    return;
  }
  const startKey = handlerKey + "Start";
  const endKey = handlerKey + "End";
  const fn = (state) => {
    let memo35 = void 0;
    if (state.first && startKey in handlers2) handlers2[startKey](state);
    if (handlerKey in handlers2) memo35 = handlers2[handlerKey](state);
    if (state.last && endKey in handlers2) handlers2[endKey](state);
    return memo35;
  };
  internalHandlers[key] = fn;
  config[key] = config[key] || {};
}
function parseMergedHandlers(mergedHandlers, mergedConfig) {
  const [handlers2, nativeHandlers, actions] = sortHandlers(mergedHandlers);
  const internalHandlers = {};
  registerGesture(actions, handlers2, "onDrag", "drag", internalHandlers, mergedConfig);
  registerGesture(actions, handlers2, "onWheel", "wheel", internalHandlers, mergedConfig);
  registerGesture(actions, handlers2, "onScroll", "scroll", internalHandlers, mergedConfig);
  registerGesture(actions, handlers2, "onPinch", "pinch", internalHandlers, mergedConfig);
  registerGesture(actions, handlers2, "onMove", "move", internalHandlers, mergedConfig);
  registerGesture(actions, handlers2, "onHover", "hover", internalHandlers, mergedConfig);
  return {
    handlers: internalHandlers,
    config: mergedConfig,
    nativeHandlers
  };
}

// ../node_modules/@use-gesture/react/dist/use-gesture-react.esm.js
function useRecognizers(handlers2, config = {}, gestureKey, nativeHandlers) {
  const ctrl = import_react40.default.useMemo(() => new Controller(handlers2), []);
  ctrl.applyHandlers(handlers2, nativeHandlers);
  ctrl.applyConfig(config, gestureKey);
  import_react40.default.useEffect(ctrl.effect.bind(ctrl));
  import_react40.default.useEffect(() => {
    return ctrl.clean.bind(ctrl);
  }, []);
  if (config.target === void 0) {
    return ctrl.bind.bind(ctrl);
  }
  return void 0;
}
function createUseGesture(actions) {
  actions.forEach(registerAction);
  return function useGesture2(_handlers2, _config) {
    const {
      handlers: handlers2,
      nativeHandlers,
      config
    } = parseMergedHandlers(_handlers2, _config || {});
    return useRecognizers(handlers2, config, void 0, nativeHandlers);
  };
}

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/useGestureEvents.mjs
var React9 = __toESM(require_react(), 1);

// ../node_modules/@tldraw/editor/dist-esm/lib/utils/normalizeWheel.mjs
var MAX_ZOOM_STEP = 10;
var IS_DARWIN = /Mac|iPod|iPhone|iPad/.test(
  // eslint-disable-next-line @typescript-eslint/no-deprecated
  typeof window === "undefined" ? "node" : window.navigator.platform
);
function normalizeWheel(event) {
  let { deltaY, deltaX } = event;
  let deltaZ = 0;
  if (event.ctrlKey || event.altKey || event.metaKey) {
    deltaZ = (Math.abs(deltaY) > MAX_ZOOM_STEP ? MAX_ZOOM_STEP * Math.sign(deltaY) : deltaY) / 100;
  } else {
    if (event.shiftKey && !IS_DARWIN) {
      deltaX = deltaY;
      deltaY = 0;
    }
  }
  return { x: -deltaX, y: -deltaY, z: -deltaZ };
}

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/useGestureEvents.mjs
var useGesture = createUseGesture([wheelAction, pinchAction]);
var lastWheelTime = void 0;
var isWheelEndEvent = (time) => {
  if (lastWheelTime === void 0) {
    lastWheelTime = time;
    return false;
  }
  if (time - lastWheelTime > 120 && time - lastWheelTime < 160) {
    lastWheelTime = time;
    return true;
  }
  lastWheelTime = time;
  return false;
};
function useGestureEvents(ref) {
  const editor = useEditor();
  const events = React9.useMemo(() => {
    let pinchState = "not sure";
    const onWheel = ({ event }) => {
      if (!editor.getInstanceState().isFocused) {
        return;
      }
      pinchState = "not sure";
      if (isWheelEndEvent(Date.now())) {
        return;
      }
      const editingShapeId = editor.getEditingShapeId();
      if (editingShapeId) {
        const shape = editor.getShape(editingShapeId);
        if (shape) {
          const util = editor.getShapeUtil(shape);
          if (util.canScroll(shape)) {
            const bounds = editor.getShapePageBounds(editingShapeId);
            if (bounds == null ? void 0 : bounds.containsPoint(editor.inputs.getCurrentPagePoint())) {
              return;
            }
          }
        }
      }
      preventDefault(event);
      event.stopPropagation();
      const delta = normalizeWheel(event);
      if (delta.x === 0 && delta.y === 0) return;
      const info = {
        type: "wheel",
        name: "wheel",
        delta,
        point: new Vec(event.clientX, event.clientY),
        shiftKey: event.shiftKey,
        altKey: event.altKey,
        ctrlKey: event.metaKey || event.ctrlKey,
        metaKey: event.metaKey,
        accelKey: isAccelKey(event)
      };
      editor.dispatch(info);
    };
    let initDistanceBetweenFingers = 1;
    let initZoom = 1;
    let currDistanceBetweenFingers = 0;
    const initPointBetweenFingers = new Vec();
    const prevPointBetweenFingers = new Vec();
    const onPinchStart = (gesture) => {
      const elm = ref.current;
      pinchState = "not sure";
      const { event, origin, da } = gesture;
      if (event instanceof WheelEvent) return;
      if (!(event.target === elm || (elm == null ? void 0 : elm.contains(event.target)))) return;
      prevPointBetweenFingers.x = origin[0];
      prevPointBetweenFingers.y = origin[1];
      initPointBetweenFingers.x = origin[0];
      initPointBetweenFingers.y = origin[1];
      initDistanceBetweenFingers = da[0];
      initZoom = editor.getZoomLevel();
      editor.dispatch({
        type: "pinch",
        name: "pinch_start",
        point: { x: origin[0], y: origin[1], z: editor.getZoomLevel() },
        delta: { x: 0, y: 0 },
        shiftKey: event.shiftKey,
        altKey: event.altKey,
        ctrlKey: event.metaKey || event.ctrlKey,
        metaKey: event.metaKey,
        accelKey: isAccelKey(event)
      });
    };
    const updatePinchState = (isSafariTrackpadPinch) => {
      if (isSafariTrackpadPinch) {
        pinchState = "zooming";
      }
      if (pinchState === "zooming") {
        return;
      }
      const touchDistance = Math.abs(currDistanceBetweenFingers - initDistanceBetweenFingers);
      const originDistance = Vec.Dist(initPointBetweenFingers, prevPointBetweenFingers);
      switch (pinchState) {
        case "not sure": {
          if (touchDistance > 24) {
            pinchState = "zooming";
          } else if (originDistance > 16) {
            pinchState = "panning";
          }
          break;
        }
        case "panning": {
          if (touchDistance > 64) {
            pinchState = "zooming";
          }
          break;
        }
      }
    };
    const onPinch = (gesture) => {
      const elm = ref.current;
      const { event, origin, offset: offset4, da } = gesture;
      if (event instanceof WheelEvent) return;
      if (!(event.target === elm || (elm == null ? void 0 : elm.contains(event.target)))) return;
      const isSafariTrackpadPinch = gesture.type === "gesturechange" || gesture.type === "gestureend";
      currDistanceBetweenFingers = da[0];
      const dx = origin[0] - prevPointBetweenFingers.x;
      const dy = origin[1] - prevPointBetweenFingers.y;
      prevPointBetweenFingers.x = origin[0];
      prevPointBetweenFingers.y = origin[1];
      updatePinchState(isSafariTrackpadPinch);
      switch (pinchState) {
        case "zooming": {
          const currZoom = offset4[0] ** editor.getCameraOptions().zoomSpeed;
          editor.dispatch({
            type: "pinch",
            name: "pinch",
            point: { x: origin[0], y: origin[1], z: currZoom },
            delta: { x: dx, y: dy },
            shiftKey: event.shiftKey,
            altKey: event.altKey,
            ctrlKey: event.metaKey || event.ctrlKey,
            metaKey: event.metaKey,
            accelKey: isAccelKey(event)
          });
          break;
        }
        case "panning": {
          editor.dispatch({
            type: "pinch",
            name: "pinch",
            point: { x: origin[0], y: origin[1], z: initZoom },
            delta: { x: dx, y: dy },
            shiftKey: event.shiftKey,
            altKey: event.altKey,
            ctrlKey: event.metaKey || event.ctrlKey,
            metaKey: event.metaKey,
            accelKey: isAccelKey(event)
          });
          break;
        }
      }
    };
    const onPinchEnd = (gesture) => {
      const elm = ref.current;
      const { event, origin, offset: offset4 } = gesture;
      if (event instanceof WheelEvent) return;
      if (!(event.target === elm || (elm == null ? void 0 : elm.contains(event.target)))) return;
      const scale = offset4[0] ** editor.getCameraOptions().zoomSpeed;
      pinchState = "not sure";
      editor.timers.requestAnimationFrame(() => {
        editor.dispatch({
          type: "pinch",
          name: "pinch_end",
          point: { x: origin[0], y: origin[1], z: scale },
          delta: { x: origin[0], y: origin[1] },
          shiftKey: event.shiftKey,
          altKey: event.altKey,
          ctrlKey: event.metaKey || event.ctrlKey,
          metaKey: event.metaKey,
          accelKey: isAccelKey(event)
        });
      });
    };
    return {
      onWheel,
      onPinchStart,
      onPinchEnd,
      onPinch
    };
  }, [editor, ref]);
  useGesture(events, {
    target: ref,
    eventOptions: { passive: false },
    pinch: {
      from: () => {
        const { zoomSpeed } = editor.getCameraOptions();
        const level = editor.getZoomLevel() ** (1 / zoomSpeed);
        return [level, 0];
      },
      // Return the camera z to use when pinch starts
      scaleBounds: () => {
        const baseZoom = editor.getBaseZoom();
        const { zoomSteps, zoomSpeed } = editor.getCameraOptions();
        const zoomMin = zoomSteps[0] * baseZoom;
        const zoomMax = zoomSteps[zoomSteps.length - 1] * baseZoom;
        return {
          max: zoomMax ** (1 / zoomSpeed),
          min: zoomMin ** (1 / zoomSpeed)
        };
      }
    }
  });
}

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/useHandleEvents.mjs
var React10 = __toESM(require_react(), 1);
function getHandle(editor, id, handleId) {
  const shape = editor.getShape(id);
  const handles = editor.getShapeHandles(shape);
  return { shape, handle: handles.find((h2) => h2.id === handleId) };
}
function useHandleEvents(id, handleId) {
  const editor = useEditor();
  return React10.useMemo(() => {
    const onPointerDown = (e) => {
      if (editor.wasEventAlreadyHandled(e)) return;
      const target = loopToHtmlElement(e.currentTarget);
      setPointerCapture(target, e);
      const { shape, handle } = getHandle(editor, id, handleId);
      if (!handle) return;
      editor.dispatch({
        type: "pointer",
        target: "handle",
        handle,
        shape,
        name: "pointer_down",
        ...getPointerInfo(editor, e)
      });
    };
    let lastX, lastY;
    const onPointerMove = (e) => {
      if (editor.wasEventAlreadyHandled(e)) return;
      if (e.clientX === lastX && e.clientY === lastY) return;
      lastX = e.clientX;
      lastY = e.clientY;
      const { shape, handle } = getHandle(editor, id, handleId);
      if (!handle) return;
      editor.dispatch({
        type: "pointer",
        target: "handle",
        handle,
        shape,
        name: "pointer_move",
        ...getPointerInfo(editor, e)
      });
    };
    const onPointerUp = (e) => {
      if (editor.wasEventAlreadyHandled(e)) return;
      const target = loopToHtmlElement(e.currentTarget);
      releasePointerCapture(target, e);
      const { shape, handle } = getHandle(editor, id, handleId);
      if (!handle) return;
      editor.dispatch({
        type: "pointer",
        target: "handle",
        handle,
        shape,
        name: "pointer_up",
        ...getPointerInfo(editor, e)
      });
    };
    return {
      onPointerDown,
      onPointerMove,
      onPointerUp
    };
  }, [editor, id, handleId]);
}

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/useScreenBounds.mjs
var import_react42 = __toESM(require_react(), 1);
function useScreenBounds(ref) {
  const editor = useEditor();
  (0, import_react42.useLayoutEffect)(() => {
    const updateBounds = (0, import_lodash3.default)(
      () => {
        if (!ref.current) return;
        editor.updateViewportScreenBounds(ref.current);
      },
      200,
      {
        trailing: true
      }
    );
    const interval = editor.timers.setInterval(updateBounds, 1e3);
    window.addEventListener("resize", updateBounds);
    const resizeObserver = new ResizeObserver((entries) => {
      if (!entries[0].contentRect) return;
      updateBounds();
    });
    const container = ref.current;
    let scrollingParent = null;
    if (container) {
      resizeObserver.observe(container);
      scrollingParent = getNearestScrollableContainer(container);
      scrollingParent.addEventListener("scroll", updateBounds);
    }
    return () => {
      clearInterval(interval);
      window.removeEventListener("resize", updateBounds);
      resizeObserver.disconnect();
      scrollingParent == null ? void 0 : scrollingParent.removeEventListener("scroll", updateBounds);
      updateBounds.cancel();
    };
  }, [editor, ref]);
}
var getNearestScrollableContainer = (element) => {
  let parent = element.parentElement;
  while (parent) {
    if (parent === document.body) {
      return document;
    }
    const { overflowY } = window.getComputedStyle(parent);
    const hasScrollableContent = parent.scrollHeight > parent.clientHeight;
    if (hasScrollableContent && (overflowY === "auto" || overflowY === "scroll" || overflowY === "overlay")) {
      return parent;
    }
    parent = parent.parentElement;
  }
  return document;
};

// ../node_modules/@tldraw/editor/dist-esm/lib/components/GeometryDebuggingView.mjs
var import_jsx_runtime33 = __toESM(require_jsx_runtime(), 1);
var GeometryDebuggingView = track(function GeometryDebuggingView2({
  showStroke = true,
  showVertices = true,
  showClosestPointOnOutline = true
}) {
  const editor = useEditor();
  const zoomLevel = editor.getZoomLevel();
  const renderingShapes = editor.getRenderingShapes();
  const currentPagePoint = editor.inputs.getCurrentPagePoint();
  return (0, import_jsx_runtime33.jsx)(
    "svg",
    {
      style: {
        position: "absolute",
        pointerEvents: "none",
        zIndex: 999999999,
        top: 0,
        left: 0,
        overflow: "visible"
      },
      children: renderingShapes.map((result) => {
        const shape = editor.getShape(result.id);
        if (shape.type === "group") return null;
        const geometry = editor.getShapeGeometry(shape);
        const pageTransform = editor.getShapePageTransform(shape);
        const pointInShapeSpace = editor.getPointInShapeSpace(shape, currentPagePoint);
        const nearestPointOnShape = geometry.nearestPoint(pointInShapeSpace);
        const distanceToPoint = geometry.distanceToPoint(pointInShapeSpace, true);
        const dist = Math.abs(distanceToPoint) * zoomLevel;
        const hitInside = distanceToPoint < 0;
        const { vertices } = geometry;
        return (0, import_jsx_runtime33.jsxs)(
          "g",
          {
            transform: pageTransform.toCssString(),
            strokeLinecap: "round",
            strokeLinejoin: "round",
            children: [
              showStroke && (0, import_jsx_runtime33.jsx)(
                "g",
                {
                  stroke: geometry.debugColor ?? "red",
                  opacity: "1",
                  strokeWidth: 2 / zoomLevel,
                  fill: "none",
                  children: (0, import_jsx_runtime33.jsx)(GeometryStroke, { geometry })
                }
              ),
              showVertices && vertices.map((v, i) => (0, import_jsx_runtime33.jsx)(
                "circle",
                {
                  cx: v.x,
                  cy: v.y,
                  r: 2 / zoomLevel,
                  fill: `hsl(${modulate(i, [0, vertices.length - 1], [120, 200])}, 100%, 50%)`,
                  stroke: "black",
                  strokeWidth: 1 / zoomLevel
                },
                `v${i}`
              )),
              showClosestPointOnOutline && dist < 150 && (0, import_jsx_runtime33.jsx)(
                "line",
                {
                  x1: nearestPointOnShape.x,
                  y1: nearestPointOnShape.y,
                  x2: pointInShapeSpace.x,
                  y2: pointInShapeSpace.y,
                  opacity: 1 - dist / 150,
                  stroke: hitInside ? "goldenrod" : "dodgerblue",
                  strokeWidth: 2 / zoomLevel
                }
              )
            ]
          },
          result.id + "_outline"
        );
      })
    }
  );
});
function GeometryStroke({ geometry }) {
  if (geometry instanceof Group2d) {
    return (0, import_jsx_runtime33.jsx)("g", { stroke: geometry.debugColor, children: [...geometry.children, ...geometry.ignoredChildren].map((child, i) => (0, import_jsx_runtime33.jsx)(GeometryStroke, { geometry: child }, i)) });
  }
  return (0, import_jsx_runtime33.jsx)("path", { d: geometry.toSimpleSvgPath(), stroke: geometry.debugColor });
}

// ../node_modules/@tldraw/editor/dist-esm/lib/components/LiveCollaborators.mjs
var import_jsx_runtime34 = __toESM(require_jsx_runtime(), 1);
var import_react43 = __toESM(require_react(), 1);

// ../node_modules/@tldraw/editor/dist-esm/lib/utils/uniq.mjs
function uniq(array) {
  return (0, import_lodash4.default)(array);
}

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/usePeerIds.mjs
function usePeerIds() {
  const editor = useEditor();
  const $userIds = useComputed(
    "userIds",
    () => uniq(editor.getCollaborators().map((p) => p.userId)).sort(),
    { isEqual: (a, b) => {
      var _a6;
      return a.join(",") === ((_a6 = b.join) == null ? void 0 : _a6.call(b, ","));
    } },
    [editor]
  );
  return useValue($userIds);
}

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/usePresence.mjs
function usePresence(userId) {
  const editor = useEditor();
  const latestPresence = useValue(
    `latestPresence:${userId}`,
    () => {
      return editor.getCollaborators().find((c) => c.userId === userId);
    },
    [editor, userId]
  );
  return latestPresence ?? null;
}

// ../node_modules/@tldraw/editor/dist-esm/lib/components/LiveCollaborators.mjs
var LiveCollaborators = track(function Collaborators() {
  const peerIds = usePeerIds();
  return peerIds.map((id) => (0, import_jsx_runtime34.jsx)(CollaboratorGuard, { collaboratorId: id }, id));
});
var CollaboratorGuard = track(function CollaboratorGuard2({
  collaboratorId
}) {
  const editor = useEditor();
  const presence = usePresence(collaboratorId);
  const collaboratorState = useCollaboratorState(editor, presence);
  if (!(presence && presence.currentPageId === editor.getCurrentPageId())) {
    return null;
  }
  switch (collaboratorState) {
    case "inactive": {
      const { followingUserId, highlightedUserIds } = editor.getInstanceState();
      if (!(followingUserId === presence.userId || highlightedUserIds.includes(presence.userId))) {
        return null;
      }
      break;
    }
    case "idle": {
      const { highlightedUserIds } = editor.getInstanceState();
      if (presence.followingUserId === editor.user.getId() && !(presence.chatMessage || highlightedUserIds.includes(presence.userId))) {
        return null;
      }
      break;
    }
    case "active": {
      break;
    }
  }
  return (0, import_jsx_runtime34.jsx)(Collaborator, { latestPresence: presence });
});
var Collaborator = track(function Collaborator2({
  latestPresence
}) {
  const editor = useEditor();
  const {
    CollaboratorBrush,
    CollaboratorScribble,
    CollaboratorCursor,
    CollaboratorHint,
    CollaboratorShapeIndicator
  } = useEditorComponents();
  const zoomLevel = editor.getZoomLevel();
  const viewportPageBounds = editor.getViewportPageBounds();
  const { userId, chatMessage, brush, scribbles, selectedShapeIds, userName, cursor, color } = latestPresence;
  if (!cursor) return null;
  const isCursorInViewport = !(cursor.x < viewportPageBounds.minX - 12 / zoomLevel || cursor.y < viewportPageBounds.minY - 16 / zoomLevel || cursor.x > viewportPageBounds.maxX - 12 / zoomLevel || cursor.y > viewportPageBounds.maxY - 16 / zoomLevel);
  return (0, import_jsx_runtime34.jsxs)(import_jsx_runtime34.Fragment, { children: [
    brush && CollaboratorBrush ? (0, import_jsx_runtime34.jsx)(
      CollaboratorBrush,
      {
        className: "tl-collaborator__brush",
        userId,
        brush,
        color,
        opacity: 0.1
      },
      userId + "_brush"
    ) : null,
    isCursorInViewport && CollaboratorCursor ? (0, import_jsx_runtime34.jsx)(
      CollaboratorCursor,
      {
        className: "tl-collaborator__cursor",
        userId,
        point: cursor,
        color,
        zoom: zoomLevel,
        name: userName !== "New User" ? userName : null,
        chatMessage: chatMessage ?? ""
      },
      userId + "_cursor"
    ) : CollaboratorHint ? (0, import_jsx_runtime34.jsx)(
      CollaboratorHint,
      {
        className: "tl-collaborator__cursor-hint",
        userId,
        point: cursor,
        color,
        zoom: zoomLevel,
        viewport: viewportPageBounds
      },
      userId + "_cursor_hint"
    ) : null,
    CollaboratorScribble && scribbles.length ? (0, import_jsx_runtime34.jsx)(import_jsx_runtime34.Fragment, { children: scribbles.map((scribble) => (0, import_jsx_runtime34.jsx)(
      CollaboratorScribble,
      {
        className: "tl-collaborator__scribble",
        userId,
        scribble,
        color,
        zoom: zoomLevel,
        opacity: scribble.color === "laser" ? 0.5 : 0.1
      },
      userId + "_scribble_" + scribble.id
    )) }) : null,
    CollaboratorShapeIndicator && selectedShapeIds.filter((id) => !editor.isShapeHidden(id)).map((shapeId) => (0, import_jsx_runtime34.jsx)(
      CollaboratorShapeIndicator,
      {
        className: "tl-collaborator__shape-indicator",
        userId,
        shapeId,
        color,
        opacity: 0.5
      },
      userId + "_" + shapeId
    ))
  ] });
});
function getStateFromElapsedTime(editor, elapsed) {
  return elapsed > editor.options.collaboratorInactiveTimeoutMs ? "inactive" : elapsed > editor.options.collaboratorIdleTimeoutMs ? "idle" : "active";
}
function useCollaboratorState(editor, latestPresence) {
  const rLastActivityTimestamp = (0, import_react43.useRef)((latestPresence == null ? void 0 : latestPresence.lastActivityTimestamp) ?? -1);
  const [state, setState] = (0, import_react43.useState)(
    () => getStateFromElapsedTime(editor, Date.now() - rLastActivityTimestamp.current)
  );
  (0, import_react43.useEffect)(() => {
    const interval = editor.timers.setInterval(() => {
      setState(getStateFromElapsedTime(editor, Date.now() - rLastActivityTimestamp.current));
    }, editor.options.collaboratorCheckIntervalMs);
    return () => clearInterval(interval);
  }, [editor]);
  if (latestPresence) {
    rLastActivityTimestamp.current = latestPresence.lastActivityTimestamp ?? Infinity;
  }
  return state;
}

// ../node_modules/@tldraw/editor/dist-esm/lib/components/MenuClickCapture.mjs
var import_jsx_runtime35 = __toESM(require_jsx_runtime(), 1);
var import_react44 = __toESM(require_react(), 1);
function MenuClickCapture() {
  const editor = useEditor();
  const isMenuOpen = useValue("is menu open", () => editor.menus.hasAnyOpenMenus(), [editor]);
  const [isPointing, setIsPointing] = (0, import_react44.useState)(false);
  const showElement = isMenuOpen || isPointing;
  const canvasEvents = useCanvasEvents();
  const rPointerState = (0, import_react44.useRef)({
    isDown: false,
    isDragging: false,
    start: new Vec()
  });
  const handlePointerDown = (0, import_react44.useCallback)(
    (e) => {
      if (e.button === 0) {
        setIsPointing(true);
        rPointerState.current = {
          isDown: true,
          isDragging: false,
          start: new Vec(e.clientX, e.clientY)
        };
        rDidAPointerDownAndDragWhileMenuWasOpen.current = false;
      }
      editor.menus.clearOpenMenus();
    },
    [editor]
  );
  const rDidAPointerDownAndDragWhileMenuWasOpen = (0, import_react44.useRef)(false);
  const handlePointerMove = (0, import_react44.useCallback)(
    (e) => {
      var _a6;
      if (!rPointerState.current.isDown) return;
      const { x, y } = rPointerState.current.start;
      if (!rDidAPointerDownAndDragWhileMenuWasOpen.current) {
        if (
          // We're pointing, but are we dragging?
          Vec.Dist2(rPointerState.current.start, new Vec(e.clientX, e.clientY)) > editor.options.dragDistanceSquared
        ) {
          rDidAPointerDownAndDragWhileMenuWasOpen.current = true;
          rPointerState.current = {
            ...rPointerState.current,
            isDown: true,
            isDragging: true
          };
          (_a6 = canvasEvents.onPointerDown) == null ? void 0 : _a6.call(canvasEvents, {
            ...e,
            clientX: x,
            clientY: y,
            button: 0
          });
        }
      }
      if (rDidAPointerDownAndDragWhileMenuWasOpen.current) {
        editor.dispatch({
          type: "pointer",
          target: "canvas",
          name: "pointer_move",
          ...getPointerInfo(editor, e)
        });
      }
    },
    [canvasEvents, editor]
  );
  const handlePointerUp = (0, import_react44.useCallback)(
    (e) => {
      var _a6;
      (_a6 = canvasEvents.onPointerUp) == null ? void 0 : _a6.call(canvasEvents, e);
      setIsPointing(false);
      rPointerState.current = {
        isDown: false,
        isDragging: false,
        start: new Vec(e.clientX, e.clientY)
      };
      rDidAPointerDownAndDragWhileMenuWasOpen.current = false;
    },
    [canvasEvents]
  );
  return showElement && (0, import_jsx_runtime35.jsx)(
    "div",
    {
      className: "tlui-menu-click-capture",
      "data-testid": "menu-click-capture.content",
      ...canvasEvents,
      onPointerDown: handlePointerDown,
      onPointerMove: handlePointerMove,
      onPointerUp: handlePointerUp
    }
  );
}

// ../node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultCanvas.mjs
function DefaultCanvas({ className }) {
  const editor = useEditor();
  const { SelectionBackground, Background, SvgDefs, ShapeIndicators } = useEditorComponents();
  const rCanvas = (0, import_react45.useRef)(null);
  const rHtmlLayer = (0, import_react45.useRef)(null);
  const rHtmlLayer2 = (0, import_react45.useRef)(null);
  const container = useContainer();
  useScreenBounds(rCanvas);
  useDocumentEvents();
  useCoarsePointer();
  useGestureEvents(rCanvas);
  useFixSafariDoubleTapZoomPencilEvents(rCanvas);
  const rMemoizedStuff = (0, import_react45.useRef)({ lodDisableTextOutline: false, allowTextOutline: true });
  useQuickReactor(
    "position layers",
    function positionLayersWhenCameraMoves() {
      const { x, y, z } = editor.getCamera();
      if (rMemoizedStuff.current.allowTextOutline && tlenv.isSafari) {
        container.style.setProperty("--tl-text-outline", "none");
        rMemoizedStuff.current.allowTextOutline = false;
      }
      if (rMemoizedStuff.current.allowTextOutline && z < editor.options.textShadowLod !== rMemoizedStuff.current.lodDisableTextOutline) {
        const lodDisableTextOutline = z < editor.options.textShadowLod;
        container.style.setProperty(
          "--tl-text-outline",
          lodDisableTextOutline ? "none" : `var(--tl-text-outline-reference)`
        );
        rMemoizedStuff.current.lodDisableTextOutline = lodDisableTextOutline;
      }
      const offset4 = z >= 1 ? modulate(z, [1, 8], [0.125, 0.5], true) : modulate(z, [0.1, 1], [-2, 0.125], true);
      const transform = `scale(${toDomPrecision(z)}) translate(${toDomPrecision(
        x + offset4
      )}px,${toDomPrecision(y + offset4)}px)`;
      setStyleProperty(rHtmlLayer.current, "transform", transform);
      setStyleProperty(rHtmlLayer2.current, "transform", transform);
    },
    [editor, container]
  );
  const events = useCanvasEvents();
  const shapeSvgDefs = useValue(
    "shapeSvgDefs",
    () => {
      const shapeSvgDefsByKey = /* @__PURE__ */ new Map();
      for (const util of objectMapValues(editor.shapeUtils)) {
        if (!util) return;
        const defs = util.getCanvasSvgDefs();
        for (const { key, component: Component2 } of defs) {
          if (shapeSvgDefsByKey.has(key)) continue;
          shapeSvgDefsByKey.set(key, (0, import_jsx_runtime36.jsx)(Component2, {}, key));
        }
      }
      return [...shapeSvgDefsByKey.values()];
    },
    [editor]
  );
  const hideShapes = useValue("debug_shapes", () => debugFlags.hideShapes.get(), [debugFlags]);
  const debugSvg = useValue("debug_svg", () => debugFlags.debugSvg.get(), [debugFlags]);
  const debugGeometry = useValue("debug_geometry", () => debugFlags.debugGeometry.get(), [
    debugFlags
  ]);
  const isEditingAnything = useValue(
    "isEditingAnything",
    () => editor.getEditingShapeId() !== null,
    [editor]
  );
  const isSelectingAnything = useValue(
    "isSelectingAnything",
    () => !!editor.getSelectedShapeIds().length,
    [editor]
  );
  return (0, import_jsx_runtime36.jsxs)(import_jsx_runtime36.Fragment, { children: [
    (0, import_jsx_runtime36.jsxs)(
      "div",
      {
        ref: rCanvas,
        draggable: false,
        "data-iseditinganything": isEditingAnything,
        "data-isselectinganything": isSelectingAnything,
        className: (0, import_classnames13.default)("tl-canvas", className),
        "data-testid": "canvas",
        ...events,
        children: [
          (0, import_jsx_runtime36.jsx)("svg", { className: "tl-svg-context", "aria-hidden": "true", children: (0, import_jsx_runtime36.jsxs)("defs", { children: [
            shapeSvgDefs,
            (0, import_jsx_runtime36.jsx)(CursorDef, {}),
            (0, import_jsx_runtime36.jsx)(CollaboratorHintDef, {}),
            SvgDefs && (0, import_jsx_runtime36.jsx)(SvgDefs, {})
          ] }) }),
          Background && (0, import_jsx_runtime36.jsx)("div", { className: "tl-background__wrapper", children: (0, import_jsx_runtime36.jsx)(Background, {}) }),
          (0, import_jsx_runtime36.jsx)(GridWrapper, {}),
          (0, import_jsx_runtime36.jsxs)("div", { ref: rHtmlLayer, className: "tl-html-layer tl-shapes", draggable: false, children: [
            (0, import_jsx_runtime36.jsx)(OnTheCanvasWrapper, {}),
            SelectionBackground && (0, import_jsx_runtime36.jsx)(SelectionBackgroundWrapper, {}),
            hideShapes ? null : debugSvg ? (0, import_jsx_runtime36.jsx)(ShapesWithSVGs, {}) : (0, import_jsx_runtime36.jsx)(ShapesToDisplay, {})
          ] }),
          (0, import_jsx_runtime36.jsx)("div", { className: "tl-overlays", children: (0, import_jsx_runtime36.jsxs)("div", { ref: rHtmlLayer2, className: "tl-html-layer", children: [
            debugGeometry ? (0, import_jsx_runtime36.jsx)(GeometryDebuggingView, {}) : null,
            (0, import_jsx_runtime36.jsx)(BrushWrapper, {}),
            (0, import_jsx_runtime36.jsx)(ScribbleWrapper, {}),
            (0, import_jsx_runtime36.jsx)(ZoomBrushWrapper, {}),
            ShapeIndicators && (0, import_jsx_runtime36.jsx)(ShapeIndicators, {}),
            (0, import_jsx_runtime36.jsx)(HintedShapeIndicator, {}),
            (0, import_jsx_runtime36.jsx)(SnapIndicatorWrapper, {}),
            (0, import_jsx_runtime36.jsx)(SelectionForegroundWrapper, {}),
            (0, import_jsx_runtime36.jsx)(HandlesWrapper, {}),
            (0, import_jsx_runtime36.jsx)(OverlaysWrapper, {}),
            (0, import_jsx_runtime36.jsx)(LiveCollaborators, {})
          ] }) }),
          (0, import_jsx_runtime36.jsx)(MovingCameraHitTestBlocker, {})
        ]
      }
    ),
    (0, import_jsx_runtime36.jsx)(
      "div",
      {
        className: "tl-canvas__in-front",
        onPointerDown: editor.markEventAsHandled,
        onPointerUp: editor.markEventAsHandled,
        onTouchStart: editor.markEventAsHandled,
        onTouchEnd: editor.markEventAsHandled,
        children: (0, import_jsx_runtime36.jsx)(InFrontOfTheCanvasWrapper, {})
      }
    ),
    (0, import_jsx_runtime36.jsx)(MenuClickCapture, {})
  ] });
}
function InFrontOfTheCanvasWrapper() {
  const { InFrontOfTheCanvas } = useEditorComponents();
  if (!InFrontOfTheCanvas) return null;
  return (0, import_jsx_runtime36.jsx)(InFrontOfTheCanvas, {});
}
function GridWrapper() {
  const editor = useEditor();
  const gridSize = useValue("gridSize", () => editor.getDocumentSettings().gridSize, [editor]);
  const { x, y, z } = useValue("camera", () => editor.getCamera(), [editor]);
  const isGridMode = useValue("isGridMode", () => editor.getInstanceState().isGridMode, [editor]);
  const { Grid } = useEditorComponents();
  if (!(Grid && isGridMode)) return null;
  return (0, import_jsx_runtime36.jsx)(Grid, { x, y, z, size: gridSize });
}
function ScribbleWrapper() {
  const editor = useEditor();
  const scribbles = useValue("scribbles", () => editor.getInstanceState().scribbles, [editor]);
  const zoomLevel = useValue("zoomLevel", () => editor.getEfficientZoomLevel(), [editor]);
  const { Scribble } = useEditorComponents();
  if (!(Scribble && scribbles.length)) return null;
  return scribbles.map((scribble) => (0, import_jsx_runtime36.jsx)(Scribble, { className: "tl-user-scribble", scribble, zoom: zoomLevel }, scribble.id));
}
function BrushWrapper() {
  const editor = useEditor();
  const brush = useValue("brush", () => editor.getInstanceState().brush, [editor]);
  const { Brush } = useEditorComponents();
  if (!(Brush && brush)) return null;
  return (0, import_jsx_runtime36.jsx)(Brush, { className: "tl-user-brush", brush });
}
function ZoomBrushWrapper() {
  const editor = useEditor();
  const zoomBrush = useValue("zoomBrush", () => editor.getInstanceState().zoomBrush, [editor]);
  const { ZoomBrush } = useEditorComponents();
  if (!(ZoomBrush && zoomBrush)) return null;
  return (0, import_jsx_runtime36.jsx)(ZoomBrush, { className: "tl-user-brush tl-zoom-brush", brush: zoomBrush });
}
function SnapIndicatorWrapper() {
  const editor = useEditor();
  const lines = useValue("snapLines", () => editor.snaps.getIndicators(), [editor]);
  const zoomLevel = useValue("zoomLevel", () => editor.getEfficientZoomLevel(), [editor]);
  const { SnapIndicator } = useEditorComponents();
  if (!(SnapIndicator && lines.length > 0)) return null;
  return lines.map((line) => (0, import_jsx_runtime36.jsx)(SnapIndicator, { className: "tl-user-snapline", line, zoom: zoomLevel }, line.id));
}
function HandlesWrapper() {
  const editor = useEditor();
  const shapeIdWithHandles = useValue(
    "handles shapeIdWithHandles",
    () => {
      const { isReadonly, isChangingStyle } = editor.getInstanceState();
      if (isReadonly || isChangingStyle) return false;
      const onlySelectedShape = editor.getOnlySelectedShape();
      if (!onlySelectedShape) return false;
      const handles = editor.getShapeHandles(onlySelectedShape);
      if (!handles) return false;
      return onlySelectedShape.id;
    },
    [editor]
  );
  if (!shapeIdWithHandles) return null;
  return (0, import_jsx_runtime36.jsx)(HandlesWrapperInner, { shapeId: shapeIdWithHandles });
}
function HandlesWrapperInner({ shapeId }) {
  const editor = useEditor();
  const { Handles } = useEditorComponents();
  const zoomLevel = useValue("zoomLevel", () => editor.getEfficientZoomLevel(), [editor]);
  const isCoarse = useValue("coarse pointer", () => editor.getInstanceState().isCoarsePointer, [
    editor
  ]);
  const transform = useValue("handles transform", () => editor.getShapePageTransform(shapeId), [
    editor,
    shapeId
  ]);
  const handles = useValue(
    "handles",
    () => {
      const handles2 = editor.getShapeHandles(shapeId);
      if (!handles2) return null;
      const minDistBetweenVirtualHandlesAndRegularHandles = (isCoarse ? editor.options.coarseHandleRadius : editor.options.handleRadius) / zoomLevel * 2;
      return handles2.filter(
        (handle) => (
          // if the handle isn't a virtual handle, we'll display it
          // but for virtual handles, we'll only display them if they're far enough away from vertex handles
          handle.type !== "virtual" || !handles2.some(
            (h2) => (
              // skip the handle we're checking against
              // and check that their distance isn't below the minimum distance
              h2 !== handle && // only check against vertex handles
              h2.type === "vertex" && Vec.Dist(handle, h2) < minDistBetweenVirtualHandlesAndRegularHandles
            )
          )
        )
      ).sort((a) => a.type === "vertex" ? 1 : -1);
    },
    [editor, zoomLevel, isCoarse, shapeId]
  );
  const isHidden2 = useValue("isHidden", () => editor.isShapeHidden(shapeId), [editor, shapeId]);
  if (!Handles || !handles || !transform || isHidden2) {
    return null;
  }
  return (0, import_jsx_runtime36.jsx)(Handles, { children: (0, import_jsx_runtime36.jsx)("g", { transform: Mat.toCssString(transform), children: handles.map((handle) => {
    return (0, import_jsx_runtime36.jsx)(
      HandleWrapper,
      {
        shapeId,
        handle,
        zoom: zoomLevel,
        isCoarse
      },
      handle.id
    );
  }) }) });
}
function HandleWrapper({
  shapeId,
  handle,
  zoom,
  isCoarse
}) {
  const events = useHandleEvents(shapeId, handle.id);
  const { Handle } = useEditorComponents();
  if (!Handle) return null;
  return (0, import_jsx_runtime36.jsx)(
    "g",
    {
      role: "button",
      "aria-label": handle.label || "handle",
      transform: `translate(${handle.x}, ${handle.y})`,
      ...events,
      children: (0, import_jsx_runtime36.jsx)(Handle, { shapeId, handle, zoom, isCoarse })
    }
  );
}
function OverlaysWrapper() {
  const { Overlays } = useEditorComponents();
  if (!Overlays) return null;
  return (0, import_jsx_runtime36.jsx)("div", { className: "tl-custom-overlays tl-overlays__item", children: (0, import_jsx_runtime36.jsx)(Overlays, {}) });
}
function ShapesWithSVGs() {
  const editor = useEditor();
  const renderingShapes = useValue("rendering shapes", () => editor.getRenderingShapes(), [editor]);
  return renderingShapes.map((result) => (0, import_jsx_runtime36.jsxs)(import_react45.Fragment, { children: [
    (0, import_jsx_runtime36.jsx)(Shape, { ...result }),
    (0, import_jsx_runtime36.jsx)(DebugSvgCopy, { id: result.id, mode: "iframe" })
  ] }, result.id + "_fragment"));
}
function ReflowIfNeeded() {
  const editor = useEditor();
  const culledShapesRef = (0, import_react45.useRef)(/* @__PURE__ */ new Set());
  useQuickReactor(
    "reflow for culled shapes",
    () => {
      const culledShapes = editor.getCulledShapes();
      if (culledShapesRef.current.size === culledShapes.size && [...culledShapes].every((id) => culledShapesRef.current.has(id)))
        return;
      culledShapesRef.current = culledShapes;
      const canvas = document.getElementsByClassName("tl-canvas");
      if (canvas.length === 0) return;
      const _height = canvas[0].offsetHeight;
    },
    [editor]
  );
  return null;
}
function ShapesToDisplay() {
  const editor = useEditor();
  const renderingShapes = useValue("rendering shapes", () => editor.getRenderingShapes(), [editor]);
  return (0, import_jsx_runtime36.jsxs)(import_jsx_runtime36.Fragment, { children: [
    renderingShapes.map((result) => (0, import_jsx_runtime36.jsx)(Shape, { ...result }, result.id + "_shape")),
    tlenv.isSafari && (0, import_jsx_runtime36.jsx)(ReflowIfNeeded, {})
  ] });
}
function HintedShapeIndicator() {
  const editor = useEditor();
  const { ShapeIndicator } = useEditorComponents();
  const ids = useValue("hinting shape ids", () => dedupe(editor.getHintingShapeIds()), [editor]);
  if (!ids.length) return null;
  if (!ShapeIndicator) return null;
  return ids.map((id) => (0, import_jsx_runtime36.jsx)(ShapeIndicator, { className: "tl-user-indicator__hint", shapeId: id }, id + "_hinting"));
}
function CursorDef() {
  return (0, import_jsx_runtime36.jsxs)("g", { id: useSharedSafeId("cursor"), children: [
    (0, import_jsx_runtime36.jsxs)("g", { fill: "rgba(0,0,0,.2)", transform: "translate(-11,-11)", children: [
      (0, import_jsx_runtime36.jsx)("path", { d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" }),
      (0, import_jsx_runtime36.jsx)("path", { d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" })
    ] }),
    (0, import_jsx_runtime36.jsxs)("g", { fill: "white", transform: "translate(-12,-12)", children: [
      (0, import_jsx_runtime36.jsx)("path", { d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" }),
      (0, import_jsx_runtime36.jsx)("path", { d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" })
    ] }),
    (0, import_jsx_runtime36.jsxs)("g", { fill: "currentColor", transform: "translate(-12,-12)", children: [
      (0, import_jsx_runtime36.jsx)("path", { d: "m19.751 24.4155-1.844.774-3.1-7.374 1.841-.775z" }),
      (0, import_jsx_runtime36.jsx)("path", { d: "m13 10.814v11.188l2.969-2.866.428-.139h4.768z" })
    ] })
  ] });
}
function CollaboratorHintDef() {
  const cursorHintId = useSharedSafeId("cursor_hint");
  return (0, import_jsx_runtime36.jsx)("path", { id: cursorHintId, fill: "currentColor", d: "M -2,-5 2,0 -2,5 Z" });
}
function DebugSvgCopy({ id, mode }) {
  const editor = useEditor();
  const [image, setImage] = (0, import_react45.useState)(null);
  const isInRoot = useValue(
    "is in root",
    () => {
      const shape = editor.getShape(id);
      return (shape == null ? void 0 : shape.parentId) === editor.getCurrentPageId();
    },
    [editor, id]
  );
  (0, import_react45.useEffect)(() => {
    if (!isInRoot) return;
    let latest = null;
    const unsubscribe = react("shape to svg", async () => {
      const renderId = Math.random();
      latest = renderId;
      const isSingleFrame = editor.isShapeOfType(id, "frame");
      const padding = isSingleFrame ? 0 : 10;
      let bounds = editor.getShapePageBounds(id);
      if (!bounds) return;
      bounds = bounds.clone().expandBy(padding);
      const result = await editor.getSvgString([id], { padding });
      if (latest !== renderId || !result) return;
      const svgDataUrl = `data:image/svg+xml;utf8,${encodeURIComponent(result.svg)}`;
      setImage({ src: svgDataUrl, bounds });
    });
    return () => {
      latest = null;
      unsubscribe();
    };
  }, [editor, id, isInRoot]);
  if (!isInRoot || !image) return null;
  if (mode === "iframe") {
    return (0, import_jsx_runtime36.jsx)(
      "iframe",
      {
        src: image.src,
        width: image.bounds.width,
        height: image.bounds.height,
        referrerPolicy: "no-referrer",
        style: {
          position: "absolute",
          top: 0,
          left: 0,
          border: "none",
          transform: `translate(${image.bounds.x}px, ${image.bounds.maxY + 12}px)`,
          outline: "1px solid black",
          maxWidth: "none"
        }
      }
    );
  }
  return (0, import_jsx_runtime36.jsx)(
    "img",
    {
      src: image.src,
      width: image.bounds.width,
      height: image.bounds.height,
      referrerPolicy: "no-referrer",
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        transform: `translate(${image.bounds.x}px, ${image.bounds.maxY + 12}px)`,
        outline: "1px solid black",
        maxWidth: "none"
      }
    }
  );
}
function SelectionForegroundWrapper() {
  const editor = useEditor();
  const selectionRotation = useValue(
    "selection rotation",
    function getSelectionRotation() {
      return editor.getSelectionRotation();
    },
    [editor]
  );
  const selectionBounds = useValue(
    "selection bounds",
    () => editor.getSelectionRotatedPageBounds(),
    [editor]
  );
  const { SelectionForeground } = useEditorComponents();
  if (!selectionBounds || !SelectionForeground) return null;
  return (0, import_jsx_runtime36.jsx)(SelectionForeground, { bounds: selectionBounds, rotation: selectionRotation });
}
function SelectionBackgroundWrapper() {
  const editor = useEditor();
  const selectionRotation = useValue("selection rotation", () => editor.getSelectionRotation(), [
    editor
  ]);
  const selectionBounds = useValue(
    "selection bounds",
    () => editor.getSelectionRotatedPageBounds(),
    [editor]
  );
  const { SelectionBackground } = useEditorComponents();
  if (!selectionBounds || !SelectionBackground) return null;
  return (0, import_jsx_runtime36.jsx)(SelectionBackground, { bounds: selectionBounds, rotation: selectionRotation });
}
function OnTheCanvasWrapper() {
  const { OnTheCanvas } = useEditorComponents();
  if (!OnTheCanvas) return null;
  return (0, import_jsx_runtime36.jsx)(OnTheCanvas, {});
}
function MovingCameraHitTestBlocker() {
  const editor = useEditor();
  const cameraState = useValue("camera state", () => editor.getCameraState(), [editor]);
  return (0, import_jsx_runtime36.jsx)(
    "div",
    {
      className: (0, import_classnames13.default)("tl-hit-test-blocker", {
        "tl-hit-test-blocker__hidden": cameraState === "idle"
      })
    }
  );
}

// ../node_modules/@tldraw/editor/dist-esm/lib/components/default-components/DefaultSelectionBackground.mjs
var import_jsx_runtime37 = __toESM(require_jsx_runtime(), 1);
var React11 = __toESM(require_react(), 1);
function DefaultSelectionBackground({ bounds, rotation }) {
  const rDiv = React11.useRef(null);
  useTransform(rDiv, bounds.x, bounds.y, 1, rotation);
  React11.useLayoutEffect(() => {
    const div = rDiv.current;
    if (!div) return;
    div.style.width = toDomPrecision(Math.max(1, bounds.width)) + "px";
    div.style.height = toDomPrecision(Math.max(1, bounds.height)) + "px";
  }, [bounds.width, bounds.height]);
  return (0, import_jsx_runtime37.jsx)("div", { ref: rDiv, className: "tl-selection__bg", draggable: false });
}

// ../node_modules/@tldraw/editor/dist-esm/lib/components/HTMLContainer.mjs
var import_jsx_runtime38 = __toESM(require_jsx_runtime(), 1);
var import_classnames14 = __toESM(require_classnames(), 1);
function HTMLContainer({ children, className = "", ...rest }) {
  return (0, import_jsx_runtime38.jsx)("div", { ...rest, className: (0, import_classnames14.default)("tl-html-container", className), children });
}

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/bindings/BindingUtil.mjs
var BindingUtil = class {
  constructor(editor) {
    this.editor = editor;
  }
};
__publicField(BindingUtil, "props");
__publicField(BindingUtil, "migrations");
/**
 * The type of the binding util, which should match the binding's type.
 *
 * @public
 */
__publicField(BindingUtil, "type");

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/shapes/shared/resizeBox.mjs
function resizeBox(shape, info, opts = {}) {
  const { newPoint, handle, scaleX, scaleY } = info;
  const { minWidth = 1, maxWidth = Infinity, minHeight = 1, maxHeight = Infinity } = opts;
  let w = shape.props.w * scaleX;
  let h2 = shape.props.h * scaleY;
  const offset4 = new Vec(0, 0);
  if (w > 0) {
    if (w < minWidth) {
      switch (handle) {
        case "top_left":
        case "left":
        case "bottom_left": {
          offset4.x = w - minWidth;
          break;
        }
        case "top":
        case "bottom": {
          offset4.x = (w - minWidth) / 2;
          break;
        }
        default: {
          offset4.x = 0;
        }
      }
      w = minWidth;
    }
  } else {
    offset4.x = w;
    w = -w;
    if (w < minWidth) {
      switch (handle) {
        case "top_left":
        case "left":
        case "bottom_left": {
          offset4.x = -w;
          break;
        }
        default: {
          offset4.x = -minWidth;
        }
      }
      w = minWidth;
    }
  }
  if (h2 > 0) {
    if (h2 < minHeight) {
      switch (handle) {
        case "top_left":
        case "top":
        case "top_right": {
          offset4.y = h2 - minHeight;
          break;
        }
        case "right":
        case "left": {
          offset4.y = (h2 - minHeight) / 2;
          break;
        }
        default: {
          offset4.y = 0;
        }
      }
      h2 = minHeight;
    }
  } else {
    offset4.y = h2;
    h2 = -h2;
    if (h2 < minHeight) {
      switch (handle) {
        case "top_left":
        case "top":
        case "top_right": {
          offset4.y = -h2;
          break;
        }
        default: {
          offset4.y = -minHeight;
        }
      }
      h2 = minHeight;
    }
  }
  const { x, y } = offset4.rot(shape.rotation).add(newPoint);
  return {
    ...shape,
    x,
    y,
    props: {
      w: Math.min(maxWidth, w),
      h: Math.min(maxHeight, h2)
    }
  };
}

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/shapes/BaseBoxShapeUtil.mjs
var BaseBoxShapeUtil = class extends ShapeUtil {
  getGeometry(shape) {
    return new Rectangle2d({
      width: shape.props.w,
      height: shape.props.h,
      isFilled: true
    });
  }
  onResize(shape, info) {
    return resizeBox(shape, info);
  }
  getHandleSnapGeometry(shape) {
    return {
      points: this.getGeometry(shape).bounds.cornersAndCenter
    };
  }
  getInterpolatedProps(startShape, endShape, t2) {
    return {
      ...endShape.props,
      w: lerp(startShape.props.w, endShape.props.w, t2),
      h: lerp(startShape.props.h, endShape.props.h, t2)
    };
  }
};

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/shapes/shared/resizeScaled.mjs
function resizeScaled(shape, { initialBounds, scaleX, scaleY, newPoint, handle }) {
  let scaleDelta;
  switch (handle) {
    case "bottom_left":
    case "bottom_right":
    case "top_left":
    case "top_right": {
      scaleDelta = Math.max(0.01, Math.max(Math.abs(scaleX), Math.abs(scaleY)));
      break;
    }
    case "left":
    case "right": {
      scaleDelta = Math.max(0.01, Math.abs(scaleX));
      break;
    }
    case "bottom":
    case "top": {
      scaleDelta = Math.max(0.01, Math.abs(scaleY));
      break;
    }
    default: {
      throw exhaustiveSwitchError(handle);
    }
  }
  const offset4 = new Vec(0, 0);
  if (scaleX < 0) {
    offset4.x = -(initialBounds.width * scaleDelta);
  }
  if (scaleY < 0) {
    offset4.y = -(initialBounds.height * scaleDelta);
  }
  const { x, y } = Vec.Add(newPoint, offset4.rot(shape.rotation));
  return {
    x,
    y,
    props: {
      scale: scaleDelta * shape.props.scale
    }
  };
}

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/tools/BaseBoxShapeTool/children/Idle.mjs
var Idle = class extends StateNode {
  onPointerDown(info) {
    this.parent.transition("pointing", info);
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
};
__publicField(Idle, "id", "idle");

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/tools/BaseBoxShapeTool/children/Pointing.mjs
var Pointing = class extends StateNode {
  onPointerMove(info) {
    const { editor } = this;
    if (editor.inputs.getIsDragging()) {
      const originPagePoint = editor.inputs.getOriginPagePoint();
      const shapeType = this.parent.shapeType;
      const id = createShapeId();
      const creatingMarkId = editor.markHistoryStoppingPoint(`creating_box:${id}`);
      const newPoint = maybeSnapToGrid(originPagePoint, editor);
      this.editor.createShapes([
        {
          id,
          type: shapeType,
          x: newPoint.x,
          y: newPoint.y,
          props: {
            w: 1,
            h: 1
          }
        }
      ]);
      const shape = editor.getShape(id);
      if (!shape) {
        this.cancel();
        return;
      }
      editor.select(id);
      const parent = this.parent;
      this.editor.setCurrentTool(
        "select.resizing",
        {
          ...info,
          target: "selection",
          handle: "bottom_right",
          isCreating: true,
          creatingMarkId,
          creationCursorOffset: { x: 1, y: 1 },
          onInteractionEnd: this.parent.id,
          onCreate: parent.onCreate ? (shape2) => {
            var _a6;
            return (_a6 = parent.onCreate) == null ? void 0 : _a6.call(parent, shape2);
          } : void 0
        }
        /** satisfies ResizingInfo, defined in main tldraw package 😧 */
      );
    }
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    this.cancel();
  }
  complete() {
    const originPagePoint = this.editor.inputs.getOriginPagePoint();
    const shapeType = this.parent.shapeType;
    const id = createShapeId();
    this.editor.markHistoryStoppingPoint(`creating_box:${id}`);
    this.editor.createShapes([
      {
        id,
        type: shapeType,
        x: originPagePoint.x,
        y: originPagePoint.y
      }
    ]);
    const shape = this.editor.getShape(id);
    if (!shape) {
      this.cancel();
      return;
    }
    let { w, h: h2 } = shape.props;
    const delta = new Vec(w / 2, h2 / 2);
    const parentTransform = this.editor.getShapeParentTransform(shape);
    if (parentTransform) delta.rot(-parentTransform.rotation());
    let scale = 1;
    if (this.editor.user.getIsDynamicResizeMode()) {
      scale = 1 / this.editor.getZoomLevel();
      w *= scale;
      h2 *= scale;
      delta.mul(scale);
    }
    const next = structuredClone(shape);
    const newPoint = maybeSnapToGrid(new Vec(shape.x - delta.x, shape.y - delta.y), this.editor);
    next.x = newPoint.x;
    next.y = newPoint.y;
    next.props.w = w;
    next.props.h = h2;
    if ("scale" in shape.props) {
      ;
      next.props.scale = scale;
    }
    this.editor.updateShape(next);
    this.editor.setSelectedShapes([id]);
    if (this.editor.getInstanceState().isToolLocked) {
      this.parent.transition("idle");
    } else {
      this.editor.setCurrentTool("select.idle");
    }
  }
  cancel() {
    this.parent.transition("idle");
  }
};
__publicField(Pointing, "id", "pointing");
function maybeSnapToGrid(point, editor) {
  const isGridMode = editor.getInstanceState().isGridMode;
  const gridSize = editor.getDocumentSettings().gridSize;
  if (isGridMode) return point.clone().snapToGrid(gridSize);
  return point.clone();
}

// ../node_modules/@tldraw/editor/dist-esm/lib/editor/tools/BaseBoxShapeTool/BaseBoxShapeTool.mjs
var BaseBoxShapeTool = class extends StateNode {
  static children() {
    return [Idle, Pointing];
  }
};
__publicField(BaseBoxShapeTool, "id", "box");
__publicField(BaseBoxShapeTool, "initial", "idle");

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/useGlobalMenuIsOpen.mjs
var import_react46 = __toESM(require_react(), 1);
function useGlobalMenuIsOpen(id, onChange, onEvent) {
  const rIsOpen = (0, import_react46.useRef)(false);
  const onOpenChange = (0, import_react46.useCallback)(
    (isOpen2) => {
      rIsOpen.current = isOpen2;
      if (isOpen2) {
        tlmenus.addOpenMenu(id);
      } else {
        tlmenus.deleteOpenMenu(id);
      }
      onChange == null ? void 0 : onChange(isOpen2);
    },
    [id, onChange]
  );
  const isOpen = useValue("is menu open", () => tlmenus.getOpenMenus().includes(id), [id]);
  (0, import_react46.useEffect)(() => {
    if (rIsOpen.current) {
      onEvent == null ? void 0 : onEvent("open-menu");
      tlmenus.addOpenMenu(id);
    }
    return () => {
      if (rIsOpen.current) {
        tlmenus.deleteOpenMenu(id);
        tlmenus.getOpenMenus().forEach((menuId) => {
          if (menuId.startsWith(id)) {
            onEvent == null ? void 0 : onEvent("close-menu");
            tlmenus.deleteOpenMenu(menuId);
          }
        });
        rIsOpen.current = false;
      }
    };
  }, [id, onEvent]);
  return [isOpen, onOpenChange];
}

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/useIsCropping.mjs
function useIsCropping(shapeId) {
  const editor = useEditor();
  return useValue("isCropping", () => editor.getCroppingShapeId() === shapeId, [editor, shapeId]);
}

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/useIsEditing.mjs
function useIsEditing(shapeId) {
  const editor = useEditor();
  return useValue("isEditing", () => editor.getEditingShapeId() === shapeId, [editor, shapeId]);
}

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/usePassThroughMouseOverEvents.mjs
var import_react47 = __toESM(require_react(), 1);
function usePassThroughMouseOverEvents(ref) {
  if (!ref) throw Error("usePassThroughWheelEvents must be passed a ref");
  const container = useContainer();
  const editor = useMaybeEditor();
  (0, import_react47.useEffect)(() => {
    function onMouseOver(e) {
      if (!(editor == null ? void 0 : editor.getInstanceState().isFocused)) return;
      if (e.isSpecialRedispatchedEvent) return;
      preventDefault(e);
      const cvs = container.querySelector(".tl-canvas");
      if (!cvs) return;
      const newEvent = new PointerEvent(e.type, e);
      newEvent.isSpecialRedispatchedEvent = true;
      cvs.dispatchEvent(newEvent);
    }
    const elm = ref.current;
    if (!elm) return;
    elm.addEventListener("mouseover", onMouseOver, { passive: false });
    return () => {
      elm.removeEventListener("mouseover", onMouseOver);
    };
  }, [container, editor, ref]);
}

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/useSelectionEvents.mjs
var import_react48 = __toESM(require_react(), 1);
function useSelectionEvents(handle) {
  const editor = useEditor();
  const events = (0, import_react48.useMemo)(
    function selectionEvents() {
      const onPointerDown = (e) => {
        if (editor.wasEventAlreadyHandled(e)) return;
        if (e.button === RIGHT_MOUSE_BUTTON) {
          editor.dispatch({
            type: "pointer",
            target: "selection",
            handle,
            name: "right_click",
            ...getPointerInfo(editor, e)
          });
          return;
        }
        if (e.button !== 0) return;
        const elm = loopToHtmlElement(e.currentTarget);
        function releaseCapture() {
          elm.removeEventListener("pointerup", releaseCapture);
          releasePointerCapture(elm, e);
        }
        setPointerCapture(elm, e);
        elm.addEventListener("pointerup", releaseCapture);
        editor.dispatch({
          name: "pointer_down",
          type: "pointer",
          target: "selection",
          handle,
          ...getPointerInfo(editor, e)
        });
        editor.markEventAsHandled(e);
      };
      let lastX, lastY;
      function onPointerMove(e) {
        if (editor.wasEventAlreadyHandled(e)) return;
        if (e.button !== 0) return;
        if (e.clientX === lastX && e.clientY === lastY) return;
        lastX = e.clientX;
        lastY = e.clientY;
        editor.dispatch({
          name: "pointer_move",
          type: "pointer",
          target: "selection",
          handle,
          ...getPointerInfo(editor, e)
        });
      }
      const onPointerUp = (e) => {
        if (editor.wasEventAlreadyHandled(e)) return;
        if (e.button !== 0) return;
        editor.dispatch({
          name: "pointer_up",
          type: "pointer",
          target: "selection",
          handle,
          ...getPointerInfo(editor, e)
        });
      };
      return {
        onPointerDown,
        onPointerMove,
        onPointerUp
      };
    },
    [editor, handle]
  );
  return events;
}

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/useTLStore.mjs
var import_react49 = __toESM(require_react(), 1);
function useTLStore(opts) {
  const [current, setCurrent] = (0, import_react49.useState)(() => ({ store: createTLStore(opts), opts }));
  if (!areObjectsShallowEqual(current.opts, opts)) {
    const next = { store: createTLStore(opts), opts };
    setCurrent(next);
    return next.store;
  }
  return current.store;
}
function useTLSchemaFromUtils(opts) {
  const [current, setCurrent] = (0, import_react49.useState)(() => ({ opts, schema: createTLSchemaFromUtils(opts) }));
  if (!areObjectsShallowEqual(current.opts, opts)) {
    const next = createTLSchemaFromUtils(opts);
    setCurrent({ opts, schema: next });
    return next;
  }
  return current.schema;
}

// ../node_modules/@tldraw/editor/dist-esm/lib/hooks/useViewportHeight.mjs
var import_react50 = __toESM(require_react(), 1);
function useViewportHeight() {
  const visualViewport = window.visualViewport;
  const [height, setHeight] = (0, import_react50.useState)(
    () => visualViewport ? visualViewport.height + visualViewport.offsetTop : window.innerHeight
  );
  (0, import_react50.useLayoutEffect)(() => {
    var _a6, _b3;
    const handleResize = () => {
      const visualViewport2 = window.visualViewport;
      setHeight(
        () => visualViewport2 ? visualViewport2.height + visualViewport2.offsetTop : window.innerHeight
      );
    };
    (_a6 = window.visualViewport) == null ? void 0 : _a6.addEventListener("resize", handleResize);
    (_b3 = window.visualViewport) == null ? void 0 : _b3.addEventListener("scroll", handleResize);
    return () => {
      var _a7, _b4;
      (_a7 = window.visualViewport) == null ? void 0 : _a7.removeEventListener("resize", handleResize);
      (_b4 = window.visualViewport) == null ? void 0 : _b4.removeEventListener("scroll", handleResize);
    };
  }, []);
  return height;
}

// ../node_modules/@tldraw/editor/dist-esm/lib/primitives/geometry/geometry-constants.mjs
var SPACING = 20;
var MIN_COUNT = 8;
function getVerticesCountForArcLength(length, spacing = SPACING) {
  return Math.max(MIN_COUNT, Math.ceil(length / spacing));
}

// ../node_modules/@tldraw/editor/dist-esm/lib/primitives/geometry/Arc2d.mjs
var Arc2d = class extends Geometry2d {
  constructor(config) {
    super({ ...config, isFilled: false, isClosed: false });
    __publicField(this, "_center");
    __publicField(this, "_radius");
    __publicField(this, "_start");
    __publicField(this, "_end");
    __publicField(this, "_largeArcFlag");
    __publicField(this, "_sweepFlag");
    __publicField(this, "_measure");
    __publicField(this, "_angleStart");
    __publicField(this, "_angleEnd");
    const { center, sweepFlag, largeArcFlag, start, end } = config;
    if (start.equals(end)) throw Error(`Arc must have different start and end points.`);
    this._angleStart = Vec.Angle(center, start);
    this._angleEnd = Vec.Angle(center, end);
    this._radius = Vec.Dist(center, start);
    this._measure = getArcMeasure(this._angleStart, this._angleEnd, sweepFlag, largeArcFlag);
    this._start = start;
    this._end = end;
    this._sweepFlag = sweepFlag;
    this._largeArcFlag = largeArcFlag;
    this._center = center;
  }
  nearestPoint(point) {
    const {
      _center,
      _measure: measure,
      _radius: radius,
      _angleEnd: angleEnd,
      _angleStart: angleStart,
      _start: A,
      _end: B
    } = this;
    const t2 = getPointInArcT(measure, angleStart, angleEnd, _center.angle(point));
    if (t2 <= 0) return A;
    if (t2 >= 1) return B;
    const P = Vec.Sub(point, _center).uni().mul(radius).add(_center);
    let nearest;
    let dist = Infinity;
    let d;
    for (const p of [A, B, P]) {
      d = Vec.Dist2(point, p);
      if (d < dist) {
        nearest = p;
        dist = d;
      }
    }
    if (!nearest) throw Error("nearest point not found");
    return nearest;
  }
  hitTestLineSegment(A, B) {
    const {
      _center,
      _radius: radius,
      _measure: measure,
      _angleStart: angleStart,
      _angleEnd: angleEnd
    } = this;
    const intersection = intersectLineSegmentCircle(A, B, _center, radius);
    if (intersection === null) return false;
    return intersection.some((p) => {
      const result = getPointInArcT(measure, angleStart, angleEnd, _center.angle(p));
      return result >= 0 && result <= 1;
    });
  }
  getVertices() {
    const { _center, _measure: measure, length, _radius: radius, _angleStart: angleStart } = this;
    const vertices = [];
    for (let i = 0, n = getVerticesCountForArcLength(Math.abs(length)); i < n + 1; i++) {
      const t2 = i / n * measure;
      const angle = angleStart + t2;
      vertices.push(getPointOnCircle(_center, radius, angle));
    }
    return vertices;
  }
  getSvgPathData(first2 = true) {
    const {
      _start: start,
      _end: end,
      _radius: radius,
      _largeArcFlag: largeArcFlag,
      _sweepFlag: sweepFlag
    } = this;
    return `${first2 ? `M${start.toFixed()}` : ``} A${radius} ${radius} 0 ${largeArcFlag} ${sweepFlag} ${end.toFixed()}`;
  }
  getLength() {
    return Math.abs(this._measure * this._radius);
  }
};

// ../node_modules/@tldraw/editor/dist-esm/lib/primitives/geometry/Circle2d.mjs
var Circle2d = class extends Geometry2d {
  constructor(config) {
    super({ isClosed: true, ...config });
    __publicField(this, "_center");
    __publicField(this, "_radius");
    __publicField(this, "_x");
    __publicField(this, "_y");
    this.config = config;
    const { x = 0, y = 0, radius } = config;
    this._x = x;
    this._y = y;
    this._center = new Vec(radius + x, radius + y);
    this._radius = radius;
  }
  getBounds() {
    return new Box(this._x, this._y, this._radius * 2, this._radius * 2);
  }
  getVertices() {
    const { _center, _radius: radius } = this;
    const perimeter = PI2 * radius;
    const vertices = [];
    for (let i = 0, n = getVerticesCountForArcLength(perimeter); i < n; i++) {
      const angle = i / n * PI2;
      vertices.push(getPointOnCircle(_center, radius, angle));
    }
    return vertices;
  }
  nearestPoint(point) {
    const { _center, _radius: radius } = this;
    if (_center.equals(point)) return Vec.AddXY(_center, radius, 0);
    return Vec.Sub(point, _center).uni().mul(radius).add(_center);
  }
  hitTestLineSegment(A, B, distance = 0) {
    const { _center, _radius: radius } = this;
    return intersectLineSegmentCircle(A, B, _center, radius + distance) !== null;
  }
  getSvgPathData() {
    const { _center, _radius: radius } = this;
    return `M${_center.x + radius},${_center.y} a${radius},${radius} 0 1,0 ${radius * 2},0a${radius},${radius} 0 1,0 -${radius * 2},0`;
  }
};

// ../node_modules/@tldraw/editor/dist-esm/lib/primitives/geometry/CubicBezier2d.mjs
var CubicBezier2d = class _CubicBezier2d extends Polyline2d {
  constructor(config) {
    const { start: a, cp1: b, cp2: c, end: d } = config;
    super({ ...config, points: [a, d] });
    __publicField(this, "_a");
    __publicField(this, "_b");
    __publicField(this, "_c");
    __publicField(this, "_d");
    __publicField(this, "_resolution");
    this._a = a;
    this._b = b;
    this._c = c;
    this._d = d;
    this._resolution = config.resolution ?? 10;
  }
  getVertices() {
    const vertices = [];
    const { _a: a, _b: b, _c: c, _d: d } = this;
    for (let i = 0, n = this._resolution; i <= n; i++) {
      const t2 = i / n;
      vertices.push(
        new Vec(
          (1 - t2) * (1 - t2) * (1 - t2) * a.x + 3 * ((1 - t2) * (1 - t2)) * t2 * b.x + 3 * (1 - t2) * (t2 * t2) * c.x + t2 * t2 * t2 * d.x,
          (1 - t2) * (1 - t2) * (1 - t2) * a.y + 3 * ((1 - t2) * (1 - t2)) * t2 * b.y + 3 * (1 - t2) * (t2 * t2) * c.y + t2 * t2 * t2 * d.y
        )
      );
    }
    return vertices;
  }
  nearestPoint(A) {
    let nearest;
    let dist = Infinity;
    let d;
    let p;
    for (const edge of this.segments) {
      p = edge.nearestPoint(A);
      d = Vec.Dist2(p, A);
      if (d < dist) {
        nearest = p;
        dist = d;
      }
    }
    if (!nearest) throw Error("nearest point not found");
    return nearest;
  }
  getSvgPathData(first2 = true) {
    const { _a: a, _b: b, _c: c, _d: d } = this;
    return `${first2 ? `M ${a.toFixed()} ` : ``} C${b.toFixed()} ${c.toFixed()} ${d.toFixed()}`;
  }
  static GetAtT(segment, t2) {
    const { _a: a, _b: b, _c: c, _d: d } = segment;
    return new Vec(
      (1 - t2) * (1 - t2) * (1 - t2) * a.x + 3 * ((1 - t2) * (1 - t2)) * t2 * b.x + 3 * (1 - t2) * (t2 * t2) * c.x + t2 * t2 * t2 * d.x,
      (1 - t2) * (1 - t2) * (1 - t2) * a.y + 3 * ((1 - t2) * (1 - t2)) * t2 * b.y + 3 * (1 - t2) * (t2 * t2) * c.y + t2 * t2 * t2 * d.y
    );
  }
  getLength(_filters, precision = 32) {
    let n1, p1 = this._a, length = 0;
    for (let i = 1; i <= precision; i++) {
      n1 = _CubicBezier2d.GetAtT(this, i / precision);
      length += Vec.Dist(p1, n1);
      p1 = n1;
    }
    return length;
  }
};

// ../node_modules/@tldraw/editor/dist-esm/lib/primitives/geometry/CubicSpline2d.mjs
var CubicSpline2d = class extends Geometry2d {
  constructor(config) {
    super({ ...config, isClosed: false, isFilled: false });
    __publicField(this, "_points");
    __publicField(this, "_segments");
    const { points } = config;
    this._points = points;
  }
  // eslint-disable-next-line no-restricted-syntax
  get segments() {
    if (!this._segments) {
      this._segments = [];
      const { _points: points } = this;
      const len = points.length;
      const last2 = len - 2;
      const k = 1.25;
      for (let i = 0; i < len - 1; i++) {
        const p0 = i === 0 ? points[0] : points[i - 1];
        const p1 = points[i];
        const p2 = points[i + 1];
        const p3 = i === last2 ? p2 : points[i + 2];
        const start = p1, cp1 = i === 0 ? p0 : new Vec(p1.x + (p2.x - p0.x) / 6 * k, p1.y + (p2.y - p0.y) / 6 * k), cp2 = i === last2 ? p2 : new Vec(p2.x - (p3.x - p1.x) / 6 * k, p2.y - (p3.y - p1.y) / 6 * k), end = p2;
        this._segments.push(new CubicBezier2d({ start, cp1, cp2, end }));
      }
    }
    return this._segments;
  }
  getLength() {
    return this.segments.reduce((acc, segment) => acc + segment.length, 0);
  }
  getVertices() {
    const vertices = this.segments.reduce((acc, segment) => {
      return acc.concat(segment.vertices);
    }, []);
    vertices.push(this._points[this._points.length - 1]);
    return vertices;
  }
  nearestPoint(A) {
    let nearest;
    let dist = Infinity;
    let d;
    let p;
    for (const segment of this.segments) {
      p = segment.nearestPoint(A);
      d = Vec.Dist2(p, A);
      if (d < dist) {
        nearest = p;
        dist = d;
      }
    }
    if (!nearest) throw Error("nearest point not found");
    return nearest;
  }
  hitTestLineSegment(A, B) {
    return this.segments.some((segment) => segment.hitTestLineSegment(A, B));
  }
  getSvgPathData() {
    let d = this.segments.reduce((d2, segment, i) => {
      return d2 + segment.getSvgPathData(i === 0);
    }, "");
    if (this.isClosed) {
      d += "Z";
    }
    return d;
  }
};

// ../node_modules/@tldraw/editor/dist-esm/lib/primitives/geometry/Ellipse2d.mjs
var Ellipse2d = class extends Geometry2d {
  constructor(config) {
    super({ ...config, isClosed: true });
    __publicField(this, "_w");
    __publicField(this, "_h");
    __publicField(this, "_edges");
    this.config = config;
    const { width, height } = config;
    this._w = width;
    this._h = height;
  }
  // eslint-disable-next-line no-restricted-syntax
  get edges() {
    if (!this._edges) {
      const { vertices } = this;
      this._edges = [];
      for (let i = 0, n = vertices.length; i < n; i++) {
        const start = vertices[i];
        const end = vertices[(i + 1) % n];
        this._edges.push(new Edge2d({ start, end }));
      }
    }
    return this._edges;
  }
  getVertices() {
    const w = Math.max(1, this._w);
    const h2 = Math.max(1, this._h);
    const cx = w / 2;
    const cy = h2 / 2;
    const q = Math.pow(cx - cy, 2) / Math.pow(cx + cy, 2);
    const p = PI * (cx + cy) * (1 + 3 * q / (10 + Math.sqrt(4 - 3 * q)));
    const len = getVerticesCountForArcLength(p);
    const step = PI2 / len;
    const a = Math.cos(step);
    const b = Math.sin(step);
    let sin = 0;
    let cos = 1;
    let ts2 = 0;
    let tc = 1;
    const vertices = Array(len);
    for (let i = 0; i < len; i++) {
      vertices[i] = new Vec(clamp(cx + cx * cos, 0, w), clamp(cy + cy * sin, 0, h2));
      ts2 = b * cos + a * sin;
      tc = a * cos - b * sin;
      sin = ts2;
      cos = tc;
    }
    return vertices;
  }
  nearestPoint(A) {
    let nearest;
    let dist = Infinity;
    let d;
    let p;
    for (const edge of this.edges) {
      p = edge.nearestPoint(A);
      d = Vec.Dist2(p, A);
      if (d < dist) {
        nearest = p;
        dist = d;
      }
    }
    if (!nearest) throw Error("nearest point not found");
    return nearest;
  }
  hitTestLineSegment(A, B) {
    return this.edges.some((edge) => edge.hitTestLineSegment(A, B));
  }
  getBounds() {
    return new Box(0, 0, this._w, this._h);
  }
  getLength() {
    const { _w: w, _h: h2 } = this;
    const cx = w / 2;
    const cy = h2 / 2;
    const rx = Math.max(0, cx);
    const ry = Math.max(0, cy);
    return perimeterOfEllipse(rx, ry);
  }
  getSvgPathData(first2 = false) {
    const { _w: w, _h: h2 } = this;
    const cx = w / 2;
    const cy = h2 / 2;
    const rx = Math.max(0, cx);
    const ry = Math.max(0, cy);
    return `${first2 ? `M${cx - rx},${cy}` : ``} a${rx},${ry},0,1,1,${rx * 2},0a${rx},${ry},0,1,1,-${rx * 2},0`;
  }
};

// ../node_modules/@tldraw/editor/dist-esm/lib/primitives/geometry/Point2d.mjs
var Point2d = class extends Geometry2d {
  constructor(config) {
    super({ ...config, isClosed: true, isFilled: true });
    __publicField(this, "_point");
    const { point } = config;
    this._point = point;
  }
  getVertices() {
    return [this._point];
  }
  nearestPoint() {
    return this._point;
  }
  hitTestLineSegment(A, B, margin) {
    return Vec.DistanceToLineSegment(A, B, this._point) < margin;
  }
  getSvgPathData() {
    const { _point: point } = this;
    return `M${point.toFixed()}`;
  }
};

// ../node_modules/@tldraw/editor/dist-esm/lib/primitives/geometry/Stadium2d.mjs
var Stadium2d = class extends Geometry2d {
  constructor(config) {
    super({ ...config, isClosed: true });
    __publicField(this, "_w");
    __publicField(this, "_h");
    __publicField(this, "_a");
    __publicField(this, "_b");
    __publicField(this, "_c");
    __publicField(this, "_d");
    this.config = config;
    const { width: w, height: h2 } = config;
    this._w = w;
    this._h = h2;
    if (h2 > w) {
      const r = w / 2;
      this._a = new Arc2d({
        start: new Vec(0, r),
        end: new Vec(w, r),
        center: new Vec(w / 2, r),
        sweepFlag: 1,
        largeArcFlag: 1
      });
      this._b = new Edge2d({ start: new Vec(w, r), end: new Vec(w, h2 - r) });
      this._c = new Arc2d({
        start: new Vec(w, h2 - r),
        end: new Vec(0, h2 - r),
        center: new Vec(w / 2, h2 - r),
        sweepFlag: 1,
        largeArcFlag: 1
      });
      this._d = new Edge2d({ start: new Vec(0, h2 - r), end: new Vec(0, r) });
    } else {
      const r = h2 / 2;
      this._a = new Arc2d({
        start: new Vec(r, h2),
        end: new Vec(r, 0),
        center: new Vec(r, r),
        sweepFlag: 1,
        largeArcFlag: 1
      });
      this._b = new Edge2d({ start: new Vec(r, 0), end: new Vec(w - r, 0) });
      this._c = new Arc2d({
        start: new Vec(w - r, 0),
        end: new Vec(w - r, h2),
        center: new Vec(w - r, r),
        sweepFlag: 1,
        largeArcFlag: 1
      });
      this._d = new Edge2d({ start: new Vec(w - r, h2), end: new Vec(r, h2) });
    }
  }
  nearestPoint(A) {
    let nearest;
    let dist = Infinity;
    let _d;
    let p;
    const { _a: a, _b: b, _c: c, _d: d } = this;
    for (const part of [a, b, c, d]) {
      p = part.nearestPoint(A);
      _d = Vec.Dist2(p, A);
      if (_d < dist) {
        nearest = p;
        dist = _d;
      }
    }
    if (!nearest) throw Error("nearest point not found");
    return nearest;
  }
  hitTestLineSegment(A, B) {
    const { _a: a, _b: b, _c: c, _d: d } = this;
    return [a, b, c, d].some((edge) => edge.hitTestLineSegment(A, B));
  }
  getVertices() {
    const { _a: a, _b: b, _c: c, _d: d } = this;
    return [a, b, c, d].reduce((a2, p) => {
      a2.push(...p.vertices);
      return a2;
    }, []);
  }
  getBounds() {
    return new Box(0, 0, this._w, this._h);
  }
  getLength() {
    const { _h: h2, _w: w } = this;
    if (h2 > w) return (PI * (w / 2) + (h2 - w)) * 2;
    else return (PI * (h2 / 2) + (w - h2)) * 2;
  }
  getSvgPathData() {
    const { _a: a, _b: b, _c: c, _d: d } = this;
    return [a, b, c, d].map((p, i) => p.getSvgPathData(i === 0)).join(" ") + " Z";
  }
};

// ../node_modules/@tldraw/editor/dist-esm/lib/utils/EditorAtom.mjs
var EditorAtom = class {
  constructor(name, getInitialState) {
    __publicField(this, "states", new WeakCache());
    this.name = name;
    this.getInitialState = getInitialState;
  }
  getAtom(editor) {
    return this.states.get(editor, () => atom(this.name, this.getInitialState(editor)));
  }
  get(editor) {
    return this.getAtom(editor).get();
  }
  update(editor, update) {
    return this.getAtom(editor).update(update);
  }
  set(editor, state) {
    return this.getAtom(editor).set(state);
  }
};

// ../node_modules/@tldraw/editor/dist-esm/lib/utils/reparenting.mjs
function kickoutOccludedShapes(editor, shapeIds, opts) {
  var _a6;
  const parentsToCheck = /* @__PURE__ */ new Set();
  for (const id of shapeIds) {
    const shape = editor.getShape(id);
    if (!shape) continue;
    parentsToCheck.add(shape);
    const parent = editor.getShape(shape.parentId);
    if (!parent) continue;
    parentsToCheck.add(parent);
  }
  const parentsToLostChildren = /* @__PURE__ */ new Map();
  for (const parent of parentsToCheck) {
    const childIds = editor.getSortedChildIdsForParent(parent);
    if ((opts == null ? void 0 : opts.filter) && !opts.filter(parent)) {
      parentsToLostChildren.set(parent, childIds);
    } else {
      const overlappingChildren = getOverlappingShapes(editor, parent.id, childIds);
      if (overlappingChildren.length < childIds.length) {
        parentsToLostChildren.set(
          parent,
          childIds.filter((id) => !overlappingChildren.includes(id))
        );
      }
    }
  }
  const sortedShapeIds = editor.getCurrentPageShapesSorted().map((s) => s.id);
  const parentsToNewChildren = {};
  for (const [prevParent, lostChildrenIds] of parentsToLostChildren) {
    const lostChildren = compact(lostChildrenIds.map((id) => editor.getShape(id)));
    const { reparenting, remainingShapesToReparent } = getDroppedShapesToNewParents(
      editor,
      lostChildren,
      (shape, maybeNewParent) => {
        if ((opts == null ? void 0 : opts.filter) && !opts.filter(maybeNewParent)) return false;
        return maybeNewParent.id !== prevParent.id && sortedShapeIds.indexOf(maybeNewParent.id) < sortedShapeIds.indexOf(shape.id);
      }
    );
    reparenting.forEach((childrenToReparent, newParentId) => {
      if (childrenToReparent.length === 0) return;
      if (!parentsToNewChildren[newParentId]) {
        parentsToNewChildren[newParentId] = {
          parentId: newParentId,
          shapeIds: []
        };
      }
      parentsToNewChildren[newParentId].shapeIds.push(...childrenToReparent.map((s) => s.id));
    });
    if (remainingShapesToReparent.size > 0) {
      const newParentId = ((_a6 = editor.findShapeAncestor(prevParent, (s) => editor.isShapeOfType(s, "group"))) == null ? void 0 : _a6.id) ?? editor.getCurrentPageId();
      remainingShapesToReparent.forEach((shape) => {
        if (!parentsToNewChildren[newParentId]) {
          let insertIndexKey;
          const oldParentSiblingIds = editor.getSortedChildIdsForParent(newParentId);
          const oldParentIndex = oldParentSiblingIds.indexOf(prevParent.id);
          if (oldParentIndex > -1) {
            const siblingsIndexAbove = oldParentSiblingIds[oldParentIndex + 1];
            const indexKeyAbove = siblingsIndexAbove ? editor.getShape(siblingsIndexAbove).index : getIndexAbove(prevParent.index);
            insertIndexKey = getIndexBetween(prevParent.index, indexKeyAbove);
          } else {
          }
          parentsToNewChildren[newParentId] = {
            parentId: newParentId,
            shapeIds: [],
            index: insertIndexKey
          };
        }
        parentsToNewChildren[newParentId].shapeIds.push(shape.id);
      });
    }
  }
  editor.run(() => {
    Object.values(parentsToNewChildren).forEach(({ parentId, shapeIds: shapeIds2, index: index2 }) => {
      if (shapeIds2.length === 0) return;
      shapeIds2.sort((a, b) => sortedShapeIds.indexOf(a) < sortedShapeIds.indexOf(b) ? -1 : 1);
      editor.reparentShapes(shapeIds2, parentId, index2);
    });
  });
}
function getOverlappingShapes(editor, shape, otherShapes) {
  var _a6, _b3;
  if (otherShapes.length === 0) {
    return EMPTY_ARRAY;
  }
  const parentPageBounds = editor.getShapePageBounds(shape);
  if (!parentPageBounds) return EMPTY_ARRAY;
  const parentGeometry = editor.getShapeGeometry(shape);
  const parentPageTransform = editor.getShapePageTransform(shape);
  const parentPageCorners = parentPageTransform.applyToPoints(parentGeometry.vertices);
  const _shape = editor.getShape(shape);
  if (!_shape) return EMPTY_ARRAY;
  const pageTransform = editor.getShapePageTransform(shape);
  const clipPath = (_b3 = (_a6 = editor.getShapeUtil(_shape.type)).getClipPath) == null ? void 0 : _b3.call(_a6, _shape);
  const parentPageMaskVertices = clipPath ? pageTransform.applyToPoints(clipPath) : void 0;
  const parentPagePolygon = parentPageMaskVertices ? intersectPolygonPolygon(parentPageMaskVertices, parentPageCorners) : parentPageCorners;
  if (!parentPagePolygon) return EMPTY_ARRAY;
  return otherShapes.filter((childId) => {
    const shapePageBounds = editor.getShapePageBounds(childId);
    if (!shapePageBounds || !parentPageBounds.includes(shapePageBounds)) return false;
    const parentPolygonInShapeShape = editor.getShapePageTransform(childId).clone().invert().applyToPoints(parentPagePolygon);
    const geometry = editor.getShapeGeometry(childId);
    return geometry.overlapsPolygon(parentPolygonInShapeShape);
  });
}
function getDroppedShapesToNewParents(editor, shapes, cb) {
  var _a6, _b3, _c, _d;
  const shapesToActuallyCheck = new Set(shapes);
  const movingGroups = /* @__PURE__ */ new Set();
  for (const shape of shapes) {
    const parent = editor.getShapeParent(shape);
    if (parent && editor.isShapeOfType(parent, "group")) {
      if (!movingGroups.has(parent)) {
        movingGroups.add(parent);
      }
    }
  }
  for (const movingGroup of movingGroups) {
    const children = compact(
      editor.getSortedChildIdsForParent(movingGroup).map((id) => editor.getShape(id))
    );
    for (const child of children) {
      shapesToActuallyCheck.delete(child);
    }
    shapesToActuallyCheck.add(movingGroup);
  }
  const shapeGroupIds = /* @__PURE__ */ new Map();
  const reparenting = /* @__PURE__ */ new Map();
  const remainingShapesToReparent = new Set(shapesToActuallyCheck);
  const potentialParentShapes = editor.getCurrentPageShapesSorted().filter(
    (s) => {
      var _a7, _b4;
      return ((_b4 = (_a7 = editor.getShapeUtil(s)).canReceiveNewChildrenOfType) == null ? void 0 : _b4.call(_a7, s, s.type)) && !remainingShapesToReparent.has(s);
    }
  );
  parentCheck: for (let i = potentialParentShapes.length - 1; i >= 0; i--) {
    const parentShape = potentialParentShapes[i];
    const parentShapeContainingGroupId = (_a6 = editor.findShapeAncestor(
      parentShape,
      (s) => editor.isShapeOfType(s, "group")
    )) == null ? void 0 : _a6.id;
    const parentGeometry = editor.getShapeGeometry(parentShape);
    const parentPageTransform = editor.getShapePageTransform(parentShape);
    const parentPageMaskVertices = editor.getShapeMask(parentShape);
    const parentPageCorners = parentPageTransform.applyToPoints(parentGeometry.vertices);
    const parentPagePolygon = parentPageMaskVertices ? intersectPolygonPolygon(parentPageMaskVertices, parentPageCorners) : parentPageCorners;
    if (!parentPagePolygon) continue parentCheck;
    const childrenToReparent = [];
    shapeCheck: for (const shape of remainingShapesToReparent) {
      if (parentShape.id === shape.id) continue shapeCheck;
      if (cb && !cb(shape, parentShape)) continue shapeCheck;
      if (!shapeGroupIds.has(shape.id)) {
        shapeGroupIds.set(
          shape.id,
          (_b3 = editor.findShapeAncestor(shape, (s) => editor.isShapeOfType(s, "group"))) == null ? void 0 : _b3.id
        );
      }
      const shapeGroupId = shapeGroupIds.get(shape.id);
      if (shapeGroupId !== parentShapeContainingGroupId) continue shapeCheck;
      if (editor.findShapeAncestor(parentShape, (s) => shape.id === s.id)) continue shapeCheck;
      const parentPolygonInShapeSpace = editor.getShapePageTransform(shape).clone().invert().applyToPoints(parentPagePolygon);
      if (editor.getShapeGeometry(shape).overlapsPolygon(parentPolygonInShapeSpace)) {
        if (!((_d = (_c = editor.getShapeUtil(parentShape)).canReceiveNewChildrenOfType) == null ? void 0 : _d.call(_c, parentShape, shape.type)))
          continue shapeCheck;
        if (shape.parentId !== parentShape.id) {
          childrenToReparent.push(shape);
        }
        remainingShapesToReparent.delete(shape);
        continue shapeCheck;
      }
    }
    if (childrenToReparent.length) {
      reparenting.set(parentShape.id, childrenToReparent);
    }
  }
  return {
    // these are the shapes that will be reparented to new parents
    reparenting,
    // these are the shapes that will be reparented to the page or their ancestral group
    remainingShapesToReparent
  };
}

// ../node_modules/orderedmap/dist/index.js
function OrderedMap(content) {
  this.content = content;
}
OrderedMap.prototype = {
  constructor: OrderedMap,
  find: function(key) {
    for (var i = 0; i < this.content.length; i += 2)
      if (this.content[i] === key) return i;
    return -1;
  },
  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(key) {
    var found2 = this.find(key);
    return found2 == -1 ? void 0 : this.content[found2 + 1];
  },
  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(key, value, newKey) {
    var self2 = newKey && newKey != key ? this.remove(newKey) : this;
    var found2 = self2.find(key), content = self2.content.slice();
    if (found2 == -1) {
      content.push(newKey || key, value);
    } else {
      content[found2 + 1] = value;
      if (newKey) content[found2] = newKey;
    }
    return new OrderedMap(content);
  },
  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(key) {
    var found2 = this.find(key);
    if (found2 == -1) return this;
    var content = this.content.slice();
    content.splice(found2, 2);
    return new OrderedMap(content);
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(key, value) {
    return new OrderedMap([key, value].concat(this.remove(key).content));
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(key, value) {
    var content = this.remove(key).content.slice();
    content.push(key, value);
    return new OrderedMap(content);
  },
  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(place, key, value) {
    var without = this.remove(key), content = without.content.slice();
    var found2 = without.find(place);
    content.splice(found2 == -1 ? content.length : found2, 0, key, value);
    return new OrderedMap(content);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(f) {
    for (var i = 0; i < this.content.length; i += 2)
      f(this.content[i], this.content[i + 1]);
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(map2) {
    map2 = OrderedMap.from(map2);
    if (!map2.size) return this;
    return new OrderedMap(map2.content.concat(this.subtract(map2).content));
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(map2) {
    map2 = OrderedMap.from(map2);
    if (!map2.size) return this;
    return new OrderedMap(this.subtract(map2).content.concat(map2.content));
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(map2) {
    var result = this;
    map2 = OrderedMap.from(map2);
    for (var i = 0; i < map2.content.length; i += 2)
      result = result.remove(map2.content[i]);
    return result;
  },
  // :: () → Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var result = {};
    this.forEach(function(key, value) {
      result[key] = value;
    });
    return result;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
OrderedMap.from = function(value) {
  if (value instanceof OrderedMap) return value;
  var content = [];
  if (value) for (var prop in value) content.push(prop, value[prop]);
  return new OrderedMap(content);
};
var dist_default = OrderedMap;

// ../node_modules/prosemirror-model/dist/index.js
function findDiffStart(a, b, pos) {
  for (let i = 0; ; i++) {
    if (i == a.childCount || i == b.childCount)
      return a.childCount == b.childCount ? null : pos;
    let childA = a.child(i), childB = b.child(i);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return pos;
    if (childA.isText && childA.text != childB.text) {
      for (let j = 0; childA.text[j] == childB.text[j]; j++)
        pos++;
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffStart(childA.content, childB.content, pos + 1);
      if (inner != null)
        return inner;
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd(a, b, posA, posB) {
  for (let iA = a.childCount, iB = b.childCount; ; ) {
    if (iA == 0 || iB == 0)
      return iA == iB ? null : { a: posA, b: posB };
    let childA = a.child(--iA), childB = b.child(--iB), size4 = childA.nodeSize;
    if (childA == childB) {
      posA -= size4;
      posB -= size4;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return { a: posA, b: posB };
    if (childA.isText && childA.text != childB.text) {
      let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner)
        return inner;
    }
    posA -= size4;
    posB -= size4;
  }
}
var Fragment12 = class _Fragment {
  /**
  @internal
  */
  constructor(content, size4) {
    this.content = content;
    this.size = size4 || 0;
    if (size4 == null)
      for (let i = 0; i < content.length; i++)
        this.size += content[i].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(from2, to, f, nodeStart = 0, parent) {
    for (let i = 0, pos = 0; pos < to; i++) {
      let child = this.content[i], end = pos + child.nodeSize;
      if (end > from2 && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {
        let start = pos + 1;
        child.nodesBetween(Math.max(0, from2 - start), Math.min(child.content.size, to - start), f, nodeStart + start);
      }
      pos = end;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(f) {
    this.nodesBetween(0, this.size, f);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(from2, to, blockSeparator, leafText) {
    let text = "", first2 = true;
    this.nodesBetween(from2, to, (node, pos) => {
      let nodeText = node.isText ? node.text.slice(Math.max(from2, pos) - pos, to - pos) : !node.isLeaf ? "" : leafText ? typeof leafText === "function" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : "";
      if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {
        if (first2)
          first2 = false;
        else
          text += blockSeparator;
      }
      text += nodeText;
    }, 0);
    return text;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(other) {
    if (!other.size)
      return this;
    if (!this.size)
      return other;
    let last2 = this.lastChild, first2 = other.firstChild, content = this.content.slice(), i = 0;
    if (last2.isText && last2.sameMarkup(first2)) {
      content[content.length - 1] = last2.withText(last2.text + first2.text);
      i = 1;
    }
    for (; i < other.content.length; i++)
      content.push(other.content[i]);
    return new _Fragment(content, this.size + other.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(from2, to = this.size) {
    if (from2 == 0 && to == this.size)
      return this;
    let result = [], size4 = 0;
    if (to > from2)
      for (let i = 0, pos = 0; pos < to; i++) {
        let child = this.content[i], end = pos + child.nodeSize;
        if (end > from2) {
          if (pos < from2 || end > to) {
            if (child.isText)
              child = child.cut(Math.max(0, from2 - pos), Math.min(child.text.length, to - pos));
            else
              child = child.cut(Math.max(0, from2 - pos - 1), Math.min(child.content.size, to - pos - 1));
          }
          result.push(child);
          size4 += child.nodeSize;
        }
        pos = end;
      }
    return new _Fragment(result, size4);
  }
  /**
  @internal
  */
  cutByIndex(from2, to) {
    if (from2 == to)
      return _Fragment.empty;
    if (from2 == 0 && to == this.content.length)
      return this;
    return new _Fragment(this.content.slice(from2, to));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(index2, node) {
    let current = this.content[index2];
    if (current == node)
      return this;
    let copy2 = this.content.slice();
    let size4 = this.size + node.nodeSize - current.nodeSize;
    copy2[index2] = node;
    return new _Fragment(copy2, size4);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(node) {
    return new _Fragment([node].concat(this.content), this.size + node.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(node) {
    return new _Fragment(this.content.concat(node), this.size + node.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(other) {
    if (this.content.length != other.content.length)
      return false;
    for (let i = 0; i < this.content.length; i++)
      if (!this.content[i].eq(other.content[i]))
        return false;
    return true;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(index2) {
    let found2 = this.content[index2];
    if (!found2)
      throw new RangeError("Index " + index2 + " out of range for " + this);
    return found2;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(index2) {
    return this.content[index2] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(f) {
    for (let i = 0, p = 0; i < this.content.length; i++) {
      let child = this.content[i];
      f(child, p, i);
      p += child.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(other, pos = 0) {
    return findDiffStart(this, other, pos);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(other, pos = this.size, otherPos = other.size) {
    return findDiffEnd(this, other, pos, otherPos);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(pos) {
    if (pos == 0)
      return retIndex(0, pos);
    if (pos == this.size)
      return retIndex(this.content.length, pos);
    if (pos > this.size || pos < 0)
      throw new RangeError(`Position ${pos} outside of fragment (${this})`);
    for (let i = 0, curPos = 0; ; i++) {
      let cur = this.child(i), end = curPos + cur.nodeSize;
      if (end >= pos) {
        if (end == pos)
          return retIndex(i + 1, end);
        return retIndex(i, curPos);
      }
      curPos = end;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((n) => n.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(schema, value) {
    if (!value)
      return _Fragment.empty;
    if (!Array.isArray(value))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new _Fragment(value.map(schema.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(array) {
    if (!array.length)
      return _Fragment.empty;
    let joined, size4 = 0;
    for (let i = 0; i < array.length; i++) {
      let node = array[i];
      size4 += node.nodeSize;
      if (i && node.isText && array[i - 1].sameMarkup(node)) {
        if (!joined)
          joined = array.slice(0, i);
        joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
      } else if (joined) {
        joined.push(node);
      }
    }
    return new _Fragment(joined || array, size4);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(nodes) {
    if (!nodes)
      return _Fragment.empty;
    if (nodes instanceof _Fragment)
      return nodes;
    if (Array.isArray(nodes))
      return this.fromArray(nodes);
    if (nodes.attrs)
      return new _Fragment([nodes], nodes.nodeSize);
    throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
};
Fragment12.empty = new Fragment12([], 0);
var found = { index: 0, offset: 0 };
function retIndex(index2, offset4) {
  found.index = index2;
  found.offset = offset4;
  return found;
}
function compareDeep(a, b) {
  if (a === b)
    return true;
  if (!(a && typeof a == "object") || !(b && typeof b == "object"))
    return false;
  let array = Array.isArray(a);
  if (Array.isArray(b) != array)
    return false;
  if (array) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!compareDeep(a[i], b[i]))
        return false;
  } else {
    for (let p in a)
      if (!(p in b) || !compareDeep(a[p], b[p]))
        return false;
    for (let p in b)
      if (!(p in a))
        return false;
  }
  return true;
}
var Mark = class _Mark2 {
  /**
  @internal
  */
  constructor(type, attrs) {
    this.type = type;
    this.attrs = attrs;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(set) {
    let copy2, placed = false;
    for (let i = 0; i < set.length; i++) {
      let other = set[i];
      if (this.eq(other))
        return set;
      if (this.type.excludes(other.type)) {
        if (!copy2)
          copy2 = set.slice(0, i);
      } else if (other.type.excludes(this.type)) {
        return set;
      } else {
        if (!placed && other.type.rank > this.type.rank) {
          if (!copy2)
            copy2 = set.slice(0, i);
          copy2.push(this);
          placed = true;
        }
        if (copy2)
          copy2.push(other);
      }
    }
    if (!copy2)
      copy2 = set.slice();
    if (!placed)
      copy2.push(this);
    return copy2;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(set) {
    for (let i = 0; i < set.length; i++)
      if (this.eq(set[i]))
        return set.slice(0, i).concat(set.slice(i + 1));
    return set;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(set) {
    for (let i = 0; i < set.length; i++)
      if (this.eq(set[i]))
        return true;
    return false;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(other) {
    return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let obj = { type: this.type.name };
    for (let _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    return obj;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let type = schema.marks[json.type];
    if (!type)
      throw new RangeError(`There is no mark type ${json.type} in this schema`);
    let mark = type.create(json.attrs);
    type.checkAttrs(mark.attrs);
    return mark;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(a, b) {
    if (a == b)
      return true;
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!a[i].eq(b[i]))
        return false;
    return true;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(marks) {
    if (!marks || Array.isArray(marks) && marks.length == 0)
      return _Mark2.none;
    if (marks instanceof _Mark2)
      return [marks];
    let copy2 = marks.slice();
    copy2.sort((a, b) => a.type.rank - b.type.rank);
    return copy2;
  }
};
Mark.none = [];
var ReplaceError = class extends Error {
};
var Slice = class _Slice {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(content, openStart, openEnd) {
    this.content = content;
    this.openStart = openStart;
    this.openEnd = openEnd;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(pos, fragment) {
    let content = insertInto(this.content, pos + this.openStart, fragment);
    return content && new _Slice(content, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(from2, to) {
    return new _Slice(removeRange(this.content, from2 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(other) {
    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let json = { content: this.content.toJSON() };
    if (this.openStart > 0)
      json.openStart = this.openStart;
    if (this.openEnd > 0)
      json.openEnd = this.openEnd;
    return json;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(schema, json) {
    if (!json)
      return _Slice.empty;
    let openStart = json.openStart || 0, openEnd = json.openEnd || 0;
    if (typeof openStart != "number" || typeof openEnd != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new _Slice(Fragment12.fromJSON(schema, json.content), openStart, openEnd);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(fragment, openIsolating = true) {
    let openStart = 0, openEnd = 0;
    for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)
      openStart++;
    for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)
      openEnd++;
    return new _Slice(fragment, openStart, openEnd);
  }
};
Slice.empty = new Slice(Fragment12.empty, 0, 0);
function removeRange(content, from2, to) {
  let { index: index2, offset: offset4 } = content.findIndex(from2), child = content.maybeChild(index2);
  let { index: indexTo, offset: offsetTo } = content.findIndex(to);
  if (offset4 == from2 || child.isText) {
    if (offsetTo != to && !content.child(indexTo).isText)
      throw new RangeError("Removing non-flat range");
    return content.cut(0, from2).append(content.cut(to));
  }
  if (index2 != indexTo)
    throw new RangeError("Removing non-flat range");
  return content.replaceChild(index2, child.copy(removeRange(child.content, from2 - offset4 - 1, to - offset4 - 1)));
}
function insertInto(content, dist, insert, parent) {
  let { index: index2, offset: offset4 } = content.findIndex(dist), child = content.maybeChild(index2);
  if (offset4 == dist || child.isText) {
    if (parent && !parent.canReplace(index2, index2, insert))
      return null;
    return content.cut(0, dist).append(insert).append(content.cut(dist));
  }
  let inner = insertInto(child.content, dist - offset4 - 1, insert, child);
  return inner && content.replaceChild(index2, child.copy(inner));
}
function replace2($from, $to, slice2) {
  if (slice2.openStart > $from.depth)
    throw new ReplaceError("Inserted content deeper than insertion position");
  if ($from.depth - slice2.openStart != $to.depth - slice2.openEnd)
    throw new ReplaceError("Inconsistent open depths");
  return replaceOuter($from, $to, slice2, 0);
}
function replaceOuter($from, $to, slice2, depth) {
  let index2 = $from.index(depth), node = $from.node(depth);
  if (index2 == $to.index(depth) && depth < $from.depth - slice2.openStart) {
    let inner = replaceOuter($from, $to, slice2, depth + 1);
    return node.copy(node.content.replaceChild(index2, inner));
  } else if (!slice2.content.size) {
    return close(node, replaceTwoWay($from, $to, depth));
  } else if (!slice2.openStart && !slice2.openEnd && $from.depth == depth && $to.depth == depth) {
    let parent = $from.parent, content = parent.content;
    return close(parent, content.cut(0, $from.parentOffset).append(slice2.content).append(content.cut($to.parentOffset)));
  } else {
    let { start, end } = prepareSliceForReplace(slice2, $from);
    return close(node, replaceThreeWay($from, start, end, $to, depth));
  }
}
function checkJoin(main, sub) {
  if (!sub.type.compatibleContent(main.type))
    throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name);
}
function joinable($before, $after, depth) {
  let node = $before.node(depth);
  checkJoin(node, $after.node(depth));
  return node;
}
function addNode(child, target) {
  let last2 = target.length - 1;
  if (last2 >= 0 && child.isText && child.sameMarkup(target[last2]))
    target[last2] = child.withText(target[last2].text + child.text);
  else
    target.push(child);
}
function addRange($start, $end, depth, target) {
  let node = ($end || $start).node(depth);
  let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (let i = startIndex; i < endIndex; i++)
    addNode(node.child(i), target);
  if ($end && $end.depth == depth && $end.textOffset)
    addNode($end.nodeBefore, target);
}
function close(node, content) {
  node.type.checkContent(content);
  return node.copy(content);
}
function replaceThreeWay($from, $start, $end, $to, depth) {
  let openStart = $from.depth > depth && joinable($from, $start, depth + 1);
  let openEnd = $to.depth > depth && joinable($end, $to, depth + 1);
  let content = [];
  addRange(null, $from, depth, content);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
  } else {
    if (openStart)
      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
    addRange($start, $end, depth, content);
    if (openEnd)
      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment12(content);
}
function replaceTwoWay($from, $to, depth) {
  let content = [];
  addRange(null, $from, depth, content);
  if ($from.depth > depth) {
    let type = joinable($from, $to, depth + 1);
    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment12(content);
}
function prepareSliceForReplace(slice2, $along) {
  let extra = $along.depth - slice2.openStart, parent = $along.node(extra);
  let node = parent.copy(slice2.content);
  for (let i = extra - 1; i >= 0; i--)
    node = $along.node(i).copy(Fragment12.from(node));
  return {
    start: node.resolveNoCache(slice2.openStart + extra),
    end: node.resolveNoCache(node.content.size - slice2.openEnd - extra)
  };
}
var ResolvedPos = class _ResolvedPos {
  /**
  @internal
  */
  constructor(pos, path, parentOffset) {
    this.pos = pos;
    this.path = path;
    this.parentOffset = parentOffset;
    this.depth = path.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(val) {
    if (val == null)
      return this.depth;
    if (val < 0)
      return this.depth + val;
    return val;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parent—text nodes are ‘flat’ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(depth) {
    return this.path[this.resolveDepth(depth) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(depth) {
    return this.path[this.resolveDepth(depth) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(depth) {
    depth = this.resolveDepth(depth);
    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(depth) {
    depth = this.resolveDepth(depth);
    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(depth) {
    depth = this.resolveDepth(depth);
    return this.start(depth) + this.node(depth).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position before the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position after the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let parent = this.parent, index2 = this.index(this.depth);
    if (index2 == parent.childCount)
      return null;
    let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index2);
    return dOff ? parent.child(index2).cut(dOff) : child;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let index2 = this.index(this.depth);
    let dOff = this.pos - this.path[this.path.length - 1];
    if (dOff)
      return this.parent.child(index2).cut(0, dOff);
    return index2 == 0 ? null : this.parent.child(index2 - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(index2, depth) {
    depth = this.resolveDepth(depth);
    let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    for (let i = 0; i < index2; i++)
      pos += node.child(i).nodeSize;
    return pos;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let parent = this.parent, index2 = this.index();
    if (parent.content.size == 0)
      return Mark.none;
    if (this.textOffset)
      return parent.child(index2).marks;
    let main = parent.maybeChild(index2 - 1), other = parent.maybeChild(index2);
    if (!main) {
      let tmp = main;
      main = other;
      other = tmp;
    }
    let marks = main.marks;
    for (var i = 0; i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))
        marks = marks[i--].removeFromSet(marks);
    return marks;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross($end) {
    let after = this.parent.maybeChild(this.index());
    if (!after || !after.isInline)
      return null;
    let marks = after.marks, next = $end.parent.maybeChild($end.index());
    for (var i = 0; i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))
        marks = marks[i--].removeFromSet(marks);
    return marks;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(pos) {
    for (let depth = this.depth; depth > 0; depth--)
      if (this.start(depth) <= pos && this.end(depth) >= pos)
        return depth;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(other = this, pred) {
    if (other.pos < this.pos)
      return other.blockRange(this);
    for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)
      if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
        return new NodeRange(this, other, d);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(other) {
    return this.pos - this.parentOffset == other.pos - other.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(other) {
    return other.pos > this.pos ? other : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(other) {
    return other.pos < this.pos ? other : this;
  }
  /**
  @internal
  */
  toString() {
    let str = "";
    for (let i = 1; i <= this.depth; i++)
      str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
    return str + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(doc3, pos) {
    if (!(pos >= 0 && pos <= doc3.content.size))
      throw new RangeError("Position " + pos + " out of range");
    let path = [];
    let start = 0, parentOffset = pos;
    for (let node = doc3; ; ) {
      let { index: index2, offset: offset4 } = node.content.findIndex(parentOffset);
      let rem = parentOffset - offset4;
      path.push(node, index2, start + offset4);
      if (!rem)
        break;
      node = node.child(index2);
      if (node.isText)
        break;
      parentOffset = rem - 1;
      start += offset4 + 1;
    }
    return new _ResolvedPos(pos, path, parentOffset);
  }
  /**
  @internal
  */
  static resolveCached(doc3, pos) {
    let cache = resolveCache.get(doc3);
    if (cache) {
      for (let i = 0; i < cache.elts.length; i++) {
        let elt = cache.elts[i];
        if (elt.pos == pos)
          return elt;
      }
    } else {
      resolveCache.set(doc3, cache = new ResolveCache());
    }
    let result = cache.elts[cache.i] = _ResolvedPos.resolve(doc3, pos);
    cache.i = (cache.i + 1) % resolveCacheSize;
    return result;
  }
};
var ResolveCache = class {
  constructor() {
    this.elts = [];
    this.i = 0;
  }
};
var resolveCacheSize = 12;
var resolveCache = /* @__PURE__ */ new WeakMap();
var NodeRange = class {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor($from, $to, depth) {
    this.$from = $from;
    this.$to = $to;
    this.depth = depth;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
};
var emptyAttrs = /* @__PURE__ */ Object.create(null);
var Node2 = class _Node2 {
  /**
  @internal
  */
  constructor(type, attrs, content, marks = Mark.none) {
    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.content = content || Fragment12.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(index2) {
    return this.content.child(index2);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(index2) {
    return this.content.maybeChild(index2);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(f) {
    this.content.forEach(f);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(from2, to, f, startPos = 0) {
    this.content.nodesBetween(from2, to, f, startPos, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(f) {
    this.nodesBetween(0, this.content.size, f);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec.leafText) will be used.
  */
  textBetween(from2, to, blockSeparator, leafText) {
    return this.content.textBetween(from2, to, blockSeparator, leafText);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(other) {
    return this == other || this.sameMarkup(other) && this.content.eq(other.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(other) {
    return this.hasMarkup(other.type, other.attrs, other.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(type, attrs, marks) {
    return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(content = null) {
    if (content == this.content)
      return this;
    return new _Node2(this.type, this.attrs, content, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(marks) {
    return marks == this.marks ? this : new _Node2(this.type, this.attrs, this.content, marks);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(from2, to = this.content.size) {
    if (from2 == 0 && to == this.content.size)
      return this;
    return this.copy(this.content.cut(from2, to));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(from2, to = this.content.size, includeParents = false) {
    if (from2 == to)
      return Slice.empty;
    let $from = this.resolve(from2), $to = this.resolve(to);
    let depth = includeParents ? 0 : $from.sharedDepth(to);
    let start = $from.start(depth), node = $from.node(depth);
    let content = node.content.cut($from.pos - start, $to.pos - start);
    return new Slice(content, $from.depth - depth, $to.depth - depth);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(from2, to, slice2) {
    return replace2(this.resolve(from2), this.resolve(to), slice2);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(pos) {
    for (let node = this; ; ) {
      let { index: index2, offset: offset4 } = node.content.findIndex(pos);
      node = node.maybeChild(index2);
      if (!node)
        return null;
      if (offset4 == pos || node.isText)
        return node;
      pos -= offset4 + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(pos) {
    let { index: index2, offset: offset4 } = this.content.findIndex(pos);
    return { node: this.content.maybeChild(index2), index: index2, offset: offset4 };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(pos) {
    if (pos == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: index2, offset: offset4 } = this.content.findIndex(pos);
    if (offset4 < pos)
      return { node: this.content.child(index2), index: index2, offset: offset4 };
    let node = this.content.child(index2 - 1);
    return { node, index: index2 - 1, offset: offset4 - node.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(pos) {
    return ResolvedPos.resolveCached(this, pos);
  }
  /**
  @internal
  */
  resolveNoCache(pos) {
    return ResolvedPos.resolve(this, pos);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(from2, to, type) {
    let found2 = false;
    if (to > from2)
      this.nodesBetween(from2, to, (node) => {
        if (type.isInSet(node.marks))
          found2 = true;
        return !found2;
      });
    return found2;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let name = this.type.name;
    if (this.content.size)
      name += "(" + this.content.toStringInner() + ")";
    return wrapMarks(this.marks, name);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(index2) {
    let match = this.type.contentMatch.matchFragment(this.content, 0, index2);
    if (!match)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return match;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(from2, to, replacement = Fragment12.empty, start = 0, end = replacement.childCount) {
    let one = this.contentMatchAt(from2).matchFragment(replacement, start, end);
    let two = one && one.matchFragment(this.content, to);
    if (!two || !two.validEnd)
      return false;
    for (let i = start; i < end; i++)
      if (!this.type.allowsMarks(replacement.child(i).marks))
        return false;
    return true;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(from2, to, type, marks) {
    if (marks && !this.type.allowsMarks(marks))
      return false;
    let start = this.contentMatchAt(from2).matchType(type);
    let end = start && start.matchFragment(this.content, to);
    return end ? end.validEnd : false;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(other) {
    if (other.content.size)
      return this.canReplace(this.childCount, this.childCount, other.content);
    else
      return this.type.compatibleContent(other.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content);
    this.type.checkAttrs(this.attrs);
    let copy2 = Mark.none;
    for (let i = 0; i < this.marks.length; i++) {
      let mark = this.marks[i];
      mark.type.checkAttrs(mark.attrs);
      copy2 = mark.addToSet(copy2);
    }
    if (!Mark.sameSet(copy2, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m) => m.type.name)}`);
    this.content.forEach((node) => node.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let obj = { type: this.type.name };
    for (let _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    if (this.content.size)
      obj.content = this.content.toJSON();
    if (this.marks.length)
      obj.marks = this.marks.map((n) => n.toJSON());
    return obj;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Node.fromJSON");
    let marks = void 0;
    if (json.marks) {
      if (!Array.isArray(json.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      marks = json.marks.map(schema.markFromJSON);
    }
    if (json.type == "text") {
      if (typeof json.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return schema.text(json.text, marks);
    }
    let content = Fragment12.fromJSON(schema, json.content);
    let node = schema.nodeType(json.type).create(json.attrs, content, marks);
    node.type.checkAttrs(node.attrs);
    return node;
  }
};
Node2.prototype.text = void 0;
var TextNode = class _TextNode extends Node2 {
  /**
  @internal
  */
  constructor(type, attrs, content, marks) {
    super(type, attrs, null, marks);
    if (!content)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = content;
  }
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    return wrapMarks(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(from2, to) {
    return this.text.slice(from2, to);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(marks) {
    return marks == this.marks ? this : new _TextNode(this.type, this.attrs, this.text, marks);
  }
  withText(text) {
    if (text == this.text)
      return this;
    return new _TextNode(this.type, this.attrs, text, this.marks);
  }
  cut(from2 = 0, to = this.text.length) {
    if (from2 == 0 && to == this.text.length)
      return this;
    return this.withText(this.text.slice(from2, to));
  }
  eq(other) {
    return this.sameMarkup(other) && this.text == other.text;
  }
  toJSON() {
    let base2 = super.toJSON();
    base2.text = this.text;
    return base2;
  }
};
function wrapMarks(marks, str) {
  for (let i = marks.length - 1; i >= 0; i--)
    str = marks[i].type.name + "(" + str + ")";
  return str;
}
var ContentMatch = class _ContentMatch {
  /**
  @internal
  */
  constructor(validEnd) {
    this.validEnd = validEnd;
    this.next = [];
    this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(string, nodeTypes) {
    let stream = new TokenStream(string, nodeTypes);
    if (stream.next == null)
      return _ContentMatch.empty;
    let expr = parseExpr(stream);
    if (stream.next)
      stream.err("Unexpected trailing text");
    let match = dfa(nfa(expr));
    checkForDeadEnds(match, stream);
    return match;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(type) {
    for (let i = 0; i < this.next.length; i++)
      if (this.next[i].type == type)
        return this.next[i].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(frag, start = 0, end = frag.childCount) {
    let cur = this;
    for (let i = start; cur && i < end; i++)
      cur = cur.matchType(frag.child(i).type);
    return cur;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let i = 0; i < this.next.length; i++) {
      let { type } = this.next[i];
      if (!(type.isText || type.hasRequiredAttrs()))
        return type;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(other) {
    for (let i = 0; i < this.next.length; i++)
      for (let j = 0; j < other.next.length; j++)
        if (this.next[i].type == other.next[j].type)
          return true;
    return false;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(after, toEnd = false, startIndex = 0) {
    let seen = [this];
    function search(match, types) {
      let finished = match.matchFragment(after, startIndex);
      if (finished && (!toEnd || finished.validEnd))
        return Fragment12.from(types.map((tp) => tp.createAndFill()));
      for (let i = 0; i < match.next.length; i++) {
        let { type, next } = match.next[i];
        if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
          seen.push(next);
          let found2 = search(next, types.concat(type));
          if (found2)
            return found2;
        }
      }
      return null;
    }
    return search(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(target) {
    for (let i = 0; i < this.wrapCache.length; i += 2)
      if (this.wrapCache[i] == target)
        return this.wrapCache[i + 1];
    let computed2 = this.computeWrapping(target);
    this.wrapCache.push(target, computed2);
    return computed2;
  }
  /**
  @internal
  */
  computeWrapping(target) {
    let seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
    while (active.length) {
      let current = active.shift(), match = current.match;
      if (match.matchType(target)) {
        let result = [];
        for (let obj = current; obj.type; obj = obj.via)
          result.push(obj.type);
        return result.reverse();
      }
      for (let i = 0; i < match.next.length; i++) {
        let { type, next } = match.next[i];
        if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {
          active.push({ match: type.contentMatch, type, via: current });
          seen[type.name] = true;
        }
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_​th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(n) {
    if (n >= this.next.length)
      throw new RangeError(`There's no ${n}th edge in this content match`);
    return this.next[n];
  }
  /**
  @internal
  */
  toString() {
    let seen = [];
    function scan(m) {
      seen.push(m);
      for (let i = 0; i < m.next.length; i++)
        if (seen.indexOf(m.next[i].next) == -1)
          scan(m.next[i].next);
    }
    scan(this);
    return seen.map((m, i) => {
      let out = i + (m.validEnd ? "*" : " ") + " ";
      for (let i2 = 0; i2 < m.next.length; i2++)
        out += (i2 ? ", " : "") + m.next[i2].type.name + "->" + seen.indexOf(m.next[i2].next);
      return out;
    }).join("\n");
  }
};
ContentMatch.empty = new ContentMatch(true);
var TokenStream = class {
  constructor(string, nodeTypes) {
    this.string = string;
    this.nodeTypes = nodeTypes;
    this.inline = null;
    this.pos = 0;
    this.tokens = string.split(/\s*(?=\b|\W|$)/);
    if (this.tokens[this.tokens.length - 1] == "")
      this.tokens.pop();
    if (this.tokens[0] == "")
      this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(tok) {
    return this.next == tok && (this.pos++ || true);
  }
  err(str) {
    throw new SyntaxError(str + " (in content expression '" + this.string + "')");
  }
};
function parseExpr(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSeq(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSubscript(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript(stream) {
  let expr = parseExprAtom(stream);
  for (; ; ) {
    if (stream.eat("+"))
      expr = { type: "plus", expr };
    else if (stream.eat("*"))
      expr = { type: "star", expr };
    else if (stream.eat("?"))
      expr = { type: "opt", expr };
    else if (stream.eat("{"))
      expr = parseExprRange(stream, expr);
    else
      break;
  }
  return expr;
}
function parseNum(stream) {
  if (/\D/.test(stream.next))
    stream.err("Expected number, got '" + stream.next + "'");
  let result = Number(stream.next);
  stream.pos++;
  return result;
}
function parseExprRange(stream, expr) {
  let min3 = parseNum(stream), max2 = min3;
  if (stream.eat(",")) {
    if (stream.next != "}")
      max2 = parseNum(stream);
    else
      max2 = -1;
  }
  if (!stream.eat("}"))
    stream.err("Unclosed braced range");
  return { type: "range", min: min3, max: max2, expr };
}
function resolveName(stream, name) {
  let types = stream.nodeTypes, type = types[name];
  if (type)
    return [type];
  let result = [];
  for (let typeName in types) {
    let type2 = types[typeName];
    if (type2.isInGroup(name))
      result.push(type2);
  }
  if (result.length == 0)
    stream.err("No node type or group '" + name + "' found");
  return result;
}
function parseExprAtom(stream) {
  if (stream.eat("(")) {
    let expr = parseExpr(stream);
    if (!stream.eat(")"))
      stream.err("Missing closing paren");
    return expr;
  } else if (!/\W/.test(stream.next)) {
    let exprs = resolveName(stream, stream.next).map((type) => {
      if (stream.inline == null)
        stream.inline = type.isInline;
      else if (stream.inline != type.isInline)
        stream.err("Mixing inline and block content");
      return { type: "name", value: type };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa(expr) {
  let nfa2 = [[]];
  connect(compile(expr, 0), node());
  return nfa2;
  function node() {
    return nfa2.push([]) - 1;
  }
  function edge(from2, to, term) {
    let edge2 = { term, to };
    nfa2[from2].push(edge2);
    return edge2;
  }
  function connect(edges, to) {
    edges.forEach((edge2) => edge2.to = to);
  }
  function compile(expr2, from2) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce((out, expr3) => out.concat(compile(expr3, from2)), []);
    } else if (expr2.type == "seq") {
      for (let i = 0; ; i++) {
        let next = compile(expr2.exprs[i], from2);
        if (i == expr2.exprs.length - 1)
          return next;
        connect(next, from2 = node());
      }
    } else if (expr2.type == "star") {
      let loop = node();
      edge(from2, loop);
      connect(compile(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "plus") {
      let loop = node();
      connect(compile(expr2.expr, from2), loop);
      connect(compile(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "opt") {
      return [edge(from2)].concat(compile(expr2.expr, from2));
    } else if (expr2.type == "range") {
      let cur = from2;
      for (let i = 0; i < expr2.min; i++) {
        let next = node();
        connect(compile(expr2.expr, cur), next);
        cur = next;
      }
      if (expr2.max == -1) {
        connect(compile(expr2.expr, cur), cur);
      } else {
        for (let i = expr2.min; i < expr2.max; i++) {
          let next = node();
          edge(cur, next);
          connect(compile(expr2.expr, cur), next);
          cur = next;
        }
      }
      return [edge(cur)];
    } else if (expr2.type == "name") {
      return [edge(from2, void 0, expr2.value)];
    } else {
      throw new Error("Unknown expr type");
    }
  }
}
function cmp(a, b) {
  return b - a;
}
function nullFrom(nfa2, node) {
  let result = [];
  scan(node);
  return result.sort(cmp);
  function scan(node2) {
    let edges = nfa2[node2];
    if (edges.length == 1 && !edges[0].term)
      return scan(edges[0].to);
    result.push(node2);
    for (let i = 0; i < edges.length; i++) {
      let { term, to } = edges[i];
      if (!term && result.indexOf(to) == -1)
        scan(to);
    }
  }
}
function dfa(nfa2) {
  let labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom(nfa2, 0));
  function explore(states) {
    let out = [];
    states.forEach((node) => {
      nfa2[node].forEach(({ term, to }) => {
        if (!term)
          return;
        let set;
        for (let i = 0; i < out.length; i++)
          if (out[i][0] == term)
            set = out[i][1];
        nullFrom(nfa2, to).forEach((node2) => {
          if (!set)
            out.push([term, set = []]);
          if (set.indexOf(node2) == -1)
            set.push(node2);
        });
      });
    });
    let state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
    for (let i = 0; i < out.length; i++) {
      let states2 = out[i][1].sort(cmp);
      state.next.push({ type: out[i][0], next: labeled[states2.join(",")] || explore(states2) });
    }
    return state;
  }
}
function checkForDeadEnds(match, stream) {
  for (let i = 0, work = [match]; i < work.length; i++) {
    let state = work[i], dead = !state.validEnd, nodes = [];
    for (let j = 0; j < state.next.length; j++) {
      let { type, next } = state.next[j];
      nodes.push(type.name);
      if (dead && !(type.isText || type.hasRequiredAttrs()))
        dead = false;
      if (work.indexOf(next) == -1)
        work.push(next);
    }
    if (dead)
      stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function defaultAttrs(attrs) {
  let defaults2 = /* @__PURE__ */ Object.create(null);
  for (let attrName in attrs) {
    let attr = attrs[attrName];
    if (!attr.hasDefault)
      return null;
    defaults2[attrName] = attr.default;
  }
  return defaults2;
}
function computeAttrs(attrs, value) {
  let built = /* @__PURE__ */ Object.create(null);
  for (let name in attrs) {
    let given = value && value[name];
    if (given === void 0) {
      let attr = attrs[name];
      if (attr.hasDefault)
        given = attr.default;
      else
        throw new RangeError("No value supplied for attribute " + name);
    }
    built[name] = given;
  }
  return built;
}
function checkAttrs(attrs, values, type, name) {
  for (let name2 in values)
    if (!(name2 in attrs))
      throw new RangeError(`Unsupported attribute ${name2} for ${type} of type ${name2}`);
  for (let name2 in attrs) {
    let attr = attrs[name2];
    if (attr.validate)
      attr.validate(values[name2]);
  }
}
function initAttrs(typeName, attrs) {
  let result = /* @__PURE__ */ Object.create(null);
  if (attrs)
    for (let name in attrs)
      result[name] = new Attribute(typeName, name, attrs[name]);
  return result;
}
var NodeType = class _NodeType {
  /**
  @internal
  */
  constructor(name, schema, spec) {
    this.name = name;
    this.schema = schema;
    this.spec = spec;
    this.markSet = null;
    this.groups = spec.group ? spec.group.split(" ") : [];
    this.attrs = initAttrs(name, spec.attrs);
    this.defaultAttrs = defaultAttrs(this.attrs);
    this.contentMatch = null;
    this.inlineContent = null;
    this.isBlock = !(spec.inline || name == "text");
    this.isText = name == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == ContentMatch.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(group) {
    return this.groups.indexOf(group) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let n in this.attrs)
      if (this.attrs[n].isRequired)
        return true;
    return false;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(other) {
    return this == other || this.contentMatch.compatible(other.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(attrs) {
    if (!attrs && this.defaultAttrs)
      return this.defaultAttrs;
    else
      return computeAttrs(this.attrs, attrs);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(attrs = null, content, marks) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Node2(this, this.computeAttrs(attrs), Fragment12.from(content), Mark.setFrom(marks));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(attrs = null, content, marks) {
    content = Fragment12.from(content);
    this.checkContent(content);
    return new Node2(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(attrs = null, content, marks) {
    attrs = this.computeAttrs(attrs);
    content = Fragment12.from(content);
    if (content.size) {
      let before = this.contentMatch.fillBefore(content);
      if (!before)
        return null;
      content = before.append(content);
    }
    let matched = this.contentMatch.matchFragment(content);
    let after = matched && matched.fillBefore(Fragment12.empty, true);
    if (!after)
      return null;
    return new Node2(this, attrs, content.append(after), Mark.setFrom(marks));
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(content) {
    let result = this.contentMatch.matchFragment(content);
    if (!result || !result.validEnd)
      return false;
    for (let i = 0; i < content.childCount; i++)
      if (!this.allowsMarks(content.child(i).marks))
        return false;
    return true;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(content) {
    if (!this.validContent(content))
      throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(attrs) {
    checkAttrs(this.attrs, attrs, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(markType) {
    return this.markSet == null || this.markSet.indexOf(markType) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(marks) {
    if (this.markSet == null)
      return true;
    for (let i = 0; i < marks.length; i++)
      if (!this.allowsMarkType(marks[i].type))
        return false;
    return true;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(marks) {
    if (this.markSet == null)
      return marks;
    let copy2;
    for (let i = 0; i < marks.length; i++) {
      if (!this.allowsMarkType(marks[i].type)) {
        if (!copy2)
          copy2 = marks.slice(0, i);
      } else if (copy2) {
        copy2.push(marks[i]);
      }
    }
    return !copy2 ? marks : copy2.length ? copy2 : Mark.none;
  }
  /**
  @internal
  */
  static compile(nodes, schema) {
    let result = /* @__PURE__ */ Object.create(null);
    nodes.forEach((name, spec) => result[name] = new _NodeType(name, schema, spec));
    let topType = schema.spec.topNode || "doc";
    if (!result[topType])
      throw new RangeError("Schema is missing its top node type ('" + topType + "')");
    if (!result.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let _ in result.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return result;
  }
};
function validateType(typeName, attrName, type) {
  let types = type.split("|");
  return (value) => {
    let name = value === null ? "null" : typeof value;
    if (types.indexOf(name) < 0)
      throw new RangeError(`Expected value of type ${types} for attribute ${attrName} on type ${typeName}, got ${name}`);
  };
}
var Attribute = class {
  constructor(typeName, attrName, options2) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(options2, "default");
    this.default = options2.default;
    this.validate = typeof options2.validate == "string" ? validateType(typeName, attrName, options2.validate) : options2.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
};
var MarkType = class _MarkType {
  /**
  @internal
  */
  constructor(name, rank, schema, spec) {
    this.name = name;
    this.rank = rank;
    this.schema = schema;
    this.spec = spec;
    this.attrs = initAttrs(name, spec.attrs);
    this.excluded = null;
    let defaults2 = defaultAttrs(this.attrs);
    this.instance = defaults2 ? new Mark(this, defaults2) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(attrs = null) {
    if (!attrs && this.instance)
      return this.instance;
    return new Mark(this, computeAttrs(this.attrs, attrs));
  }
  /**
  @internal
  */
  static compile(marks, schema) {
    let result = /* @__PURE__ */ Object.create(null), rank = 0;
    marks.forEach((name, spec) => result[name] = new _MarkType(name, rank++, schema, spec));
    return result;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(set) {
    for (var i = 0; i < set.length; i++)
      if (set[i].type == this) {
        set = set.slice(0, i).concat(set.slice(i + 1));
        i--;
      }
    return set;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(set) {
    for (let i = 0; i < set.length; i++)
      if (set[i].type == this)
        return set[i];
  }
  /**
  @internal
  */
  checkAttrs(attrs) {
    checkAttrs(this.attrs, attrs, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(other) {
    return this.excluded.indexOf(other) > -1;
  }
};
var Schema = class {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(spec) {
    this.linebreakReplacement = null;
    this.cached = /* @__PURE__ */ Object.create(null);
    let instanceSpec = this.spec = {};
    for (let prop in spec)
      instanceSpec[prop] = spec[prop];
    instanceSpec.nodes = dist_default.from(spec.nodes), instanceSpec.marks = dist_default.from(spec.marks || {}), this.nodes = NodeType.compile(this.spec.nodes, this);
    this.marks = MarkType.compile(this.spec.marks, this);
    let contentExprCache = /* @__PURE__ */ Object.create(null);
    for (let prop in this.nodes) {
      if (prop in this.marks)
        throw new RangeError(prop + " can not be both a node and a mark");
      let type = this.nodes[prop], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
      type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
      type.inlineContent = type.contentMatch.inlineContent;
      if (type.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!type.isInline || !type.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = type;
      }
      type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
    }
    for (let prop in this.marks) {
      let type = this.marks[prop], excl = type.spec.excludes;
      type.excluded = excl == null ? [type] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
    }
    this.nodeFromJSON = (json) => Node2.fromJSON(this, json);
    this.markFromJSON = (json) => Mark.fromJSON(this, json);
    this.topNodeType = this.nodes[this.spec.topNode || "doc"];
    this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(type, attrs = null, content, marks) {
    if (typeof type == "string")
      type = this.nodeType(type);
    else if (!(type instanceof NodeType))
      throw new RangeError("Invalid node type: " + type);
    else if (type.schema != this)
      throw new RangeError("Node type from different schema used (" + type.name + ")");
    return type.createChecked(attrs, content, marks);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(text, marks) {
    let type = this.nodes.text;
    return new TextNode(type, type.defaultAttrs, text, Mark.setFrom(marks));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(type, attrs) {
    if (typeof type == "string")
      type = this.marks[type];
    return type.create(attrs);
  }
  /**
  @internal
  */
  nodeType(name) {
    let found2 = this.nodes[name];
    if (!found2)
      throw new RangeError("Unknown node type: " + name);
    return found2;
  }
};
function gatherMarks(schema, marks) {
  let found2 = [];
  for (let i = 0; i < marks.length; i++) {
    let name = marks[i], mark = schema.marks[name], ok = mark;
    if (mark) {
      found2.push(mark);
    } else {
      for (let prop in schema.marks) {
        let mark2 = schema.marks[prop];
        if (name == "_" || mark2.spec.group && mark2.spec.group.split(" ").indexOf(name) > -1)
          found2.push(ok = mark2);
      }
    }
    if (!ok)
      throw new SyntaxError("Unknown mark type: '" + marks[i] + "'");
  }
  return found2;
}
function isTagRule(rule) {
  return rule.tag != null;
}
function isStyleRule(rule) {
  return rule.style != null;
}
var DOMParser2 = class _DOMParser {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(schema, rules) {
    this.schema = schema;
    this.rules = rules;
    this.tags = [];
    this.styles = [];
    let matchedStyles = this.matchedStyles = [];
    rules.forEach((rule) => {
      if (isTagRule(rule)) {
        this.tags.push(rule);
      } else if (isStyleRule(rule)) {
        let prop = /[^=]*/.exec(rule.style)[0];
        if (matchedStyles.indexOf(prop) < 0)
          matchedStyles.push(prop);
        this.styles.push(rule);
      }
    });
    this.normalizeLists = !this.tags.some((r) => {
      if (!/^(ul|ol)\b/.test(r.tag) || !r.node)
        return false;
      let node = schema.nodes[r.node];
      return node.contentMatch.matchType(node);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(dom, options2 = {}) {
    let context = new ParseContext(this, options2, false);
    context.addAll(dom, Mark.none, options2.from, options2.to);
    return context.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(dom, options2 = {}) {
    let context = new ParseContext(this, options2, true);
    context.addAll(dom, Mark.none, options2.from, options2.to);
    return Slice.maxOpen(context.finish());
  }
  /**
  @internal
  */
  matchTag(dom, context, after) {
    for (let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {
      let rule = this.tags[i];
      if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
        if (rule.getAttrs) {
          let result = rule.getAttrs(dom);
          if (result === false)
            continue;
          rule.attrs = result || void 0;
        }
        return rule;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(prop, value, context, after) {
    for (let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {
      let rule = this.styles[i], style2 = rule.style;
      if (style2.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      style2.length > prop.length && (style2.charCodeAt(prop.length) != 61 || style2.slice(prop.length + 1) != value))
        continue;
      if (rule.getAttrs) {
        let result = rule.getAttrs(value);
        if (result === false)
          continue;
        rule.attrs = result || void 0;
      }
      return rule;
    }
  }
  /**
  @internal
  */
  static schemaRules(schema) {
    let result = [];
    function insert(rule) {
      let priority = rule.priority == null ? 50 : rule.priority, i = 0;
      for (; i < result.length; i++) {
        let next = result[i], nextPriority = next.priority == null ? 50 : next.priority;
        if (nextPriority < priority)
          break;
      }
      result.splice(i, 0, rule);
    }
    for (let name in schema.marks) {
      let rules = schema.marks[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert(rule = copy(rule));
          if (!(rule.mark || rule.ignore || rule.clearMark))
            rule.mark = name;
        });
    }
    for (let name in schema.nodes) {
      let rules = schema.nodes[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert(rule = copy(rule));
          if (!(rule.node || rule.ignore || rule.mark))
            rule.node = name;
        });
    }
    return result;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.GenericParseRule.priority).
  */
  static fromSchema(schema) {
    return schema.cached.domParser || (schema.cached.domParser = new _DOMParser(schema, _DOMParser.schemaRules(schema)));
  }
};
var blockTags = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
var ignoreTags = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
var listTags = { ol: true, ul: true };
var OPT_PRESERVE_WS = 1;
var OPT_PRESERVE_WS_FULL = 2;
var OPT_OPEN_LEFT = 4;
function wsOptionsFor(type, preserveWhitespace, base2) {
  if (preserveWhitespace != null)
    return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
  return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base2 & ~OPT_OPEN_LEFT;
}
var NodeContext = class {
  constructor(type, attrs, marks, solid, match, options2) {
    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.solid = solid;
    this.options = options2;
    this.content = [];
    this.activeMarks = Mark.none;
    this.match = match || (options2 & OPT_OPEN_LEFT ? null : type.contentMatch);
  }
  findWrapping(node) {
    if (!this.match) {
      if (!this.type)
        return [];
      let fill = this.type.contentMatch.fillBefore(Fragment12.from(node));
      if (fill) {
        this.match = this.type.contentMatch.matchFragment(fill);
      } else {
        let start = this.type.contentMatch, wrap3;
        if (wrap3 = start.findWrapping(node.type)) {
          this.match = start;
          return wrap3;
        } else {
          return null;
        }
      }
    }
    return this.match.findWrapping(node.type);
  }
  finish(openEnd) {
    if (!(this.options & OPT_PRESERVE_WS)) {
      let last2 = this.content[this.content.length - 1], m;
      if (last2 && last2.isText && (m = /[ \t\r\n\u000c]+$/.exec(last2.text))) {
        let text = last2;
        if (last2.text.length == m[0].length)
          this.content.pop();
        else
          this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));
      }
    }
    let content = Fragment12.from(this.content);
    if (!openEnd && this.match)
      content = content.append(this.match.fillBefore(Fragment12.empty, true));
    return this.type ? this.type.create(this.attrs, content, this.marks) : content;
  }
  inlineContext(node) {
    if (this.type)
      return this.type.inlineContent;
    if (this.content.length)
      return this.content[0].isInline;
    return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
  }
};
var ParseContext = class {
  constructor(parser, options2, isOpen) {
    this.parser = parser;
    this.options = options2;
    this.isOpen = isOpen;
    this.open = 0;
    this.localPreserveWS = false;
    let topNode = options2.topNode, topContext;
    let topOptions = wsOptionsFor(null, options2.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
    if (topNode)
      topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, true, options2.topMatch || topNode.type.contentMatch, topOptions);
    else if (isOpen)
      topContext = new NodeContext(null, null, Mark.none, true, null, topOptions);
    else
      topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, true, null, topOptions);
    this.nodes = [topContext];
    this.find = options2.findPositions;
    this.needsBlock = false;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(dom, marks) {
    if (dom.nodeType == 3)
      this.addTextNode(dom, marks);
    else if (dom.nodeType == 1)
      this.addElement(dom, marks);
  }
  addTextNode(dom, marks) {
    let value = dom.nodeValue;
    let top = this.top, preserveWS = top.options & OPT_PRESERVE_WS_FULL ? "full" : this.localPreserveWS || (top.options & OPT_PRESERVE_WS) > 0;
    let { schema } = this.parser;
    if (preserveWS === "full" || top.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
      if (!preserveWS) {
        value = value.replace(/[ \t\r\n\u000c]+/g, " ");
        if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
          let nodeBefore = top.content[top.content.length - 1];
          let domNodeBefore = dom.previousSibling;
          if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
            value = value.slice(1);
        }
      } else if (preserveWS === "full") {
        value = value.replace(/\r\n?/g, "\n");
      } else if (schema.linebreakReplacement && /[\r\n]/.test(value) && this.top.findWrapping(schema.linebreakReplacement.create())) {
        let lines = value.split(/\r?\n|\r/);
        for (let i = 0; i < lines.length; i++) {
          if (i)
            this.insertNode(schema.linebreakReplacement.create(), marks, true);
          if (lines[i])
            this.insertNode(schema.text(lines[i]), marks, !/\S/.test(lines[i]));
        }
        value = "";
      } else {
        value = value.replace(/\r?\n|\r/g, " ");
      }
      if (value)
        this.insertNode(schema.text(value), marks, !/\S/.test(value));
      this.findInText(dom);
    } else {
      this.findInside(dom);
    }
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(dom, marks, matchAfter) {
    let outerWS = this.localPreserveWS, top = this.top;
    if (dom.tagName == "PRE" || /pre/.test(dom.style && dom.style.whiteSpace))
      this.localPreserveWS = true;
    let name = dom.nodeName.toLowerCase(), ruleID;
    if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)
      normalizeList(dom);
    let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
    out: if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
      this.findInside(dom);
      this.ignoreFallback(dom, marks);
    } else if (!rule || rule.skip || rule.closeParent) {
      if (rule && rule.closeParent)
        this.open = Math.max(0, this.open - 1);
      else if (rule && rule.skip.nodeType)
        dom = rule.skip;
      let sync, oldNeedsBlock = this.needsBlock;
      if (blockTags.hasOwnProperty(name)) {
        if (top.content.length && top.content[0].isInline && this.open) {
          this.open--;
          top = this.top;
        }
        sync = true;
        if (!top.type)
          this.needsBlock = true;
      } else if (!dom.firstChild) {
        this.leafFallback(dom, marks);
        break out;
      }
      let innerMarks = rule && rule.skip ? marks : this.readStyles(dom, marks);
      if (innerMarks)
        this.addAll(dom, innerMarks);
      if (sync)
        this.sync(top);
      this.needsBlock = oldNeedsBlock;
    } else {
      let innerMarks = this.readStyles(dom, marks);
      if (innerMarks)
        this.addElementByRule(dom, rule, innerMarks, rule.consuming === false ? ruleID : void 0);
    }
    this.localPreserveWS = outerWS;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(dom, marks) {
    if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
      this.addTextNode(dom.ownerDocument.createTextNode("\n"), marks);
  }
  // Called for ignored nodes
  ignoreFallback(dom, marks) {
    if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
      this.findPlace(this.parser.schema.text("-"), marks, true);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(dom, marks) {
    let styles = dom.style;
    if (styles && styles.length)
      for (let i = 0; i < this.parser.matchedStyles.length; i++) {
        let name = this.parser.matchedStyles[i], value = styles.getPropertyValue(name);
        if (value)
          for (let after = void 0; ; ) {
            let rule = this.parser.matchStyle(name, value, this, after);
            if (!rule)
              break;
            if (rule.ignore)
              return null;
            if (rule.clearMark)
              marks = marks.filter((m) => !rule.clearMark(m));
            else
              marks = marks.concat(this.parser.schema.marks[rule.mark].create(rule.attrs));
            if (rule.consuming === false)
              after = rule;
            else
              break;
          }
      }
    return marks;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(dom, rule, marks, continueAfter) {
    let sync, nodeType;
    if (rule.node) {
      nodeType = this.parser.schema.nodes[rule.node];
      if (!nodeType.isLeaf) {
        let inner = this.enter(nodeType, rule.attrs || null, marks, rule.preserveWhitespace);
        if (inner) {
          sync = true;
          marks = inner;
        }
      } else if (!this.insertNode(nodeType.create(rule.attrs), marks, dom.nodeName == "BR")) {
        this.leafFallback(dom, marks);
      }
    } else {
      let markType = this.parser.schema.marks[rule.mark];
      marks = marks.concat(markType.create(rule.attrs));
    }
    let startIn = this.top;
    if (nodeType && nodeType.isLeaf) {
      this.findInside(dom);
    } else if (continueAfter) {
      this.addElement(dom, marks, continueAfter);
    } else if (rule.getContent) {
      this.findInside(dom);
      rule.getContent(dom, this.parser.schema).forEach((node) => this.insertNode(node, marks, false));
    } else {
      let contentDOM = dom;
      if (typeof rule.contentElement == "string")
        contentDOM = dom.querySelector(rule.contentElement);
      else if (typeof rule.contentElement == "function")
        contentDOM = rule.contentElement(dom);
      else if (rule.contentElement)
        contentDOM = rule.contentElement;
      this.findAround(dom, contentDOM, true);
      this.addAll(contentDOM, marks);
      this.findAround(dom, contentDOM, false);
    }
    if (sync && this.sync(startIn))
      this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(parent, marks, startIndex, endIndex) {
    let index2 = startIndex || 0;
    for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index2) {
      this.findAtPoint(parent, index2);
      this.addDOM(dom, marks);
    }
    this.findAtPoint(parent, index2);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(node, marks, cautious) {
    let route, sync;
    for (let depth = this.open, penalty = 0; depth >= 0; depth--) {
      let cx = this.nodes[depth];
      let found2 = cx.findWrapping(node);
      if (found2 && (!route || route.length > found2.length + penalty)) {
        route = found2;
        sync = cx;
        if (!found2.length)
          break;
      }
      if (cx.solid) {
        if (cautious)
          break;
        penalty += 2;
      }
    }
    if (!route)
      return null;
    this.sync(sync);
    for (let i = 0; i < route.length; i++)
      marks = this.enterInner(route[i], null, marks, false);
    return marks;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(node, marks, cautious) {
    if (node.isInline && this.needsBlock && !this.top.type) {
      let block = this.textblockFromContext();
      if (block)
        marks = this.enterInner(block, null, marks);
    }
    let innerMarks = this.findPlace(node, marks, cautious);
    if (innerMarks) {
      this.closeExtra();
      let top = this.top;
      if (top.match)
        top.match = top.match.matchType(node.type);
      let nodeMarks = Mark.none;
      for (let m of innerMarks.concat(node.marks))
        if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, node.type))
          nodeMarks = m.addToSet(nodeMarks);
      top.content.push(node.mark(nodeMarks));
      return true;
    }
    return false;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(type, attrs, marks, preserveWS) {
    let innerMarks = this.findPlace(type.create(attrs), marks, false);
    if (innerMarks)
      innerMarks = this.enterInner(type, attrs, marks, true, preserveWS);
    return innerMarks;
  }
  // Open a node of the given type
  enterInner(type, attrs, marks, solid = false, preserveWS) {
    this.closeExtra();
    let top = this.top;
    top.match = top.match && top.match.matchType(type);
    let options2 = wsOptionsFor(type, preserveWS, top.options);
    if (top.options & OPT_OPEN_LEFT && top.content.length == 0)
      options2 |= OPT_OPEN_LEFT;
    let applyMarks = Mark.none;
    marks = marks.filter((m) => {
      if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, type)) {
        applyMarks = m.addToSet(applyMarks);
        return false;
      }
      return true;
    });
    this.nodes.push(new NodeContext(type, attrs, applyMarks, solid, null, options2));
    this.open++;
    return marks;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(openEnd = false) {
    let i = this.nodes.length - 1;
    if (i > this.open) {
      for (; i > this.open; i--)
        this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    this.open = 0;
    this.closeExtra(this.isOpen);
    return this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(to) {
    for (let i = this.open; i >= 0; i--) {
      if (this.nodes[i] == to) {
        this.open = i;
        return true;
      } else if (this.localPreserveWS) {
        this.nodes[i].options |= OPT_PRESERVE_WS;
      }
    }
    return false;
  }
  get currentPos() {
    this.closeExtra();
    let pos = 0;
    for (let i = this.open; i >= 0; i--) {
      let content = this.nodes[i].content;
      for (let j = content.length - 1; j >= 0; j--)
        pos += content[j].nodeSize;
      if (i)
        pos++;
    }
    return pos;
  }
  findAtPoint(parent, offset4) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].node == parent && this.find[i].offset == offset4)
          this.find[i].pos = this.currentPos;
      }
  }
  findInside(parent) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))
          this.find[i].pos = this.currentPos;
      }
  }
  findAround(parent, content, before) {
    if (parent != content && this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
          let pos = content.compareDocumentPosition(this.find[i].node);
          if (pos & (before ? 2 : 4))
            this.find[i].pos = this.currentPos;
        }
      }
  }
  findInText(textNode) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].node == textNode)
          this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
      }
  }
  // Determines whether the given context string matches this context.
  matchesContext(context) {
    if (context.indexOf("|") > -1)
      return context.split(/\s*\|\s*/).some(this.matchesContext, this);
    let parts = context.split("/");
    let option = this.options.context;
    let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
    let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
    let match = (i, depth) => {
      for (; i >= 0; i--) {
        let part = parts[i];
        if (part == "") {
          if (i == parts.length - 1 || i == 0)
            continue;
          for (; depth >= minDepth; depth--)
            if (match(i - 1, depth))
              return true;
          return false;
        } else {
          let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
          if (!next || next.name != part && !next.isInGroup(part))
            return false;
          depth--;
        }
      }
      return true;
    };
    return match(parts.length - 1, this.open);
  }
  textblockFromContext() {
    let $context = this.options.context;
    if ($context)
      for (let d = $context.depth; d >= 0; d--) {
        let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
        if (deflt && deflt.isTextblock && deflt.defaultAttrs)
          return deflt;
      }
    for (let name in this.parser.schema.nodes) {
      let type = this.parser.schema.nodes[name];
      if (type.isTextblock && type.defaultAttrs)
        return type;
    }
  }
};
function normalizeList(dom) {
  for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
    let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
    if (name && listTags.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child);
      child = prevItem;
    } else if (name == "li") {
      prevItem = child;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
function copy(obj) {
  let copy2 = {};
  for (let prop in obj)
    copy2[prop] = obj[prop];
  return copy2;
}
function markMayApply(markType, nodeType) {
  let nodes = nodeType.schema.nodes;
  for (let name in nodes) {
    let parent = nodes[name];
    if (!parent.allowsMarkType(markType))
      continue;
    let seen = [], scan = (match) => {
      seen.push(match);
      for (let i = 0; i < match.edgeCount; i++) {
        let { type, next } = match.edge(i);
        if (type == nodeType)
          return true;
        if (seen.indexOf(next) < 0 && scan(next))
          return true;
      }
    };
    if (scan(parent.contentMatch))
      return true;
  }
}
var DOMSerializer = class _DOMSerializer {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(nodes, marks) {
    this.nodes = nodes;
    this.marks = marks;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(fragment, options2 = {}, target) {
    if (!target)
      target = doc(options2).createDocumentFragment();
    let top = target, active = [];
    fragment.forEach((node) => {
      if (active.length || node.marks.length) {
        let keep = 0, rendered = 0;
        while (keep < active.length && rendered < node.marks.length) {
          let next = node.marks[rendered];
          if (!this.marks[next.type.name]) {
            rendered++;
            continue;
          }
          if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)
            break;
          keep++;
          rendered++;
        }
        while (keep < active.length)
          top = active.pop()[1];
        while (rendered < node.marks.length) {
          let add = node.marks[rendered++];
          let markDOM = this.serializeMark(add, node.isInline, options2);
          if (markDOM) {
            active.push([add, top]);
            top.appendChild(markDOM.dom);
            top = markDOM.contentDOM || markDOM.dom;
          }
        }
      }
      top.appendChild(this.serializeNodeInner(node, options2));
    });
    return target;
  }
  /**
  @internal
  */
  serializeNodeInner(node, options2) {
    let { dom, contentDOM } = renderSpec(doc(options2), this.nodes[node.type.name](node), null, node.attrs);
    if (contentDOM) {
      if (node.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(node.content, options2, contentDOM);
    }
    return dom;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(node, options2 = {}) {
    let dom = this.serializeNodeInner(node, options2);
    for (let i = node.marks.length - 1; i >= 0; i--) {
      let wrap3 = this.serializeMark(node.marks[i], node.isInline, options2);
      if (wrap3) {
        (wrap3.contentDOM || wrap3.dom).appendChild(dom);
        dom = wrap3.dom;
      }
    }
    return dom;
  }
  /**
  @internal
  */
  serializeMark(mark, inline3, options2 = {}) {
    let toDOM = this.marks[mark.type.name];
    return toDOM && renderSpec(doc(options2), toDOM(mark, inline3), null, mark.attrs);
  }
  static renderSpec(doc3, structure, xmlNS = null, blockArraysIn) {
    return renderSpec(doc3, structure, xmlNS, blockArraysIn);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(schema) {
    return schema.cached.domSerializer || (schema.cached.domSerializer = new _DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(schema) {
    let result = gatherToDOM(schema.nodes);
    if (!result.text)
      result.text = (node) => node.text;
    return result;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(schema) {
    return gatherToDOM(schema.marks);
  }
};
function gatherToDOM(obj) {
  let result = {};
  for (let name in obj) {
    let toDOM = obj[name].spec.toDOM;
    if (toDOM)
      result[name] = toDOM;
  }
  return result;
}
function doc(options2) {
  return options2.document || window.document;
}
var suspiciousAttributeCache = /* @__PURE__ */ new WeakMap();
function suspiciousAttributes(attrs) {
  let value = suspiciousAttributeCache.get(attrs);
  if (value === void 0)
    suspiciousAttributeCache.set(attrs, value = suspiciousAttributesInner(attrs));
  return value;
}
function suspiciousAttributesInner(attrs) {
  let result = null;
  function scan(value) {
    if (value && typeof value == "object") {
      if (Array.isArray(value)) {
        if (typeof value[0] == "string") {
          if (!result)
            result = [];
          result.push(value);
        } else {
          for (let i = 0; i < value.length; i++)
            scan(value[i]);
        }
      } else {
        for (let prop in value)
          scan(value[prop]);
      }
    }
  }
  scan(attrs);
  return result;
}
function renderSpec(doc3, structure, xmlNS, blockArraysIn) {
  if (typeof structure == "string")
    return { dom: doc3.createTextNode(structure) };
  if (structure.nodeType != null)
    return { dom: structure };
  if (structure.dom && structure.dom.nodeType != null)
    return structure;
  let tagName = structure[0], suspicious;
  if (typeof tagName != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (blockArraysIn && (suspicious = suspiciousAttributes(blockArraysIn)) && suspicious.indexOf(structure) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let space = tagName.indexOf(" ");
  if (space > 0) {
    xmlNS = tagName.slice(0, space);
    tagName = tagName.slice(space + 1);
  }
  let contentDOM;
  let dom = xmlNS ? doc3.createElementNS(xmlNS, tagName) : doc3.createElement(tagName);
  let attrs = structure[1], start = 1;
  if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
    start = 2;
    for (let name in attrs)
      if (attrs[name] != null) {
        let space2 = name.indexOf(" ");
        if (space2 > 0)
          dom.setAttributeNS(name.slice(0, space2), name.slice(space2 + 1), attrs[name]);
        else if (name == "style" && dom.style)
          dom.style.cssText = attrs[name];
        else
          dom.setAttribute(name, attrs[name]);
      }
  }
  for (let i = start; i < structure.length; i++) {
    let child = structure[i];
    if (child === 0) {
      if (i < structure.length - 1 || i > start)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom, contentDOM: dom };
    } else {
      let { dom: inner, contentDOM: innerContent } = renderSpec(doc3, child, xmlNS, blockArraysIn);
      dom.appendChild(inner);
      if (innerContent) {
        if (contentDOM)
          throw new RangeError("Multiple content holes");
        contentDOM = innerContent;
      }
    }
  }
  return { dom, contentDOM };
}

// ../node_modules/prosemirror-transform/dist/index.js
var lower16 = 65535;
var factor16 = Math.pow(2, 16);
function makeRecover(index2, offset4) {
  return index2 + offset4 * factor16;
}
function recoverIndex(value) {
  return value & lower16;
}
function recoverOffset(value) {
  return (value - (value & lower16)) / factor16;
}
var DEL_BEFORE = 1;
var DEL_AFTER = 2;
var DEL_ACROSS = 4;
var DEL_SIDE = 8;
var MapResult = class {
  /**
  @internal
  */
  constructor(pos, delInfo, recover) {
    this.pos = pos;
    this.delInfo = delInfo;
    this.recover = recover;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & DEL_SIDE) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & DEL_ACROSS) > 0;
  }
};
var StepMap = class _StepMap {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(ranges, inverted = false) {
    this.ranges = ranges;
    this.inverted = inverted;
    if (!ranges.length && _StepMap.empty)
      return _StepMap.empty;
  }
  /**
  @internal
  */
  recover(value) {
    let diff = 0, index2 = recoverIndex(value);
    if (!this.inverted)
      for (let i = 0; i < index2; i++)
        diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[index2 * 3] + diff + recoverOffset(value);
  }
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  map(pos, assoc = 1) {
    return this._map(pos, assoc, true);
  }
  /**
  @internal
  */
  _map(pos, assoc, simple) {
    let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start = this.ranges[i] - (this.inverted ? diff : 0);
      if (start > pos)
        break;
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;
      if (pos <= end) {
        let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;
        let result = start + diff + (side < 0 ? 0 : newSize);
        if (simple)
          return result;
        let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);
        let del2 = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;
        if (assoc < 0 ? pos != start : pos != end)
          del2 |= DEL_SIDE;
        return new MapResult(result, del2, recover);
      }
      diff += newSize - oldSize;
    }
    return simple ? pos + diff : new MapResult(pos + diff, 0, null);
  }
  /**
  @internal
  */
  touches(pos, recover) {
    let diff = 0, index2 = recoverIndex(recover);
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start = this.ranges[i] - (this.inverted ? diff : 0);
      if (start > pos)
        break;
      let oldSize = this.ranges[i + oldIndex], end = start + oldSize;
      if (pos <= end && i == index2 * 3)
        return true;
      diff += this.ranges[i + newIndex] - oldSize;
    }
    return false;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(f) {
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {
      let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
      f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
      diff += newSize - oldSize;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new _StepMap(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(n) {
    return n == 0 ? _StepMap.empty : new _StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
  }
};
StepMap.empty = new StepMap([]);
var Mapping = class _Mapping {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(maps, mirror, from2 = 0, to = maps ? maps.length : 0) {
    this.mirror = mirror;
    this.from = from2;
    this.to = to;
    this._maps = maps || [];
    this.ownData = !(maps || mirror);
  }
  /**
  The step maps in this mapping.
  */
  get maps() {
    return this._maps;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(from2 = 0, to = this.maps.length) {
    return new _Mapping(this._maps, this.mirror, from2, to);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(map2, mirrors) {
    if (!this.ownData) {
      this._maps = this._maps.slice();
      this.mirror = this.mirror && this.mirror.slice();
      this.ownData = true;
    }
    this.to = this._maps.push(map2);
    if (mirrors != null)
      this.setMirror(this._maps.length - 1, mirrors);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(mapping) {
    for (let i = 0, startSize = this._maps.length; i < mapping._maps.length; i++) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping._maps[i], mirr != null && mirr < i ? startSize + mirr : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(n) {
    if (this.mirror) {
      for (let i = 0; i < this.mirror.length; i++)
        if (this.mirror[i] == n)
          return this.mirror[i + (i % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(n, m) {
    if (!this.mirror)
      this.mirror = [];
    this.mirror.push(n, m);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(mapping) {
    for (let i = mapping.maps.length - 1, totalSize = this._maps.length + mapping._maps.length; i >= 0; i--) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping._maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let inverse = new _Mapping();
    inverse.appendMappingInverted(this);
    return inverse;
  }
  /**
  Map a position through this mapping.
  */
  map(pos, assoc = 1) {
    if (this.mirror)
      return this._map(pos, assoc, true);
    for (let i = this.from; i < this.to; i++)
      pos = this._maps[i].map(pos, assoc);
    return pos;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  /**
  @internal
  */
  _map(pos, assoc, simple) {
    let delInfo = 0;
    for (let i = this.from; i < this.to; i++) {
      let map2 = this._maps[i], result = map2.mapResult(pos, assoc);
      if (result.recover != null) {
        let corr = this.getMirror(i);
        if (corr != null && corr > i && corr < this.to) {
          i = corr;
          pos = this._maps[corr].recover(result.recover);
          continue;
        }
      }
      delInfo |= result.delInfo;
      pos = result.pos;
    }
    return simple ? pos : new MapResult(pos, delInfo, null);
  }
};
var stepsByID = /* @__PURE__ */ Object.create(null);
var Step = class {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return StepMap.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(other) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(schema, json) {
    if (!json || !json.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let type = stepsByID[json.stepType];
    if (!type)
      throw new RangeError(`No step type ${json.stepType} defined`);
    return type.fromJSON(schema, json);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(id, stepClass) {
    if (id in stepsByID)
      throw new RangeError("Duplicate use of step JSON ID " + id);
    stepsByID[id] = stepClass;
    stepClass.prototype.jsonID = id;
    return stepClass;
  }
};
var StepResult = class _StepResult {
  /**
  @internal
  */
  constructor(doc3, failed) {
    this.doc = doc3;
    this.failed = failed;
  }
  /**
  Create a successful step result.
  */
  static ok(doc3) {
    return new _StepResult(doc3, null);
  }
  /**
  Create a failed step result.
  */
  static fail(message) {
    return new _StepResult(null, message);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(doc3, from2, to, slice2) {
    try {
      return _StepResult.ok(doc3.replace(from2, to, slice2));
    } catch (e) {
      if (e instanceof ReplaceError)
        return _StepResult.fail(e.message);
      throw e;
    }
  }
};
function mapFragment(fragment, f, parent) {
  let mapped = [];
  for (let i = 0; i < fragment.childCount; i++) {
    let child = fragment.child(i);
    if (child.content.size)
      child = child.copy(mapFragment(child.content, f, child));
    if (child.isInline)
      child = f(child, parent, i);
    mapped.push(child);
  }
  return Fragment12.fromArray(mapped);
}
var AddMarkStep = class _AddMarkStep extends Step {
  /**
  Create a mark step.
  */
  constructor(from2, to, mark) {
    super();
    this.from = from2;
    this.to = to;
    this.mark = mark;
  }
  apply(doc3) {
    let oldSlice = doc3.slice(this.from, this.to), $from = doc3.resolve(this.from);
    let parent = $from.node($from.sharedDepth(this.to));
    let slice2 = new Slice(mapFragment(oldSlice.content, (node, parent2) => {
      if (!node.isAtom || !parent2.type.allowsMarkType(this.mark.type))
        return node;
      return node.mark(this.mark.addToSet(node.marks));
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc3, this.from, this.to, slice2);
  }
  invert() {
    return new RemoveMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deleted && to.deleted || from2.pos >= to.pos)
      return null;
    return new _AddMarkStep(from2.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof _AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new _AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new _AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("addMark", AddMarkStep);
var RemoveMarkStep = class _RemoveMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(from2, to, mark) {
    super();
    this.from = from2;
    this.to = to;
    this.mark = mark;
  }
  apply(doc3) {
    let oldSlice = doc3.slice(this.from, this.to);
    let slice2 = new Slice(mapFragment(oldSlice.content, (node) => {
      return node.mark(this.mark.removeFromSet(node.marks));
    }, doc3), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc3, this.from, this.to, slice2);
  }
  invert() {
    return new AddMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deleted && to.deleted || from2.pos >= to.pos)
      return null;
    return new _RemoveMarkStep(from2.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof _RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new _RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new _RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("removeMark", RemoveMarkStep);
var AddNodeMarkStep = class _AddNodeMarkStep extends Step {
  /**
  Create a node mark step.
  */
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at mark step's position");
    let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));
    return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment12.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  invert(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (node) {
      let newSet = this.mark.addToSet(node.marks);
      if (newSet.length == node.marks.length) {
        for (let i = 0; i < node.marks.length; i++)
          if (!node.marks[i].isInSet(newSet))
            return new _AddNodeMarkStep(this.pos, node.marks[i]);
        return new _AddNodeMarkStep(this.pos, this.mark);
      }
    }
    return new RemoveNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new _AddNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new _AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("addNodeMark", AddNodeMarkStep);
var RemoveNodeMarkStep = class _RemoveNodeMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at mark step's position");
    let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));
    return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment12.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  invert(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node || !this.mark.isInSet(node.marks))
      return this;
    return new AddNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new _RemoveNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new _RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
var ReplaceStep = class _ReplaceStep extends Step {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(from2, to, slice2, structure = false) {
    super();
    this.from = from2;
    this.to = to;
    this.slice = slice2;
    this.structure = structure;
  }
  apply(doc3) {
    if (this.structure && contentBetween(doc3, this.from, this.to))
      return StepResult.fail("Structure replace would overwrite content");
    return StepResult.fromReplace(doc3, this.from, this.to, this.slice);
  }
  getMap() {
    return new StepMap([this.from, this.to - this.from, this.slice.size]);
  }
  invert(doc3) {
    return new _ReplaceStep(this.from, this.from + this.slice.size, doc3.slice(this.from, this.to));
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deletedAcross && to.deletedAcross)
      return null;
    return new _ReplaceStep(from2.pos, Math.max(from2.pos, to.pos), this.slice, this.structure);
  }
  merge(other) {
    if (!(other instanceof _ReplaceStep) || other.structure || this.structure)
      return null;
    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new _ReplaceStep(this.from, this.to + (other.to - other.from), slice2, this.structure);
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new _ReplaceStep(other.from, this.to, slice2, this.structure);
    } else {
      return null;
    }
  }
  toJSON() {
    let json = { stepType: "replace", from: this.from, to: this.to };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new _ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);
  }
};
Step.jsonID("replace", ReplaceStep);
var ReplaceAroundStep = class _ReplaceAroundStep extends Step {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(from2, to, gapFrom, gapTo, slice2, insert, structure = false) {
    super();
    this.from = from2;
    this.to = to;
    this.gapFrom = gapFrom;
    this.gapTo = gapTo;
    this.slice = slice2;
    this.insert = insert;
    this.structure = structure;
  }
  apply(doc3) {
    if (this.structure && (contentBetween(doc3, this.from, this.gapFrom) || contentBetween(doc3, this.gapTo, this.to)))
      return StepResult.fail("Structure gap-replace would overwrite content");
    let gap = doc3.slice(this.gapFrom, this.gapTo);
    if (gap.openStart || gap.openEnd)
      return StepResult.fail("Gap is not a flat range");
    let inserted = this.slice.insertAt(this.insert, gap.content);
    if (!inserted)
      return StepResult.fail("Content does not fit in gap");
    return StepResult.fromReplace(doc3, this.from, this.to, inserted);
  }
  getMap() {
    return new StepMap([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(doc3) {
    let gap = this.gapTo - this.gapFrom;
    return new _ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc3.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    let gapFrom = this.from == this.gapFrom ? from2.pos : mapping.map(this.gapFrom, -1);
    let gapTo = this.to == this.gapTo ? to.pos : mapping.map(this.gapTo, 1);
    if (from2.deletedAcross && to.deletedAcross || gapFrom < from2.pos || gapTo > to.pos)
      return null;
    return new _ReplaceAroundStep(from2.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let json = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new _ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
  }
};
Step.jsonID("replaceAround", ReplaceAroundStep);
function contentBetween(doc3, from2, to) {
  let $from = doc3.resolve(from2), dist = to - from2, depth = $from.depth;
  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }
  if (dist > 0) {
    let next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist > 0) {
      if (!next || next.isLeaf)
        return true;
      next = next.firstChild;
      dist--;
    }
  }
  return false;
}
function addMark(tr2, from2, to, mark) {
  let removed = [], added = [];
  let removing, adding;
  tr2.doc.nodesBetween(from2, to, (node, pos, parent) => {
    if (!node.isInline)
      return;
    let marks = node.marks;
    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
      let start = Math.max(pos, from2), end = Math.min(pos + node.nodeSize, to);
      let newSet = mark.addToSet(marks);
      for (let i = 0; i < marks.length; i++) {
        if (!marks[i].isInSet(newSet)) {
          if (removing && removing.to == start && removing.mark.eq(marks[i]))
            removing.to = end;
          else
            removed.push(removing = new RemoveMarkStep(start, end, marks[i]));
        }
      }
      if (adding && adding.to == start)
        adding.to = end;
      else
        added.push(adding = new AddMarkStep(start, end, mark));
    }
  });
  removed.forEach((s) => tr2.step(s));
  added.forEach((s) => tr2.step(s));
}
function removeMark(tr2, from2, to, mark) {
  let matched = [], step = 0;
  tr2.doc.nodesBetween(from2, to, (node, pos) => {
    if (!node.isInline)
      return;
    step++;
    let toRemove = null;
    if (mark instanceof MarkType) {
      let set = node.marks, found2;
      while (found2 = mark.isInSet(set)) {
        (toRemove || (toRemove = [])).push(found2);
        set = found2.removeFromSet(set);
      }
    } else if (mark) {
      if (mark.isInSet(node.marks))
        toRemove = [mark];
    } else {
      toRemove = node.marks;
    }
    if (toRemove && toRemove.length) {
      let end = Math.min(pos + node.nodeSize, to);
      for (let i = 0; i < toRemove.length; i++) {
        let style2 = toRemove[i], found2;
        for (let j = 0; j < matched.length; j++) {
          let m = matched[j];
          if (m.step == step - 1 && style2.eq(matched[j].style))
            found2 = m;
        }
        if (found2) {
          found2.to = end;
          found2.step = step;
        } else {
          matched.push({ style: style2, from: Math.max(pos, from2), to: end, step });
        }
      }
    }
  });
  matched.forEach((m) => tr2.step(new RemoveMarkStep(m.from, m.to, m.style)));
}
function clearIncompatible(tr2, pos, parentType, match = parentType.contentMatch, clearNewlines = true) {
  let node = tr2.doc.nodeAt(pos);
  let replSteps = [], cur = pos + 1;
  for (let i = 0; i < node.childCount; i++) {
    let child = node.child(i), end = cur + child.nodeSize;
    let allowed = match.matchType(child.type);
    if (!allowed) {
      replSteps.push(new ReplaceStep(cur, end, Slice.empty));
    } else {
      match = allowed;
      for (let j = 0; j < child.marks.length; j++)
        if (!parentType.allowsMarkType(child.marks[j].type))
          tr2.step(new RemoveMarkStep(cur, end, child.marks[j]));
      if (clearNewlines && child.isText && parentType.whitespace != "pre") {
        let m, newline = /\r?\n|\r/g, slice2;
        while (m = newline.exec(child.text)) {
          if (!slice2)
            slice2 = new Slice(Fragment12.from(parentType.schema.text(" ", parentType.allowedMarks(child.marks))), 0, 0);
          replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice2));
        }
      }
    }
    cur = end;
  }
  if (!match.validEnd) {
    let fill = match.fillBefore(Fragment12.empty, true);
    tr2.replace(cur, cur, new Slice(fill, 0, 0));
  }
  for (let i = replSteps.length - 1; i >= 0; i--)
    tr2.step(replSteps[i]);
}
function canCut(node, start, end) {
  return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));
}
function liftTarget(range) {
  let parent = range.parent;
  let content = parent.content.cutByIndex(range.startIndex, range.endIndex);
  for (let depth = range.depth, contentBefore = 0, contentAfter = 0; ; --depth) {
    let node = range.$from.node(depth);
    let index2 = range.$from.index(depth) + contentBefore, endIndex = range.$to.indexAfter(depth) - contentAfter;
    if (depth < range.depth && node.canReplace(index2, endIndex, content))
      return depth;
    if (depth == 0 || node.type.spec.isolating || !canCut(node, index2, endIndex))
      break;
    if (index2)
      contentBefore = 1;
    if (endIndex < node.childCount)
      contentAfter = 1;
  }
  return null;
}
function lift(tr2, range, target) {
  let { $from, $to, depth } = range;
  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  let start = gapStart, end = gapEnd;
  let before = Fragment12.empty, openStart = 0;
  for (let d = depth, splitting = false; d > target; d--)
    if (splitting || $from.index(d) > 0) {
      splitting = true;
      before = Fragment12.from($from.node(d).copy(before));
      openStart++;
    } else {
      start--;
    }
  let after = Fragment12.empty, openEnd = 0;
  for (let d = depth, splitting = false; d > target; d--)
    if (splitting || $to.after(d + 1) < $to.end(d)) {
      splitting = true;
      after = Fragment12.from($to.node(d).copy(after));
      openEnd++;
    } else {
      end++;
    }
  tr2.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
}
function findWrapping(range, nodeType, attrs = null, innerRange = range) {
  let around = findWrappingOutside(range, nodeType);
  let inner = around && findWrappingInside(innerRange, nodeType);
  if (!inner)
    return null;
  return around.map(withAttrs).concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));
}
function withAttrs(type) {
  return { type, attrs: null };
}
function findWrappingOutside(range, type) {
  let { parent, startIndex, endIndex } = range;
  let around = parent.contentMatchAt(startIndex).findWrapping(type);
  if (!around)
    return null;
  let outer = around.length ? around[0] : type;
  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
}
function findWrappingInside(range, type) {
  let { parent, startIndex, endIndex } = range;
  let inner = parent.child(startIndex);
  let inside = type.contentMatch.findWrapping(inner.type);
  if (!inside)
    return null;
  let lastType = inside.length ? inside[inside.length - 1] : type;
  let innerMatch = lastType.contentMatch;
  for (let i = startIndex; innerMatch && i < endIndex; i++)
    innerMatch = innerMatch.matchType(parent.child(i).type);
  if (!innerMatch || !innerMatch.validEnd)
    return null;
  return inside;
}
function wrap2(tr2, range, wrappers) {
  let content = Fragment12.empty;
  for (let i = wrappers.length - 1; i >= 0; i--) {
    if (content.size) {
      let match = wrappers[i].type.contentMatch.matchFragment(content);
      if (!match || !match.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    content = Fragment12.from(wrappers[i].type.create(wrappers[i].attrs, content));
  }
  let start = range.start, end = range.end;
  tr2.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true));
}
function setBlockType(tr2, from2, to, type, attrs) {
  if (!type.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let mapFrom = tr2.steps.length;
  tr2.doc.nodesBetween(from2, to, (node, pos) => {
    let attrsHere = typeof attrs == "function" ? attrs(node) : attrs;
    if (node.isTextblock && !node.hasMarkup(type, attrsHere) && canChangeType(tr2.doc, tr2.mapping.slice(mapFrom).map(pos), type)) {
      let convertNewlines = null;
      if (type.schema.linebreakReplacement) {
        let pre = type.whitespace == "pre", supportLinebreak = !!type.contentMatch.matchType(type.schema.linebreakReplacement);
        if (pre && !supportLinebreak)
          convertNewlines = false;
        else if (!pre && supportLinebreak)
          convertNewlines = true;
      }
      if (convertNewlines === false)
        replaceLinebreaks(tr2, node, pos, mapFrom);
      clearIncompatible(tr2, tr2.mapping.slice(mapFrom).map(pos, 1), type, void 0, convertNewlines === null);
      let mapping = tr2.mapping.slice(mapFrom);
      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);
      tr2.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment12.from(type.create(attrsHere, null, node.marks)), 0, 0), 1, true));
      if (convertNewlines === true)
        replaceNewlines(tr2, node, pos, mapFrom);
      return false;
    }
  });
}
function replaceNewlines(tr2, node, pos, mapFrom) {
  node.forEach((child, offset4) => {
    if (child.isText) {
      let m, newline = /\r?\n|\r/g;
      while (m = newline.exec(child.text)) {
        let start = tr2.mapping.slice(mapFrom).map(pos + 1 + offset4 + m.index);
        tr2.replaceWith(start, start + 1, node.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function replaceLinebreaks(tr2, node, pos, mapFrom) {
  node.forEach((child, offset4) => {
    if (child.type == child.type.schema.linebreakReplacement) {
      let start = tr2.mapping.slice(mapFrom).map(pos + 1 + offset4);
      tr2.replaceWith(start, start + 1, node.type.schema.text("\n"));
    }
  });
}
function canChangeType(doc3, pos, type) {
  let $pos = doc3.resolve(pos), index2 = $pos.index();
  return $pos.parent.canReplaceWith(index2, index2 + 1, type);
}
function setNodeMarkup(tr2, pos, type, attrs, marks) {
  let node = tr2.doc.nodeAt(pos);
  if (!node)
    throw new RangeError("No node at given position");
  if (!type)
    type = node.type;
  let newNode = type.create(attrs, null, marks || node.marks);
  if (node.isLeaf)
    return tr2.replaceWith(pos, pos + node.nodeSize, newNode);
  if (!type.validContent(node.content))
    throw new RangeError("Invalid content for node type " + type.name);
  tr2.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new Slice(Fragment12.from(newNode), 0, 0), 1, true));
}
function canSplit(doc3, pos, depth = 1, typesAfter) {
  let $pos = doc3.resolve(pos), base2 = $pos.depth - depth;
  let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
  if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
    return false;
  for (let d = $pos.depth - 1, i = depth - 2; d > base2; d--, i--) {
    let node = $pos.node(d), index3 = $pos.index(d);
    if (node.type.spec.isolating)
      return false;
    let rest = node.content.cutByIndex(index3, node.childCount);
    let overrideChild = typesAfter && typesAfter[i + 1];
    if (overrideChild)
      rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));
    let after = typesAfter && typesAfter[i] || node;
    if (!node.canReplace(index3 + 1, node.childCount) || !after.type.validContent(rest))
      return false;
  }
  let index2 = $pos.indexAfter(base2);
  let baseType = typesAfter && typesAfter[0];
  return $pos.node(base2).canReplaceWith(index2, index2, baseType ? baseType.type : $pos.node(base2 + 1).type);
}
function split(tr2, pos, depth = 1, typesAfter) {
  let $pos = tr2.doc.resolve(pos), before = Fragment12.empty, after = Fragment12.empty;
  for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
    before = Fragment12.from($pos.node(d).copy(before));
    let typeAfter = typesAfter && typesAfter[i];
    after = Fragment12.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
  }
  tr2.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));
}
function canJoin(doc3, pos) {
  let $pos = doc3.resolve(pos), index2 = $pos.index();
  return joinable2($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index2, index2 + 1);
}
function canAppendWithSubstitutedLinebreaks(a, b) {
  if (!b.content.size)
    a.type.compatibleContent(b.type);
  let match = a.contentMatchAt(a.childCount);
  let { linebreakReplacement } = a.type.schema;
  for (let i = 0; i < b.childCount; i++) {
    let child = b.child(i);
    let type = child.type == linebreakReplacement ? a.type.schema.nodes.text : child.type;
    match = match.matchType(type);
    if (!match)
      return false;
    if (!a.type.allowsMarks(child.marks))
      return false;
  }
  return match.validEnd;
}
function joinable2(a, b) {
  return !!(a && b && !a.isLeaf && canAppendWithSubstitutedLinebreaks(a, b));
}
function joinPoint(doc3, pos, dir = -1) {
  let $pos = doc3.resolve(pos);
  for (let d = $pos.depth; ; d--) {
    let before, after, index2 = $pos.index(d);
    if (d == $pos.depth) {
      before = $pos.nodeBefore;
      after = $pos.nodeAfter;
    } else if (dir > 0) {
      before = $pos.node(d + 1);
      index2++;
      after = $pos.node(d).maybeChild(index2);
    } else {
      before = $pos.node(d).maybeChild(index2 - 1);
      after = $pos.node(d + 1);
    }
    if (before && !before.isTextblock && joinable2(before, after) && $pos.node(d).canReplace(index2, index2 + 1))
      return pos;
    if (d == 0)
      break;
    pos = dir < 0 ? $pos.before(d) : $pos.after(d);
  }
}
function join(tr2, pos, depth) {
  let convertNewlines = null;
  let { linebreakReplacement } = tr2.doc.type.schema;
  let $before = tr2.doc.resolve(pos - depth), beforeType = $before.node().type;
  if (linebreakReplacement && beforeType.inlineContent) {
    let pre = beforeType.whitespace == "pre";
    let supportLinebreak = !!beforeType.contentMatch.matchType(linebreakReplacement);
    if (pre && !supportLinebreak)
      convertNewlines = false;
    else if (!pre && supportLinebreak)
      convertNewlines = true;
  }
  let mapFrom = tr2.steps.length;
  if (convertNewlines === false) {
    let $after = tr2.doc.resolve(pos + depth);
    replaceLinebreaks(tr2, $after.node(), $after.before(), mapFrom);
  }
  if (beforeType.inlineContent)
    clearIncompatible(tr2, pos + depth - 1, beforeType, $before.node().contentMatchAt($before.index()), convertNewlines == null);
  let mapping = tr2.mapping.slice(mapFrom), start = mapping.map(pos - depth);
  tr2.step(new ReplaceStep(start, mapping.map(pos + depth, -1), Slice.empty, true));
  if (convertNewlines === true) {
    let $full = tr2.doc.resolve(start);
    replaceNewlines(tr2, $full.node(), $full.before(), tr2.steps.length);
  }
  return tr2;
}
function insertPoint(doc3, pos, nodeType) {
  let $pos = doc3.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))
    return pos;
  if ($pos.parentOffset == 0)
    for (let d = $pos.depth - 1; d >= 0; d--) {
      let index2 = $pos.index(d);
      if ($pos.node(d).canReplaceWith(index2, index2, nodeType))
        return $pos.before(d + 1);
      if (index2 > 0)
        return null;
    }
  if ($pos.parentOffset == $pos.parent.content.size)
    for (let d = $pos.depth - 1; d >= 0; d--) {
      let index2 = $pos.indexAfter(d);
      if ($pos.node(d).canReplaceWith(index2, index2, nodeType))
        return $pos.after(d + 1);
      if (index2 < $pos.node(d).childCount)
        return null;
    }
  return null;
}
function dropPoint(doc3, pos, slice2) {
  let $pos = doc3.resolve(pos);
  if (!slice2.content.size)
    return pos;
  let content = slice2.content;
  for (let i = 0; i < slice2.openStart; i++)
    content = content.firstChild.content;
  for (let pass = 1; pass <= (slice2.openStart == 0 && slice2.size ? 2 : 1); pass++) {
    for (let d = $pos.depth; d >= 0; d--) {
      let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
      let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
      let parent = $pos.node(d), fits = false;
      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content);
      } else {
        let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }
      if (fits)
        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
    }
  }
  return null;
}
function replaceStep(doc3, from2, to = from2, slice2 = Slice.empty) {
  if (from2 == to && !slice2.size)
    return null;
  let $from = doc3.resolve(from2), $to = doc3.resolve(to);
  if (fitsTrivially($from, $to, slice2))
    return new ReplaceStep(from2, to, slice2);
  return new Fitter($from, $to, slice2).fit();
}
function fitsTrivially($from, $to, slice2) {
  return !slice2.openStart && !slice2.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice2.content);
}
var Fitter = class {
  constructor($from, $to, unplaced) {
    this.$from = $from;
    this.$to = $to;
    this.unplaced = unplaced;
    this.frontier = [];
    this.placed = Fragment12.empty;
    for (let i = 0; i <= $from.depth; i++) {
      let node = $from.node(i);
      this.frontier.push({
        type: node.type,
        match: node.contentMatchAt($from.indexAfter(i))
      });
    }
    for (let i = $from.depth; i > 0; i--)
      this.placed = Fragment12.from($from.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    while (this.unplaced.size) {
      let fit = this.findFittable();
      if (fit)
        this.placeNodes(fit);
      else
        this.openMore() || this.dropNode();
    }
    let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
    let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
    if (!$to)
      return null;
    let content = this.placed, openStart = $from.depth, openEnd = $to.depth;
    while (openStart && openEnd && content.childCount == 1) {
      content = content.firstChild.content;
      openStart--;
      openEnd--;
    }
    let slice2 = new Slice(content, openStart, openEnd);
    if (moveInline > -1)
      return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice2, placedSize);
    if (slice2.size || $from.pos != this.$to.pos)
      return new ReplaceStep($from.pos, $to.pos, slice2);
    return null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let startDepth = this.unplaced.openStart;
    for (let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {
      let node = cur.firstChild;
      if (cur.childCount > 1)
        openEnd = 0;
      if (node.type.spec.isolating && openEnd <= d) {
        startDepth = d;
        break;
      }
      cur = node.content;
    }
    for (let pass = 1; pass <= 2; pass++) {
      for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
        let fragment, parent = null;
        if (sliceDepth) {
          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
          fragment = parent.content;
        } else {
          fragment = this.unplaced.content;
        }
        let first2 = fragment.firstChild;
        for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
          let { type, match } = this.frontier[frontierDepth], wrap3, inject = null;
          if (pass == 1 && (first2 ? match.matchType(first2.type) || (inject = match.fillBefore(Fragment12.from(first2), false)) : parent && type.compatibleContent(parent.type)))
            return { sliceDepth, frontierDepth, parent, inject };
          else if (pass == 2 && first2 && (wrap3 = match.findWrapping(first2.type)))
            return { sliceDepth, frontierDepth, parent, wrap: wrap3 };
          if (parent && match.matchType(parent.type))
            break;
        }
      }
    }
  }
  openMore() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (!inner.childCount || inner.firstChild.isLeaf)
      return false;
    this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
    return true;
  }
  dropNode() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (inner.childCount <= 1 && openStart > 0) {
      let openAtEnd = content.size - openStart <= openStart + inner.size;
      this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
    } else {
      this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
    }
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap: wrap3 }) {
    while (this.depth > frontierDepth)
      this.closeFrontierNode();
    if (wrap3)
      for (let i = 0; i < wrap3.length; i++)
        this.openFrontierNode(wrap3[i]);
    let slice2 = this.unplaced, fragment = parent ? parent.content : slice2.content;
    let openStart = slice2.openStart - sliceDepth;
    let taken = 0, add = [];
    let { match, type } = this.frontier[frontierDepth];
    if (inject) {
      for (let i = 0; i < inject.childCount; i++)
        add.push(inject.child(i));
      match = match.matchFragment(inject);
    }
    let openEndCount = fragment.size + sliceDepth - (slice2.content.size - slice2.openEnd);
    while (taken < fragment.childCount) {
      let next = fragment.child(taken), matches2 = match.matchType(next.type);
      if (!matches2)
        break;
      taken++;
      if (taken > 1 || openStart == 0 || next.content.size) {
        match = matches2;
        add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
      }
    }
    let toEnd = taken == fragment.childCount;
    if (!toEnd)
      openEndCount = -1;
    this.placed = addToFragment(this.placed, frontierDepth, Fragment12.from(add));
    this.frontier[frontierDepth].match = match;
    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
      this.closeFrontierNode();
    for (let i = 0, cur = fragment; i < openEndCount; i++) {
      let node = cur.lastChild;
      this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });
      cur = node.content;
    }
    this.unplaced = !toEnd ? new Slice(dropFromFragment(slice2.content, sliceDepth, taken), slice2.openStart, slice2.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice2.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice2.openEnd : sliceDepth - 1);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let top = this.frontier[this.depth], level;
    if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)
      return -1;
    let { depth } = this.$to, after = this.$to.after(depth);
    while (depth > 1 && after == this.$to.end(--depth))
      ++after;
    return after;
  }
  findCloseLevel($to) {
    scan: for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {
      let { match, type } = this.frontier[i];
      let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
      let fit = contentAfterFits($to, i, type, match, dropInner);
      if (!fit)
        continue;
      for (let d = i - 1; d >= 0; d--) {
        let { match: match2, type: type2 } = this.frontier[d];
        let matches2 = contentAfterFits($to, d, type2, match2, true);
        if (!matches2 || matches2.childCount)
          continue scan;
      }
      return { depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };
    }
  }
  close($to) {
    let close2 = this.findCloseLevel($to);
    if (!close2)
      return null;
    while (this.depth > close2.depth)
      this.closeFrontierNode();
    if (close2.fit.childCount)
      this.placed = addToFragment(this.placed, close2.depth, close2.fit);
    $to = close2.move;
    for (let d = close2.depth + 1; d <= $to.depth; d++) {
      let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
      this.openFrontierNode(node.type, node.attrs, add);
    }
    return $to;
  }
  openFrontierNode(type, attrs = null, content) {
    let top = this.frontier[this.depth];
    top.match = top.match.matchType(type);
    this.placed = addToFragment(this.placed, this.depth, Fragment12.from(type.create(attrs, content)));
    this.frontier.push({ type, match: type.contentMatch });
  }
  closeFrontierNode() {
    let open = this.frontier.pop();
    let add = open.match.fillBefore(Fragment12.empty, true);
    if (add.childCount)
      this.placed = addToFragment(this.placed, this.frontier.length, add);
  }
};
function dropFromFragment(fragment, depth, count3) {
  if (depth == 0)
    return fragment.cutByIndex(count3, fragment.childCount);
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count3)));
}
function addToFragment(fragment, depth, content) {
  if (depth == 0)
    return fragment.append(content);
  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
}
function contentAt(fragment, depth) {
  for (let i = 0; i < depth; i++)
    fragment = fragment.firstChild.content;
  return fragment;
}
function closeNodeStart(node, openStart, openEnd) {
  if (openStart <= 0)
    return node;
  let frag = node.content;
  if (openStart > 1)
    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
  if (openStart > 0) {
    frag = node.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0)
      frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment12.empty, true));
  }
  return node.copy(frag);
}
function contentAfterFits($to, depth, type, match, open) {
  let node = $to.node(depth), index2 = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index2 == node.childCount && !type.compatibleContent(node.type))
    return null;
  let fit = match.fillBefore(node.content, true, index2);
  return fit && !invalidMarks(type, node.content, index2) ? fit : null;
}
function invalidMarks(type, fragment, start) {
  for (let i = start; i < fragment.childCount; i++)
    if (!type.allowsMarks(fragment.child(i).marks))
      return true;
  return false;
}
function definesContent(type) {
  return type.spec.defining || type.spec.definingForContent;
}
function replaceRange(tr2, from2, to, slice2) {
  if (!slice2.size)
    return tr2.deleteRange(from2, to);
  let $from = tr2.doc.resolve(from2), $to = tr2.doc.resolve(to);
  if (fitsTrivially($from, $to, slice2))
    return tr2.step(new ReplaceStep(from2, to, slice2));
  let targetDepths = coveredDepths($from, $to);
  if (targetDepths[targetDepths.length - 1] == 0)
    targetDepths.pop();
  let preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
    let spec = $from.node(d).type.spec;
    if (spec.defining || spec.definingAsContext || spec.isolating)
      break;
    if (targetDepths.indexOf(d) > -1)
      preferredTarget = d;
    else if ($from.before(d) == pos)
      targetDepths.splice(1, 0, -d);
  }
  let preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  let leftNodes = [], preferredDepth = slice2.openStart;
  for (let content = slice2.content, i = 0; ; i++) {
    let node = content.firstChild;
    leftNodes.push(node);
    if (i == slice2.openStart)
      break;
    content = node.content;
  }
  for (let d = preferredDepth - 1; d >= 0; d--) {
    let leftNode = leftNodes[d], def = definesContent(leftNode.type);
    if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))
      preferredDepth = d;
    else if (def || !leftNode.type.isTextblock)
      break;
  }
  for (let j = slice2.openStart; j >= 0; j--) {
    let openDepth = (j + preferredDepth + 1) % (slice2.openStart + 1);
    let insert = leftNodes[openDepth];
    if (!insert)
      continue;
    for (let i = 0; i < targetDepths.length; i++) {
      let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true;
      if (targetDepth < 0) {
        expand = false;
        targetDepth = -targetDepth;
      }
      let parent = $from.node(targetDepth - 1), index2 = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index2, index2, insert.type, insert.marks))
        return tr2.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice2.content, 0, slice2.openStart, openDepth), openDepth, slice2.openEnd));
    }
  }
  let startSteps = tr2.steps.length;
  for (let i = targetDepths.length - 1; i >= 0; i--) {
    tr2.replace(from2, to, slice2);
    if (tr2.steps.length > startSteps)
      break;
    let depth = targetDepths[i];
    if (depth < 0)
      continue;
    from2 = $from.before(depth);
    to = $to.after(depth);
  }
}
function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    let first2 = fragment.firstChild;
    fragment = fragment.replaceChild(0, first2.copy(closeFragment(first2.content, depth + 1, oldOpen, newOpen, first2)));
  }
  if (depth > newOpen) {
    let match = parent.contentMatchAt(0);
    let start = match.fillBefore(fragment).append(fragment);
    fragment = start.append(match.matchFragment(start).fillBefore(Fragment12.empty, true));
  }
  return fragment;
}
function replaceRangeWith(tr2, from2, to, node) {
  if (!node.isInline && from2 == to && tr2.doc.resolve(from2).parent.content.size) {
    let point = insertPoint(tr2.doc, from2, node.type);
    if (point != null)
      from2 = to = point;
  }
  tr2.replaceRange(from2, to, new Slice(Fragment12.from(node), 0, 0));
}
function deleteRange(tr2, from2, to) {
  let $from = tr2.doc.resolve(from2), $to = tr2.doc.resolve(to);
  let covered = coveredDepths($from, $to);
  for (let i = 0; i < covered.length; i++) {
    let depth = covered[i], last2 = i == covered.length - 1;
    if (last2 && depth == 0 || $from.node(depth).type.contentMatch.validEnd)
      return tr2.delete($from.start(depth), $to.end(depth));
    if (depth > 0 && (last2 || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
      return tr2.delete($from.before(depth), $to.after(depth));
  }
  for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {
    if (from2 - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d && $from.start(d - 1) == $to.start(d - 1) && $from.node(d - 1).canReplace($from.index(d - 1), $to.index(d - 1)))
      return tr2.delete($from.before(d), to);
  }
  tr2.delete(from2, to);
}
function coveredDepths($from, $to) {
  let result = [], minDepth = Math.min($from.depth, $to.depth);
  for (let d = minDepth; d >= 0; d--) {
    let start = $from.start(d);
    if (start < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating)
      break;
    if (start == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start - 1)
      result.push(d);
  }
  return result;
}
var AttrStep = class _AttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(pos, attr, value) {
    super();
    this.pos = pos;
    this.attr = attr;
    this.value = value;
  }
  apply(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at attribute step's position");
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let name in node.attrs)
      attrs[name] = node.attrs[name];
    attrs[this.attr] = this.value;
    let updated = node.type.create(attrs, null, node.marks);
    return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment12.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc3) {
    return new _AttrStep(this.pos, this.attr, doc3.nodeAt(this.pos).attrs[this.attr]);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new _AttrStep(pos.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(schema, json) {
    if (typeof json.pos != "number" || typeof json.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new _AttrStep(json.pos, json.attr, json.value);
  }
};
Step.jsonID("attr", AttrStep);
var DocAttrStep = class _DocAttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(attr, value) {
    super();
    this.attr = attr;
    this.value = value;
  }
  apply(doc3) {
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let name in doc3.attrs)
      attrs[name] = doc3.attrs[name];
    attrs[this.attr] = this.value;
    let updated = doc3.type.create(attrs, doc3.content, doc3.marks);
    return StepResult.ok(updated);
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc3) {
    return new _DocAttrStep(this.attr, doc3.attrs[this.attr]);
  }
  map(mapping) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(schema, json) {
    if (typeof json.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new _DocAttrStep(json.attr, json.value);
  }
};
Step.jsonID("docAttr", DocAttrStep);
var TransformError = class extends Error {
};
TransformError = function TransformError2(message) {
  let err = Error.call(this, message);
  err.__proto__ = TransformError2.prototype;
  return err;
};
TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";
var Transform = class {
  /**
  Create a transform that starts with the given document.
  */
  constructor(doc3) {
    this.doc = doc3;
    this.steps = [];
    this.docs = [];
    this.mapping = new Mapping();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(step) {
    let result = this.maybeStep(step);
    if (result.failed)
      throw new TransformError(result.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(step) {
    let result = step.apply(this.doc);
    if (!result.failed)
      this.addStep(step, result.doc);
    return result;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  Return a single range, in post-transform document positions,
  that covers all content changed by this transform. Returns null
  if no replacements are made. Note that this will ignore changes
  that add/remove marks without replacing the underlying content.
  */
  changedRange() {
    let from2 = 1e9, to = -1e9;
    for (let i = 0; i < this.mapping.maps.length; i++) {
      let map2 = this.mapping.maps[i];
      if (i) {
        from2 = map2.map(from2, 1);
        to = map2.map(to, -1);
      }
      map2.forEach((_f, _t, fromB, toB) => {
        from2 = Math.min(from2, fromB);
        to = Math.max(to, toB);
      });
    }
    return from2 == 1e9 ? null : { from: from2, to };
  }
  /**
  @internal
  */
  addStep(step, doc3) {
    this.docs.push(this.doc);
    this.steps.push(step);
    this.mapping.appendMap(step.getMap());
    this.doc = doc3;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(from2, to = from2, slice2 = Slice.empty) {
    let step = replaceStep(this.doc, from2, to, slice2);
    if (step)
      this.step(step);
    return this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(from2, to, content) {
    return this.replace(from2, to, new Slice(Fragment12.from(content), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(from2, to) {
    return this.replace(from2, to, Slice.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(pos, content) {
    return this.replaceWith(pos, pos, content);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(from2, to, slice2) {
    replaceRange(this, from2, to, slice2);
    return this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(from2, to, node) {
    replaceRangeWith(this, from2, to, node);
    return this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(from2, to) {
    deleteRange(this, from2, to);
    return this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(range, target) {
    lift(this, range, target);
    return this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(pos, depth = 1) {
    join(this, pos, depth);
    return this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(range, wrappers) {
    wrap2(this, range, wrappers);
    return this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(from2, to = from2, type, attrs = null) {
    setBlockType(this, from2, to, type, attrs);
    return this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(pos, type, attrs = null, marks) {
    setNodeMarkup(this, pos, type, attrs, marks);
    return this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(pos, attr, value) {
    this.step(new AttrStep(pos, attr, value));
    return this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(attr, value) {
    this.step(new DocAttrStep(attr, value));
    return this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(pos, mark) {
    this.step(new AddNodeMarkStep(pos, mark));
    return this;
  }
  /**
  Remove a mark (or all marks of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(pos, mark) {
    let node = this.doc.nodeAt(pos);
    if (!node)
      throw new RangeError("No node at position " + pos);
    if (mark instanceof Mark) {
      if (mark.isInSet(node.marks))
        this.step(new RemoveNodeMarkStep(pos, mark));
    } else {
      let set = node.marks, found2, steps = [];
      while (found2 = mark.isInSet(set)) {
        steps.push(new RemoveNodeMarkStep(pos, found2));
        set = found2.removeFromSet(set);
      }
      for (let i = steps.length - 1; i >= 0; i--)
        this.step(steps[i]);
    }
    return this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split (with the outermost nodes coming first).
  */
  split(pos, depth = 1, typesAfter) {
    split(this, pos, depth, typesAfter);
    return this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(from2, to, mark) {
    addMark(this, from2, to, mark);
    return this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(from2, to, mark) {
    removeMark(this, from2, to, mark);
    return this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(pos, parentType, match) {
    clearIncompatible(this, pos, parentType, match);
    return this;
  }
};

// ../node_modules/prosemirror-state/dist/index.js
var classesById = /* @__PURE__ */ Object.create(null);
var Selection = class {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor($anchor, $head, ranges) {
    this.$anchor = $anchor;
    this.$head = $head;
    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++)
      if (ranges[i].$from.pos != ranges[i].$to.pos)
        return false;
    return true;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, true);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(tr2, content = Slice.empty) {
    let lastNode = content.content.lastChild, lastParent = null;
    for (let i = 0; i < content.openEnd; i++) {
      lastParent = lastNode;
      lastNode = lastNode.lastChild;
    }
    let mapFrom = tr2.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr2.mapping.slice(mapFrom);
      tr2.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);
      if (i == 0)
        selectionToInsertionEnd(tr2, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(tr2, node) {
    let mapFrom = tr2.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr2.mapping.slice(mapFrom);
      let from2 = mapping.map($from.pos), to = mapping.map($to.pos);
      if (i) {
        tr2.deleteRange(from2, to);
      } else {
        tr2.replaceRangeWith(from2, to, node);
        selectionToInsertionEnd(tr2, mapFrom, node.isInline ? -1 : 1);
      }
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom($pos, dir, textOnly = false) {
    let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
    if (inner)
      return inner;
    for (let depth = $pos.depth - 1; depth >= 0; depth--) {
      let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
      if (found2)
        return found2;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near($pos, bias = 1) {
    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(doc3) {
    return findSelectionIn(doc3, doc3, 0, 0, 1) || new AllSelection(doc3);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(doc3) {
    return findSelectionIn(doc3, doc3, doc3.content.size, doc3.childCount, -1) || new AllSelection(doc3);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(doc3, json) {
    if (!json || !json.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let cls = classesById[json.type];
    if (!cls)
      throw new RangeError(`No selection type ${json.type} defined`);
    return cls.fromJSON(doc3, json);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(id, selectionClass) {
    if (id in classesById)
      throw new RangeError("Duplicate use of selection JSON ID " + id);
    classesById[id] = selectionClass;
    selectionClass.prototype.jsonID = id;
    return selectionClass;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return TextSelection.between(this.$anchor, this.$head).getBookmark();
  }
};
Selection.prototype.visible = true;
var SelectionRange = class {
  /**
  Create a range.
  */
  constructor($from, $to) {
    this.$from = $from;
    this.$to = $to;
  }
};
var warnedAboutTextSelection = false;
function checkTextSelection($pos) {
  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
    warnedAboutTextSelection = true;
    console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
  }
}
var TextSelection = class _TextSelection extends Selection {
  /**
  Construct a text selection between the given points.
  */
  constructor($anchor, $head = $anchor) {
    checkTextSelection($anchor);
    checkTextSelection($head);
    super($anchor, $head);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(doc3, mapping) {
    let $head = doc3.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent)
      return Selection.near($head);
    let $anchor = doc3.resolve(mapping.map(this.anchor));
    return new _TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
  }
  replace(tr2, content = Slice.empty) {
    super.replace(tr2, content);
    if (content == Slice.empty) {
      let marks = this.$from.marksAcross(this.$to);
      if (marks)
        tr2.ensureMarks(marks);
    }
  }
  eq(other) {
    return other instanceof _TextSelection && other.anchor == this.anchor && other.head == this.head;
  }
  getBookmark() {
    return new TextBookmark(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(doc3, json) {
    if (typeof json.anchor != "number" || typeof json.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new _TextSelection(doc3.resolve(json.anchor), doc3.resolve(json.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(doc3, anchor, head = anchor) {
    let $anchor = doc3.resolve(anchor);
    return new this($anchor, head == anchor ? $anchor : doc3.resolve(head));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between($anchor, $head, bias) {
    let dPos = $anchor.pos - $head.pos;
    if (!bias || dPos)
      bias = dPos >= 0 ? 1 : -1;
    if (!$head.parent.inlineContent) {
      let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
      if (found2)
        $head = found2.$head;
      else
        return Selection.near($head, bias);
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
        if ($anchor.pos < $head.pos != dPos < 0)
          $anchor = $head;
      }
    }
    return new _TextSelection($anchor, $head);
  }
};
Selection.jsonID("text", TextSelection);
var TextBookmark = class _TextBookmark {
  constructor(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  map(mapping) {
    return new _TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
  }
  resolve(doc3) {
    return TextSelection.between(doc3.resolve(this.anchor), doc3.resolve(this.head));
  }
};
var NodeSelection = class _NodeSelection extends Selection {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor($pos) {
    let node = $pos.nodeAfter;
    let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
    super($pos, $end);
    this.node = node;
  }
  map(doc3, mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    let $pos = doc3.resolve(pos);
    if (deleted)
      return Selection.near($pos);
    return new _NodeSelection($pos);
  }
  content() {
    return new Slice(Fragment12.from(this.node), 0, 0);
  }
  eq(other) {
    return other instanceof _NodeSelection && other.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new NodeBookmark(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(doc3, json) {
    if (typeof json.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new _NodeSelection(doc3.resolve(json.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(doc3, from2) {
    return new _NodeSelection(doc3.resolve(from2));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(node) {
    return !node.isText && node.type.spec.selectable !== false;
  }
};
NodeSelection.prototype.visible = false;
Selection.jsonID("node", NodeSelection);
var NodeBookmark = class _NodeBookmark {
  constructor(anchor) {
    this.anchor = anchor;
  }
  map(mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    return deleted ? new TextBookmark(pos, pos) : new _NodeBookmark(pos);
  }
  resolve(doc3) {
    let $pos = doc3.resolve(this.anchor), node = $pos.nodeAfter;
    if (node && NodeSelection.isSelectable(node))
      return new NodeSelection($pos);
    return Selection.near($pos);
  }
};
var AllSelection = class _AllSelection extends Selection {
  /**
  Create an all-selection over the given document.
  */
  constructor(doc3) {
    super(doc3.resolve(0), doc3.resolve(doc3.content.size));
  }
  replace(tr2, content = Slice.empty) {
    if (content == Slice.empty) {
      tr2.delete(0, tr2.doc.content.size);
      let sel = Selection.atStart(tr2.doc);
      if (!sel.eq(tr2.selection))
        tr2.setSelection(sel);
    } else {
      super.replace(tr2, content);
    }
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(doc3) {
    return new _AllSelection(doc3);
  }
  map(doc3) {
    return new _AllSelection(doc3);
  }
  eq(other) {
    return other instanceof _AllSelection;
  }
  getBookmark() {
    return AllBookmark;
  }
};
Selection.jsonID("all", AllSelection);
var AllBookmark = {
  map() {
    return this;
  },
  resolve(doc3) {
    return new AllSelection(doc3);
  }
};
function findSelectionIn(doc3, node, pos, index2, dir, text = false) {
  if (node.inlineContent)
    return TextSelection.create(doc3, pos);
  for (let i = index2 - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {
    let child = node.child(i);
    if (!child.isAtom) {
      let inner = findSelectionIn(doc3, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
      if (inner)
        return inner;
    } else if (!text && NodeSelection.isSelectable(child)) {
      return NodeSelection.create(doc3, pos - (dir < 0 ? child.nodeSize : 0));
    }
    pos += child.nodeSize * dir;
  }
  return null;
}
function selectionToInsertionEnd(tr2, startLen, bias) {
  let last2 = tr2.steps.length - 1;
  if (last2 < startLen)
    return;
  let step = tr2.steps[last2];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))
    return;
  let map2 = tr2.mapping.maps[last2], end;
  map2.forEach((_from, _to, _newFrom, newTo) => {
    if (end == null)
      end = newTo;
  });
  tr2.setSelection(Selection.near(tr2.doc.resolve(end), bias));
}
var UPDATED_SEL = 1;
var UPDATED_MARKS = 2;
var UPDATED_SCROLL = 4;
var Transaction2 = class extends Transform {
  /**
  @internal
  */
  constructor(state) {
    super(state.doc);
    this.curSelectionFor = 0;
    this.updated = 0;
    this.meta = /* @__PURE__ */ Object.create(null);
    this.time = Date.now();
    this.curSelection = state.selection;
    this.storedMarks = state.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    if (this.curSelectionFor < this.steps.length) {
      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
      this.curSelectionFor = this.steps.length;
    }
    return this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(selection) {
    if (selection.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    this.curSelection = selection;
    this.curSelectionFor = this.steps.length;
    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
    this.storedMarks = null;
    return this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & UPDATED_SEL) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(marks) {
    this.storedMarks = marks;
    this.updated |= UPDATED_MARKS;
    return this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(marks) {
    if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
      this.setStoredMarks(marks);
    return this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(mark) {
    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(mark) {
    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & UPDATED_MARKS) > 0;
  }
  /**
  @internal
  */
  addStep(step, doc3) {
    super.addStep(step, doc3);
    this.updated = this.updated & ~UPDATED_MARKS;
    this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(time) {
    this.time = time;
    return this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(slice2) {
    this.selection.replace(this, slice2);
    return this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(node, inheritMarks = true) {
    let selection = this.selection;
    if (inheritMarks)
      node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark.none));
    selection.replaceWith(this, node);
    return this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    this.selection.replace(this);
    return this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(text, from2, to) {
    let schema = this.doc.type.schema;
    if (from2 == null) {
      if (!text)
        return this.deleteSelection();
      return this.replaceSelectionWith(schema.text(text), true);
    } else {
      if (to == null)
        to = from2;
      if (!text)
        return this.deleteRange(from2, to);
      let marks = this.storedMarks;
      if (!marks) {
        let $from = this.doc.resolve(from2);
        marks = to == from2 ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
      }
      this.replaceRangeWith(from2, to, schema.text(text, marks));
      if (!this.selection.empty && this.selection.to == from2 + text.length)
        this.setSelection(Selection.near(this.selection.$to));
      return this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(key, value) {
    this.meta[typeof key == "string" ? key : key.key] = value;
    return this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(key) {
    return this.meta[typeof key == "string" ? key : key.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let _ in this.meta)
      return false;
    return true;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    this.updated |= UPDATED_SCROLL;
    return this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & UPDATED_SCROLL) > 0;
  }
};
function bind2(f, self2) {
  return !self2 || !f ? f : f.bind(self2);
}
var FieldDesc = class {
  constructor(name, desc, self2) {
    this.name = name;
    this.init = bind2(desc.init, self2);
    this.apply = bind2(desc.apply, self2);
  }
};
var baseFields = [
  new FieldDesc("doc", {
    init(config) {
      return config.doc || config.schema.topNodeType.createAndFill();
    },
    apply(tr2) {
      return tr2.doc;
    }
  }),
  new FieldDesc("selection", {
    init(config, instance) {
      return config.selection || Selection.atStart(instance.doc);
    },
    apply(tr2) {
      return tr2.selection;
    }
  }),
  new FieldDesc("storedMarks", {
    init(config) {
      return config.storedMarks || null;
    },
    apply(tr2, _marks, _old, state) {
      return state.selection.$cursor ? tr2.storedMarks : null;
    }
  }),
  new FieldDesc("scrollToSelection", {
    init() {
      return 0;
    },
    apply(tr2, prev) {
      return tr2.scrolledIntoView ? prev + 1 : prev;
    }
  })
];
var Configuration = class {
  constructor(schema, plugins) {
    this.schema = schema;
    this.plugins = [];
    this.pluginsByKey = /* @__PURE__ */ Object.create(null);
    this.fields = baseFields.slice();
    if (plugins)
      plugins.forEach((plugin) => {
        if (this.pluginsByKey[plugin.key])
          throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
        this.plugins.push(plugin);
        this.pluginsByKey[plugin.key] = plugin;
        if (plugin.spec.state)
          this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
      });
  }
};
var EditorState = class _EditorState {
  /**
  @internal
  */
  constructor(config) {
    this.config = config;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(tr2) {
    return this.applyTransaction(tr2).state;
  }
  /**
  @internal
  */
  filterTransaction(tr2, ignore = -1) {
    for (let i = 0; i < this.config.plugins.length; i++)
      if (i != ignore) {
        let plugin = this.config.plugins[i];
        if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr2, this))
          return false;
      }
    return true;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(rootTr) {
    if (!this.filterTransaction(rootTr))
      return { state: this, transactions: [] };
    let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
    for (; ; ) {
      let haveNew = false;
      for (let i = 0; i < this.config.plugins.length; i++) {
        let plugin = this.config.plugins[i];
        if (plugin.spec.appendTransaction) {
          let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
          let tr2 = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
          if (tr2 && newState.filterTransaction(tr2, i)) {
            tr2.setMeta("appendedTransaction", rootTr);
            if (!seen) {
              seen = [];
              for (let j = 0; j < this.config.plugins.length; j++)
                seen.push(j < i ? { state: newState, n: trs.length } : { state: this, n: 0 });
            }
            trs.push(tr2);
            newState = newState.applyInner(tr2);
            haveNew = true;
          }
          if (seen)
            seen[i] = { state: newState, n: trs.length };
        }
      }
      if (!haveNew)
        return { state: newState, transactions: trs };
    }
  }
  /**
  @internal
  */
  applyInner(tr2) {
    if (!tr2.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let newInstance = new _EditorState(this.config), fields = this.config.fields;
    for (let i = 0; i < fields.length; i++) {
      let field = fields[i];
      newInstance[field.name] = field.apply(tr2, this[field.name], this, newInstance);
    }
    return newInstance;
  }
  /**
  Accessor that constructs and returns a new [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new Transaction2(this);
  }
  /**
  Create a new state.
  */
  static create(config) {
    let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
    let instance = new _EditorState($config);
    for (let i = 0; i < $config.fields.length; i++)
      instance[$config.fields[i].name] = $config.fields[i].init(config, instance);
    return instance;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(config) {
    let $config = new Configuration(this.schema, config.plugins);
    let fields = $config.fields, instance = new _EditorState($config);
    for (let i = 0; i < fields.length; i++) {
      let name = fields[i].name;
      instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);
    }
    return instance;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(pluginFields) {
    let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks)
      result.storedMarks = this.storedMarks.map((m) => m.toJSON());
    if (pluginFields && typeof pluginFields == "object")
      for (let prop in pluginFields) {
        if (prop == "doc" || prop == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let plugin = pluginFields[prop], state = plugin.spec.state;
        if (state && state.toJSON)
          result[prop] = state.toJSON.call(plugin, this[plugin.key]);
      }
    return result;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(config, json, pluginFields) {
    if (!json)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!config.schema)
      throw new RangeError("Required config field 'schema' missing");
    let $config = new Configuration(config.schema, config.plugins);
    let instance = new _EditorState($config);
    $config.fields.forEach((field) => {
      if (field.name == "doc") {
        instance.doc = Node2.fromJSON(config.schema, json.doc);
      } else if (field.name == "selection") {
        instance.selection = Selection.fromJSON(instance.doc, json.selection);
      } else if (field.name == "storedMarks") {
        if (json.storedMarks)
          instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
      } else {
        if (pluginFields)
          for (let prop in pluginFields) {
            let plugin = pluginFields[prop], state = plugin.spec.state;
            if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
              instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
              return;
            }
          }
        instance[field.name] = field.init(config, instance);
      }
    });
    return instance;
  }
};
function bindProps(obj, self2, target) {
  for (let prop in obj) {
    let val = obj[prop];
    if (val instanceof Function)
      val = val.bind(self2);
    else if (prop == "handleDOMEvents")
      val = bindProps(val, self2, {});
    target[prop] = val;
  }
  return target;
}
var Plugin = class {
  /**
  Create a plugin.
  */
  constructor(spec) {
    this.spec = spec;
    this.props = {};
    if (spec.props)
      bindProps(spec.props, this, this.props);
    this.key = spec.key ? spec.key.key : createKey("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(state) {
    return state[this.key];
  }
};
var keys = /* @__PURE__ */ Object.create(null);
function createKey(name) {
  if (name in keys)
    return name + "$" + ++keys[name];
  keys[name] = 0;
  return name + "$";
}
var PluginKey = class {
  /**
  Create a plugin key.
  */
  constructor(name = "key") {
    this.key = createKey(name);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(state) {
    return state.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(state) {
    return state[this.key];
  }
};

// ../node_modules/prosemirror-commands/dist/index.js
var deleteSelection = (state, dispatch2) => {
  if (state.selection.empty)
    return false;
  if (dispatch2)
    dispatch2(state.tr.deleteSelection().scrollIntoView());
  return true;
};
function atBlockStart(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0))
    return null;
  return $cursor;
}
var joinBackward = (state, dispatch2, view) => {
  let $cursor = atBlockStart(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutBefore($cursor);
  if (!$cut) {
    let range = $cursor.blockRange(), target = range && liftTarget(range);
    if (target == null)
      return false;
    if (dispatch2)
      dispatch2(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  let before = $cut.nodeBefore;
  if (deleteBarrier(state, $cut, dispatch2, -1))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || NodeSelection.isSelectable(before))) {
    for (let depth = $cursor.depth; ; depth--) {
      let delStep = replaceStep(state.doc, $cursor.before(depth), $cursor.after(depth), Slice.empty);
      if (delStep && delStep.slice.size < delStep.to - delStep.from) {
        if (dispatch2) {
          let tr2 = state.tr.step(delStep);
          tr2.setSelection(textblockAt(before, "end") ? Selection.findFrom(tr2.doc.resolve(tr2.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr2.doc, $cut.pos - before.nodeSize));
          dispatch2(tr2.scrollIntoView());
        }
        return true;
      }
      if (depth == 1 || $cursor.node(depth - 1).childCount > 1)
        break;
    }
  }
  if (before.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch2)
      dispatch2(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
    return true;
  }
  return false;
};
var joinTextblockBackward = (state, dispatch2, view) => {
  let $cursor = atBlockStart(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutBefore($cursor);
  return $cut ? joinTextblocksAround(state, $cut, dispatch2) : false;
};
var joinTextblockForward = (state, dispatch2, view) => {
  let $cursor = atBlockEnd(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutAfter($cursor);
  return $cut ? joinTextblocksAround(state, $cut, dispatch2) : false;
};
function joinTextblocksAround(state, $cut, dispatch2) {
  let before = $cut.nodeBefore, beforeText = before, beforePos = $cut.pos - 1;
  for (; !beforeText.isTextblock; beforePos--) {
    if (beforeText.type.spec.isolating)
      return false;
    let child = beforeText.lastChild;
    if (!child)
      return false;
    beforeText = child;
  }
  let after = $cut.nodeAfter, afterText = after, afterPos = $cut.pos + 1;
  for (; !afterText.isTextblock; afterPos++) {
    if (afterText.type.spec.isolating)
      return false;
    let child = afterText.firstChild;
    if (!child)
      return false;
    afterText = child;
  }
  let step = replaceStep(state.doc, beforePos, afterPos, Slice.empty);
  if (!step || step.from != beforePos || step instanceof ReplaceStep && step.slice.size >= afterPos - beforePos)
    return false;
  if (dispatch2) {
    let tr2 = state.tr.step(step);
    tr2.setSelection(TextSelection.create(tr2.doc, beforePos));
    dispatch2(tr2.scrollIntoView());
  }
  return true;
}
function textblockAt(node, side, only = false) {
  for (let scan = node; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
    if (scan.isTextblock)
      return true;
    if (only && scan.childCount != 1)
      return false;
  }
  return false;
}
var selectNodeBackward = (state, dispatch2, view) => {
  let { $head, empty: empty2 } = state.selection, $cut = $head;
  if (!empty2)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0)
      return false;
    $cut = findCutBefore($head);
  }
  let node = $cut && $cut.nodeBefore;
  if (!node || !NodeSelection.isSelectable(node))
    return false;
  if (dispatch2)
    dispatch2(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
  return true;
};
function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i = $pos.depth - 1; i >= 0; i--) {
      if ($pos.index(i) > 0)
        return $pos.doc.resolve($pos.before(i + 1));
      if ($pos.node(i).type.spec.isolating)
        break;
    }
  return null;
}
function atBlockEnd(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size))
    return null;
  return $cursor;
}
var joinForward = (state, dispatch2, view) => {
  let $cursor = atBlockEnd(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutAfter($cursor);
  if (!$cut)
    return false;
  let after = $cut.nodeAfter;
  if (deleteBarrier(state, $cut, dispatch2, 1))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || NodeSelection.isSelectable(after))) {
    let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch2) {
        let tr2 = state.tr.step(delStep);
        tr2.setSelection(textblockAt(after, "start") ? Selection.findFrom(tr2.doc.resolve(tr2.mapping.map($cut.pos)), 1) : NodeSelection.create(tr2.doc, tr2.mapping.map($cut.pos)));
        dispatch2(tr2.scrollIntoView());
      }
      return true;
    }
  }
  if (after.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch2)
      dispatch2(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
    return true;
  }
  return false;
};
var selectNodeForward = (state, dispatch2, view) => {
  let { $head, empty: empty2 } = state.selection, $cut = $head;
  if (!empty2)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)
      return false;
    $cut = findCutAfter($head);
  }
  let node = $cut && $cut.nodeAfter;
  if (!node || !NodeSelection.isSelectable(node))
    return false;
  if (dispatch2)
    dispatch2(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
  return true;
};
function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i = $pos.depth - 1; i >= 0; i--) {
      let parent = $pos.node(i);
      if ($pos.index(i) + 1 < parent.childCount)
        return $pos.doc.resolve($pos.after(i + 1));
      if (parent.type.spec.isolating)
        break;
    }
  return null;
}
var joinUp = (state, dispatch2) => {
  let sel = state.selection, nodeSel = sel instanceof NodeSelection, point;
  if (nodeSel) {
    if (sel.node.isTextblock || !canJoin(state.doc, sel.from))
      return false;
    point = sel.from;
  } else {
    point = joinPoint(state.doc, sel.from, -1);
    if (point == null)
      return false;
  }
  if (dispatch2) {
    let tr2 = state.tr.join(point);
    if (nodeSel)
      tr2.setSelection(NodeSelection.create(tr2.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));
    dispatch2(tr2.scrollIntoView());
  }
  return true;
};
var joinDown = (state, dispatch2) => {
  let sel = state.selection, point;
  if (sel instanceof NodeSelection) {
    if (sel.node.isTextblock || !canJoin(state.doc, sel.to))
      return false;
    point = sel.to;
  } else {
    point = joinPoint(state.doc, sel.to, 1);
    if (point == null)
      return false;
  }
  if (dispatch2)
    dispatch2(state.tr.join(point).scrollIntoView());
  return true;
};
var lift2 = (state, dispatch2) => {
  let { $from, $to } = state.selection;
  let range = $from.blockRange($to), target = range && liftTarget(range);
  if (target == null)
    return false;
  if (dispatch2)
    dispatch2(state.tr.lift(range, target).scrollIntoView());
  return true;
};
var newlineInCode = (state, dispatch2) => {
  let { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  if (dispatch2)
    dispatch2(state.tr.insertText("\n").scrollIntoView());
  return true;
};
function defaultBlockAt(match) {
  for (let i = 0; i < match.edgeCount; i++) {
    let { type } = match.edge(i);
    if (type.isTextblock && !type.hasRequiredAttrs())
      return type;
  }
  return null;
}
var exitCode = (state, dispatch2) => {
  let { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));
  if (!type || !above.canReplaceWith(after, after, type))
    return false;
  if (dispatch2) {
    let pos = $head.after(), tr2 = state.tr.replaceWith(pos, pos, type.createAndFill());
    tr2.setSelection(Selection.near(tr2.doc.resolve(pos), 1));
    dispatch2(tr2.scrollIntoView());
  }
  return true;
};
var createParagraphNear = (state, dispatch2) => {
  let sel = state.selection, { $from, $to } = sel;
  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)
    return false;
  let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
  if (!type || !type.isTextblock)
    return false;
  if (dispatch2) {
    let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    let tr2 = state.tr.insert(side, type.createAndFill());
    tr2.setSelection(TextSelection.create(tr2.doc, side + 1));
    dispatch2(tr2.scrollIntoView());
  }
  return true;
};
var liftEmptyBlock = (state, dispatch2) => {
  let { $cursor } = state.selection;
  if (!$cursor || $cursor.parent.content.size)
    return false;
  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
    let before = $cursor.before();
    if (canSplit(state.doc, before)) {
      if (dispatch2)
        dispatch2(state.tr.split(before).scrollIntoView());
      return true;
    }
  }
  let range = $cursor.blockRange(), target = range && liftTarget(range);
  if (target == null)
    return false;
  if (dispatch2)
    dispatch2(state.tr.lift(range, target).scrollIntoView());
  return true;
};
function splitBlockAs(splitNode) {
  return (state, dispatch2) => {
    let { $from, $to } = state.selection;
    if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {
      if (!$from.parentOffset || !canSplit(state.doc, $from.pos))
        return false;
      if (dispatch2)
        dispatch2(state.tr.split($from.pos).scrollIntoView());
      return true;
    }
    if (!$from.depth)
      return false;
    let types = [];
    let splitDepth, deflt, atEnd = false, atStart = false;
    for (let d = $from.depth; ; d--) {
      let node = $from.node(d);
      if (node.isBlock) {
        atEnd = $from.end(d) == $from.pos + ($from.depth - d);
        atStart = $from.start(d) == $from.pos - ($from.depth - d);
        deflt = defaultBlockAt($from.node(d - 1).contentMatchAt($from.indexAfter(d - 1)));
        let splitType = splitNode && splitNode($to.parent, atEnd, $from);
        types.unshift(splitType || (atEnd && deflt ? { type: deflt } : null));
        splitDepth = d;
        break;
      } else {
        if (d == 1)
          return false;
        types.unshift(null);
      }
    }
    let tr2 = state.tr;
    if (state.selection instanceof TextSelection || state.selection instanceof AllSelection)
      tr2.deleteSelection();
    let splitPos = tr2.mapping.map($from.pos);
    let can = canSplit(tr2.doc, splitPos, types.length, types);
    if (!can) {
      types[0] = deflt ? { type: deflt } : null;
      can = canSplit(tr2.doc, splitPos, types.length, types);
    }
    if (!can)
      return false;
    tr2.split(splitPos, types.length, types);
    if (!atEnd && atStart && $from.node(splitDepth).type != deflt) {
      let first2 = tr2.mapping.map($from.before(splitDepth)), $first = tr2.doc.resolve(first2);
      if (deflt && $from.node(splitDepth - 1).canReplaceWith($first.index(), $first.index() + 1, deflt))
        tr2.setNodeMarkup(tr2.mapping.map($from.before(splitDepth)), deflt);
    }
    if (dispatch2)
      dispatch2(tr2.scrollIntoView());
    return true;
  };
}
var splitBlock = splitBlockAs();
var selectParentNode = (state, dispatch2) => {
  let { $from, to } = state.selection, pos;
  let same = $from.sharedDepth(to);
  if (same == 0)
    return false;
  pos = $from.before(same);
  if (dispatch2)
    dispatch2(state.tr.setSelection(NodeSelection.create(state.doc, pos)));
  return true;
};
var selectAll = (state, dispatch2) => {
  if (dispatch2)
    dispatch2(state.tr.setSelection(new AllSelection(state.doc)));
  return true;
};
function joinMaybeClear(state, $pos, dispatch2) {
  let before = $pos.nodeBefore, after = $pos.nodeAfter, index2 = $pos.index();
  if (!before || !after || !before.type.compatibleContent(after.type))
    return false;
  if (!before.content.size && $pos.parent.canReplace(index2 - 1, index2)) {
    if (dispatch2)
      dispatch2(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
    return true;
  }
  if (!$pos.parent.canReplace(index2, index2 + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))
    return false;
  if (dispatch2)
    dispatch2(state.tr.join($pos.pos).scrollIntoView());
  return true;
}
function deleteBarrier(state, $cut, dispatch2, dir) {
  let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;
  let isolated = before.type.spec.isolating || after.type.spec.isolating;
  if (!isolated && joinMaybeClear(state, $cut, dispatch2))
    return true;
  let canDelAfter = !isolated && $cut.parent.canReplace($cut.index(), $cut.index() + 1);
  if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {
    if (dispatch2) {
      let end = $cut.pos + after.nodeSize, wrap3 = Fragment12.empty;
      for (let i = conn.length - 1; i >= 0; i--)
        wrap3 = Fragment12.from(conn[i].create(null, wrap3));
      wrap3 = Fragment12.from(before.copy(wrap3));
      let tr2 = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap3, 1, 0), conn.length, true));
      let $joinAt = tr2.doc.resolve(end + 2 * conn.length);
      if ($joinAt.nodeAfter && $joinAt.nodeAfter.type == before.type && canJoin(tr2.doc, $joinAt.pos))
        tr2.join($joinAt.pos);
      dispatch2(tr2.scrollIntoView());
    }
    return true;
  }
  let selAfter = after.type.spec.isolating || dir > 0 && isolated ? null : Selection.findFrom($cut, 1);
  let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);
  if (target != null && target >= $cut.depth) {
    if (dispatch2)
      dispatch2(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
    let at2 = before, wrap3 = [];
    for (; ; ) {
      wrap3.push(at2);
      if (at2.isTextblock)
        break;
      at2 = at2.lastChild;
    }
    let afterText = after, afterDepth = 1;
    for (; !afterText.isTextblock; afterText = afterText.firstChild)
      afterDepth++;
    if (at2.canReplace(at2.childCount, at2.childCount, afterText.content)) {
      if (dispatch2) {
        let end = Fragment12.empty;
        for (let i = wrap3.length - 1; i >= 0; i--)
          end = Fragment12.from(wrap3[i].copy(end));
        let tr2 = state.tr.step(new ReplaceAroundStep($cut.pos - wrap3.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end, wrap3.length, 0), 0, true));
        dispatch2(tr2.scrollIntoView());
      }
      return true;
    }
  }
  return false;
}
function selectTextblockSide(side) {
  return function(state, dispatch2) {
    let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
    let depth = $pos.depth;
    while ($pos.node(depth).isInline) {
      if (!depth)
        return false;
      depth--;
    }
    if (!$pos.node(depth).isTextblock)
      return false;
    if (dispatch2)
      dispatch2(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
    return true;
  };
}
var selectTextblockStart = selectTextblockSide(-1);
var selectTextblockEnd = selectTextblockSide(1);
function wrapIn(nodeType, attrs = null) {
  return function(state, dispatch2) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs);
    if (!wrapping)
      return false;
    if (dispatch2)
      dispatch2(state.tr.wrap(range, wrapping).scrollIntoView());
    return true;
  };
}
function setBlockType2(nodeType, attrs = null) {
  return function(state, dispatch2) {
    let applicable = false;
    for (let i = 0; i < state.selection.ranges.length && !applicable; i++) {
      let { $from: { pos: from2 }, $to: { pos: to } } = state.selection.ranges[i];
      state.doc.nodesBetween(from2, to, (node, pos) => {
        if (applicable)
          return false;
        if (!node.isTextblock || node.hasMarkup(nodeType, attrs))
          return;
        if (node.type == nodeType) {
          applicable = true;
        } else {
          let $pos = state.doc.resolve(pos), index2 = $pos.index();
          applicable = $pos.parent.canReplaceWith(index2, index2 + 1, nodeType);
        }
      });
    }
    if (!applicable)
      return false;
    if (dispatch2) {
      let tr2 = state.tr;
      for (let i = 0; i < state.selection.ranges.length; i++) {
        let { $from: { pos: from2 }, $to: { pos: to } } = state.selection.ranges[i];
        tr2.setBlockType(from2, to, nodeType, attrs);
      }
      dispatch2(tr2.scrollIntoView());
    }
    return true;
  };
}
function chainCommands(...commands) {
  return function(state, dispatch2, view) {
    for (let i = 0; i < commands.length; i++)
      if (commands[i](state, dispatch2, view))
        return true;
    return false;
  };
}
var backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
var del = chainCommands(deleteSelection, joinForward, selectNodeForward);
var pcBaseKeymap = {
  "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
  "Mod-Enter": exitCode,
  "Backspace": backspace,
  "Mod-Backspace": backspace,
  "Shift-Backspace": backspace,
  "Delete": del,
  "Mod-Delete": del,
  "Mod-a": selectAll
};
var macBaseKeymap = {
  "Ctrl-h": pcBaseKeymap["Backspace"],
  "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
  "Ctrl-d": pcBaseKeymap["Delete"],
  "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
  "Alt-Delete": pcBaseKeymap["Mod-Delete"],
  "Alt-d": pcBaseKeymap["Mod-Delete"],
  "Ctrl-a": selectTextblockStart,
  "Ctrl-e": selectTextblockEnd
};
for (let key in pcBaseKeymap)
  macBaseKeymap[key] = pcBaseKeymap[key];
var mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;

// ../node_modules/prosemirror-schema-list/dist/index.js
function wrapInList(listType, attrs = null) {
  return function(state, dispatch2) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to);
    if (!range)
      return false;
    let tr2 = dispatch2 ? state.tr : null;
    if (!wrapRangeInList(tr2, range, listType, attrs))
      return false;
    if (dispatch2)
      dispatch2(tr2.scrollIntoView());
    return true;
  };
}
function wrapRangeInList(tr2, range, listType, attrs = null) {
  let doJoin = false, outerRange = range, doc3 = range.$from.doc;
  if (range.depth >= 2 && range.$from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
    if (range.$from.index(range.depth - 1) == 0)
      return false;
    let $insert = doc3.resolve(range.start - 2);
    outerRange = new NodeRange($insert, $insert, range.depth);
    if (range.endIndex < range.parent.childCount)
      range = new NodeRange(range.$from, doc3.resolve(range.$to.end(range.depth)), range.depth);
    doJoin = true;
  }
  let wrap3 = findWrapping(outerRange, listType, attrs, range);
  if (!wrap3)
    return false;
  if (tr2)
    doWrapInList(tr2, range, wrap3, doJoin, listType);
  return true;
}
function doWrapInList(tr2, range, wrappers, joinBefore, listType) {
  let content = Fragment12.empty;
  for (let i = wrappers.length - 1; i >= 0; i--)
    content = Fragment12.from(wrappers[i].type.create(wrappers[i].attrs, content));
  tr2.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));
  let found2 = 0;
  for (let i = 0; i < wrappers.length; i++)
    if (wrappers[i].type == listType)
      found2 = i + 1;
  let splitDepth = wrappers.length - found2;
  let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;
  for (let i = range.startIndex, e = range.endIndex, first2 = true; i < e; i++, first2 = false) {
    if (!first2 && canSplit(tr2.doc, splitPos, splitDepth)) {
      tr2.split(splitPos, splitDepth);
      splitPos += 2 * splitDepth;
    }
    splitPos += parent.child(i).nodeSize;
  }
  return tr2;
}
function liftListItem(itemType) {
  return function(state, dispatch2) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    if (!dispatch2)
      return true;
    if ($from.node(range.depth - 1).type == itemType)
      return liftToOuterList(state, dispatch2, itemType, range);
    else
      return liftOutOfList(state, dispatch2, range);
  };
}
function liftToOuterList(state, dispatch2, itemType, range) {
  let tr2 = state.tr, end = range.end, endOfList = range.$to.end(range.depth);
  if (end < endOfList) {
    tr2.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment12.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
    range = new NodeRange(tr2.doc.resolve(range.$from.pos), tr2.doc.resolve(endOfList), range.depth);
  }
  const target = liftTarget(range);
  if (target == null)
    return false;
  tr2.lift(range, target);
  let $after = tr2.doc.resolve(tr2.mapping.map(end, -1) - 1);
  if (canJoin(tr2.doc, $after.pos) && $after.nodeBefore.type == $after.nodeAfter.type)
    tr2.join($after.pos);
  dispatch2(tr2.scrollIntoView());
  return true;
}
function liftOutOfList(state, dispatch2, range) {
  let tr2 = state.tr, list = range.parent;
  for (let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {
    pos -= list.child(i).nodeSize;
    tr2.delete(pos - 1, pos + 1);
  }
  let $start = tr2.doc.resolve(range.start), item = $start.nodeAfter;
  if (tr2.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)
    return false;
  let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;
  let parent = $start.node(-1), indexBefore = $start.index(-1);
  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment12.empty : Fragment12.from(list))))
    return false;
  let start = $start.pos, end = start + item.nodeSize;
  tr2.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new Slice((atStart ? Fragment12.empty : Fragment12.from(list.copy(Fragment12.empty))).append(atEnd ? Fragment12.empty : Fragment12.from(list.copy(Fragment12.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
  dispatch2(tr2.scrollIntoView());
  return true;
}
function sinkListItem(itemType) {
  return function(state, dispatch2) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    let startIndex = range.startIndex;
    if (startIndex == 0)
      return false;
    let parent = range.parent, nodeBefore = parent.child(startIndex - 1);
    if (nodeBefore.type != itemType)
      return false;
    if (dispatch2) {
      let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
      let inner = Fragment12.from(nestedBefore ? itemType.create() : null);
      let slice2 = new Slice(Fragment12.from(itemType.create(null, Fragment12.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
      let before = range.start, after = range.end;
      dispatch2(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice2, 1, true)).scrollIntoView());
    }
    return true;
  };
}

// ../node_modules/prosemirror-view/dist/index.js
var domIndex = function(node) {
  for (var index2 = 0; ; index2++) {
    node = node.previousSibling;
    if (!node)
      return index2;
  }
};
var parentNode = function(node) {
  let parent = node.assignedSlot || node.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent;
};
var reusedRange = null;
var textRange = function(node, from2, to) {
  let range = reusedRange || (reusedRange = document.createRange());
  range.setEnd(node, to == null ? node.nodeValue.length : to);
  range.setStart(node, from2 || 0);
  return range;
};
var clearReusedRange = function() {
  reusedRange = null;
};
var isEquivalentPosition = function(node, off, targetNode, targetOff) {
  return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));
};
var atomElements = /^(img|br|input|textarea|hr)$/i;
function scanFor(node, off, targetNode, targetOff, dir) {
  var _a6;
  for (; ; ) {
    if (node == targetNode && off == targetOff)
      return true;
    if (off == (dir < 0 ? 0 : nodeSize(node))) {
      let parent = node.parentNode;
      if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false")
        return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      let child = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (child.nodeType == 1 && child.contentEditable == "false") {
        if ((_a6 = child.pmViewDesc) === null || _a6 === void 0 ? void 0 : _a6.ignoreForSelection)
          off += dir;
        else
          return false;
      } else {
        node = child;
        off = dir < 0 ? nodeSize(node) : 0;
      }
    } else {
      return false;
    }
  }
}
function nodeSize(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function textNodeBefore$1(node, offset4) {
  for (; ; ) {
    if (node.nodeType == 3 && offset4)
      return node;
    if (node.nodeType == 1 && offset4 > 0) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset4 - 1];
      offset4 = nodeSize(node);
    } else if (node.parentNode && !hasBlockDesc(node)) {
      offset4 = domIndex(node);
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function textNodeAfter$1(node, offset4) {
  for (; ; ) {
    if (node.nodeType == 3 && offset4 < node.nodeValue.length)
      return node;
    if (node.nodeType == 1 && offset4 < node.childNodes.length) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset4];
      offset4 = 0;
    } else if (node.parentNode && !hasBlockDesc(node)) {
      offset4 = domIndex(node) + 1;
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function isOnEdge(node, offset4, parent) {
  for (let atStart = offset4 == 0, atEnd = offset4 == nodeSize(node); atStart || atEnd; ) {
    if (node == parent)
      return true;
    let index2 = domIndex(node);
    node = node.parentNode;
    if (!node)
      return false;
    atStart = atStart && index2 == 0;
    atEnd = atEnd && index2 == nodeSize(node);
  }
}
function hasBlockDesc(dom) {
  let desc;
  for (let cur = dom; cur; cur = cur.parentNode)
    if (desc = cur.pmViewDesc)
      break;
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
}
var selectionCollapsed = function(domSel) {
  return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
};
function keyEvent(keyCode, key) {
  let event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key;
  return event;
}
function deepActiveElement(doc3) {
  let elt = doc3.activeElement;
  while (elt && elt.shadowRoot)
    elt = elt.shadowRoot.activeElement;
  return elt;
}
function caretFromPoint(doc3, x, y) {
  if (doc3.caretPositionFromPoint) {
    try {
      let pos = doc3.caretPositionFromPoint(x, y);
      if (pos)
        return { node: pos.offsetNode, offset: Math.min(nodeSize(pos.offsetNode), pos.offset) };
    } catch (_) {
    }
  }
  if (doc3.caretRangeFromPoint) {
    let range = doc3.caretRangeFromPoint(x, y);
    if (range)
      return { node: range.startContainer, offset: Math.min(nodeSize(range.startContainer), range.startOffset) };
  }
}
var nav = typeof navigator != "undefined" ? navigator : null;
var doc2 = typeof document != "undefined" ? document : null;
var agent = nav && nav.userAgent || "";
var ie_edge = /Edge\/(\d+)/.exec(agent);
var ie_upto10 = /MSIE \d/.exec(agent);
var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
var ie = !!(ie_upto10 || ie_11up || ie_edge);
var ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
var gecko = !ie && /gecko\/(\d+)/i.test(agent);
gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
var _chrome = !ie && /Chrome\/(\d+)/.exec(agent);
var chrome = !!_chrome;
var chrome_version = _chrome ? +_chrome[1] : 0;
var safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);
var ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
var mac2 = ios || (nav ? /Mac/.test(nav.platform) : false);
var windows = nav ? /Win/.test(nav.platform) : false;
var android = /Android \d/.test(agent);
var webkit = !!doc2 && "webkitFontSmoothing" in doc2.documentElement.style;
var webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function windowRect(doc3) {
  let vp = doc3.defaultView && doc3.defaultView.visualViewport;
  if (vp)
    return {
      left: 0,
      right: vp.width,
      top: 0,
      bottom: vp.height
    };
  return {
    left: 0,
    right: doc3.documentElement.clientWidth,
    top: 0,
    bottom: doc3.documentElement.clientHeight
  };
}
function getSide(value, side) {
  return typeof value == "number" ? value : value[side];
}
function clientRect(node) {
  let rect = node.getBoundingClientRect();
  let scaleX = rect.width / node.offsetWidth || 1;
  let scaleY = rect.height / node.offsetHeight || 1;
  return {
    left: rect.left,
    right: rect.left + node.clientWidth * scaleX,
    top: rect.top,
    bottom: rect.top + node.clientHeight * scaleY
  };
}
function scrollRectIntoView(view, rect, startDOM) {
  let scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
  let doc3 = view.dom.ownerDocument;
  for (let parent = startDOM || view.dom; ; ) {
    if (!parent)
      break;
    if (parent.nodeType != 1) {
      parent = parentNode(parent);
      continue;
    }
    let elt = parent;
    let atTop = elt == doc3.body;
    let bounding = atTop ? windowRect(doc3) : clientRect(elt);
    let moveX = 0, moveY = 0;
    if (rect.top < bounding.top + getSide(scrollThreshold, "top"))
      moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
    else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom"))
      moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide(scrollMargin, "top") - bounding.top : rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
    if (rect.left < bounding.left + getSide(scrollThreshold, "left"))
      moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
    else if (rect.right > bounding.right - getSide(scrollThreshold, "right"))
      moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
    if (moveX || moveY) {
      if (atTop) {
        doc3.defaultView.scrollBy(moveX, moveY);
      } else {
        let startX = elt.scrollLeft, startY = elt.scrollTop;
        if (moveY)
          elt.scrollTop += moveY;
        if (moveX)
          elt.scrollLeft += moveX;
        let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;
        rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
      }
    }
    let pos = atTop ? "fixed" : getComputedStyle(parent).position;
    if (/^(fixed|sticky)$/.test(pos))
      break;
    parent = pos == "absolute" ? parent.offsetParent : parentNode(parent);
  }
}
function storeScrollPos(view) {
  let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
  let refDOM, refTop;
  for (let x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
    let dom = view.root.elementFromPoint(x, y);
    if (!dom || dom == view.dom || !view.dom.contains(dom))
      continue;
    let localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break;
    }
  }
  return { refDOM, refTop, stack: scrollStack(view.dom) };
}
function scrollStack(dom) {
  let stack2 = [], doc3 = dom.ownerDocument;
  for (let cur = dom; cur; cur = parentNode(cur)) {
    stack2.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });
    if (dom == doc3)
      break;
  }
  return stack2;
}
function resetScrollPos({ refDOM, refTop, stack: stack2 }) {
  let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack2, newRefTop == 0 ? 0 : newRefTop - refTop);
}
function restoreScrollStack(stack2, dTop) {
  for (let i = 0; i < stack2.length; i++) {
    let { dom, top, left } = stack2[i];
    if (dom.scrollTop != top + dTop)
      dom.scrollTop = top + dTop;
    if (dom.scrollLeft != left)
      dom.scrollLeft = left;
  }
}
var preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stored = scrollStack(dom);
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}
function findOffsetInNode(node, coords) {
  let closest, dxClosest = 2e8, coordsClosest, offset4 = 0;
  let rowBot = coords.top, rowTop = coords.top;
  let firstBelow, coordsBelow;
  for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
    let rects;
    if (child.nodeType == 1)
      rects = child.getClientRects();
    else if (child.nodeType == 3)
      rects = textRange(child).getClientRects();
    else
      continue;
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest = child;
          dxClosest = dx;
          coordsClosest = dx && closest.nodeType == 3 ? {
            left: rect.right < coords.left ? rect.right : rect.left,
            top: coords.top
          } : coords;
          if (child.nodeType == 1 && dx)
            offset4 = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          continue;
        }
      } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {
        firstBelow = child;
        coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };
      }
      if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))
        offset4 = childIndex + 1;
    }
  }
  if (!closest && firstBelow) {
    closest = firstBelow;
    coordsClosest = coordsBelow;
    dxClosest = 0;
  }
  if (closest && closest.nodeType == 3)
    return findOffsetInText(closest, coordsClosest);
  if (!closest || dxClosest && closest.nodeType == 1)
    return { node, offset: offset4 };
  return findOffsetInNode(closest, coordsClosest);
}
function findOffsetInText(node, coords) {
  let len = node.nodeValue.length;
  let range = document.createRange(), result;
  for (let i = 0; i < len; i++) {
    range.setEnd(node, i + 1);
    range.setStart(node, i);
    let rect = singleRect(range, 1);
    if (rect.top == rect.bottom)
      continue;
    if (inRect(coords, rect)) {
      result = { node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
      break;
    }
  }
  range.detach();
  return result || { node, offset: 0 };
}
function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
}
function targetKludge(dom, coords) {
  let parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
    return parent;
  return dom;
}
function posFromElement(view, elt, coords) {
  let { node, offset: offset4 } = findOffsetInNode(elt, coords), bias = -1;
  if (node.nodeType == 1 && !node.firstChild) {
    let rect = node.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view.docView.posFromDOM(node, offset4, bias);
}
function posFromCaret(view, node, offset4, coords) {
  let outsideBlock = -1;
  for (let cur = node, sawBlock = false; ; ) {
    if (cur == view.dom)
      break;
    let desc = view.docView.nearestDesc(cur, true), rect;
    if (!desc)
      return null;
    if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent || !desc.contentDOM) && // Ignore elements with zero-size bounding rectangles
    ((rect = desc.dom.getBoundingClientRect()).width || rect.height)) {
      if (desc.node.isBlock && desc.parent && !/^T(R|BODY|HEAD|FOOT)$/.test(desc.dom.nodeName)) {
        if (!sawBlock && rect.left > coords.left || rect.top > coords.top)
          outsideBlock = desc.posBefore;
        else if (!sawBlock && rect.right < coords.left || rect.bottom < coords.top)
          outsideBlock = desc.posAfter;
        sawBlock = true;
      }
      if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {
        let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;
        return before ? desc.posBefore : desc.posAfter;
      }
    }
    cur = desc.dom.parentNode;
  }
  return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset4, -1);
}
function elementFromPoint(element, coords, box) {
  let len = element.childNodes.length;
  if (len && box.top < box.bottom) {
    for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI; ; ) {
      let child = element.childNodes[i];
      if (child.nodeType == 1) {
        let rects = child.getClientRects();
        for (let j = 0; j < rects.length; j++) {
          let rect = rects[j];
          if (inRect(coords, rect))
            return elementFromPoint(child, coords, rect);
        }
      }
      if ((i = (i + 1) % len) == startI)
        break;
    }
  }
  return element;
}
function posAtCoords(view, coords) {
  let doc3 = view.dom.ownerDocument, node, offset4 = 0;
  let caret = caretFromPoint(doc3, coords.left, coords.top);
  if (caret)
    ({ node, offset: offset4 } = caret);
  let elt = (view.root.elementFromPoint ? view.root : doc3).elementFromPoint(coords.left, coords.top);
  let pos;
  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    let box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box))
      return null;
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt)
      return null;
  }
  if (safari) {
    for (let p = elt; node && p; p = parentNode(p))
      if (p.draggable)
        node = void 0;
  }
  elt = targetKludge(elt, coords);
  if (node) {
    if (gecko && node.nodeType == 1) {
      offset4 = Math.min(offset4, node.childNodes.length);
      if (offset4 < node.childNodes.length) {
        let next = node.childNodes[offset4], box;
        if (next.nodeName == "IMG" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top)
          offset4++;
      }
    }
    let prev;
    if (webkit && offset4 && node.nodeType == 1 && (prev = node.childNodes[offset4 - 1]).nodeType == 1 && prev.contentEditable == "false" && prev.getBoundingClientRect().top >= coords.top)
      offset4--;
    if (node == view.dom && offset4 == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom)
      pos = view.state.doc.content.size;
    else if (offset4 == 0 || node.nodeType != 1 || node.childNodes[offset4 - 1].nodeName != "BR")
      pos = posFromCaret(view, node, offset4, coords);
  }
  if (pos == null)
    pos = posFromElement(view, elt, coords);
  let desc = view.docView.nearestDesc(elt, true);
  return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
}
function nonZero(rect) {
  return rect.top < rect.bottom || rect.left < rect.right;
}
function singleRect(target, bias) {
  let rects = target.getClientRects();
  if (rects.length) {
    let first2 = rects[bias < 0 ? 0 : rects.length - 1];
    if (nonZero(first2))
      return first2;
  }
  return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();
}
var BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function coordsAtPos(view, pos, side) {
  let { node, offset: offset4, atom: atom2 } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
  let supportEmptyRange = webkit || gecko;
  if (node.nodeType == 3) {
    if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset4 : offset4 == node.nodeValue.length))) {
      let rect = singleRect(textRange(node, offset4, offset4), side);
      if (gecko && offset4 && /\s/.test(node.nodeValue[offset4 - 1]) && offset4 < node.nodeValue.length) {
        let rectBefore = singleRect(textRange(node, offset4 - 1, offset4 - 1), -1);
        if (rectBefore.top == rect.top) {
          let rectAfter = singleRect(textRange(node, offset4, offset4 + 1), -1);
          if (rectAfter.top != rect.top)
            return flattenV(rectAfter, rectAfter.left < rectBefore.left);
        }
      }
      return rect;
    } else {
      let from2 = offset4, to = offset4, takeSide = side < 0 ? 1 : -1;
      if (side < 0 && !offset4) {
        to++;
        takeSide = -1;
      } else if (side >= 0 && offset4 == node.nodeValue.length) {
        from2--;
        takeSide = 1;
      } else if (side < 0) {
        from2--;
      } else {
        to++;
      }
      return flattenV(singleRect(textRange(node, from2, to), takeSide), takeSide < 0);
    }
  }
  let $dom = view.state.doc.resolve(pos - (atom2 || 0));
  if (!$dom.parent.inlineContent) {
    if (atom2 == null && offset4 && (side < 0 || offset4 == nodeSize(node))) {
      let before = node.childNodes[offset4 - 1];
      if (before.nodeType == 1)
        return flattenH(before.getBoundingClientRect(), false);
    }
    if (atom2 == null && offset4 < nodeSize(node)) {
      let after = node.childNodes[offset4];
      if (after.nodeType == 1)
        return flattenH(after.getBoundingClientRect(), true);
    }
    return flattenH(node.getBoundingClientRect(), side >= 0);
  }
  if (atom2 == null && offset4 && (side < 0 || offset4 == nodeSize(node))) {
    let before = node.childNodes[offset4 - 1];
    let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != "BR" || !before.nextSibling) ? before : null;
    if (target)
      return flattenV(singleRect(target, 1), false);
  }
  if (atom2 == null && offset4 < nodeSize(node)) {
    let after = node.childNodes[offset4];
    while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)
      after = after.nextSibling;
    let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;
    if (target)
      return flattenV(singleRect(target, -1), true);
  }
  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);
}
function flattenV(rect, left) {
  if (rect.width == 0)
    return rect;
  let x = left ? rect.left : rect.right;
  return { top: rect.top, bottom: rect.bottom, left: x, right: x };
}
function flattenH(rect, top) {
  if (rect.height == 0)
    return rect;
  let y = top ? rect.top : rect.bottom;
  return { top: y, bottom: y, left: rect.left, right: rect.right };
}
function withFlushedState(view, state, f) {
  let viewState = view.state, active = view.root.activeElement;
  if (viewState != state)
    view.updateState(state);
  if (active != view.dom)
    view.focus();
  try {
    return f();
  } finally {
    if (viewState != state)
      view.updateState(viewState);
    if (active != view.dom && active)
      active.focus();
  }
}
function endOfTextblockVertical(view, state, dir) {
  let sel = state.selection;
  let $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state, () => {
    let { node: dom } = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
    for (; ; ) {
      let nearest = view.docView.nearestDesc(dom, true);
      if (!nearest)
        break;
      if (nearest.node.isBlock) {
        dom = nearest.contentDOM || nearest.dom;
        break;
      }
      dom = nearest.dom.parentNode;
    }
    let coords = coordsAtPos(view, $pos.pos, 1);
    for (let child = dom.firstChild; child; child = child.nextSibling) {
      let boxes;
      if (child.nodeType == 1)
        boxes = child.getClientRects();
      else if (child.nodeType == 3)
        boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
      else
        continue;
      for (let i = 0; i < boxes.length; i++) {
        let box = boxes[i];
        if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
          return false;
      }
    }
    return true;
  });
}
var maybeRTL = /[\u0590-\u08ac]/;
function endOfTextblockHorizontal(view, state, dir) {
  let { $head } = state.selection;
  if (!$head.parent.isTextblock)
    return false;
  let offset4 = $head.parentOffset, atStart = !offset4, atEnd = offset4 == $head.parent.content.size;
  let sel = view.domSelection();
  if (!sel)
    return $head.pos == $head.start() || $head.pos == $head.end();
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
    return dir == "left" || dir == "backward" ? atStart : atEnd;
  return withFlushedState(view, state, () => {
    let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();
    let oldBidiLevel = sel.caretBidiLevel;
    sel.modify("move", dir, "character");
    let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();
    let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;
    try {
      sel.collapse(anchorNode, anchorOffset);
      if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)
        sel.extend(oldNode, oldOff);
    } catch (_) {
    }
    if (oldBidiLevel != null)
      sel.caretBidiLevel = oldBidiLevel;
    return result;
  });
}
var cachedState = null;
var cachedDir = null;
var cachedResult = false;
function endOfTextblock(view, state, dir) {
  if (cachedState == state && cachedDir == dir)
    return cachedResult;
  cachedState = state;
  cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
}
var NOT_DIRTY = 0;
var CHILD_DIRTY = 1;
var CONTENT_DIRTY = 2;
var NODE_DIRTY = 3;
var ViewDesc = class {
  constructor(parent, children, dom, contentDOM) {
    this.parent = parent;
    this.children = children;
    this.dom = dom;
    this.contentDOM = contentDOM;
    this.dirty = NOT_DIRTY;
    dom.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(widget) {
    return false;
  }
  matchesMark(mark) {
    return false;
  }
  matchesNode(node, outerDeco, innerDeco) {
    return false;
  }
  matchesHack(nodeName) {
    return false;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(event) {
    return false;
  }
  // The size of the content represented by this desc.
  get size() {
    let size4 = 0;
    for (let i = 0; i < this.children.length; i++)
      size4 += this.children[i].size;
    return size4;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0;
    if (this.dom.pmViewDesc == this)
      this.dom.pmViewDesc = void 0;
    for (let i = 0; i < this.children.length; i++)
      this.children[i].destroy();
  }
  posBeforeChild(child) {
    for (let i = 0, pos = this.posAtStart; ; i++) {
      let cur = this.children[i];
      if (cur == child)
        return pos;
      pos += cur.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(dom, offset4, bias) {
    if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
      if (bias < 0) {
        let domBefore, desc;
        if (dom == this.contentDOM) {
          domBefore = dom.childNodes[offset4 - 1];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domBefore = dom.previousSibling;
        }
        while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))
          domBefore = domBefore.previousSibling;
        return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
      } else {
        let domAfter, desc;
        if (dom == this.contentDOM) {
          domAfter = dom.childNodes[offset4];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domAfter = dom.nextSibling;
        }
        while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))
          domAfter = domAfter.nextSibling;
        return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;
      }
    }
    let atEnd;
    if (dom == this.dom && this.contentDOM) {
      atEnd = offset4 > domIndex(this.contentDOM);
    } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
      atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
    } else if (this.dom.firstChild) {
      if (offset4 == 0)
        for (let search = dom; ; search = search.parentNode) {
          if (search == this.dom) {
            atEnd = false;
            break;
          }
          if (search.previousSibling)
            break;
        }
      if (atEnd == null && offset4 == dom.childNodes.length)
        for (let search = dom; ; search = search.parentNode) {
          if (search == this.dom) {
            atEnd = true;
            break;
          }
          if (search.nextSibling)
            break;
        }
    }
    return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(dom, onlyNodes = false) {
    for (let first2 = true, cur = dom; cur; cur = cur.parentNode) {
      let desc = this.getDesc(cur), nodeDOM;
      if (desc && (!onlyNodes || desc.node)) {
        if (first2 && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))
          first2 = false;
        else
          return desc;
      }
    }
  }
  getDesc(dom) {
    let desc = dom.pmViewDesc;
    for (let cur = desc; cur; cur = cur.parent)
      if (cur == this)
        return desc;
  }
  posFromDOM(dom, offset4, bias) {
    for (let scan = dom; scan; scan = scan.parentNode) {
      let desc = this.getDesc(scan);
      if (desc)
        return desc.localPosFromDOM(dom, offset4, bias);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(pos) {
    for (let i = 0, offset4 = 0; i < this.children.length; i++) {
      let child = this.children[i], end = offset4 + child.size;
      if (offset4 == pos && end != offset4) {
        while (!child.border && child.children.length) {
          for (let i2 = 0; i2 < child.children.length; i2++) {
            let inner = child.children[i2];
            if (inner.size) {
              child = inner;
              break;
            }
          }
        }
        return child;
      }
      if (pos < end)
        return child.descAt(pos - offset4 - child.border);
      offset4 = end;
    }
  }
  domFromPos(pos, side) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: pos + 1 };
    let i = 0, offset4 = 0;
    for (let curPos = 0; i < this.children.length; i++) {
      let child = this.children[i], end = curPos + child.size;
      if (end > pos || child instanceof TrailingHackViewDesc) {
        offset4 = pos - curPos;
        break;
      }
      curPos = end;
    }
    if (offset4)
      return this.children[i].domFromPos(offset4 - this.children[i].border, side);
    for (let prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) {
    }
    if (side <= 0) {
      let prev, enter2 = true;
      for (; ; i--, enter2 = false) {
        prev = i ? this.children[i - 1] : null;
        if (!prev || prev.dom.parentNode == this.contentDOM)
          break;
      }
      if (prev && side && enter2 && !prev.border && !prev.domAtom)
        return prev.domFromPos(prev.size, side);
      return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };
    } else {
      let next, enter2 = true;
      for (; ; i++, enter2 = false) {
        next = i < this.children.length ? this.children[i] : null;
        if (!next || next.dom.parentNode == this.contentDOM)
          break;
      }
      if (next && enter2 && !next.border && !next.domAtom)
        return next.domFromPos(0, side);
      return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(from2, to, base2 = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: from2, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let fromOffset = -1, toOffset = -1;
    for (let offset4 = base2, i = 0; ; i++) {
      let child = this.children[i], end = offset4 + child.size;
      if (fromOffset == -1 && from2 <= end) {
        let childBase = offset4 + child.border;
        if (from2 >= childBase && to <= end - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))
          return child.parseRange(from2, to, childBase);
        from2 = offset4;
        for (let j = i; j > 0; j--) {
          let prev = this.children[j - 1];
          if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
            fromOffset = domIndex(prev.dom) + 1;
            break;
          }
          from2 -= prev.size;
        }
        if (fromOffset == -1)
          fromOffset = 0;
      }
      if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {
        to = end;
        for (let j = i + 1; j < this.children.length; j++) {
          let next = this.children[j];
          if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
            toOffset = domIndex(next.dom);
            break;
          }
          to += next.size;
        }
        if (toOffset == -1)
          toOffset = this.contentDOM.childNodes.length;
        break;
      }
      offset4 = end;
    }
    return { node: this.contentDOM, from: from2, to, fromOffset, toOffset };
  }
  emptyChildAt(side) {
    if (this.border || !this.contentDOM || !this.children.length)
      return false;
    let child = this.children[side < 0 ? 0 : this.children.length - 1];
    return child.size == 0 || child.emptyChildAt(side);
  }
  domAfterPos(pos) {
    let { node, offset: offset4 } = this.domFromPos(pos, 0);
    if (node.nodeType != 1 || offset4 == node.childNodes.length)
      throw new RangeError("No node after pos " + pos);
    return node.childNodes[offset4];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(anchor, head, view, force = false) {
    let from2 = Math.min(anchor, head), to = Math.max(anchor, head);
    for (let i = 0, offset4 = 0; i < this.children.length; i++) {
      let child = this.children[i], end = offset4 + child.size;
      if (from2 > offset4 && to < end)
        return child.setSelection(anchor - offset4 - child.border, head - offset4 - child.border, view, force);
      offset4 = end;
    }
    let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
    let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
    let domSel = view.root.getSelection();
    let selRange = view.domSelectionRange();
    let brKludge = false;
    if ((gecko || safari) && anchor == head) {
      let { node, offset: offset4 } = anchorDOM;
      if (node.nodeType == 3) {
        brKludge = !!(offset4 && node.nodeValue[offset4 - 1] == "\n");
        if (brKludge && offset4 == node.nodeValue.length) {
          for (let scan = node, after; scan; scan = scan.parentNode) {
            if (after = scan.nextSibling) {
              if (after.nodeName == "BR")
                anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };
              break;
            }
            let desc = scan.pmViewDesc;
            if (desc && desc.node && desc.node.isBlock)
              break;
          }
        }
      } else {
        let prev = node.childNodes[offset4 - 1];
        brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
      }
    }
    if (gecko && selRange.focusNode && selRange.focusNode != headDOM.node && selRange.focusNode.nodeType == 1) {
      let after = selRange.focusNode.childNodes[selRange.focusOffset];
      if (after && after.contentEditable == "false")
        force = true;
    }
    if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, selRange.anchorNode, selRange.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, selRange.focusNode, selRange.focusOffset))
      return;
    let domSelExtended = false;
    if ((domSel.extend || anchor == head) && !(brKludge && gecko)) {
      domSel.collapse(anchorDOM.node, anchorDOM.offset);
      try {
        if (anchor != head)
          domSel.extend(headDOM.node, headDOM.offset);
        domSelExtended = true;
      } catch (_) {
      }
    }
    if (!domSelExtended) {
      if (anchor > head) {
        let tmp = anchorDOM;
        anchorDOM = headDOM;
        headDOM = tmp;
      }
      let range = document.createRange();
      range.setEnd(headDOM.node, headDOM.offset);
      range.setStart(anchorDOM.node, anchorDOM.offset);
      domSel.removeAllRanges();
      domSel.addRange(range);
    }
  }
  ignoreMutation(mutation) {
    return !this.contentDOM && mutation.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(from2, to) {
    for (let offset4 = 0, i = 0; i < this.children.length; i++) {
      let child = this.children[i], end = offset4 + child.size;
      if (offset4 == end ? from2 <= end && to >= offset4 : from2 < end && to > offset4) {
        let startInside = offset4 + child.border, endInside = end - child.border;
        if (from2 >= startInside && to <= endInside) {
          this.dirty = from2 == offset4 || to == end ? CONTENT_DIRTY : CHILD_DIRTY;
          if (from2 == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))
            child.dirty = NODE_DIRTY;
          else
            child.markDirty(from2 - startInside, to - startInside);
          return;
        } else {
          child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
        }
      }
      offset4 = end;
    }
    this.dirty = CONTENT_DIRTY;
  }
  markParentsDirty() {
    let level = 1;
    for (let node = this.parent; node; node = node.parent, level++) {
      let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
      if (node.dirty < dirty)
        node.dirty = dirty;
    }
  }
  get domAtom() {
    return false;
  }
  get ignoreForCoords() {
    return false;
  }
  get ignoreForSelection() {
    return false;
  }
  isText(text) {
    return false;
  }
};
var WidgetViewDesc = class extends ViewDesc {
  constructor(parent, widget, view, pos) {
    let self2, dom = widget.type.toDOM;
    if (typeof dom == "function")
      dom = dom(view, () => {
        if (!self2)
          return pos;
        if (self2.parent)
          return self2.parent.posBeforeChild(self2);
      });
    if (!widget.type.spec.raw) {
      if (dom.nodeType != 1) {
        let wrap3 = document.createElement("span");
        wrap3.appendChild(dom);
        dom = wrap3;
      }
      dom.contentEditable = "false";
      dom.classList.add("ProseMirror-widget");
    }
    super(parent, [], dom, null);
    this.widget = widget;
    this.widget = widget;
    self2 = this;
  }
  matchesWidget(widget) {
    return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: true };
  }
  stopEvent(event) {
    let stop = this.widget.spec.stopEvent;
    return stop ? stop(event) : false;
  }
  ignoreMutation(mutation) {
    return mutation.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom);
    super.destroy();
  }
  get domAtom() {
    return true;
  }
  get ignoreForSelection() {
    return !!this.widget.type.spec.relaxedSide;
  }
  get side() {
    return this.widget.type.side;
  }
};
var CompositionViewDesc = class extends ViewDesc {
  constructor(parent, dom, textDOM, text) {
    super(parent, [], dom, null);
    this.textDOM = textDOM;
    this.text = text;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(dom, offset4) {
    if (dom != this.textDOM)
      return this.posAtStart + (offset4 ? this.size : 0);
    return this.posAtStart + offset4;
  }
  domFromPos(pos) {
    return { node: this.textDOM, offset: pos };
  }
  ignoreMutation(mut) {
    return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
  }
};
var MarkViewDesc = class _MarkViewDesc extends ViewDesc {
  constructor(parent, mark, dom, contentDOM, spec) {
    super(parent, [], dom, contentDOM);
    this.mark = mark;
    this.spec = spec;
  }
  static create(parent, mark, inline3, view) {
    let custom = view.nodeViews[mark.type.name];
    let spec = custom && custom(mark, view, inline3);
    if (!spec || !spec.dom)
      spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline3), null, mark.attrs);
    return new _MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom, spec);
  }
  parseRule() {
    if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)
      return null;
    return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(mark) {
    return this.dirty != NODE_DIRTY && this.mark.eq(mark);
  }
  markDirty(from2, to) {
    super.markDirty(from2, to);
    if (this.dirty != NOT_DIRTY) {
      let parent = this.parent;
      while (!parent.node)
        parent = parent.parent;
      if (parent.dirty < this.dirty)
        parent.dirty = this.dirty;
      this.dirty = NOT_DIRTY;
    }
  }
  slice(from2, to, view) {
    let copy2 = _MarkViewDesc.create(this.parent, this.mark, true, view);
    let nodes = this.children, size4 = this.size;
    if (to < size4)
      nodes = replaceNodes(nodes, to, size4, view);
    if (from2 > 0)
      nodes = replaceNodes(nodes, 0, from2, view);
    for (let i = 0; i < nodes.length; i++)
      nodes[i].parent = copy2;
    copy2.children = nodes;
    return copy2;
  }
  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
  }
  destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    super.destroy();
  }
};
var NodeViewDesc = class _NodeViewDesc extends ViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
    super(parent, [], dom, contentDOM);
    this.node = node;
    this.outerDeco = outerDeco;
    this.innerDeco = innerDeco;
    this.nodeDOM = nodeDOM;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(parent, node, outerDeco, innerDeco, view, pos) {
    let custom = view.nodeViews[node.type.name], descObj;
    let spec = custom && custom(node, view, () => {
      if (!descObj)
        return pos;
      if (descObj.parent)
        return descObj.parent.posBeforeChild(descObj);
    }, outerDeco, innerDeco);
    let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
    if (node.isText) {
      if (!dom)
        dom = document.createTextNode(node.text);
      else if (dom.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else if (!dom) {
      let spec2 = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node), null, node.attrs);
      ({ dom, contentDOM } = spec2);
    }
    if (!contentDOM && !node.isText && dom.nodeName != "BR") {
      if (!dom.hasAttribute("contenteditable"))
        dom.contentEditable = "false";
      if (node.type.spec.draggable)
        dom.draggable = true;
    }
    let nodeDOM = dom;
    dom = applyOuterDeco(dom, outerDeco, node);
    if (spec)
      return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);
    else if (node.isText)
      return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);
    else
      return new _NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let rule = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre")
      rule.preserveWhitespace = "full";
    if (!this.contentDOM) {
      rule.getContent = () => this.node.content;
    } else if (!this.contentLost) {
      rule.contentElement = this.contentDOM;
    } else {
      for (let i = this.children.length - 1; i >= 0; i--) {
        let child = this.children[i];
        if (this.dom.contains(child.dom.parentNode)) {
          rule.contentElement = child.dom.parentNode;
          break;
        }
      }
      if (!rule.contentElement)
        rule.getContent = () => Fragment12.empty;
    }
    return rule;
  }
  matchesNode(node, outerDeco, innerDeco) {
    return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(view, pos) {
    let inline3 = this.node.inlineContent, off = pos;
    let composition = view.composing ? this.localCompositionInfo(view, pos) : null;
    let localComposition = composition && composition.pos > -1 ? composition : null;
    let compositionInChild = composition && composition.pos < 0;
    let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);
    iterDeco(this.node, this.innerDeco, (widget, i, insideNode) => {
      if (widget.spec.marks)
        updater.syncToMarks(widget.spec.marks, inline3, view, i);
      else if (widget.type.side >= 0 && !insideNode)
        updater.syncToMarks(i == this.node.childCount ? Mark.none : this.node.child(i).marks, inline3, view, i);
      updater.placeWidget(widget, view, off);
    }, (child, outerDeco, innerDeco, i) => {
      updater.syncToMarks(child.marks, inline3, view, i);
      let compIndex;
      if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ;
      else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;
      else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off)) ;
      else {
        updater.addNode(child, outerDeco, innerDeco, view, off);
      }
      off += child.nodeSize;
    });
    updater.syncToMarks([], inline3, view, 0);
    if (this.node.isTextblock)
      updater.addTextblockHacks();
    updater.destroyRest();
    if (updater.changed || this.dirty == CONTENT_DIRTY) {
      if (localComposition)
        this.protectLocalComposition(view, localComposition);
      renderDescs(this.contentDOM, this.children, view);
      if (ios)
        iosHacks(this.dom);
    }
  }
  localCompositionInfo(view, pos) {
    let { from: from2, to } = view.state.selection;
    if (!(view.state.selection instanceof TextSelection) || from2 < pos || to > pos + this.node.content.size)
      return null;
    let textNode = view.input.compositionNode;
    if (!textNode || !this.dom.contains(textNode.parentNode))
      return null;
    if (this.node.inlineContent) {
      let text = textNode.nodeValue;
      let textPos = findTextInFragment(this.node.content, text, from2 - pos, to - pos);
      return textPos < 0 ? null : { node: textNode, pos: textPos, text };
    } else {
      return { node: textNode, pos: -1, text: "" };
    }
  }
  protectLocalComposition(view, { node, pos, text }) {
    if (this.getDesc(node))
      return;
    let topNode = node;
    for (; ; topNode = topNode.parentNode) {
      if (topNode.parentNode == this.contentDOM)
        break;
      while (topNode.previousSibling)
        topNode.parentNode.removeChild(topNode.previousSibling);
      while (topNode.nextSibling)
        topNode.parentNode.removeChild(topNode.nextSibling);
      if (topNode.pmViewDesc)
        topNode.pmViewDesc = void 0;
    }
    let desc = new CompositionViewDesc(this, topNode, node, text);
    view.input.compositionNodes.push(desc);
    this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node))
      return false;
    this.updateInner(node, outerDeco, innerDeco, view);
    return true;
  }
  updateInner(node, outerDeco, innerDeco, view) {
    this.updateOuterDeco(outerDeco);
    this.node = node;
    this.innerDeco = innerDeco;
    if (this.contentDOM)
      this.updateChildren(view, this.posAtStart);
    this.dirty = NOT_DIRTY;
  }
  updateOuterDeco(outerDeco) {
    if (sameOuterDeco(outerDeco, this.outerDeco))
      return;
    let needsWrap = this.nodeDOM.nodeType != 1;
    let oldDOM = this.dom;
    this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
    if (this.dom != oldDOM) {
      oldDOM.pmViewDesc = void 0;
      this.dom.pmViewDesc = this;
    }
    this.outerDeco = outerDeco;
  }
  // Mark this node as being the selected node.
  selectNode() {
    if (this.nodeDOM.nodeType == 1) {
      this.nodeDOM.classList.add("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable)
        this.nodeDOM.draggable = true;
    }
  }
  // Remove selected node marking from this node.
  deselectNode() {
    if (this.nodeDOM.nodeType == 1) {
      this.nodeDOM.classList.remove("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable)
        this.nodeDOM.removeAttribute("draggable");
    }
  }
  get domAtom() {
    return this.node.isAtom;
  }
};
function docViewDesc(doc3, outerDeco, innerDeco, dom, view) {
  applyOuterDeco(dom, outerDeco, doc3);
  let docView = new NodeViewDesc(void 0, doc3, outerDeco, innerDeco, dom, dom, dom, view, 0);
  if (docView.contentDOM)
    docView.updateChildren(view, 0);
  return docView;
}
var TextViewDesc = class _TextViewDesc extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
    super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);
  }
  parseRule() {
    let skip = this.nodeDOM.parentNode;
    while (skip && skip != this.dom && !skip.pmIsDeco)
      skip = skip.parentNode;
    return { skip: skip || true };
  }
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node))
      return false;
    this.updateOuterDeco(outerDeco);
    if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
      this.nodeDOM.nodeValue = node.text;
      if (view.trackWrites == this.nodeDOM)
        view.trackWrites = null;
    }
    this.node = node;
    this.dirty = NOT_DIRTY;
    return true;
  }
  inParent() {
    let parentDOM = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode)
      if (n == parentDOM)
        return true;
    return false;
  }
  domFromPos(pos) {
    return { node: this.nodeDOM, offset: pos };
  }
  localPosFromDOM(dom, offset4, bias) {
    if (dom == this.nodeDOM)
      return this.posAtStart + Math.min(offset4, this.node.text.length);
    return super.localPosFromDOM(dom, offset4, bias);
  }
  ignoreMutation(mutation) {
    return mutation.type != "characterData" && mutation.type != "selection";
  }
  slice(from2, to, view) {
    let node = this.node.cut(from2, to), dom = document.createTextNode(node.text);
    return new _TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);
  }
  markDirty(from2, to) {
    super.markDirty(from2, to);
    if (this.dom != this.nodeDOM && (from2 == 0 || to == this.nodeDOM.nodeValue.length))
      this.dirty = NODE_DIRTY;
  }
  get domAtom() {
    return false;
  }
  isText(text) {
    return this.node.text == text;
  }
};
var TrailingHackViewDesc = class extends ViewDesc {
  parseRule() {
    return { ignore: true };
  }
  matchesHack(nodeName) {
    return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
  }
  get domAtom() {
    return true;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
};
var CustomNodeViewDesc = class extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
    super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
    this.spec = spec;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY)
      return false;
    if (this.spec.update && (this.node.type == node.type || this.spec.multiType)) {
      let result = this.spec.update(node, outerDeco, innerDeco);
      if (result)
        this.updateInner(node, outerDeco, innerDeco, view);
      return result;
    } else if (!this.contentDOM && !node.isLeaf) {
      return false;
    } else {
      return super.update(node, outerDeco, innerDeco, view);
    }
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(anchor, head, view, force) {
    this.spec.setSelection ? this.spec.setSelection(anchor, head, view.root) : super.setSelection(anchor, head, view, force);
  }
  destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    super.destroy();
  }
  stopEvent(event) {
    return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
  }
  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
  }
};
function renderDescs(parentDOM, descs, view) {
  let dom = parentDOM.firstChild, written = false;
  for (let i = 0; i < descs.length; i++) {
    let desc = descs[i], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) {
        dom = rm(dom);
        written = true;
      }
      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc) {
      let pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) {
    dom = rm(dom);
    written = true;
  }
  if (written && view.trackWrites == parentDOM)
    view.trackWrites = null;
}
var OuterDecoLevel = function(nodeName) {
  if (nodeName)
    this.nodeName = nodeName;
};
OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
var noDeco = [new OuterDecoLevel()];
function computeOuterDeco(outerDeco, node, needsWrap) {
  if (outerDeco.length == 0)
    return noDeco;
  let top = needsWrap ? noDeco[0] : new OuterDecoLevel(), result = [top];
  for (let i = 0; i < outerDeco.length; i++) {
    let attrs = outerDeco[i].type.attrs;
    if (!attrs)
      continue;
    if (attrs.nodeName)
      result.push(top = new OuterDecoLevel(attrs.nodeName));
    for (let name in attrs) {
      let val = attrs[name];
      if (val == null)
        continue;
      if (needsWrap && result.length == 1)
        result.push(top = new OuterDecoLevel(node.isInline ? "span" : "div"));
      if (name == "class")
        top.class = (top.class ? top.class + " " : "") + val;
      else if (name == "style")
        top.style = (top.style ? top.style + ";" : "") + val;
      else if (name != "nodeName")
        top[name] = val;
    }
  }
  return result;
}
function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
  if (prevComputed == noDeco && curComputed == noDeco)
    return nodeDOM;
  let curDOM = nodeDOM;
  for (let i = 0; i < curComputed.length; i++) {
    let deco = curComputed[i], prev = prevComputed[i];
    if (i) {
      let parent;
      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev = noDeco[0];
        curDOM = parent;
      }
    }
    patchAttributes(curDOM, prev || noDeco[0], deco);
  }
  return curDOM;
}
function patchAttributes(dom, prev, cur) {
  for (let name in prev)
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
      dom.removeAttribute(name);
  for (let name in cur)
    if (name != "class" && name != "style" && name != "nodeName" && cur[name] != prev[name])
      dom.setAttribute(name, cur[name]);
  if (prev.class != cur.class) {
    let prevList = prev.class ? prev.class.split(" ").filter(Boolean) : [];
    let curList = cur.class ? cur.class.split(" ").filter(Boolean) : [];
    for (let i = 0; i < prevList.length; i++)
      if (curList.indexOf(prevList[i]) == -1)
        dom.classList.remove(prevList[i]);
    for (let i = 0; i < curList.length; i++)
      if (prevList.indexOf(curList[i]) == -1)
        dom.classList.add(curList[i]);
    if (dom.classList.length == 0)
      dom.removeAttribute("class");
  }
  if (prev.style != cur.style) {
    if (prev.style) {
      let prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
      while (m = prop.exec(prev.style))
        dom.style.removeProperty(m[1]);
    }
    if (cur.style)
      dom.style.cssText += cur.style;
  }
}
function applyOuterDeco(dom, deco, node) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));
}
function sameOuterDeco(a, b) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!a[i].type.eq(b[i].type))
      return false;
  return true;
}
function rm(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
var ViewTreeUpdater = class {
  constructor(top, lock, view) {
    this.lock = lock;
    this.view = view;
    this.index = 0;
    this.stack = [];
    this.changed = false;
    this.top = top;
    this.preMatch = preMatch(top.node.content, top);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(start, end) {
    if (start == end)
      return;
    for (let i = start; i < end; i++)
      this.top.children[i].destroy();
    this.top.children.splice(start, end - start);
    this.changed = true;
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(marks, inline3, view, parentIndex) {
    let keep = 0, depth = this.stack.length >> 1;
    let maxKeep = Math.min(depth, marks.length);
    while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)
      keep++;
    while (keep < depth) {
      this.destroyRest();
      this.top.dirty = NOT_DIRTY;
      this.index = this.stack.pop();
      this.top = this.stack.pop();
      depth--;
    }
    while (depth < marks.length) {
      this.stack.push(this.top, this.index + 1);
      let found2 = -1, scanTo = this.top.children.length;
      if (parentIndex < this.preMatch.index)
        scanTo = Math.min(this.index + 3, scanTo);
      for (let i = this.index; i < scanTo; i++) {
        let next = this.top.children[i];
        if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {
          found2 = i;
          break;
        }
      }
      if (found2 > -1) {
        if (found2 > this.index) {
          this.changed = true;
          this.destroyBetween(this.index, found2);
        }
        this.top = this.top.children[this.index];
      } else {
        let markDesc = MarkViewDesc.create(this.top, marks[depth], inline3, view);
        this.top.children.splice(this.index, 0, markDesc);
        this.top = markDesc;
        this.changed = true;
      }
      this.index = 0;
      depth++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(node, outerDeco, innerDeco, index2) {
    let found2 = -1, targetDesc;
    if (index2 >= this.preMatch.index && (targetDesc = this.preMatch.matches[index2 - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {
      found2 = this.top.children.indexOf(targetDesc, this.index);
    } else {
      for (let i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {
        let child = this.top.children[i];
        if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
          found2 = i;
          break;
        }
      }
    }
    if (found2 < 0)
      return false;
    this.destroyBetween(this.index, found2);
    this.index++;
    return true;
  }
  updateNodeAt(node, outerDeco, innerDeco, index2, view) {
    let child = this.top.children[index2];
    if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)
      child.dirty = CONTENT_DIRTY;
    if (!child.update(node, outerDeco, innerDeco, view))
      return false;
    this.destroyBetween(this.index, index2);
    this.index++;
    return true;
  }
  findIndexWithChild(domNode) {
    for (; ; ) {
      let parent = domNode.parentNode;
      if (!parent)
        return -1;
      if (parent == this.top.contentDOM) {
        let desc = domNode.pmViewDesc;
        if (desc)
          for (let i = this.index; i < this.top.children.length; i++) {
            if (this.top.children[i] == desc)
              return i;
          }
        return -1;
      }
      domNode = parent;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(node, outerDeco, innerDeco, view, index2, pos) {
    for (let i = this.index; i < this.top.children.length; i++) {
      let next = this.top.children[i];
      if (next instanceof NodeViewDesc) {
        let preMatch2 = this.preMatch.matched.get(next);
        if (preMatch2 != null && preMatch2 != index2)
          return false;
        let nextDOM = next.dom, updated;
        let locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
        if (!locked && next.update(node, outerDeco, innerDeco, view)) {
          this.destroyBetween(this.index, i);
          if (next.dom != nextDOM)
            this.changed = true;
          this.index++;
          return true;
        } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {
          this.destroyBetween(this.index, i);
          this.top.children[this.index] = updated;
          if (updated.contentDOM) {
            updated.dirty = CONTENT_DIRTY;
            updated.updateChildren(view, pos + 1);
            updated.dirty = NOT_DIRTY;
          }
          this.changed = true;
          this.index++;
          return true;
        }
        break;
      }
    }
    return false;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {
    if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content) || !sameOuterDeco(outerDeco, next.outerDeco) || !innerDeco.eq(next.innerDeco))
      return null;
    let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
    if (wrapper.contentDOM) {
      wrapper.children = next.children;
      next.children = [];
      for (let ch of wrapper.children)
        ch.parent = wrapper;
    }
    next.destroy();
    return wrapper;
  }
  // Insert the node as a newly created node desc.
  addNode(node, outerDeco, innerDeco, view, pos) {
    let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
    if (desc.contentDOM)
      desc.updateChildren(view, pos + 1);
    this.top.children.splice(this.index++, 0, desc);
    this.changed = true;
  }
  placeWidget(widget, view, pos) {
    let next = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
      this.index++;
    } else {
      let desc = new WidgetViewDesc(this.top, widget, view, pos);
      this.top.children.splice(this.index++, 0, desc);
      this.changed = true;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let lastChild = this.top.children[this.index - 1], parent = this.top;
    while (lastChild instanceof MarkViewDesc) {
      parent = lastChild;
      lastChild = parent.children[parent.children.length - 1];
    }
    if (!lastChild || // Empty textblock
    !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild.node.text)) {
      if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == "false")
        this.addHackNode("IMG", parent);
      this.addHackNode("BR", this.top);
    }
  }
  addHackNode(nodeName, parent) {
    if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
      this.index++;
    } else {
      let dom = document.createElement(nodeName);
      if (nodeName == "IMG") {
        dom.className = "ProseMirror-separator";
        dom.alt = "";
      }
      if (nodeName == "BR")
        dom.className = "ProseMirror-trailingBreak";
      let hack = new TrailingHackViewDesc(this.top, [], dom, null);
      if (parent != this.top)
        parent.children.push(hack);
      else
        parent.children.splice(this.index++, 0, hack);
      this.changed = true;
    }
  }
  isLocked(node) {
    return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));
  }
};
function preMatch(frag, parentDesc) {
  let curDesc = parentDesc, descI = curDesc.children.length;
  let fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches2 = [];
  outer: while (fI > 0) {
    let desc;
    for (; ; ) {
      if (descI) {
        let next = curDesc.children[descI - 1];
        if (next instanceof MarkViewDesc) {
          curDesc = next;
          descI = next.children.length;
        } else {
          desc = next;
          descI--;
          break;
        }
      } else if (curDesc == parentDesc) {
        break outer;
      } else {
        descI = curDesc.parent.children.indexOf(curDesc);
        curDesc = curDesc.parent;
      }
    }
    let node = desc.node;
    if (!node)
      continue;
    if (node != frag.child(fI - 1))
      break;
    --fI;
    matched.set(desc, fI);
    matches2.push(desc);
  }
  return { index: fI, matched, matches: matches2.reverse() };
}
function compareSide(a, b) {
  return a.type.side - b.type.side;
}
function iterDeco(parent, deco, onWidget, onNode) {
  let locals = deco.locals(parent), offset4 = 0;
  if (locals.length == 0) {
    for (let i = 0; i < parent.childCount; i++) {
      let child = parent.child(i);
      onNode(child, locals, deco.forChild(offset4, child), i);
      offset4 += child.nodeSize;
    }
    return;
  }
  let decoIndex = 0, active = [], restNode = null;
  for (let parentIndex = 0; ; ) {
    let widget, widgets;
    while (decoIndex < locals.length && locals[decoIndex].to == offset4) {
      let next = locals[decoIndex++];
      if (next.widget) {
        if (!widget)
          widget = next;
        else
          (widgets || (widgets = [widget])).push(next);
      }
    }
    if (widget) {
      if (widgets) {
        widgets.sort(compareSide);
        for (let i = 0; i < widgets.length; i++)
          onWidget(widgets[i], parentIndex, !!restNode);
      } else {
        onWidget(widget, parentIndex, !!restNode);
      }
    }
    let child, index2;
    if (restNode) {
      index2 = -1;
      child = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index2 = parentIndex;
      child = parent.child(parentIndex++);
    } else {
      break;
    }
    for (let i = 0; i < active.length; i++)
      if (active[i].to <= offset4)
        active.splice(i--, 1);
    while (decoIndex < locals.length && locals[decoIndex].from <= offset4 && locals[decoIndex].to > offset4)
      active.push(locals[decoIndex++]);
    let end = offset4 + child.nodeSize;
    if (child.isText) {
      let cutAt = end;
      if (decoIndex < locals.length && locals[decoIndex].from < cutAt)
        cutAt = locals[decoIndex].from;
      for (let i = 0; i < active.length; i++)
        if (active[i].to < cutAt)
          cutAt = active[i].to;
      if (cutAt < end) {
        restNode = child.cut(cutAt - offset4);
        child = child.cut(0, cutAt - offset4);
        end = cutAt;
        index2 = -1;
      }
    } else {
      while (decoIndex < locals.length && locals[decoIndex].to < end)
        decoIndex++;
    }
    let outerDeco = child.isInline && !child.isLeaf ? active.filter((d) => !d.inline) : active.slice();
    onNode(child, outerDeco, deco.forChild(offset4, child), index2);
    offset4 = end;
  }
}
function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    let oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}
function findTextInFragment(frag, text, from2, to) {
  for (let i = 0, pos = 0; i < frag.childCount && pos <= to; ) {
    let child = frag.child(i++), childStart = pos;
    pos += child.nodeSize;
    if (!child.isText)
      continue;
    let str = child.text;
    while (i < frag.childCount) {
      let next = frag.child(i++);
      pos += next.nodeSize;
      if (!next.isText)
        break;
      str += next.text;
    }
    if (pos >= from2) {
      if (pos >= to && str.slice(to - text.length - childStart, to - childStart) == text)
        return to - text.length;
      let found2 = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;
      if (found2 >= 0 && found2 + text.length + childStart >= from2)
        return childStart + found2;
      if (from2 == to && str.length >= to + text.length - childStart && str.slice(to - childStart, to - childStart + text.length) == text)
        return to;
    }
  }
  return -1;
}
function replaceNodes(nodes, from2, to, view, replacement) {
  let result = [];
  for (let i = 0, off = 0; i < nodes.length; i++) {
    let child = nodes[i], start = off, end = off += child.size;
    if (start >= to || end <= from2) {
      result.push(child);
    } else {
      if (start < from2)
        result.push(child.slice(0, from2 - start, view));
      if (replacement) {
        result.push(replacement);
        replacement = void 0;
      }
      if (end > to)
        result.push(child.slice(to - start, child.size, view));
    }
  }
  return result;
}
function selectionFromDOM(view, origin = null) {
  let domSel = view.domSelectionRange(), doc3 = view.state.doc;
  if (!domSel.focusNode)
    return null;
  let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
  let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
  if (head < 0)
    return null;
  let $head = doc3.resolve(head), anchor, selection;
  if (selectionCollapsed(domSel)) {
    anchor = head;
    while (nearestDesc && !nearestDesc.node)
      nearestDesc = nearestDesc.parent;
    let nearestDescNode = nearestDesc.node;
    if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
      let pos = nearestDesc.posBefore;
      selection = new NodeSelection(head == pos ? $head : doc3.resolve(pos));
    }
  } else {
    if (domSel instanceof view.dom.ownerDocument.defaultView.Selection && domSel.rangeCount > 1) {
      let min3 = head, max2 = head;
      for (let i = 0; i < domSel.rangeCount; i++) {
        let range = domSel.getRangeAt(i);
        min3 = Math.min(min3, view.docView.posFromDOM(range.startContainer, range.startOffset, 1));
        max2 = Math.max(max2, view.docView.posFromDOM(range.endContainer, range.endOffset, -1));
      }
      if (min3 < 0)
        return null;
      [anchor, head] = max2 == view.state.selection.anchor ? [max2, min3] : [min3, max2];
      $head = doc3.resolve(head);
    } else {
      anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
    }
    if (anchor < 0)
      return null;
  }
  let $anchor = doc3.resolve(anchor);
  if (!selection) {
    let bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }
  return selection;
}
function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
}
function selectionToDOM(view, force = false) {
  let sel = view.state.selection;
  syncNodeSelection(view, sel);
  if (!editorOwnsSelection(view))
    return;
  if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
    let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;
    if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
      view.input.mouseDown.delayedSelectionSync = true;
      view.domObserver.setCurSelection();
      return;
    }
  }
  view.domObserver.disconnectSelection();
  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    let { anchor, head } = sel, resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
      if (!sel.$from.parent.inlineContent)
        resetEditableFrom = temporarilyEditableNear(view, sel.from);
      if (!sel.empty && !sel.$from.parent.inlineContent)
        resetEditableTo = temporarilyEditableNear(view, sel.to);
    }
    view.docView.setSelection(anchor, head, view, force);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom)
        resetEditable(resetEditableFrom);
      if (resetEditableTo)
        resetEditable(resetEditableTo);
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document)
        removeClassOnSelectionChange(view);
    }
  }
  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}
var brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;
function temporarilyEditableNear(view, pos) {
  let { node, offset: offset4 } = view.docView.domFromPos(pos, 0);
  let after = offset4 < node.childNodes.length ? node.childNodes[offset4] : null;
  let before = offset4 ? node.childNodes[offset4 - 1] : null;
  if (safari && after && after.contentEditable == "false")
    return setEditable(after);
  if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
    if (after)
      return setEditable(after);
    else if (before)
      return setEditable(before);
  }
}
function setEditable(element) {
  element.contentEditable = "true";
  if (safari && element.draggable) {
    element.draggable = false;
    element.wasDraggable = true;
  }
  return element;
}
function resetEditable(element) {
  element.contentEditable = "false";
  if (element.wasDraggable) {
    element.draggable = true;
    element.wasDraggable = null;
  }
}
function removeClassOnSelectionChange(view) {
  let doc3 = view.dom.ownerDocument;
  doc3.removeEventListener("selectionchange", view.input.hideSelectionGuard);
  let domSel = view.domSelectionRange();
  let node = domSel.anchorNode, offset4 = domSel.anchorOffset;
  doc3.addEventListener("selectionchange", view.input.hideSelectionGuard = () => {
    if (domSel.anchorNode != node || domSel.anchorOffset != offset4) {
      doc3.removeEventListener("selectionchange", view.input.hideSelectionGuard);
      setTimeout(() => {
        if (!editorOwnsSelection(view) || view.state.selection.visible)
          view.dom.classList.remove("ProseMirror-hideselection");
      }, 20);
    }
  });
}
function selectCursorWrapper(view) {
  let domSel = view.domSelection();
  if (!domSel)
    return;
  let node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
  if (img)
    domSel.collapse(node.parentNode, domIndex(node) + 1);
  else
    domSel.collapse(node, 0);
  if (!img && !view.state.selection.visible && ie && ie_version <= 11) {
    node.disabled = true;
    node.disabled = false;
  }
}
function syncNodeSelection(view, sel) {
  if (sel instanceof NodeSelection) {
    let desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc)
        desc.selectNode();
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}
function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent)
      view.lastSelectedViewDesc.deselectNode();
    view.lastSelectedViewDesc = void 0;
  }
}
function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", (f) => f(view, $anchor, $head)) || TextSelection.between($anchor, $head, bias);
}
function hasFocusAndSelection(view) {
  if (view.editable && !view.hasFocus())
    return false;
  return hasSelection(view);
}
function hasSelection(view) {
  let sel = view.domSelectionRange();
  if (!sel.anchorNode)
    return false;
  try {
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_) {
    return false;
  }
}
function anchorInRightPlace(view) {
  let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  let domSel = view.domSelectionRange();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}
function moveSelectionBlock(state, dir) {
  let { $anchor, $head } = state.selection;
  let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && Selection.findFrom($start, dir);
}
function apply(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection) {
    if (mods.indexOf("s") > -1) {
      let { $head } = sel, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;
      if (!node || node.isText || !node.isLeaf)
        return false;
      let $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));
      return apply(view, new TextSelection(sel.$anchor, $newHead));
    } else if (!sel.empty) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
      let next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof NodeSelection)
        return apply(view, next);
      return false;
    } else if (!(mac2 && mods.indexOf("m") > -1)) {
      let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (!node || node.isText)
        return false;
      let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
      if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))
        return false;
      if (NodeSelection.isSelectable(node)) {
        return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));
      } else if (webkit) {
        return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof NodeSelection && sel.node.isInline) {
    return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    let next = moveSelectionBlock(view.state, dir);
    if (next)
      return apply(view, next);
    return false;
  }
}
function nodeLen(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function isIgnorable(dom, dir) {
  let desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != "BR");
}
function skipIgnoredNodes(view, dir) {
  return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);
}
function skipIgnoredNodesBefore(view) {
  let sel = view.domSelectionRange();
  let node = sel.focusNode, offset4 = sel.focusOffset;
  if (!node)
    return;
  let moveNode, moveOffset, force = false;
  if (gecko && node.nodeType == 1 && offset4 < nodeLen(node) && isIgnorable(node.childNodes[offset4], -1))
    force = true;
  for (; ; ) {
    if (offset4 > 0) {
      if (node.nodeType != 1) {
        break;
      } else {
        let before = node.childNodes[offset4 - 1];
        if (isIgnorable(before, -1)) {
          moveNode = node;
          moveOffset = --offset4;
        } else if (before.nodeType == 3) {
          node = before;
          offset4 = node.nodeValue.length;
        } else
          break;
      }
    } else if (isBlockNode(node)) {
      break;
    } else {
      let prev = node.previousSibling;
      while (prev && isIgnorable(prev, -1)) {
        moveNode = node.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }
      if (!prev) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset4 = 0;
      } else {
        node = prev;
        offset4 = nodeLen(node);
      }
    }
  }
  if (force)
    setSelFocus(view, node, offset4);
  else if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function skipIgnoredNodesAfter(view) {
  let sel = view.domSelectionRange();
  let node = sel.focusNode, offset4 = sel.focusOffset;
  if (!node)
    return;
  let len = nodeLen(node);
  let moveNode, moveOffset;
  for (; ; ) {
    if (offset4 < len) {
      if (node.nodeType != 1)
        break;
      let after = node.childNodes[offset4];
      if (isIgnorable(after, 1)) {
        moveNode = node;
        moveOffset = ++offset4;
      } else
        break;
    } else if (isBlockNode(node)) {
      break;
    } else {
      let next = node.nextSibling;
      while (next && isIgnorable(next, 1)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }
      if (!next) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset4 = len = 0;
      } else {
        node = next;
        offset4 = 0;
        len = nodeLen(node);
      }
    }
  }
  if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function isBlockNode(dom) {
  let desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
function textNodeAfter(node, offset4) {
  while (node && offset4 == node.childNodes.length && !hasBlockDesc(node)) {
    offset4 = domIndex(node) + 1;
    node = node.parentNode;
  }
  while (node && offset4 < node.childNodes.length) {
    let next = node.childNodes[offset4];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset4 = 0;
  }
}
function textNodeBefore(node, offset4) {
  while (node && !offset4 && !hasBlockDesc(node)) {
    offset4 = domIndex(node);
    node = node.parentNode;
  }
  while (node && offset4) {
    let next = node.childNodes[offset4 - 1];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset4 = node.childNodes.length;
  }
}
function setSelFocus(view, node, offset4) {
  if (node.nodeType != 3) {
    let before, after;
    if (after = textNodeAfter(node, offset4)) {
      node = after;
      offset4 = 0;
    } else if (before = textNodeBefore(node, offset4)) {
      node = before;
      offset4 = before.nodeValue.length;
    }
  }
  let sel = view.domSelection();
  if (!sel)
    return;
  if (selectionCollapsed(sel)) {
    let range = document.createRange();
    range.setEnd(node, offset4);
    range.setStart(node, offset4);
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (sel.extend) {
    sel.extend(node, offset4);
  }
  view.domObserver.setCurSelection();
  let { state } = view;
  setTimeout(() => {
    if (view.state == state)
      selectionToDOM(view);
  }, 50);
}
function findDirection(view, pos) {
  let $pos = view.state.doc.resolve(pos);
  if (!(chrome || windows) && $pos.parent.inlineContent) {
    let coords = view.coordsAtPos(pos);
    if (pos > $pos.start()) {
      let before = view.coordsAtPos(pos - 1);
      let mid = (before.top + before.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)
        return before.left < coords.left ? "ltr" : "rtl";
    }
    if (pos < $pos.end()) {
      let after = view.coordsAtPos(pos + 1);
      let mid = (after.top + after.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1)
        return after.left > coords.left ? "ltr" : "rtl";
    }
  }
  let computed2 = getComputedStyle(view.dom).direction;
  return computed2 == "rtl" ? "rtl" : "ltr";
}
function selectVertically(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1)
    return false;
  if (mac2 && mods.indexOf("m") > -1)
    return false;
  let { $from, $to } = sel;
  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    let next = moveSelectionBlock(view.state, dir);
    if (next && next instanceof NodeSelection)
      return apply(view, next);
  }
  if (!$from.parent.inlineContent) {
    let side = dir < 0 ? $from : $to;
    let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
    return beyond ? apply(view, beyond) : false;
  }
  return false;
}
function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof TextSelection))
    return true;
  let { $head, $anchor, empty: empty2 } = view.state.selection;
  if (!$head.sameParent($anchor))
    return true;
  if (!empty2)
    return false;
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))
    return true;
  let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    let tr2 = view.state.tr;
    if (dir < 0)
      tr2.delete($head.pos - nextNode.nodeSize, $head.pos);
    else
      tr2.delete($head.pos, $head.pos + nextNode.nodeSize);
    view.dispatch(tr2);
    return true;
  }
  return false;
}
function switchEditable(view, node, state) {
  view.domObserver.stop();
  node.contentEditable = state;
  view.domObserver.start();
}
function safariDownArrowBug(view) {
  if (!safari || view.state.selection.$head.parentOffset > 0)
    return false;
  let { focusNode, focusOffset } = view.domSelectionRange();
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    let child = focusNode.firstChild;
    switchEditable(view, child, "true");
    setTimeout(() => switchEditable(view, child, "false"), 20);
  }
  return false;
}
function getMods(event) {
  let result = "";
  if (event.ctrlKey)
    result += "c";
  if (event.metaKey)
    result += "m";
  if (event.altKey)
    result += "a";
  if (event.shiftKey)
    result += "s";
  return result;
}
function captureKeyDown(view, event) {
  let code2 = event.keyCode, mods = getMods(event);
  if (code2 == 8 || mac2 && code2 == 72 && mods == "c") {
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);
  } else if (code2 == 46 && !event.shiftKey || mac2 && code2 == 68 && mods == "c") {
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);
  } else if (code2 == 13 || code2 == 27) {
    return true;
  } else if (code2 == 37 || mac2 && code2 == 66 && mods == "c") {
    let dir = code2 == 37 ? findDirection(view, view.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code2 == 39 || mac2 && code2 == 70 && mods == "c") {
    let dir = code2 == 39 ? findDirection(view, view.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code2 == 38 || mac2 && code2 == 80 && mods == "c") {
    return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);
  } else if (code2 == 40 || mac2 && code2 == 78 && mods == "c") {
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);
  } else if (mods == (mac2 ? "m" : "c") && (code2 == 66 || code2 == 73 || code2 == 89 || code2 == 90)) {
    return true;
  }
  return false;
}
function serializeForClipboard(view, slice2) {
  view.someProp("transformCopied", (f) => {
    slice2 = f(slice2, view);
  });
  let context = [], { content, openStart, openEnd } = slice2;
  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    let node = content.firstChild;
    context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
    content = node.content;
  }
  let serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
  let doc3 = detachedDoc(), wrap3 = doc3.createElement("div");
  wrap3.appendChild(serializer.serializeFragment(content, { document: doc3 }));
  let firstChild = wrap3.firstChild, needsWrap, wrappers = 0;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (let i = needsWrap.length - 1; i >= 0; i--) {
      let wrapper = doc3.createElement(needsWrap[i]);
      while (wrap3.firstChild)
        wrapper.appendChild(wrap3.firstChild);
      wrap3.appendChild(wrapper);
      wrappers++;
    }
    firstChild = wrap3.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1)
    firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`);
  let text = view.someProp("clipboardTextSerializer", (f) => f(slice2, view)) || slice2.content.textBetween(0, slice2.content.size, "\n\n");
  return { dom: wrap3, text, slice: slice2 };
}
function parseFromClipboard(view, text, html, plainText, $context) {
  let inCode = $context.parent.type.spec.code;
  let dom, slice2;
  if (!html && !text)
    return null;
  let asText = !!text && (plainText || inCode || !html);
  if (asText) {
    view.someProp("transformPastedText", (f) => {
      text = f(text, inCode || plainText, view);
    });
    if (inCode) {
      slice2 = new Slice(Fragment12.from(view.state.schema.text(text.replace(/\r\n?/g, "\n"))), 0, 0);
      view.someProp("transformPasted", (f) => {
        slice2 = f(slice2, view, true);
      });
      return slice2;
    }
    let parsed = view.someProp("clipboardTextParser", (f) => f(text, $context, plainText, view));
    if (parsed) {
      slice2 = parsed;
    } else {
      let marks = $context.marks();
      let { schema } = view.state, serializer = DOMSerializer.fromSchema(schema);
      dom = document.createElement("div");
      text.split(/(?:\r\n?|\n)+/).forEach((block) => {
        let p = dom.appendChild(document.createElement("p"));
        if (block)
          p.appendChild(serializer.serializeNode(schema.text(block, marks)));
      });
    }
  } else {
    view.someProp("transformPastedHTML", (f) => {
      html = f(html, view);
    });
    dom = readHTML(html);
    if (webkit)
      restoreReplacedSpaces(dom);
  }
  let contextNode = dom && dom.querySelector("[data-pm-slice]");
  let sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
  if (sliceData && sliceData[3])
    for (let i = +sliceData[3]; i > 0; i--) {
      let child = dom.firstChild;
      while (child && child.nodeType != 1)
        child = child.nextSibling;
      if (!child)
        break;
      dom = child;
    }
  if (!slice2) {
    let parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser2.fromSchema(view.state.schema);
    slice2 = parser.parseSlice(dom, {
      preserveWhitespace: !!(asText || sliceData),
      context: $context,
      ruleFromNode(dom2) {
        if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))
          return { ignore: true };
        return null;
      }
    });
  }
  if (sliceData) {
    slice2 = addContext(closeSlice(slice2, +sliceData[1], +sliceData[2]), sliceData[4]);
  } else {
    slice2 = Slice.maxOpen(normalizeSiblings(slice2.content, $context), true);
    if (slice2.openStart || slice2.openEnd) {
      let openStart = 0, openEnd = 0;
      for (let node = slice2.content.firstChild; openStart < slice2.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {
      }
      for (let node = slice2.content.lastChild; openEnd < slice2.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild) {
      }
      slice2 = closeSlice(slice2, openStart, openEnd);
    }
  }
  view.someProp("transformPasted", (f) => {
    slice2 = f(slice2, view, asText);
  });
  return slice2;
}
var inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2)
    return fragment;
  for (let d = $context.depth; d >= 0; d--) {
    let parent = $context.node(d);
    let match = parent.contentMatchAt($context.index(d));
    let lastWrap, result = [];
    fragment.forEach((node) => {
      if (!result)
        return;
      let wrap3 = match.findWrapping(node.type), inLast;
      if (!wrap3)
        return result = null;
      if (inLast = result.length && lastWrap.length && addToSibling(wrap3, lastWrap, node, result[result.length - 1], 0)) {
        result[result.length - 1] = inLast;
      } else {
        if (result.length)
          result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
        let wrapped = withWrappers(node, wrap3);
        result.push(wrapped);
        match = match.matchType(wrapped.type);
        lastWrap = wrap3;
      }
    });
    if (result)
      return Fragment12.from(result);
  }
  return fragment;
}
function withWrappers(node, wrap3, from2 = 0) {
  for (let i = wrap3.length - 1; i >= from2; i--)
    node = wrap3[i].create(null, Fragment12.from(node));
  return node;
}
function addToSibling(wrap3, lastWrap, node, sibling, depth) {
  if (depth < wrap3.length && depth < lastWrap.length && wrap3[depth] == lastWrap[depth]) {
    let inner = addToSibling(wrap3, lastWrap, node, sibling.lastChild, depth + 1);
    if (inner)
      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    let match = sibling.contentMatchAt(sibling.childCount);
    if (match.matchType(depth == wrap3.length - 1 ? node.type : wrap3[depth + 1]))
      return sibling.copy(sibling.content.append(Fragment12.from(withWrappers(node, wrap3, depth + 1))));
  }
}
function closeRight(node, depth) {
  if (depth == 0)
    return node;
  let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
  let fill = node.contentMatchAt(node.childCount).fillBefore(Fragment12.empty, true);
  return node.copy(fragment.append(fill));
}
function closeRange(fragment, side, from2, to, depth, openEnd) {
  let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;
  if (fragment.childCount > 1)
    openEnd = 0;
  if (depth < to - 1)
    inner = closeRange(inner, side, from2, to, depth + 1, openEnd);
  if (depth >= from2)
    inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment12.empty, true));
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));
}
function closeSlice(slice2, openStart, openEnd) {
  if (openStart < slice2.openStart)
    slice2 = new Slice(closeRange(slice2.content, -1, openStart, slice2.openStart, 0, slice2.openEnd), openStart, slice2.openEnd);
  if (openEnd < slice2.openEnd)
    slice2 = new Slice(closeRange(slice2.content, 1, openEnd, slice2.openEnd, 0, 0), slice2.openStart, openEnd);
  return slice2;
}
var wrapMap = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
var _detachedDoc = null;
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
var _policy = null;
function maybeWrapTrusted(html) {
  let trustedTypes = window.trustedTypes;
  if (!trustedTypes)
    return html;
  if (!_policy)
    _policy = trustedTypes.defaultPolicy || trustedTypes.createPolicy("ProseMirrorClipboard", { createHTML: (s) => s });
  return _policy.createHTML(html);
}
function readHTML(html) {
  let metas = /^(\s*<meta [^>]*>)*/.exec(html);
  if (metas)
    html = html.slice(metas[0].length);
  let elt = detachedDoc().createElement("div");
  let firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap3;
  if (wrap3 = firstTag && wrapMap[firstTag[1].toLowerCase()])
    html = wrap3.map((n) => "<" + n + ">").join("") + html + wrap3.map((n) => "</" + n + ">").reverse().join("");
  elt.innerHTML = maybeWrapTrusted(html);
  if (wrap3)
    for (let i = 0; i < wrap3.length; i++)
      elt = elt.querySelector(wrap3[i]) || elt;
  return elt;
}
function restoreReplacedSpaces(dom) {
  let nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let i = 0; i < nodes.length; i++) {
    let node = nodes[i];
    if (node.childNodes.length == 1 && node.textContent == " " && node.parentNode)
      node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node);
  }
}
function addContext(slice2, context) {
  if (!slice2.size)
    return slice2;
  let schema = slice2.content.firstChild.type.schema, array;
  try {
    array = JSON.parse(context);
  } catch (e) {
    return slice2;
  }
  let { content, openStart, openEnd } = slice2;
  for (let i = array.length - 2; i >= 0; i -= 2) {
    let type = schema.nodes[array[i]];
    if (!type || type.hasRequiredAttrs())
      break;
    content = Fragment12.from(type.create(array[i + 1], content));
    openStart++;
    openEnd++;
  }
  return new Slice(content, openStart, openEnd);
}
var handlers = {};
var editHandlers = {};
var passiveHandlers = { touchstart: true, touchmove: true };
var InputState = class {
  constructor() {
    this.shiftKey = false;
    this.mouseDown = null;
    this.lastKeyCode = null;
    this.lastKeyCodeTime = 0;
    this.lastClick = { time: 0, x: 0, y: 0, type: "", button: 0 };
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastIOSEnter = 0;
    this.lastIOSEnterFallbackTimeout = -1;
    this.lastFocus = 0;
    this.lastTouch = 0;
    this.lastChromeDelete = 0;
    this.composing = false;
    this.compositionNode = null;
    this.composingTimeout = -1;
    this.compositionNodes = [];
    this.compositionEndedAt = -2e8;
    this.compositionID = 1;
    this.badSafariComposition = false;
    this.compositionPendingChanges = 0;
    this.domChangeCount = 0;
    this.eventHandlers = /* @__PURE__ */ Object.create(null);
    this.hideSelectionGuard = null;
  }
};
function initInput(view) {
  for (let event in handlers) {
    let handler = handlers[event];
    view.dom.addEventListener(event, view.input.eventHandlers[event] = (event2) => {
      if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers)))
        handler(view, event2);
    }, passiveHandlers[event] ? { passive: true } : void 0);
  }
  if (safari)
    view.dom.addEventListener("input", () => null);
  ensureListeners(view);
}
function setSelectionOrigin(view, origin) {
  view.input.lastSelectionOrigin = origin;
  view.input.lastSelectionTime = Date.now();
}
function destroyInput(view) {
  view.domObserver.stop();
  for (let type in view.input.eventHandlers)
    view.dom.removeEventListener(type, view.input.eventHandlers[type]);
  clearTimeout(view.input.composingTimeout);
  clearTimeout(view.input.lastIOSEnterFallbackTimeout);
}
function ensureListeners(view) {
  view.someProp("handleDOMEvents", (currentHandlers) => {
    for (let type in currentHandlers)
      if (!view.input.eventHandlers[type])
        view.dom.addEventListener(type, view.input.eventHandlers[type] = (event) => runCustomHandler(view, event));
  });
}
function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", (handlers2) => {
    let handler = handlers2[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false;
  });
}
function eventBelongsToView(view, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (let node = event.target; node != view.dom; node = node.parentNode)
    if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event))
      return false;
  return true;
}
function dispatchEvent(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers)))
    handlers[event.type](view, event);
}
editHandlers.keydown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition(view, event))
    return;
  view.input.lastKeyCode = event.keyCode;
  view.input.lastKeyCodeTime = Date.now();
  if (android && chrome && event.keyCode == 13)
    return;
  if (event.keyCode != 229)
    view.domObserver.forceFlush();
  if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    let now = Date.now();
    view.input.lastIOSEnter = now;
    view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
      if (view.input.lastIOSEnter == now) {
        view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")));
        view.input.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view.someProp("handleKeyDown", (f) => f(view, event)) || captureKeyDown(view, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "key");
  }
};
editHandlers.keyup = (view, event) => {
  if (event.keyCode == 16)
    view.input.shiftKey = false;
};
editHandlers.keypress = (view, _event) => {
  let event = _event;
  if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac2 && event.metaKey)
    return;
  if (view.someProp("handleKeyPress", (f) => f(view, event))) {
    event.preventDefault();
    return;
  }
  let sel = view.state.selection;
  if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
    let text = String.fromCharCode(event.charCode);
    let deflt = () => view.state.tr.insertText(text).scrollIntoView();
    if (!/[\r\n]/.test(text) && !view.someProp("handleTextInput", (f) => f(view, sel.$from.pos, sel.$to.pos, text, deflt)))
      view.dispatch(deflt());
    event.preventDefault();
  }
};
function eventCoords(event) {
  return { left: event.clientX, top: event.clientY };
}
function isNear(event, click) {
  let dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    if (view.someProp(propName, (f) => i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false)))
      return true;
  }
  return false;
}
function updateSelection(view, selection, origin) {
  if (!view.focused)
    view.focus();
  if (view.state.selection.eq(selection))
    return;
  let tr2 = view.state.tr.setSelection(selection);
  if (origin == "pointer")
    tr2.setMeta("pointer", true);
  view.dispatch(tr2);
}
function selectClickedLeaf(view, inside) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
  if (node && node.isAtom && NodeSelection.isSelectable(node)) {
    updateSelection(view, new NodeSelection($pos), "pointer");
    return true;
  }
  return false;
}
function selectClickedNode(view, inside) {
  if (inside == -1)
    return false;
  let sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof NodeSelection)
    selectedNode = sel.node;
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    if (NodeSelection.isSelectable(node)) {
      if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
        selectAt = $pos.before(sel.$from.depth);
      else
        selectAt = $pos.before(i);
      break;
    }
  }
  if (selectAt != null) {
    updateSelection(view, NodeSelection.create(view.state.doc, selectAt), "pointer");
    return true;
  } else {
    return false;
  }
}
function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", (f) => f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
}
function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", (f) => f(view, pos, event));
}
function handleTripleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", (f) => f(view, pos, event)) || defaultTripleClick(view, inside, event);
}
function defaultTripleClick(view, inside, event) {
  if (event.button != 0)
    return false;
  let doc3 = view.state.doc;
  if (inside == -1) {
    if (doc3.inlineContent) {
      updateSelection(view, TextSelection.create(doc3, 0, doc3.content.size), "pointer");
      return true;
    }
    return false;
  }
  let $pos = doc3.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    let nodePos = $pos.before(i);
    if (node.inlineContent)
      updateSelection(view, TextSelection.create(doc3, nodePos + 1, nodePos + 1 + node.content.size), "pointer");
    else if (NodeSelection.isSelectable(node))
      updateSelection(view, NodeSelection.create(doc3, nodePos), "pointer");
    else
      continue;
    return true;
  }
}
function forceDOMFlush(view) {
  return endComposition(view);
}
var selectNodeModifier = mac2 ? "metaKey" : "ctrlKey";
handlers.mousedown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.shiftKey;
  let flushed = forceDOMFlush(view);
  let now = Date.now(), type = "singleClick";
  if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier] && view.input.lastClick.button == event.button) {
    if (view.input.lastClick.type == "singleClick")
      type = "doubleClick";
    else if (view.input.lastClick.type == "doubleClick")
      type = "tripleClick";
  }
  view.input.lastClick = { time: now, x: event.clientX, y: event.clientY, type, button: event.button };
  let pos = view.posAtCoords(eventCoords(event));
  if (!pos)
    return;
  if (type == "singleClick") {
    if (view.input.mouseDown)
      view.input.mouseDown.done();
    view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
  } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "pointer");
  }
};
var MouseDown = class {
  constructor(view, pos, event, flushed) {
    this.view = view;
    this.pos = pos;
    this.event = event;
    this.flushed = flushed;
    this.delayedSelectionSync = false;
    this.mightDrag = null;
    this.startDoc = view.state.doc;
    this.selectNode = !!event[selectNodeModifier];
    this.allowDefault = event.shiftKey;
    let targetNode, targetPos;
    if (pos.inside > -1) {
      targetNode = view.state.doc.nodeAt(pos.inside);
      targetPos = pos.inside;
    } else {
      let $pos = view.state.doc.resolve(pos.pos);
      targetNode = $pos.parent;
      targetPos = $pos.depth ? $pos.before() : 0;
    }
    const target = flushed ? null : event.target;
    const targetDesc = target ? view.docView.nearestDesc(target, true) : null;
    this.target = targetDesc && targetDesc.nodeDOM.nodeType == 1 ? targetDesc.nodeDOM : null;
    let { selection } = view.state;
    if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)
      this.mightDrag = {
        node: targetNode,
        pos: targetPos,
        addAttr: !!(this.target && !this.target.draggable),
        setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
      };
    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.draggable = true;
      if (this.mightDrag.setUneditable)
        setTimeout(() => {
          if (this.view.input.mouseDown == this)
            this.target.setAttribute("contentEditable", "false");
        }, 20);
      this.view.domObserver.start();
    }
    view.root.addEventListener("mouseup", this.up = this.up.bind(this));
    view.root.addEventListener("mousemove", this.move = this.move.bind(this));
    setSelectionOrigin(view, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up);
    this.view.root.removeEventListener("mousemove", this.move);
    if (this.mightDrag && this.target) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.removeAttribute("draggable");
      if (this.mightDrag.setUneditable)
        this.target.removeAttribute("contentEditable");
      this.view.domObserver.start();
    }
    if (this.delayedSelectionSync)
      setTimeout(() => selectionToDOM(this.view));
    this.view.input.mouseDown = null;
  }
  up(event) {
    this.done();
    if (!this.view.dom.contains(event.target))
      return;
    let pos = this.pos;
    if (this.view.state.doc != this.startDoc)
      pos = this.view.posAtCoords(eventCoords(event));
    this.updateAllowDefault(event);
    if (this.allowDefault || !pos) {
      setSelectionOrigin(this.view, "pointer");
    } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
      event.preventDefault();
    } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
      updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
      event.preventDefault();
    } else {
      setSelectionOrigin(this.view, "pointer");
    }
  }
  move(event) {
    this.updateAllowDefault(event);
    setSelectionOrigin(this.view, "pointer");
    if (event.buttons == 0)
      this.done();
  }
  updateAllowDefault(event) {
    if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))
      this.allowDefault = true;
  }
};
handlers.touchstart = (view) => {
  view.input.lastTouch = Date.now();
  forceDOMFlush(view);
  setSelectionOrigin(view, "pointer");
};
handlers.touchmove = (view) => {
  view.input.lastTouch = Date.now();
  setSelectionOrigin(view, "pointer");
};
handlers.contextmenu = (view) => forceDOMFlush(view);
function inOrNearComposition(view, event) {
  if (view.composing)
    return true;
  if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
    view.input.compositionEndedAt = -2e8;
    return true;
  }
  return false;
}
var timeoutComposition = android ? 5e3 : -1;
editHandlers.compositionstart = editHandlers.compositionupdate = (view) => {
  if (!view.composing) {
    view.domObserver.flush();
    let { state } = view, $pos = state.selection.$to;
    if (state.selection instanceof TextSelection && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m) => m.type.spec.inclusive === false) || chrome && windows && selectionBeforeUneditable(view))) {
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition(view, true);
      view.markCursor = null;
    } else {
      endComposition(view, !state.selection.empty);
      if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        let sel = view.domSelectionRange();
        for (let node = sel.focusNode, offset4 = sel.focusOffset; node && node.nodeType == 1 && offset4 != 0; ) {
          let before = offset4 < 0 ? node.lastChild : node.childNodes[offset4 - 1];
          if (!before)
            break;
          if (before.nodeType == 3) {
            let sel2 = view.domSelection();
            if (sel2)
              sel2.collapse(before, before.nodeValue.length);
            break;
          } else {
            node = before;
            offset4 = -1;
          }
        }
      }
    }
    view.input.composing = true;
  }
  scheduleComposeEnd(view, timeoutComposition);
};
function selectionBeforeUneditable(view) {
  let { focusNode, focusOffset } = view.domSelectionRange();
  if (!focusNode || focusNode.nodeType != 1 || focusOffset >= focusNode.childNodes.length)
    return false;
  let next = focusNode.childNodes[focusOffset];
  return next.nodeType == 1 && next.contentEditable == "false";
}
editHandlers.compositionend = (view, event) => {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = event.timeStamp;
    view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;
    view.input.compositionNode = null;
    if (view.input.badSafariComposition)
      view.domObserver.forceFlush();
    else if (view.input.compositionPendingChanges)
      Promise.resolve().then(() => view.domObserver.flush());
    view.input.compositionID++;
    scheduleComposeEnd(view, 20);
  }
};
function scheduleComposeEnd(view, delay) {
  clearTimeout(view.input.composingTimeout);
  if (delay > -1)
    view.input.composingTimeout = setTimeout(() => endComposition(view), delay);
}
function clearComposition(view) {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = timestampFromCustomEvent();
  }
  while (view.input.compositionNodes.length > 0)
    view.input.compositionNodes.pop().markParentsDirty();
}
function findCompositionNode(view) {
  let sel = view.domSelectionRange();
  if (!sel.focusNode)
    return null;
  let textBefore = textNodeBefore$1(sel.focusNode, sel.focusOffset);
  let textAfter = textNodeAfter$1(sel.focusNode, sel.focusOffset);
  if (textBefore && textAfter && textBefore != textAfter) {
    let descAfter = textAfter.pmViewDesc, lastChanged = view.domObserver.lastChangedTextNode;
    if (textBefore == lastChanged || textAfter == lastChanged)
      return lastChanged;
    if (!descAfter || !descAfter.isText(textAfter.nodeValue)) {
      return textAfter;
    } else if (view.input.compositionNode == textAfter) {
      let descBefore = textBefore.pmViewDesc;
      if (!(!descBefore || !descBefore.isText(textBefore.nodeValue)))
        return textAfter;
    }
  }
  return textBefore || textAfter;
}
function timestampFromCustomEvent() {
  let event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp;
}
function endComposition(view, restarting = false) {
  if (android && view.domObserver.flushingSoon >= 0)
    return;
  view.domObserver.forceFlush();
  clearComposition(view);
  if (restarting || view.docView && view.docView.dirty) {
    let sel = selectionFromDOM(view), cur = view.state.selection;
    if (sel && !sel.eq(cur))
      view.dispatch(view.state.tr.setSelection(sel));
    else if ((view.markCursor || restarting) && !cur.$from.node(cur.$from.sharedDepth(cur.to)).inlineContent)
      view.dispatch(view.state.tr.deleteSelection());
    else
      view.updateState(view.state);
    return true;
  }
  return false;
}
function captureCopy(view, dom) {
  if (!view.dom.parentNode)
    return;
  let wrap3 = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap3.appendChild(dom);
  wrap3.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let sel = getSelection(), range = document.createRange();
  range.selectNodeContents(dom);
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range);
  setTimeout(() => {
    if (wrap3.parentNode)
      wrap3.parentNode.removeChild(wrap3);
    view.focus();
  }, 50);
}
var brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;
handlers.copy = editHandlers.cut = (view, _event) => {
  let event = _event;
  let sel = view.state.selection, cut2 = event.type == "cut";
  if (sel.empty)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let slice2 = sel.content(), { dom, text } = serializeForClipboard(view, slice2);
  if (data) {
    event.preventDefault();
    data.clearData();
    data.setData("text/html", dom.innerHTML);
    data.setData("text/plain", text);
  } else {
    captureCopy(view, dom);
  }
  if (cut2)
    view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function sliceSingleNode(slice2) {
  return slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1 ? slice2.content.firstChild : null;
}
function capturePaste(view, event) {
  if (!view.dom.parentNode)
    return;
  let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
  let target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText)
    target.contentEditable = "true";
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  setTimeout(() => {
    view.focus();
    if (target.parentNode)
      target.parentNode.removeChild(target);
    if (plainText)
      doPaste(view, target.value, null, plain, event);
    else
      doPaste(view, target.textContent, target.innerHTML, plain, event);
  }, 50);
}
function doPaste(view, text, html, preferPlain, event) {
  let slice2 = parseFromClipboard(view, text, html, preferPlain, view.state.selection.$from);
  if (view.someProp("handlePaste", (f) => f(view, event, slice2 || Slice.empty)))
    return true;
  if (!slice2)
    return false;
  let singleNode = sliceSingleNode(slice2);
  let tr2 = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice2);
  view.dispatch(tr2.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
function getText(clipboardData) {
  let text = clipboardData.getData("text/plain") || clipboardData.getData("Text");
  if (text)
    return text;
  let uris = clipboardData.getData("text/uri-list");
  return uris ? uris.replace(/\r?\n/g, " ") : "";
}
editHandlers.paste = (view, _event) => {
  let event = _event;
  if (view.composing && !android)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  if (data && doPaste(view, getText(data), data.getData("text/html"), plain, event))
    event.preventDefault();
  else
    capturePaste(view, event);
};
var Dragging = class {
  constructor(slice2, move, node) {
    this.slice = slice2;
    this.move = move;
    this.node = node;
  }
};
var dragCopyModifier = mac2 ? "altKey" : "ctrlKey";
function dragMoves(view, event) {
  let moves = view.someProp("dragCopies", (test) => !test(event));
  return moves != null ? moves : !event[dragCopyModifier];
}
handlers.dragstart = (view, _event) => {
  let event = _event;
  let mouseDown = view.input.mouseDown;
  if (mouseDown)
    mouseDown.done();
  if (!event.dataTransfer)
    return;
  let sel = view.state.selection;
  let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
  let node;
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to)) ;
  else if (mouseDown && mouseDown.mightDrag) {
    node = NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);
  } else if (event.target && event.target.nodeType == 1) {
    let desc = view.docView.nearestDesc(event.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view.docView)
      node = NodeSelection.create(view.state.doc, desc.posBefore);
  }
  let draggedSlice = (node || view.state.selection).content();
  let { dom, text, slice: slice2 } = serializeForClipboard(view, draggedSlice);
  if (!event.dataTransfer.files.length || !chrome || chrome_version > 120)
    event.dataTransfer.clearData();
  event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
  event.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI)
    event.dataTransfer.setData("text/plain", text);
  view.dragging = new Dragging(slice2, dragMoves(view, event), node);
};
handlers.dragend = (view) => {
  let dragging = view.dragging;
  window.setTimeout(() => {
    if (view.dragging == dragging)
      view.dragging = null;
  }, 50);
};
editHandlers.dragover = editHandlers.dragenter = (_, e) => e.preventDefault();
editHandlers.drop = (view, event) => {
  try {
    handleDrop(view, event, view.dragging);
  } finally {
    view.dragging = null;
  }
};
function handleDrop(view, event, dragging) {
  if (!event.dataTransfer)
    return;
  let eventPos = view.posAtCoords(eventCoords(event));
  if (!eventPos)
    return;
  let $mouse = view.state.doc.resolve(eventPos.pos);
  let slice2 = dragging && dragging.slice;
  if (slice2) {
    view.someProp("transformPasted", (f) => {
      slice2 = f(slice2, view, false);
    });
  } else {
    slice2 = parseFromClipboard(view, getText(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
  }
  let move = !!(dragging && dragMoves(view, event));
  if (view.someProp("handleDrop", (f) => f(view, event, slice2 || Slice.empty, move))) {
    event.preventDefault();
    return;
  }
  if (!slice2)
    return;
  event.preventDefault();
  let insertPos = slice2 ? dropPoint(view.state.doc, $mouse.pos, slice2) : $mouse.pos;
  if (insertPos == null)
    insertPos = $mouse.pos;
  let tr2 = view.state.tr;
  if (move) {
    let { node } = dragging;
    if (node)
      node.replace(tr2);
    else
      tr2.deleteSelection();
  }
  let pos = tr2.mapping.map(insertPos);
  let isNode3 = slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1;
  let beforeInsert = tr2.doc;
  if (isNode3)
    tr2.replaceRangeWith(pos, pos, slice2.content.firstChild);
  else
    tr2.replaceRange(pos, pos, slice2);
  if (tr2.doc.eq(beforeInsert))
    return;
  let $pos = tr2.doc.resolve(pos);
  if (isNode3 && NodeSelection.isSelectable(slice2.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice2.content.firstChild)) {
    tr2.setSelection(new NodeSelection($pos));
  } else {
    let end = tr2.mapping.map(insertPos);
    tr2.mapping.maps[tr2.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end = newTo);
    tr2.setSelection(selectionBetween(view, $pos, tr2.doc.resolve(end)));
  }
  view.focus();
  view.dispatch(tr2.setMeta("uiEvent", "drop"));
}
handlers.focus = (view) => {
  view.input.lastFocus = Date.now();
  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
    setTimeout(() => {
      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))
        selectionToDOM(view);
    }, 20);
  }
};
handlers.blur = (view, _event) => {
  let event = _event;
  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    if (event.relatedTarget && view.dom.contains(event.relatedTarget))
      view.domObserver.currentSelection.clear();
    view.focused = false;
  }
};
handlers.beforeinput = (view, _event) => {
  let event = _event;
  if (chrome && android && event.inputType == "deleteContentBackward") {
    view.domObserver.flushSoon();
    let { domChangeCount } = view.input;
    setTimeout(() => {
      if (view.input.domChangeCount != domChangeCount)
        return;
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace"))))
        return;
      let { $cursor } = view.state.selection;
      if ($cursor && $cursor.pos > 0)
        view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
    }, 50);
  }
};
for (let prop in editHandlers)
  handlers[prop] = editHandlers[prop];
function compareObjs(a, b) {
  if (a == b)
    return true;
  for (let p in a)
    if (a[p] !== b[p])
      return false;
  for (let p in b)
    if (!(p in a))
      return false;
  return true;
}
var WidgetType = class _WidgetType {
  constructor(toDOM, spec) {
    this.toDOM = toDOM;
    this.spec = spec || noSpec;
    this.side = this.spec.side || 0;
  }
  map(mapping, span, offset4, oldOffset) {
    let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
    return deleted ? null : new Decoration(pos - offset4, pos - offset4, this);
  }
  valid() {
    return true;
  }
  eq(other) {
    return this == other || other instanceof _WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
  }
  destroy(node) {
    if (this.spec.destroy)
      this.spec.destroy(node);
  }
};
var InlineType = class _InlineType {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset4, oldOffset) {
    let from2 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset4;
    let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset4;
    return from2 >= to ? null : new Decoration(from2, to, this);
  }
  valid(_, span) {
    return span.from < span.to;
  }
  eq(other) {
    return this == other || other instanceof _InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  static is(span) {
    return span.type instanceof _InlineType;
  }
  destroy() {
  }
};
var NodeType2 = class _NodeType {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset4, oldOffset) {
    let from2 = mapping.mapResult(span.from + oldOffset, 1);
    if (from2.deleted)
      return null;
    let to = mapping.mapResult(span.to + oldOffset, -1);
    if (to.deleted || to.pos <= from2.pos)
      return null;
    return new Decoration(from2.pos - offset4, to.pos - offset4, this);
  }
  valid(node, span) {
    let { index: index2, offset: offset4 } = node.content.findIndex(span.from), child;
    return offset4 == span.from && !(child = node.child(index2)).isText && offset4 + child.nodeSize == span.to;
  }
  eq(other) {
    return this == other || other instanceof _NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  destroy() {
  }
};
var Decoration = class _Decoration {
  /**
  @internal
  */
  constructor(from2, to, type) {
    this.from = from2;
    this.to = to;
    this.type = type;
  }
  /**
  @internal
  */
  copy(from2, to) {
    return new _Decoration(from2, to, this.type);
  }
  /**
  @internal
  */
  eq(other, offset4 = 0) {
    return this.type.eq(other.type) && this.from + offset4 == other.from && this.to + offset4 == other.to;
  }
  /**
  @internal
  */
  map(mapping, offset4, oldOffset) {
    return this.type.map(mapping, this, offset4, oldOffset);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(pos, toDOM, spec) {
    return new _Decoration(pos, pos, new WidgetType(toDOM, spec));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(from2, to, attrs, spec) {
    return new _Decoration(from2, to, new InlineType(attrs, spec));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(from2, to, attrs, spec) {
    return new _Decoration(from2, to, new NodeType2(attrs, spec));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof InlineType;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof WidgetType;
  }
};
var none = [];
var noSpec = {};
var DecorationSet = class _DecorationSet {
  /**
  @internal
  */
  constructor(local, children) {
    this.local = local.length ? local : none;
    this.children = children.length ? children : none;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(doc3, decorations) {
    return decorations.length ? buildTree(decorations, doc3, 0, noSpec) : empty;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(start, end, predicate) {
    let result = [];
    this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);
    return result;
  }
  findInner(start, end, result, offset4, predicate) {
    for (let i = 0; i < this.local.length; i++) {
      let span = this.local[i];
      if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))
        result.push(span.copy(span.from + offset4, span.to + offset4));
    }
    for (let i = 0; i < this.children.length; i += 3) {
      if (this.children[i] < end && this.children[i + 1] > start) {
        let childOff = this.children[i] + 1;
        this.children[i + 2].findInner(start - childOff, end - childOff, result, offset4 + childOff, predicate);
      }
    }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(mapping, doc3, options2) {
    if (this == empty || mapping.maps.length == 0)
      return this;
    return this.mapInner(mapping, doc3, 0, 0, options2 || noSpec);
  }
  /**
  @internal
  */
  mapInner(mapping, node, offset4, oldOffset, options2) {
    let newLocal;
    for (let i = 0; i < this.local.length; i++) {
      let mapped = this.local[i].map(mapping, offset4, oldOffset);
      if (mapped && mapped.type.valid(node, mapped))
        (newLocal || (newLocal = [])).push(mapped);
      else if (options2.onRemove)
        options2.onRemove(this.local[i].spec);
    }
    if (this.children.length)
      return mapChildren(this.children, newLocal || [], mapping, node, offset4, oldOffset, options2);
    else
      return newLocal ? new _DecorationSet(newLocal.sort(byPos), none) : empty;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(doc3, decorations) {
    if (!decorations.length)
      return this;
    if (this == empty)
      return _DecorationSet.create(doc3, decorations);
    return this.addInner(doc3, decorations, 0);
  }
  addInner(doc3, decorations, offset4) {
    let children, childIndex = 0;
    doc3.forEach((childNode, childOffset) => {
      let baseOffset = childOffset + offset4, found2;
      if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset)))
        return;
      if (!children)
        children = this.children.slice();
      while (childIndex < children.length && children[childIndex] < childOffset)
        childIndex += 3;
      if (children[childIndex] == childOffset)
        children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
      else
        children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
      childIndex += 3;
    });
    let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset4);
    for (let i = 0; i < local.length; i++)
      if (!local[i].type.valid(doc3, local[i]))
        local.splice(i--, 1);
    return new _DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(decorations) {
    if (decorations.length == 0 || this == empty)
      return this;
    return this.removeInner(decorations, 0);
  }
  removeInner(decorations, offset4) {
    let children = this.children, local = this.local;
    for (let i = 0; i < children.length; i += 3) {
      let found2;
      let from2 = children[i] + offset4, to = children[i + 1] + offset4;
      for (let j = 0, span; j < decorations.length; j++)
        if (span = decorations[j]) {
          if (span.from > from2 && span.to < to) {
            decorations[j] = null;
            (found2 || (found2 = [])).push(span);
          }
        }
      if (!found2)
        continue;
      if (children == this.children)
        children = this.children.slice();
      let removed = children[i + 2].removeInner(found2, from2 + 1);
      if (removed != empty) {
        children[i + 2] = removed;
      } else {
        children.splice(i, 3);
        i -= 3;
      }
    }
    if (local.length) {
      for (let i = 0, span; i < decorations.length; i++)
        if (span = decorations[i]) {
          for (let j = 0; j < local.length; j++)
            if (local[j].eq(span, offset4)) {
              if (local == this.local)
                local = this.local.slice();
              local.splice(j--, 1);
            }
        }
    }
    if (children == this.children && local == this.local)
      return this;
    return local.length || children.length ? new _DecorationSet(local, children) : empty;
  }
  forChild(offset4, node) {
    if (this == empty)
      return this;
    if (node.isLeaf)
      return _DecorationSet.empty;
    let child, local;
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] >= offset4) {
        if (this.children[i] == offset4)
          child = this.children[i + 2];
        break;
      }
    let start = offset4 + 1, end = start + node.content.size;
    for (let i = 0; i < this.local.length; i++) {
      let dec = this.local[i];
      if (dec.from < end && dec.to > start && dec.type instanceof InlineType) {
        let from2 = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;
        if (from2 < to)
          (local || (local = [])).push(dec.copy(from2, to));
      }
    }
    if (local) {
      let localSet = new _DecorationSet(local.sort(byPos), none);
      return child ? new DecorationGroup([localSet, child]) : localSet;
    }
    return child || empty;
  }
  /**
  @internal
  */
  eq(other) {
    if (this == other)
      return true;
    if (!(other instanceof _DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length)
      return false;
    for (let i = 0; i < this.local.length; i++)
      if (!this.local[i].eq(other.local[i]))
        return false;
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] != other.children[i] || this.children[i + 1] != other.children[i + 1] || !this.children[i + 2].eq(other.children[i + 2]))
        return false;
    return true;
  }
  /**
  @internal
  */
  locals(node) {
    return removeOverlap(this.localsInner(node));
  }
  /**
  @internal
  */
  localsInner(node) {
    if (this == empty)
      return none;
    if (node.inlineContent || !this.local.some(InlineType.is))
      return this.local;
    let result = [];
    for (let i = 0; i < this.local.length; i++) {
      if (!(this.local[i].type instanceof InlineType))
        result.push(this.local[i]);
    }
    return result;
  }
  forEachSet(f) {
    f(this);
  }
};
DecorationSet.empty = new DecorationSet([], []);
DecorationSet.removeOverlap = removeOverlap;
var empty = DecorationSet.empty;
var DecorationGroup = class _DecorationGroup {
  constructor(members) {
    this.members = members;
  }
  map(mapping, doc3) {
    const mappedDecos = this.members.map((member) => member.map(mapping, doc3, noSpec));
    return _DecorationGroup.from(mappedDecos);
  }
  forChild(offset4, child) {
    if (child.isLeaf)
      return DecorationSet.empty;
    let found2 = [];
    for (let i = 0; i < this.members.length; i++) {
      let result = this.members[i].forChild(offset4, child);
      if (result == empty)
        continue;
      if (result instanceof _DecorationGroup)
        found2 = found2.concat(result.members);
      else
        found2.push(result);
    }
    return _DecorationGroup.from(found2);
  }
  eq(other) {
    if (!(other instanceof _DecorationGroup) || other.members.length != this.members.length)
      return false;
    for (let i = 0; i < this.members.length; i++)
      if (!this.members[i].eq(other.members[i]))
        return false;
    return true;
  }
  locals(node) {
    let result, sorted = true;
    for (let i = 0; i < this.members.length; i++) {
      let locals = this.members[i].localsInner(node);
      if (!locals.length)
        continue;
      if (!result) {
        result = locals;
      } else {
        if (sorted) {
          result = result.slice();
          sorted = false;
        }
        for (let j = 0; j < locals.length; j++)
          result.push(locals[j]);
      }
    }
    return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(members) {
    switch (members.length) {
      case 0:
        return empty;
      case 1:
        return members[0];
      default:
        return new _DecorationGroup(members.every((m) => m instanceof DecorationSet) ? members : members.reduce((r, m) => r.concat(m instanceof DecorationSet ? m : m.members), []));
    }
  }
  forEachSet(f) {
    for (let i = 0; i < this.members.length; i++)
      this.members[i].forEachSet(f);
  }
};
function mapChildren(oldChildren, newLocal, mapping, node, offset4, oldOffset, options2) {
  let children = oldChildren.slice();
  for (let i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++) {
    let moved = 0;
    mapping.maps[i].forEach((oldStart, oldEnd, newStart, newEnd) => {
      let dSize = newEnd - newStart - (oldEnd - oldStart);
      for (let i2 = 0; i2 < children.length; i2 += 3) {
        let end = children[i2 + 1];
        if (end < 0 || oldStart > end + baseOffset - moved)
          continue;
        let start = children[i2] + baseOffset - moved;
        if (oldEnd >= start) {
          children[i2 + 1] = oldStart <= start ? -2 : -1;
        } else if (oldStart >= baseOffset && dSize) {
          children[i2] += dSize;
          children[i2 + 1] += dSize;
        }
      }
      moved += dSize;
    });
    baseOffset = mapping.maps[i].map(baseOffset, -1);
  }
  let mustRebuild = false;
  for (let i = 0; i < children.length; i += 3)
    if (children[i + 1] < 0) {
      if (children[i + 1] == -2) {
        mustRebuild = true;
        children[i + 1] = -1;
        continue;
      }
      let from2 = mapping.map(oldChildren[i] + oldOffset), fromLocal = from2 - offset4;
      if (fromLocal < 0 || fromLocal >= node.content.size) {
        mustRebuild = true;
        continue;
      }
      let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset4;
      let { index: index2, offset: childOffset } = node.content.findIndex(fromLocal);
      let childNode = node.maybeChild(index2);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        let mapped = children[i + 2].mapInner(mapping, childNode, from2 + 1, oldChildren[i] + oldOffset + 1, options2);
        if (mapped != empty) {
          children[i] = fromLocal;
          children[i + 1] = toLocal;
          children[i + 2] = mapped;
        } else {
          children[i + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  if (mustRebuild) {
    let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset4, oldOffset, options2);
    let built = buildTree(decorations, node, 0, options2);
    newLocal = built.local;
    for (let i = 0; i < children.length; i += 3)
      if (children[i + 1] < 0) {
        children.splice(i, 3);
        i -= 3;
      }
    for (let i = 0, j = 0; i < built.children.length; i += 3) {
      let from2 = built.children[i];
      while (j < children.length && children[j] < from2)
        j += 3;
      children.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2]);
    }
  }
  return new DecorationSet(newLocal.sort(byPos), children);
}
function moveSpans(spans, offset4) {
  if (!offset4 || !spans.length)
    return spans;
  let result = [];
  for (let i = 0; i < spans.length; i++) {
    let span = spans[i];
    result.push(new Decoration(span.from + offset4, span.to + offset4, span.type));
  }
  return result;
}
function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset4, oldOffset, options2) {
  function gather(set, oldOffset2) {
    for (let i = 0; i < set.local.length; i++) {
      let mapped = set.local[i].map(mapping, offset4, oldOffset2);
      if (mapped)
        decorations.push(mapped);
      else if (options2.onRemove)
        options2.onRemove(set.local[i].spec);
    }
    for (let i = 0; i < set.children.length; i += 3)
      gather(set.children[i + 2], set.children[i] + oldOffset2 + 1);
  }
  for (let i = 0; i < children.length; i += 3)
    if (children[i + 1] == -1)
      gather(children[i + 2], oldChildren[i] + oldOffset + 1);
  return decorations;
}
function takeSpansForNode(spans, node, offset4) {
  if (node.isLeaf)
    return null;
  let end = offset4 + node.nodeSize, found2 = null;
  for (let i = 0, span; i < spans.length; i++) {
    if ((span = spans[i]) && span.from > offset4 && span.to < end) {
      (found2 || (found2 = [])).push(span);
      spans[i] = null;
    }
  }
  return found2;
}
function withoutNulls(array) {
  let result = [];
  for (let i = 0; i < array.length; i++)
    if (array[i] != null)
      result.push(array[i]);
  return result;
}
function buildTree(spans, node, offset4, options2) {
  let children = [], hasNulls = false;
  node.forEach((childNode, localStart) => {
    let found2 = takeSpansForNode(spans, childNode, localStart + offset4);
    if (found2) {
      hasNulls = true;
      let subtree = buildTree(found2, childNode, offset4 + localStart + 1, options2);
      if (subtree != empty)
        children.push(localStart, localStart + childNode.nodeSize, subtree);
    }
  });
  let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset4).sort(byPos);
  for (let i = 0; i < locals.length; i++)
    if (!locals[i].type.valid(node, locals[i])) {
      if (options2.onRemove)
        options2.onRemove(locals[i].spec);
      locals.splice(i--, 1);
    }
  return locals.length || children.length ? new DecorationSet(locals, children) : empty;
}
function byPos(a, b) {
  return a.from - b.from || a.to - b.to;
}
function removeOverlap(spans) {
  let working = spans;
  for (let i = 0; i < working.length - 1; i++) {
    let span = working[i];
    if (span.from != span.to)
      for (let j = i + 1; j < working.length; j++) {
        let next = working[j];
        if (next.from == span.from) {
          if (next.to != span.to) {
            if (working == spans)
              working = spans.slice();
            working[j] = next.copy(next.from, span.to);
            insertAhead(working, j + 1, next.copy(span.to, next.to));
          }
          continue;
        } else {
          if (next.from < span.to) {
            if (working == spans)
              working = spans.slice();
            working[i] = span.copy(span.from, next.from);
            insertAhead(working, j, span.copy(next.from, span.to));
          }
          break;
        }
      }
  }
  return working;
}
function insertAhead(array, i, deco) {
  while (i < array.length && byPos(deco, array[i]) > 0)
    i++;
  array.splice(i, 0, deco);
}
function viewDecorations(view) {
  let found2 = [];
  view.someProp("decorations", (f) => {
    let result = f(view.state);
    if (result && result != empty)
      found2.push(result);
  });
  if (view.cursorWrapper)
    found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
  return DecorationGroup.from(found2);
}
var observeOptions = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  attributes: true,
  attributeOldValue: true,
  subtree: true
};
var useCharData = ie && ie_version <= 11;
var SelectionState = class {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  set(sel) {
    this.anchorNode = sel.anchorNode;
    this.anchorOffset = sel.anchorOffset;
    this.focusNode = sel.focusNode;
    this.focusOffset = sel.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(sel) {
    return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
  }
};
var DOMObserver = class {
  constructor(view, handleDOMChange) {
    this.view = view;
    this.handleDOMChange = handleDOMChange;
    this.queue = [];
    this.flushingSoon = -1;
    this.observer = null;
    this.currentSelection = new SelectionState();
    this.onCharData = null;
    this.suppressingSelectionUpdates = false;
    this.lastChangedTextNode = null;
    this.observer = window.MutationObserver && new window.MutationObserver((mutations) => {
      for (let i = 0; i < mutations.length; i++)
        this.queue.push(mutations[i]);
      if (ie && ie_version <= 11 && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length)) {
        this.flushSoon();
      } else if (safari && view.composing && mutations.some((m) => m.type == "childList" && m.target.nodeName == "TR")) {
        view.input.badSafariComposition = true;
        this.flushSoon();
      } else {
        this.flush();
      }
    });
    if (useCharData) {
      this.onCharData = (e) => {
        this.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue });
        this.flushSoon();
      };
    }
    this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    if (this.flushingSoon < 0)
      this.flushingSoon = window.setTimeout(() => {
        this.flushingSoon = -1;
        this.flush();
      }, 20);
  }
  forceFlush() {
    if (this.flushingSoon > -1) {
      window.clearTimeout(this.flushingSoon);
      this.flushingSoon = -1;
      this.flush();
    }
  }
  start() {
    if (this.observer) {
      this.observer.takeRecords();
      this.observer.observe(this.view.dom, observeOptions);
    }
    if (this.onCharData)
      this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let take = this.observer.takeRecords();
      if (take.length) {
        for (let i = 0; i < take.length; i++)
          this.queue.push(take[i]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    if (this.onCharData)
      this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = true;
    setTimeout(() => this.suppressingSelectionUpdates = false, 50);
  }
  onSelectionChange() {
    if (!hasFocusAndSelection(this.view))
      return;
    if (this.suppressingSelectionUpdates)
      return selectionToDOM(this.view);
    if (ie && ie_version <= 11 && !this.view.state.selection.empty) {
      let sel = this.view.domSelectionRange();
      if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
        return this.flushSoon();
    }
    this.flush();
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(sel) {
    if (!sel.focusNode)
      return true;
    let ancestors = /* @__PURE__ */ new Set(), container;
    for (let scan = sel.focusNode; scan; scan = parentNode(scan))
      ancestors.add(scan);
    for (let scan = sel.anchorNode; scan; scan = parentNode(scan))
      if (ancestors.has(scan)) {
        container = scan;
        break;
      }
    let desc = container && this.view.docView.nearestDesc(container);
    if (desc && desc.ignoreMutation({
      type: "selection",
      target: container.nodeType == 3 ? container.parentNode : container
    })) {
      this.setCurSelection();
      return true;
    }
  }
  pendingRecords() {
    if (this.observer)
      for (let mut of this.observer.takeRecords())
        this.queue.push(mut);
    return this.queue;
  }
  flush() {
    let { view } = this;
    if (!view.docView || this.flushingSoon > -1)
      return;
    let mutations = this.pendingRecords();
    if (mutations.length)
      this.queue = [];
    let sel = view.domSelectionRange();
    let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);
    let from2 = -1, to = -1, typeOver = false, added = [];
    if (view.editable) {
      for (let i = 0; i < mutations.length; i++) {
        let result = this.registerMutation(mutations[i], added);
        if (result) {
          from2 = from2 < 0 ? result.from : Math.min(result.from, from2);
          to = to < 0 ? result.to : Math.max(result.to, to);
          if (result.typeOver)
            typeOver = true;
        }
      }
    }
    if (added.some((n) => n.nodeName == "BR") && (view.input.lastKeyCode == 8 || view.input.lastKeyCode == 46)) {
      for (let node of added)
        if (node.nodeName == "BR" && node.parentNode) {
          let after = node.nextSibling;
          if (after && after.nodeType == 1 && after.contentEditable == "false")
            node.parentNode.removeChild(node);
        }
    } else if (gecko && added.length) {
      let brs = added.filter((n) => n.nodeName == "BR");
      if (brs.length == 2) {
        let [a, b] = brs;
        if (a.parentNode && a.parentNode.parentNode == b.parentNode)
          b.remove();
        else
          a.remove();
      } else {
        let { focusNode } = this.currentSelection;
        for (let br of brs) {
          let parent = br.parentNode;
          if (parent && parent.nodeName == "LI" && (!focusNode || blockParent(view, focusNode) != parent))
            br.remove();
        }
      }
    }
    let readSel = null;
    if (from2 < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(Selection.near(view.state.doc.resolve(0), 1))) {
      view.input.lastFocus = 0;
      selectionToDOM(view);
      this.currentSelection.set(sel);
      view.scrollToSelection();
    } else if (from2 > -1 || newSel) {
      if (from2 > -1) {
        view.docView.markDirty(from2, to);
        checkCSS(view);
      }
      if (view.input.badSafariComposition) {
        view.input.badSafariComposition = false;
        fixUpBadSafariComposition(view, added);
      }
      this.handleDOMChange(from2, to, typeOver, added);
      if (view.docView && view.docView.dirty)
        view.updateState(view.state);
      else if (!this.currentSelection.eq(sel))
        selectionToDOM(view);
      this.currentSelection.set(sel);
    }
  }
  registerMutation(mut, added) {
    if (added.indexOf(mut.target) > -1)
      return null;
    let desc = this.view.docView.nearestDesc(mut.target);
    if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style")))
      return null;
    if (!desc || desc.ignoreMutation(mut))
      return null;
    if (mut.type == "childList") {
      for (let i = 0; i < mut.addedNodes.length; i++) {
        let node = mut.addedNodes[i];
        added.push(node);
        if (node.nodeType == 3)
          this.lastChangedTextNode = node;
      }
      if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
        return { from: desc.posBefore, to: desc.posAfter };
      let prev = mut.previousSibling, next = mut.nextSibling;
      if (ie && ie_version <= 11 && mut.addedNodes.length) {
        for (let i = 0; i < mut.addedNodes.length; i++) {
          let { previousSibling, nextSibling } = mut.addedNodes[i];
          if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)
            prev = previousSibling;
          if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)
            next = nextSibling;
        }
      }
      let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
      let from2 = desc.localPosFromDOM(mut.target, fromOffset, -1);
      let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
      let to = desc.localPosFromDOM(mut.target, toOffset, 1);
      return { from: from2, to };
    } else if (mut.type == "attributes") {
      return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
    } else {
      this.lastChangedTextNode = mut.target;
      return {
        from: desc.posAtStart,
        to: desc.posAtEnd,
        // An event was generated for a text change that didn't change
        // any text. Mark the dom change to fall back to assuming the
        // selection was typed over with an identical value if it can't
        // find another change.
        typeOver: mut.target.nodeValue == mut.oldValue
      };
    }
  }
};
var cssChecked = /* @__PURE__ */ new WeakMap();
var cssCheckWarned = false;
function checkCSS(view) {
  if (cssChecked.has(view))
    return;
  cssChecked.set(view, null);
  if (["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {
    view.requiresGeckoHackNode = gecko;
    if (cssCheckWarned)
      return;
    console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
    cssCheckWarned = true;
  }
}
function rangeToSelectionRange(view, range) {
  let anchorNode = range.startContainer, anchorOffset = range.startOffset;
  let focusNode = range.endContainer, focusOffset = range.endOffset;
  let currentAnchor = view.domAtPos(view.state.selection.anchor);
  if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
function safariShadowSelectionRange(view, selection) {
  if (selection.getComposedRanges) {
    let range = selection.getComposedRanges(view.root)[0];
    if (range)
      return rangeToSelectionRange(view, range);
  }
  let found2;
  function read(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found2 = event.getTargetRanges()[0];
  }
  view.dom.addEventListener("beforeinput", read, true);
  document.execCommand("indent");
  view.dom.removeEventListener("beforeinput", read, true);
  return found2 ? rangeToSelectionRange(view, found2) : null;
}
function blockParent(view, node) {
  for (let p = node.parentNode; p && p != view.dom; p = p.parentNode) {
    let desc = view.docView.nearestDesc(p, true);
    if (desc && desc.node.isBlock)
      return p;
  }
  return null;
}
function fixUpBadSafariComposition(view, addedNodes) {
  var _a6;
  let { focusNode, focusOffset } = view.domSelectionRange();
  for (let node of addedNodes) {
    if (((_a6 = node.parentNode) === null || _a6 === void 0 ? void 0 : _a6.nodeName) == "TR") {
      let nextCell = node.nextSibling;
      while (nextCell && (nextCell.nodeName != "TD" && nextCell.nodeName != "TH"))
        nextCell = nextCell.nextSibling;
      if (nextCell) {
        let parent = nextCell;
        for (; ; ) {
          let first2 = parent.firstChild;
          if (!first2 || first2.nodeType != 1 || first2.contentEditable == "false" || /^(BR|IMG)$/.test(first2.nodeName))
            break;
          parent = first2;
        }
        parent.insertBefore(node, parent.firstChild);
        if (focusNode == node)
          view.domSelection().collapse(node, focusOffset);
      } else {
        node.parentNode.removeChild(node);
      }
    }
  }
}
function parseBetween(view, from_, to_) {
  let { node: parent, fromOffset, toOffset, from: from2, to } = view.docView.parseRange(from_, to_);
  let domSel = view.domSelectionRange();
  let find2;
  let anchor = domSel.anchorNode;
  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find2 = [{ node: anchor, offset: domSel.anchorOffset }];
    if (!selectionCollapsed(domSel))
      find2.push({ node: domSel.focusNode, offset: domSel.focusOffset });
  }
  if (chrome && view.input.lastKeyCode === 8) {
    for (let off = toOffset; off > fromOffset; off--) {
      let node = parent.childNodes[off - 1], desc = node.pmViewDesc;
      if (node.nodeName == "BR" && !desc) {
        toOffset = off;
        break;
      }
      if (!desc || desc.size)
        break;
    }
  }
  let startDoc = view.state.doc;
  let parser = view.someProp("domParser") || DOMParser2.fromSchema(view.state.schema);
  let $from = startDoc.resolve(from2);
  let sel = null, doc3 = parser.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
    findPositions: find2,
    ruleFromNode,
    context: $from
  });
  if (find2 && find2[0].pos != null) {
    let anchor2 = find2[0].pos, head = find2[1] && find2[1].pos;
    if (head == null)
      head = anchor2;
    sel = { anchor: anchor2 + from2, head: head + from2 };
  }
  return { doc: doc3, sel, from: from2, to };
}
function ruleFromNode(dom) {
  let desc = dom.pmViewDesc;
  if (desc) {
    return desc.parseRule();
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      let skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return { skip };
    } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return { ignore: true };
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return { ignore: true };
  }
  return null;
}
var isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|img|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function readDOMChange(view, from2, to, typeOver, addedNodes) {
  let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);
  view.input.compositionPendingChanges = 0;
  if (from2 < 0) {
    let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
    let newSel = selectionFromDOM(view, origin);
    if (newSel && !view.state.selection.eq(newSel)) {
      if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter"))))
        return;
      let tr2 = view.state.tr.setSelection(newSel);
      if (origin == "pointer")
        tr2.setMeta("pointer", true);
      else if (origin == "key")
        tr2.scrollIntoView();
      if (compositionID)
        tr2.setMeta("composition", compositionID);
      view.dispatch(tr2);
    }
    return;
  }
  let $before = view.state.doc.resolve(from2);
  let shared = $before.sharedDepth(to);
  from2 = $before.before(shared + 1);
  to = view.state.doc.resolve(to).after(shared + 1);
  let sel = view.state.selection;
  let parse3 = parseBetween(view, from2, to);
  let doc3 = view.state.doc, compare = doc3.slice(parse3.from, parse3.to);
  let preferredPos, preferredSide;
  if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }
  view.input.lastKeyCode = null;
  let change = findDiff(compare.content, parse3.doc.content, parse3.from, preferredPos, preferredSide);
  if (change)
    view.input.domChangeCount++;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n) => n.nodeType == 1 && !isInline.test(n.nodeName)) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (!change) {
    if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse3.sel && parse3.sel.anchor != parse3.sel.head)) {
      change = { start: sel.from, endA: sel.to, endB: sel.to };
    } else {
      if (parse3.sel) {
        let sel2 = resolveSelection(view, view.state.doc, parse3.sel);
        if (sel2 && !sel2.eq(view.state.selection)) {
          let tr2 = view.state.tr.setSelection(sel2);
          if (compositionID)
            tr2.setMeta("composition", compositionID);
          view.dispatch(tr2);
        }
      }
      return;
    }
  }
  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse3.from) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse3.to) {
      change.endB += view.state.selection.to - change.endA;
      change.endA = view.state.selection.to;
    }
  }
  if (ie && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse3.from && parse3.doc.textBetween(change.start - parse3.from - 1, change.start - parse3.from + 1) == "  ") {
    change.start--;
    change.endA--;
    change.endB--;
  }
  let $from = parse3.doc.resolveNoCache(change.start - parse3.from);
  let $to = parse3.doc.resolveNoCache(change.endB - parse3.from);
  let $fromA = doc3.resolve(change.start);
  let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n) => n.nodeName == "DIV" || n.nodeName == "P")) || !inlineChange && $from.pos < parse3.doc.content.size && (!$from.sameParent($to) || !$from.parent.inlineContent) && $from.pos < $to.pos && !/\S/.test(parse3.doc.textBetween($from.pos, $to.pos, "", ""))) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (view.state.selection.anchor > change.start && looksLikeBackspace(doc3, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace")))) {
    if (android && chrome)
      view.domObserver.suppressSelectionUpdates();
    return;
  }
  if (chrome && change.endB == change.start)
    view.input.lastChromeDelete = Date.now();
  if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse3.sel && parse3.sel.anchor == parse3.sel.head && parse3.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse3.doc.resolveNoCache(change.endB - parse3.from);
    setTimeout(() => {
      view.someProp("handleKeyDown", function(f) {
        return f(view, keyEvent(13, "Enter"));
      });
    }, 20);
  }
  let chFrom = change.start, chTo = change.endA;
  let mkTr = (base2) => {
    let tr2 = base2 || view.state.tr.replace(chFrom, chTo, parse3.doc.slice(change.start - parse3.from, change.endB - parse3.from));
    if (parse3.sel) {
      let sel2 = resolveSelection(view, tr2.doc, parse3.sel);
      if (sel2 && !(chrome && view.composing && sel2.empty && (change.start != change.endB || view.input.lastChromeDelete < Date.now() - 100) && (sel2.head == chFrom || sel2.head == tr2.mapping.map(chTo) - 1) || ie && sel2.empty && sel2.head == chFrom))
        tr2.setSelection(sel2);
    }
    if (compositionID)
      tr2.setMeta("composition", compositionID);
    return tr2.scrollIntoView();
  };
  let markChange;
  if (inlineChange) {
    if ($from.pos == $to.pos) {
      if (ie && ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(() => selectionToDOM(view), 20);
      }
      let tr2 = mkTr(view.state.tr.delete(chFrom, chTo));
      let marks = doc3.resolve(change.start).marksAcross(doc3.resolve(change.endA));
      if (marks)
        tr2.ensureMarks(marks);
      view.dispatch(tr2);
    } else if (
      // Adding or removing a mark
      change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))
    ) {
      let tr2 = mkTr(view.state.tr);
      if (markChange.type == "add")
        tr2.addMark(chFrom, chTo, markChange.mark);
      else
        tr2.removeMark(chFrom, chTo, markChange.mark);
      view.dispatch(tr2);
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      let deflt = () => mkTr(view.state.tr.insertText(text, chFrom, chTo));
      if (!view.someProp("handleTextInput", (f) => f(view, chFrom, chTo, text, deflt)))
        view.dispatch(deflt());
    } else {
      view.dispatch(mkTr());
    }
  } else {
    view.dispatch(mkTr());
  }
}
function resolveSelection(view, doc3, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc3.content.size)
    return null;
  return selectionBetween(view, doc3.resolve(parsedSel.anchor), doc3.resolve(parsedSel.head));
}
function isMarkChange(cur, prev) {
  let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
  let added = curMarks, removed = prevMarks, type, mark, update;
  for (let i = 0; i < prevMarks.length; i++)
    added = prevMarks[i].removeFromSet(added);
  for (let i = 0; i < curMarks.length; i++)
    removed = curMarks[i].removeFromSet(removed);
  if (added.length == 1 && removed.length == 0) {
    mark = added[0];
    type = "add";
    update = (node) => node.mark(mark.addToSet(node.marks));
  } else if (added.length == 0 && removed.length == 1) {
    mark = removed[0];
    type = "remove";
    update = (node) => node.mark(mark.removeFromSet(node.marks));
  } else {
    return null;
  }
  let updated = [];
  for (let i = 0; i < prev.childCount; i++)
    updated.push(update(prev.child(i)));
  if (Fragment12.from(updated).eq(cur))
    return { mark, type };
}
function looksLikeBackspace(old, start, end, $newStart, $newEnd) {
  if (
    // The content must have shrunk
    end - start <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into
    skipClosingAndOpening($newStart, true, false) < $newEnd.pos
  )
    return false;
  let $start = old.resolve(start);
  if (!$newStart.parent.isTextblock) {
    let after = $start.nodeAfter;
    return after != null && end == start + after.nodeSize;
  }
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
    return false;
  let $next = old.resolve(skipClosingAndOpening($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end)
    return false;
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}
function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  let depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end++;
    fromEnd = false;
  }
  if (mayOpen) {
    let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next && !next.isLeaf) {
      next = next.firstChild;
      end++;
    }
  }
  return end;
}
function findDiff(a, b, pos, preferredPos, preferredSide) {
  let start = a.findDiffStart(b, pos);
  if (start == null)
    return null;
  let { a: endA, b: endB } = a.findDiffEnd(b, pos + a.size, pos + b.size);
  if (preferredSide == "end") {
    let adjust = Math.max(0, start - Math.min(endA, endB));
    preferredPos -= endA + adjust - start;
  }
  if (endA < start && a.size < b.size) {
    let move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;
    start -= move;
    if (start && start < b.size && isSurrogatePair(b.textBetween(start - 1, start + 1)))
      start += move ? 1 : -1;
    endB = start + (endB - endA);
    endA = start;
  } else if (endB < start) {
    let move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;
    start -= move;
    if (start && start < a.size && isSurrogatePair(a.textBetween(start - 1, start + 1)))
      start += move ? 1 : -1;
    endA = start + (endA - endB);
    endB = start;
  }
  return { start, endA, endB };
}
function isSurrogatePair(str) {
  if (str.length != 2)
    return false;
  let a = str.charCodeAt(0), b = str.charCodeAt(1);
  return a >= 56320 && a <= 57343 && b >= 55296 && b <= 56319;
}
var EditorView = class {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(place, props) {
    this._root = null;
    this.focused = false;
    this.trackWrites = null;
    this.mounted = false;
    this.markCursor = null;
    this.cursorWrapper = null;
    this.lastSelectedViewDesc = void 0;
    this.input = new InputState();
    this.prevDirectPlugins = [];
    this.pluginViews = [];
    this.requiresGeckoHackNode = false;
    this.dragging = null;
    this._props = props;
    this.state = props.state;
    this.directPlugins = props.plugins || [];
    this.directPlugins.forEach(checkStateComponent);
    this.dispatch = this.dispatch.bind(this);
    this.dom = place && place.mount || document.createElement("div");
    if (place) {
      if (place.appendChild)
        place.appendChild(this.dom);
      else if (typeof place == "function")
        place(this.dom);
      else if (place.mount)
        this.mounted = true;
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    this.nodeViews = buildNodeViews(this);
    this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
    this.domObserver = new DOMObserver(this, (from2, to, typeOver, added) => readDOMChange(this, from2, to, typeOver, added));
    this.domObserver.start();
    initInput(this);
    this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let prev = this._props;
      this._props = {};
      for (let name in prev)
        this._props[name] = prev[name];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(props) {
    if (props.handleDOMEvents != this._props.handleDOMEvents)
      ensureListeners(this);
    let prevProps = this._props;
    this._props = props;
    if (props.plugins) {
      props.plugins.forEach(checkStateComponent);
      this.directPlugins = props.plugins;
    }
    this.updateStateInner(props.state, prevProps);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(props) {
    let updated = {};
    for (let name in this._props)
      updated[name] = this._props[name];
    updated.state = this.state;
    for (let name in props)
      updated[name] = props[name];
    this.update(updated);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(state) {
    this.updateStateInner(state, this._props);
  }
  updateStateInner(state, prevProps) {
    var _a6;
    let prev = this.state, redraw = false, updateSel = false;
    if (state.storedMarks && this.composing) {
      clearComposition(this);
      updateSel = true;
    }
    this.state = state;
    let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;
    if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
      let nodeViews = buildNodeViews(this);
      if (changedNodeViews(nodeViews, this.nodeViews)) {
        this.nodeViews = nodeViews;
        redraw = true;
      }
    }
    if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
      ensureListeners(this);
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
    let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
    let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
    if (updateDoc || !state.selection.eq(prev.selection))
      updateSel = true;
    let oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
    if (updateSel) {
      this.domObserver.stop();
      let forceSelUpdate = updateDoc && (ie || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
      if (updateDoc) {
        let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;
        if (this.composing)
          this.input.compositionNode = findCompositionNode(this);
        if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
          this.docView.updateOuterDeco(outerDeco);
          this.docView.destroy();
          this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
        }
        if (chromeKludge && (!this.trackWrites || !this.dom.contains(this.trackWrites)))
          forceSelUpdate = true;
      }
      if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {
        selectionToDOM(this, forceSelUpdate);
      } else {
        syncNodeSelection(this, state.selection);
        this.domObserver.setCurSelection();
      }
      this.domObserver.start();
    }
    this.updatePluginViews(prev);
    if (((_a6 = this.dragging) === null || _a6 === void 0 ? void 0 : _a6.node) && !prev.doc.eq(state.doc))
      this.updateDraggedNode(this.dragging, prev);
    if (scroll == "reset") {
      this.dom.scrollTop = 0;
    } else if (scroll == "to selection") {
      this.scrollToSelection();
    } else if (oldScrollPos) {
      resetScrollPos(oldScrollPos);
    }
  }
  /**
  @internal
  */
  scrollToSelection() {
    let startDOM = this.domSelectionRange().focusNode;
    if (!startDOM || !this.dom.contains(startDOM.nodeType == 1 ? startDOM : startDOM.parentNode)) ;
    else if (this.someProp("handleScrollToSelection", (f) => f(this))) ;
    else if (this.state.selection instanceof NodeSelection) {
      let target = this.docView.domAfterPos(this.state.selection.from);
      if (target.nodeType == 1)
        scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
    } else {
      scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
    }
  }
  destroyPluginViews() {
    let view;
    while (view = this.pluginViews.pop())
      if (view.destroy)
        view.destroy();
  }
  updatePluginViews(prevState) {
    if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins;
      this.destroyPluginViews();
      for (let i = 0; i < this.directPlugins.length; i++) {
        let plugin = this.directPlugins[i];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
      for (let i = 0; i < this.state.plugins.length; i++) {
        let plugin = this.state.plugins[i];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
    } else {
      for (let i = 0; i < this.pluginViews.length; i++) {
        let pluginView = this.pluginViews[i];
        if (pluginView.update)
          pluginView.update(this, prevState);
      }
    }
  }
  updateDraggedNode(dragging, prev) {
    let sel = dragging.node, found2 = -1;
    if (this.state.doc.nodeAt(sel.from) == sel.node) {
      found2 = sel.from;
    } else {
      let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);
      let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);
      if (moved == sel.node)
        found2 = movedPos;
    }
    this.dragging = new Dragging(dragging.slice, dragging.move, found2 < 0 ? void 0 : NodeSelection.create(this.state.doc, found2));
  }
  someProp(propName, f) {
    let prop = this._props && this._props[propName], value;
    if (prop != null && (value = f ? f(prop) : prop))
      return value;
    for (let i = 0; i < this.directPlugins.length; i++) {
      let prop2 = this.directPlugins[i].props[propName];
      if (prop2 != null && (value = f ? f(prop2) : prop2))
        return value;
    }
    let plugins = this.state.plugins;
    if (plugins)
      for (let i = 0; i < plugins.length; i++) {
        let prop2 = plugins[i].props[propName];
        if (prop2 != null && (value = f ? f(prop2) : prop2))
          return value;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (ie) {
      let node = this.root.activeElement;
      if (node == this.dom)
        return true;
      if (!node || !this.dom.contains(node))
        return false;
      while (node && this.dom != node && this.dom.contains(node)) {
        if (node.contentEditable == "false")
          return false;
        node = node.parentElement;
      }
      return true;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop();
    if (this.editable)
      focusPreventScroll(this.dom);
    selectionToDOM(this);
    this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let cached = this._root;
    if (cached == null)
      for (let search = this.dom.parentNode; search; search = search.parentNode) {
        if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
          if (!search.getSelection)
            Object.getPrototypeOf(search).getSelection = () => search.ownerDocument.getSelection();
          return this._root = search;
        }
      }
    return cached || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(coords) {
    return posAtCoords(this, coords);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(pos, side = 1) {
    return coordsAtPos(this, pos, side);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(pos, side = 0) {
    return this.docView.domFromPos(pos, side);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(pos) {
    let desc = this.docView.descAt(pos);
    return desc ? desc.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimes—for example when interpreting an event
  target—you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(node, offset4, bias = -1) {
    let pos = this.docView.posFromDOM(node, offset4, bias);
    if (pos == null)
      throw new RangeError("DOM position not inside the editor");
    return pos;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(dir, state) {
    return endOfTextblock(this, state || this.state, dir);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(html, event) {
    return doPaste(this, "", html, false, event || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(text, event) {
    return doPaste(this, text, null, true, event || new ClipboardEvent("paste"));
  }
  /**
  Serialize the given slice as it would be if it was copied from
  this editor. Returns a DOM element that contains a
  representation of the slice as its children, a textual
  representation, and the transformed slice (which can be
  different from the given input due to hooks like
  [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
  */
  serializeForClipboard(slice2) {
    return serializeForClipboard(this, slice2);
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    if (!this.docView)
      return;
    destroyInput(this);
    this.destroyPluginViews();
    if (this.mounted) {
      this.docView.update(this.state.doc, [], viewDecorations(this), this);
      this.dom.textContent = "";
    } else if (this.dom.parentNode) {
      this.dom.parentNode.removeChild(this.dom);
    }
    this.docView.destroy();
    this.docView = null;
    clearReusedRange();
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(event) {
    return dispatchEvent(this, event);
  }
  /**
  @internal
  */
  domSelectionRange() {
    let sel = this.domSelection();
    if (!sel)
      return { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
    return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariShadowSelectionRange(this, sel) || sel;
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
};
EditorView.prototype.dispatch = function(tr2) {
  let dispatchTransaction = this._props.dispatchTransaction;
  if (dispatchTransaction)
    dispatchTransaction.call(this, tr2);
  else
    this.updateState(this.state.apply(tr2));
};
function computeDocDeco(view) {
  let attrs = /* @__PURE__ */ Object.create(null);
  attrs.class = "ProseMirror";
  attrs.contenteditable = String(view.editable);
  view.someProp("attributes", (value) => {
    if (typeof value == "function")
      value = value(view.state);
    if (value)
      for (let attr in value) {
        if (attr == "class")
          attrs.class += " " + value[attr];
        else if (attr == "style")
          attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
        else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName")
          attrs[attr] = String(value[attr]);
      }
  });
  if (!attrs.translate)
    attrs.translate = "no";
  return [Decoration.node(0, view.state.doc.content.size, attrs)];
}
function updateCursorWrapper(view) {
  if (view.markCursor) {
    let dom = document.createElement("img");
    dom.className = "ProseMirror-separator";
    dom.setAttribute("mark-placeholder", "true");
    dom.setAttribute("alt", "");
    view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.from, dom, { raw: true, marks: view.markCursor }) };
  } else {
    view.cursorWrapper = null;
  }
}
function getEditable(view) {
  return !view.someProp("editable", (value) => value(view.state) === false);
}
function selectionContextChanged(sel1, sel2) {
  let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}
function buildNodeViews(view) {
  let result = /* @__PURE__ */ Object.create(null);
  function add(obj) {
    for (let prop in obj)
      if (!Object.prototype.hasOwnProperty.call(result, prop))
        result[prop] = obj[prop];
  }
  view.someProp("nodeViews", add);
  view.someProp("markViews", add);
  return result;
}
function changedNodeViews(a, b) {
  let nA = 0, nB = 0;
  for (let prop in a) {
    if (a[prop] != b[prop])
      return true;
    nA++;
  }
  for (let _ in b)
    nB++;
  return nA != nB;
}
function checkStateComponent(plugin) {
  if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}

// ../node_modules/w3c-keyname/index.js
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
var mac3 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie2 = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);
var i;
for (i = 1; i <= 24; i++) base[i + 111] = "F" + i;
var i;
for (i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}
var i;
for (code2 in base) if (!shift.hasOwnProperty(code2)) shift[code2] = base[code2];
var code2;
function keyName(event) {
  var ignoreKey = mac3 && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie2 && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
  var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
  if (name == "Esc") name = "Escape";
  if (name == "Del") name = "Delete";
  if (name == "Left") name = "ArrowLeft";
  if (name == "Up") name = "ArrowUp";
  if (name == "Right") name = "ArrowRight";
  if (name == "Down") name = "ArrowDown";
  return name;
}

// ../node_modules/prosemirror-keymap/dist/index.js
var mac4 = typeof navigator != "undefined" && /Mac|iP(hone|[oa]d)/.test(navigator.platform);
var windows2 = typeof navigator != "undefined" && /Win/.test(navigator.platform);
function normalizeKeyName(name) {
  let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
  if (result == "Space")
    result = " ";
  let alt, ctrl, shift5, meta;
  for (let i = 0; i < parts.length - 1; i++) {
    let mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift5 = true;
    else if (/^mod$/i.test(mod)) {
      if (mac4)
        meta = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result = "Alt-" + result;
  if (ctrl)
    result = "Ctrl-" + result;
  if (meta)
    result = "Meta-" + result;
  if (shift5)
    result = "Shift-" + result;
  return result;
}
function normalize(map2) {
  let copy2 = /* @__PURE__ */ Object.create(null);
  for (let prop in map2)
    copy2[normalizeKeyName(prop)] = map2[prop];
  return copy2;
}
function modifiers(name, event, shift5 = true) {
  if (event.altKey)
    name = "Alt-" + name;
  if (event.ctrlKey)
    name = "Ctrl-" + name;
  if (event.metaKey)
    name = "Meta-" + name;
  if (shift5 && event.shiftKey)
    name = "Shift-" + name;
  return name;
}
function keymap(bindings) {
  return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
}
function keydownHandler(bindings) {
  let map2 = normalize(bindings);
  return function(view, event) {
    let name = keyName(event), baseName, direct = map2[modifiers(name, event)];
    if (direct && direct(view.state, view.dispatch, view))
      return true;
    if (name.length == 1 && name != " ") {
      if (event.shiftKey) {
        let noShift = map2[modifiers(name, event, false)];
        if (noShift && noShift(view.state, view.dispatch, view))
          return true;
      }
      if ((event.altKey || event.metaKey || event.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
      !(windows2 && event.ctrlKey && event.altKey) && (baseName = base[event.keyCode]) && baseName != name) {
        let fromCode = map2[modifiers(baseName, event)];
        if (fromCode && fromCode(view.state, view.dispatch, view))
          return true;
      }
    }
    return false;
  };
}

// ../node_modules/@tiptap/core/dist/index.js
var __defProp11 = Object.defineProperty;
var __export2 = (target, all) => {
  for (var name in all)
    __defProp11(target, name, { get: all[name], enumerable: true });
};
function createChainableState(config) {
  const { state, transaction: transaction2 } = config;
  let { selection } = transaction2;
  let { doc: doc3 } = transaction2;
  let { storedMarks } = transaction2;
  return {
    ...state,
    apply: state.apply.bind(state),
    applyTransaction: state.applyTransaction.bind(state),
    plugins: state.plugins,
    schema: state.schema,
    reconfigure: state.reconfigure.bind(state),
    toJSON: state.toJSON.bind(state),
    get storedMarks() {
      return storedMarks;
    },
    get selection() {
      return selection;
    },
    get doc() {
      return doc3;
    },
    get tr() {
      selection = transaction2.selection;
      doc3 = transaction2.doc;
      storedMarks = transaction2.storedMarks;
      return transaction2;
    }
  };
}
var CommandManager = class {
  constructor(props) {
    this.editor = props.editor;
    this.rawCommands = this.editor.extensionManager.commands;
    this.customState = props.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const { tr: tr2 } = state;
    const props = this.buildProps(tr2);
    return Object.fromEntries(
      Object.entries(rawCommands).map(([name, command2]) => {
        const method = (...args) => {
          const callback = command2(...args)(props);
          if (!tr2.getMeta("preventDispatch") && !this.hasCustomState) {
            view.dispatch(tr2);
          }
          return callback;
        };
        return [name, method];
      })
    );
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(startTr, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const callbacks = [];
    const hasStartTransaction = !!startTr;
    const tr2 = startTr || state.tr;
    const run32 = () => {
      if (!hasStartTransaction && shouldDispatch && !tr2.getMeta("preventDispatch") && !this.hasCustomState) {
        view.dispatch(tr2);
      }
      return callbacks.every((callback) => callback === true);
    };
    const chain2 = {
      ...Object.fromEntries(
        Object.entries(rawCommands).map(([name, command2]) => {
          const chainedCommand = (...args) => {
            const props = this.buildProps(tr2, shouldDispatch);
            const callback = command2(...args)(props);
            callbacks.push(callback);
            return chain2;
          };
          return [name, chainedCommand];
        })
      ),
      run: run32
    };
    return chain2;
  }
  createCan(startTr) {
    const { rawCommands, state } = this;
    const dispatch2 = false;
    const tr2 = startTr || state.tr;
    const props = this.buildProps(tr2, dispatch2);
    const formattedCommands = Object.fromEntries(
      Object.entries(rawCommands).map(([name, command2]) => {
        return [name, (...args) => command2(...args)({ ...props, dispatch: void 0 })];
      })
    );
    return {
      ...formattedCommands,
      chain: () => this.createChain(tr2, dispatch2)
    };
  }
  buildProps(tr2, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const props = {
      tr: tr2,
      editor,
      view,
      state: createChainableState({
        state,
        transaction: tr2
      }),
      dispatch: shouldDispatch ? () => void 0 : void 0,
      chain: () => this.createChain(tr2, shouldDispatch),
      can: () => this.createCan(tr2),
      get commands() {
        return Object.fromEntries(
          Object.entries(rawCommands).map(([name, command2]) => {
            return [name, (...args) => command2(...args)(props)];
          })
        );
      }
    };
    return props;
  }
};
var commands_exports = {};
__export2(commands_exports, {
  blur: () => blur,
  clearContent: () => clearContent,
  clearNodes: () => clearNodes,
  command: () => command,
  createParagraphNear: () => createParagraphNear2,
  cut: () => cut,
  deleteCurrentNode: () => deleteCurrentNode,
  deleteNode: () => deleteNode,
  deleteRange: () => deleteRange2,
  deleteSelection: () => deleteSelection2,
  enter: () => enter,
  exitCode: () => exitCode2,
  extendMarkRange: () => extendMarkRange,
  first: () => first,
  focus: () => focus,
  forEach: () => forEach,
  insertContent: () => insertContent,
  insertContentAt: () => insertContentAt,
  joinBackward: () => joinBackward2,
  joinDown: () => joinDown2,
  joinForward: () => joinForward2,
  joinItemBackward: () => joinItemBackward,
  joinItemForward: () => joinItemForward,
  joinTextblockBackward: () => joinTextblockBackward2,
  joinTextblockForward: () => joinTextblockForward2,
  joinUp: () => joinUp2,
  keyboardShortcut: () => keyboardShortcut,
  lift: () => lift3,
  liftEmptyBlock: () => liftEmptyBlock2,
  liftListItem: () => liftListItem2,
  newlineInCode: () => newlineInCode2,
  resetAttributes: () => resetAttributes,
  scrollIntoView: () => scrollIntoView,
  selectAll: () => selectAll2,
  selectNodeBackward: () => selectNodeBackward2,
  selectNodeForward: () => selectNodeForward2,
  selectParentNode: () => selectParentNode2,
  selectTextblockEnd: () => selectTextblockEnd2,
  selectTextblockStart: () => selectTextblockStart2,
  setContent: () => setContent,
  setMark: () => setMark,
  setMeta: () => setMeta,
  setNode: () => setNode,
  setNodeSelection: () => setNodeSelection,
  setTextDirection: () => setTextDirection,
  setTextSelection: () => setTextSelection,
  sinkListItem: () => sinkListItem2,
  splitBlock: () => splitBlock2,
  splitListItem: () => splitListItem,
  toggleList: () => toggleList,
  toggleMark: () => toggleMark,
  toggleNode: () => toggleNode,
  toggleWrap: () => toggleWrap,
  undoInputRule: () => undoInputRule,
  unsetAllMarks: () => unsetAllMarks,
  unsetMark: () => unsetMark,
  unsetTextDirection: () => unsetTextDirection,
  updateAttributes: () => updateAttributes,
  wrapIn: () => wrapIn2,
  wrapInList: () => wrapInList2
});
var blur = () => ({ editor, view }) => {
  requestAnimationFrame(() => {
    var _a6;
    if (!editor.isDestroyed) {
      ;
      view.dom.blur();
      (_a6 = window == null ? void 0 : window.getSelection()) == null ? void 0 : _a6.removeAllRanges();
    }
  });
  return true;
};
var clearContent = (emitUpdate = true) => ({ commands }) => {
  return commands.setContent("", { emitUpdate });
};
var clearNodes = () => ({ state, tr: tr2, dispatch: dispatch2 }) => {
  const { selection } = tr2;
  const { ranges } = selection;
  if (!dispatch2) {
    return true;
  }
  ranges.forEach(({ $from, $to }) => {
    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {
      if (node.type.isText) {
        return;
      }
      const { doc: doc3, mapping } = tr2;
      const $mappedFrom = doc3.resolve(mapping.map(pos));
      const $mappedTo = doc3.resolve(mapping.map(pos + node.nodeSize));
      const nodeRange = $mappedFrom.blockRange($mappedTo);
      if (!nodeRange) {
        return;
      }
      const targetLiftDepth = liftTarget(nodeRange);
      if (node.type.isTextblock) {
        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
        tr2.setNodeMarkup(nodeRange.start, defaultType);
      }
      if (targetLiftDepth || targetLiftDepth === 0) {
        tr2.lift(nodeRange, targetLiftDepth);
      }
    });
  });
  return true;
};
var command = (fn) => (props) => {
  return fn(props);
};
var createParagraphNear2 = () => ({ state, dispatch: dispatch2 }) => {
  return createParagraphNear(state, dispatch2);
};
var cut = (originRange, targetPos) => ({ editor, tr: tr2 }) => {
  const { state } = editor;
  const contentSlice = state.doc.slice(originRange.from, originRange.to);
  tr2.deleteRange(originRange.from, originRange.to);
  const newPos = tr2.mapping.map(targetPos);
  tr2.insert(newPos, contentSlice.content);
  tr2.setSelection(new TextSelection(tr2.doc.resolve(Math.max(newPos - 1, 0))));
  return true;
};
var deleteCurrentNode = () => ({ tr: tr2, dispatch: dispatch2 }) => {
  const { selection } = tr2;
  const currentNode = selection.$anchor.node();
  if (currentNode.content.size > 0) {
    return false;
  }
  const $pos = tr2.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === currentNode.type) {
      if (dispatch2) {
        const from2 = $pos.before(depth);
        const to = $pos.after(depth);
        tr2.delete(from2, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
function getNodeType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.nodes[nameOrType]) {
      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.nodes[nameOrType];
  }
  return nameOrType;
}
var deleteNode = (typeOrName) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  const $pos = tr2.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === type) {
      if (dispatch2) {
        const from2 = $pos.before(depth);
        const to = $pos.after(depth);
        tr2.delete(from2, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
var deleteRange2 = (range) => ({ tr: tr2, dispatch: dispatch2 }) => {
  const { from: from2, to } = range;
  if (dispatch2) {
    tr2.delete(from2, to);
  }
  return true;
};
var deleteSelection2 = () => ({ state, dispatch: dispatch2 }) => {
  return deleteSelection(state, dispatch2);
};
var enter = () => ({ commands }) => {
  return commands.keyboardShortcut("Enter");
};
var exitCode2 = () => ({ state, dispatch: dispatch2 }) => {
  return exitCode(state, dispatch2);
};
function isRegExp(value) {
  return Object.prototype.toString.call(value) === "[object RegExp]";
}
function objectIncludes(object1, object2, options2 = { strict: true }) {
  const keys3 = Object.keys(object2);
  if (!keys3.length) {
    return true;
  }
  return keys3.every((key) => {
    if (options2.strict) {
      return object2[key] === object1[key];
    }
    if (isRegExp(object2[key])) {
      return object2[key].test(object1[key]);
    }
    return object2[key] === object1[key];
  });
}
function findMarkInSet(marks, type, attributes = {}) {
  return marks.find((item) => {
    return item.type === type && objectIncludes(
      // Only check equality for the attributes that are provided
      Object.fromEntries(Object.keys(attributes).map((k) => [k, item.attrs[k]])),
      attributes
    );
  });
}
function isMarkInSet(marks, type, attributes = {}) {
  return !!findMarkInSet(marks, type, attributes);
}
function getMarkRange($pos, type, attributes) {
  var _a6;
  if (!$pos || !type) {
    return;
  }
  let start = $pos.parent.childAfter($pos.parentOffset);
  if (!start.node || !start.node.marks.some((mark2) => mark2.type === type)) {
    start = $pos.parent.childBefore($pos.parentOffset);
  }
  if (!start.node || !start.node.marks.some((mark2) => mark2.type === type)) {
    return;
  }
  attributes = attributes || ((_a6 = start.node.marks[0]) == null ? void 0 : _a6.attrs);
  const mark = findMarkInSet([...start.node.marks], type, attributes);
  if (!mark) {
    return;
  }
  let startIndex = start.index;
  let startPos = $pos.start() + start.offset;
  let endIndex = startIndex + 1;
  let endPos = startPos + start.node.nodeSize;
  while (startIndex > 0 && isMarkInSet([...$pos.parent.child(startIndex - 1).marks], type, attributes)) {
    startIndex -= 1;
    startPos -= $pos.parent.child(startIndex).nodeSize;
  }
  while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {
    endPos += $pos.parent.child(endIndex).nodeSize;
    endIndex += 1;
  }
  return {
    from: startPos,
    to: endPos
  };
}
function getMarkType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.marks[nameOrType]) {
      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.marks[nameOrType];
  }
  return nameOrType;
}
var extendMarkRange = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  const type = getMarkType(typeOrName, state.schema);
  const { doc: doc3, selection } = tr2;
  const { $from, from: from2, to } = selection;
  if (dispatch2) {
    const range = getMarkRange($from, type, attributes);
    if (range && range.from <= from2 && range.to >= to) {
      const newSelection = TextSelection.create(doc3, range.from, range.to);
      tr2.setSelection(newSelection);
    }
  }
  return true;
};
var first = (commands) => (props) => {
  const items = typeof commands === "function" ? commands(props) : commands;
  for (let i = 0; i < items.length; i += 1) {
    if (items[i](props)) {
      return true;
    }
  }
  return false;
};
function isTextSelection(value) {
  return value instanceof TextSelection;
}
function minMax(value = 0, min3 = 0, max2 = 0) {
  return Math.min(Math.max(value, min3), max2);
}
function resolveFocusPosition(doc3, position = null) {
  if (!position) {
    return null;
  }
  const selectionAtStart = Selection.atStart(doc3);
  const selectionAtEnd = Selection.atEnd(doc3);
  if (position === "start" || position === true) {
    return selectionAtStart;
  }
  if (position === "end") {
    return selectionAtEnd;
  }
  const minPos = selectionAtStart.from;
  const maxPos = selectionAtEnd.to;
  if (position === "all") {
    return TextSelection.create(doc3, minMax(0, minPos, maxPos), minMax(doc3.content.size, minPos, maxPos));
  }
  return TextSelection.create(doc3, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));
}
function isAndroid() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
function isiOS() {
  return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || // iPad on iOS 13 detection
  navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
function isSafari() {
  return typeof navigator !== "undefined" ? /^((?!chrome|android).)*safari/i.test(navigator.userAgent) : false;
}
var focus = (position = null, options2 = {}) => ({ editor, view, tr: tr2, dispatch: dispatch2 }) => {
  options2 = {
    scrollIntoView: true,
    ...options2
  };
  const delayedFocus = () => {
    if (isiOS() || isAndroid()) {
      ;
      view.dom.focus();
    }
    if (isSafari() && !isiOS() && !isAndroid()) {
      ;
      view.dom.focus({ preventScroll: true });
    }
    requestAnimationFrame(() => {
      if (!editor.isDestroyed) {
        view.focus();
        if (options2 == null ? void 0 : options2.scrollIntoView) {
          editor.commands.scrollIntoView();
        }
      }
    });
  };
  try {
    if (view.hasFocus() && position === null || position === false) {
      return true;
    }
  } catch {
    return false;
  }
  if (dispatch2 && position === null && !isTextSelection(editor.state.selection)) {
    delayedFocus();
    return true;
  }
  const selection = resolveFocusPosition(tr2.doc, position) || editor.state.selection;
  const isSameSelection = editor.state.selection.eq(selection);
  if (dispatch2) {
    if (!isSameSelection) {
      tr2.setSelection(selection);
    }
    if (isSameSelection && tr2.storedMarks) {
      tr2.setStoredMarks(tr2.storedMarks);
    }
    delayedFocus();
  }
  return true;
};
var forEach = (items, fn) => (props) => {
  return items.every((item, index2) => fn(item, { ...props, index: index2 }));
};
var insertContent = (value, options2) => ({ tr: tr2, commands }) => {
  return commands.insertContentAt({ from: tr2.selection.from, to: tr2.selection.to }, value, options2);
};
var removeWhitespaces = (node) => {
  const children = node.childNodes;
  for (let i = children.length - 1; i >= 0; i -= 1) {
    const child = children[i];
    if (child.nodeType === 3 && child.nodeValue && /^(\n\s\s|\n)$/.test(child.nodeValue)) {
      node.removeChild(child);
    } else if (child.nodeType === 1) {
      removeWhitespaces(child);
    }
  }
  return node;
};
function elementFromString(value) {
  if (typeof window === "undefined") {
    throw new Error("[tiptap error]: there is no window object available, so this function cannot be used");
  }
  const wrappedValue = `<body>${value}</body>`;
  const html = new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
  return removeWhitespaces(html);
}
function createNodeFromContent(content, schema, options2) {
  if (content instanceof Node2 || content instanceof Fragment12) {
    return content;
  }
  options2 = {
    slice: true,
    parseOptions: {},
    ...options2
  };
  const isJSONContent = typeof content === "object" && content !== null;
  const isTextContent = typeof content === "string";
  if (isJSONContent) {
    try {
      const isArrayContent = Array.isArray(content) && content.length > 0;
      if (isArrayContent) {
        return Fragment12.fromArray(content.map((item) => schema.nodeFromJSON(item)));
      }
      const node = schema.nodeFromJSON(content);
      if (options2.errorOnInvalidContent) {
        node.check();
      }
      return node;
    } catch (error) {
      if (options2.errorOnInvalidContent) {
        throw new Error("[tiptap error]: Invalid JSON content", { cause: error });
      }
      console.warn("[tiptap warn]: Invalid content.", "Passed value:", content, "Error:", error);
      return createNodeFromContent("", schema, options2);
    }
  }
  if (isTextContent) {
    if (options2.errorOnInvalidContent) {
      let hasInvalidContent = false;
      let invalidContent = "";
      const contentCheckSchema = new Schema({
        topNode: schema.spec.topNode,
        marks: schema.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: schema.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (e) => {
                  hasInvalidContent = true;
                  invalidContent = typeof e === "string" ? e : e.outerHTML;
                  return null;
                }
              }
            ]
          }
        })
      });
      if (options2.slice) {
        DOMParser2.fromSchema(contentCheckSchema).parseSlice(elementFromString(content), options2.parseOptions);
      } else {
        DOMParser2.fromSchema(contentCheckSchema).parse(elementFromString(content), options2.parseOptions);
      }
      if (options2.errorOnInvalidContent && hasInvalidContent) {
        throw new Error("[tiptap error]: Invalid HTML content", {
          cause: new Error(`Invalid element found: ${invalidContent}`)
        });
      }
    }
    const parser = DOMParser2.fromSchema(schema);
    if (options2.slice) {
      return parser.parseSlice(elementFromString(content), options2.parseOptions).content;
    }
    return parser.parse(elementFromString(content), options2.parseOptions);
  }
  return createNodeFromContent("", schema, options2);
}
function selectionToInsertionEnd2(tr2, startLen, bias) {
  const last2 = tr2.steps.length - 1;
  if (last2 < startLen) {
    return;
  }
  const step = tr2.steps[last2];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {
    return;
  }
  const map2 = tr2.mapping.maps[last2];
  let end = 0;
  map2.forEach((_from, _to, _newFrom, newTo) => {
    if (end === 0) {
      end = newTo;
    }
  });
  tr2.setSelection(Selection.near(tr2.doc.resolve(end), bias));
}
var isFragment = (nodeOrFragment) => {
  return !("type" in nodeOrFragment);
};
var insertContentAt = (position, value, options2) => ({ tr: tr2, dispatch: dispatch2, editor }) => {
  var _a6;
  if (dispatch2) {
    options2 = {
      parseOptions: editor.options.parseOptions,
      updateSelection: true,
      applyInputRules: false,
      applyPasteRules: false,
      ...options2
    };
    let content;
    const emitContentError = (error) => {
      editor.emit("contentError", {
        editor,
        error,
        disableCollaboration: () => {
          if ("collaboration" in editor.storage && typeof editor.storage.collaboration === "object" && editor.storage.collaboration) {
            ;
            editor.storage.collaboration.isDisabled = true;
          }
        }
      });
    };
    const parseOptions = {
      preserveWhitespace: "full",
      ...options2.parseOptions
    };
    if (!options2.errorOnInvalidContent && !editor.options.enableContentCheck && editor.options.emitContentError) {
      try {
        createNodeFromContent(value, editor.schema, {
          parseOptions,
          errorOnInvalidContent: true
        });
      } catch (e) {
        emitContentError(e);
      }
    }
    try {
      content = createNodeFromContent(value, editor.schema, {
        parseOptions,
        errorOnInvalidContent: (_a6 = options2.errorOnInvalidContent) != null ? _a6 : editor.options.enableContentCheck
      });
    } catch (e) {
      emitContentError(e);
      return false;
    }
    let { from: from2, to } = typeof position === "number" ? { from: position, to: position } : { from: position.from, to: position.to };
    let isOnlyTextContent = true;
    let isOnlyBlockContent = true;
    const nodes = isFragment(content) ? content : [content];
    nodes.forEach((node) => {
      node.check();
      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;
      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;
    });
    if (from2 === to && isOnlyBlockContent) {
      const { parent } = tr2.doc.resolve(from2);
      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
      if (isEmptyTextBlock) {
        from2 -= 1;
        to += 1;
      }
    }
    let newContent;
    if (isOnlyTextContent) {
      if (Array.isArray(value)) {
        newContent = value.map((v) => v.text || "").join("");
      } else if (value instanceof Fragment12) {
        let text = "";
        value.forEach((node) => {
          if (node.text) {
            text += node.text;
          }
        });
        newContent = text;
      } else if (typeof value === "object" && !!value && !!value.text) {
        newContent = value.text;
      } else {
        newContent = value;
      }
      tr2.insertText(newContent, from2, to);
    } else {
      newContent = content;
      const $from = tr2.doc.resolve(from2);
      const $fromNode = $from.node();
      const fromSelectionAtStart = $from.parentOffset === 0;
      const isTextSelection2 = $fromNode.isText || $fromNode.isTextblock;
      const hasContent = $fromNode.content.size > 0;
      if (fromSelectionAtStart && isTextSelection2 && hasContent) {
        from2 = Math.max(0, from2 - 1);
      }
      tr2.replaceWith(from2, to, newContent);
    }
    if (options2.updateSelection) {
      selectionToInsertionEnd2(tr2, tr2.steps.length - 1, -1);
    }
    if (options2.applyInputRules) {
      tr2.setMeta("applyInputRules", { from: from2, text: newContent });
    }
    if (options2.applyPasteRules) {
      tr2.setMeta("applyPasteRules", { from: from2, text: newContent });
    }
  }
  return true;
};
var joinUp2 = () => ({ state, dispatch: dispatch2 }) => {
  return joinUp(state, dispatch2);
};
var joinDown2 = () => ({ state, dispatch: dispatch2 }) => {
  return joinDown(state, dispatch2);
};
var joinBackward2 = () => ({ state, dispatch: dispatch2 }) => {
  return joinBackward(state, dispatch2);
};
var joinForward2 = () => ({ state, dispatch: dispatch2 }) => {
  return joinForward(state, dispatch2);
};
var joinItemBackward = () => ({ state, dispatch: dispatch2, tr: tr2 }) => {
  try {
    const point = joinPoint(state.doc, state.selection.$from.pos, -1);
    if (point === null || point === void 0) {
      return false;
    }
    tr2.join(point, 2);
    if (dispatch2) {
      dispatch2(tr2);
    }
    return true;
  } catch {
    return false;
  }
};
var joinItemForward = () => ({ state, dispatch: dispatch2, tr: tr2 }) => {
  try {
    const point = joinPoint(state.doc, state.selection.$from.pos, 1);
    if (point === null || point === void 0) {
      return false;
    }
    tr2.join(point, 2);
    if (dispatch2) {
      dispatch2(tr2);
    }
    return true;
  } catch {
    return false;
  }
};
var joinTextblockBackward2 = () => ({ state, dispatch: dispatch2 }) => {
  return joinTextblockBackward(state, dispatch2);
};
var joinTextblockForward2 = () => ({ state, dispatch: dispatch2 }) => {
  return joinTextblockForward(state, dispatch2);
};
function isMacOS() {
  return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
}
function normalizeKeyName2(name) {
  const parts = name.split(/-(?!$)/);
  let result = parts[parts.length - 1];
  if (result === "Space") {
    result = " ";
  }
  let alt;
  let ctrl;
  let shift5;
  let meta;
  for (let i = 0; i < parts.length - 1; i += 1) {
    const mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod)) {
      meta = true;
    } else if (/^a(lt)?$/i.test(mod)) {
      alt = true;
    } else if (/^(c|ctrl|control)$/i.test(mod)) {
      ctrl = true;
    } else if (/^s(hift)?$/i.test(mod)) {
      shift5 = true;
    } else if (/^mod$/i.test(mod)) {
      if (isiOS() || isMacOS()) {
        meta = true;
      } else {
        ctrl = true;
      }
    } else {
      throw new Error(`Unrecognized modifier name: ${mod}`);
    }
  }
  if (alt) {
    result = `Alt-${result}`;
  }
  if (ctrl) {
    result = `Ctrl-${result}`;
  }
  if (meta) {
    result = `Meta-${result}`;
  }
  if (shift5) {
    result = `Shift-${result}`;
  }
  return result;
}
var keyboardShortcut = (name) => ({ editor, view, tr: tr2, dispatch: dispatch2 }) => {
  const keys3 = normalizeKeyName2(name).split(/-(?!$)/);
  const key = keys3.find((item) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item));
  const event = new KeyboardEvent("keydown", {
    key: key === "Space" ? " " : key,
    altKey: keys3.includes("Alt"),
    ctrlKey: keys3.includes("Ctrl"),
    metaKey: keys3.includes("Meta"),
    shiftKey: keys3.includes("Shift"),
    bubbles: true,
    cancelable: true
  });
  const capturedTransaction = editor.captureTransaction(() => {
    view.someProp("handleKeyDown", (f) => f(view, event));
  });
  capturedTransaction == null ? void 0 : capturedTransaction.steps.forEach((step) => {
    const newStep = step.map(tr2.mapping);
    if (newStep && dispatch2) {
      tr2.maybeStep(newStep);
    }
  });
  return true;
};
function isNodeActive(state, typeOrName, attributes = {}) {
  const { from: from2, to, empty: empty2 } = state.selection;
  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
  const nodeRanges = [];
  state.doc.nodesBetween(from2, to, (node, pos) => {
    if (node.isText) {
      return;
    }
    const relativeFrom = Math.max(from2, pos);
    const relativeTo = Math.min(to, pos + node.nodeSize);
    nodeRanges.push({
      node,
      from: relativeFrom,
      to: relativeTo
    });
  });
  const selectionRange = to - from2;
  const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
    if (!type) {
      return true;
    }
    return type.name === nodeRange.node.type.name;
  }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));
  if (empty2) {
    return !!matchedNodeRanges.length;
  }
  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
  return range >= selectionRange;
}
var lift3 = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (!isActive2) {
    return false;
  }
  return lift2(state, dispatch2);
};
var liftEmptyBlock2 = () => ({ state, dispatch: dispatch2 }) => {
  return liftEmptyBlock(state, dispatch2);
};
var liftListItem2 = (typeOrName) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  return liftListItem(type)(state, dispatch2);
};
var newlineInCode2 = () => ({ state, dispatch: dispatch2 }) => {
  return newlineInCode(state, dispatch2);
};
function getSchemaTypeNameByName(name, schema) {
  if (schema.nodes[name]) {
    return "node";
  }
  if (schema.marks[name]) {
    return "mark";
  }
  return null;
}
function deleteProps(obj, propOrProps) {
  const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
  return Object.keys(obj).reduce((newObj, prop) => {
    if (!props.includes(prop)) {
      newObj[prop] = obj[prop];
    }
    return newObj;
  }, {});
}
var resetAttributes = (typeOrName, attributes) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(
    typeof typeOrName === "string" ? typeOrName : typeOrName.name,
    state.schema
  );
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  let canReset = false;
  tr2.selection.ranges.forEach((range) => {
    state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {
      if (nodeType && nodeType === node.type) {
        canReset = true;
        if (dispatch2) {
          tr2.setNodeMarkup(pos, void 0, deleteProps(node.attrs, attributes));
        }
      }
      if (markType && node.marks.length) {
        node.marks.forEach((mark) => {
          if (markType === mark.type) {
            canReset = true;
            if (dispatch2) {
              tr2.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));
            }
          }
        });
      }
    });
  });
  return canReset;
};
var scrollIntoView = () => ({ tr: tr2, dispatch: dispatch2 }) => {
  if (dispatch2) {
    tr2.scrollIntoView();
  }
  return true;
};
var selectAll2 = () => ({ tr: tr2, dispatch: dispatch2 }) => {
  if (dispatch2) {
    const selection = new AllSelection(tr2.doc);
    tr2.setSelection(selection);
  }
  return true;
};
var selectNodeBackward2 = () => ({ state, dispatch: dispatch2 }) => {
  return selectNodeBackward(state, dispatch2);
};
var selectNodeForward2 = () => ({ state, dispatch: dispatch2 }) => {
  return selectNodeForward(state, dispatch2);
};
var selectParentNode2 = () => ({ state, dispatch: dispatch2 }) => {
  return selectParentNode(state, dispatch2);
};
var selectTextblockEnd2 = () => ({ state, dispatch: dispatch2 }) => {
  return selectTextblockEnd(state, dispatch2);
};
var selectTextblockStart2 = () => ({ state, dispatch: dispatch2 }) => {
  return selectTextblockStart(state, dispatch2);
};
function createDocument(content, schema, parseOptions = {}, options2 = {}) {
  return createNodeFromContent(content, schema, {
    slice: false,
    parseOptions,
    errorOnInvalidContent: options2.errorOnInvalidContent
  });
}
var setContent = (content, { errorOnInvalidContent, emitUpdate = true, parseOptions = {} } = {}) => ({ editor, tr: tr2, dispatch: dispatch2, commands }) => {
  const { doc: doc3 } = tr2;
  if (parseOptions.preserveWhitespace !== "full") {
    const document2 = createDocument(content, editor.schema, parseOptions, {
      errorOnInvalidContent: errorOnInvalidContent != null ? errorOnInvalidContent : editor.options.enableContentCheck
    });
    if (dispatch2) {
      tr2.replaceWith(0, doc3.content.size, document2).setMeta("preventUpdate", !emitUpdate);
    }
    return true;
  }
  if (dispatch2) {
    tr2.setMeta("preventUpdate", !emitUpdate);
  }
  return commands.insertContentAt({ from: 0, to: doc3.content.size }, content, {
    parseOptions,
    errorOnInvalidContent: errorOnInvalidContent != null ? errorOnInvalidContent : editor.options.enableContentCheck
  });
};
function getMarkAttributes(state, typeOrName) {
  const type = getMarkType(typeOrName, state.schema);
  const { from: from2, to, empty: empty2 } = state.selection;
  const marks = [];
  if (empty2) {
    if (state.storedMarks) {
      marks.push(...state.storedMarks);
    }
    marks.push(...state.selection.$head.marks());
  } else {
    state.doc.nodesBetween(from2, to, (node) => {
      marks.push(...node.marks);
    });
  }
  const mark = marks.find((markItem) => markItem.type.name === type.name);
  if (!mark) {
    return {};
  }
  return { ...mark.attrs };
}
function combineTransactionSteps(oldDoc, transactions) {
  const transform = new Transform(oldDoc);
  transactions.forEach((transaction2) => {
    transaction2.steps.forEach((step) => {
      transform.step(step);
    });
  });
  return transform;
}
function defaultBlockAt2(match) {
  for (let i = 0; i < match.edgeCount; i += 1) {
    const { type } = match.edge(i);
    if (type.isTextblock && !type.hasRequiredAttrs()) {
      return type;
    }
  }
  return null;
}
function findChildrenInRange(node, range, predicate) {
  const nodesWithPos = [];
  node.nodesBetween(range.from, range.to, (child, pos) => {
    if (predicate(child)) {
      nodesWithPos.push({
        node: child,
        pos
      });
    }
  });
  return nodesWithPos;
}
function findParentNodeClosestToPos($pos, predicate) {
  for (let i = $pos.depth; i > 0; i -= 1) {
    const node = $pos.node(i);
    if (predicate(node)) {
      return {
        pos: i > 0 ? $pos.before(i) : 0,
        start: $pos.start(i),
        depth: i,
        node
      };
    }
  }
}
function findParentNode(predicate) {
  return (selection) => findParentNodeClosestToPos(selection.$from, predicate);
}
function getExtensionField(extension, field, context) {
  if (extension.config[field] === void 0 && extension.parent) {
    return getExtensionField(extension.parent, field, context);
  }
  if (typeof extension.config[field] === "function") {
    const value = extension.config[field].bind({
      ...context,
      parent: extension.parent ? getExtensionField(extension.parent, field, context) : null
    });
    return value;
  }
  return extension.config[field];
}
function flattenExtensions(extensions) {
  return extensions.map((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addExtensions = getExtensionField(extension, "addExtensions", context);
    if (addExtensions) {
      return [extension, ...flattenExtensions(addExtensions())];
    }
    return extension;
  }).flat(10);
}
function getHTMLFromFragment(fragment, schema) {
  const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment);
  const temporaryDocument = document.implementation.createHTMLDocument();
  const container = temporaryDocument.createElement("div");
  container.appendChild(documentFragment);
  return container.innerHTML;
}
function isFunction(value) {
  return typeof value === "function";
}
function callOrReturn(value, context = void 0, ...props) {
  if (isFunction(value)) {
    if (context) {
      return value.bind(context)(...props);
    }
    return value(...props);
  }
  return value;
}
function isEmptyObject(value = {}) {
  return Object.keys(value).length === 0 && value.constructor === Object;
}
function splitExtensions(extensions) {
  const baseExtensions = extensions.filter((extension) => extension.type === "extension");
  const nodeExtensions = extensions.filter((extension) => extension.type === "node");
  const markExtensions = extensions.filter((extension) => extension.type === "mark");
  return {
    baseExtensions,
    nodeExtensions,
    markExtensions
  };
}
function getAttributesFromExtensions(extensions) {
  const extensionAttributes = [];
  const { nodeExtensions, markExtensions } = splitExtensions(extensions);
  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];
  const defaultAttribute = {
    default: null,
    validate: void 0,
    rendered: true,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: true,
    isRequired: false
  };
  extensions.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      extensions: nodeAndMarkExtensions
    };
    const addGlobalAttributes = getExtensionField(
      extension,
      "addGlobalAttributes",
      context
    );
    if (!addGlobalAttributes) {
      return;
    }
    const globalAttributes = addGlobalAttributes();
    globalAttributes.forEach((globalAttribute) => {
      globalAttribute.types.forEach((type) => {
        Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {
          extensionAttributes.push({
            type,
            name,
            attribute: {
              ...defaultAttribute,
              ...attribute
            }
          });
        });
      });
    });
  });
  nodeAndMarkExtensions.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addAttributes = getExtensionField(
      extension,
      "addAttributes",
      context
    );
    if (!addAttributes) {
      return;
    }
    const attributes = addAttributes();
    Object.entries(attributes).forEach(([name, attribute]) => {
      const mergedAttr = {
        ...defaultAttribute,
        ...attribute
      };
      if (typeof (mergedAttr == null ? void 0 : mergedAttr.default) === "function") {
        mergedAttr.default = mergedAttr.default();
      }
      if ((mergedAttr == null ? void 0 : mergedAttr.isRequired) && (mergedAttr == null ? void 0 : mergedAttr.default) === void 0) {
        delete mergedAttr.default;
      }
      extensionAttributes.push({
        type: extension.name,
        name,
        attribute: mergedAttr
      });
    });
  });
  return extensionAttributes;
}
function mergeAttributes(...objects) {
  return objects.filter((item) => !!item).reduce((items, item) => {
    const mergedAttributes = { ...items };
    Object.entries(item).forEach(([key, value]) => {
      const exists = mergedAttributes[key];
      if (!exists) {
        mergedAttributes[key] = value;
        return;
      }
      if (key === "class") {
        const valueClasses = value ? String(value).split(" ") : [];
        const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(" ") : [];
        const insertClasses = valueClasses.filter((valueClass) => !existingClasses.includes(valueClass));
        mergedAttributes[key] = [...existingClasses, ...insertClasses].join(" ");
      } else if (key === "style") {
        const newStyles = value ? value.split(";").map((style2) => style2.trim()).filter(Boolean) : [];
        const existingStyles = mergedAttributes[key] ? mergedAttributes[key].split(";").map((style2) => style2.trim()).filter(Boolean) : [];
        const styleMap = /* @__PURE__ */ new Map();
        existingStyles.forEach((style2) => {
          const [property, val] = style2.split(":").map((part) => part.trim());
          styleMap.set(property, val);
        });
        newStyles.forEach((style2) => {
          const [property, val] = style2.split(":").map((part) => part.trim());
          styleMap.set(property, val);
        });
        mergedAttributes[key] = Array.from(styleMap.entries()).map(([property, val]) => `${property}: ${val}`).join("; ");
      } else {
        mergedAttributes[key] = value;
      }
    });
    return mergedAttributes;
  }, {});
}
function getRenderedAttributes(nodeOrMark, extensionAttributes) {
  return extensionAttributes.filter((attribute) => attribute.type === nodeOrMark.type.name).filter((item) => item.attribute.rendered).map((item) => {
    if (!item.attribute.renderHTML) {
      return {
        [item.name]: nodeOrMark.attrs[item.name]
      };
    }
    return item.attribute.renderHTML(nodeOrMark.attrs) || {};
  }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});
}
function fromString(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (value.match(/^[+-]?(?:\d*\.)?\d+$/)) {
    return Number(value);
  }
  if (value === "true") {
    return true;
  }
  if (value === "false") {
    return false;
  }
  return value;
}
function injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {
  if ("style" in parseRule) {
    return parseRule;
  }
  return {
    ...parseRule,
    getAttrs: (node) => {
      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;
      if (oldAttributes === false) {
        return false;
      }
      const newAttributes = extensionAttributes.reduce((items, item) => {
        const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));
        if (value === null || value === void 0) {
          return items;
        }
        return {
          ...items,
          [item.name]: value
        };
      }, {});
      return { ...oldAttributes, ...newAttributes };
    }
  };
}
function cleanUpSchemaItem(data) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(data).filter(([key, value]) => {
      if (key === "attrs" && isEmptyObject(value)) {
        return false;
      }
      return value !== null && value !== void 0;
    })
  );
}
function buildAttributeSpec(extensionAttribute) {
  var _a6, _b3;
  const spec = {};
  if (!((_a6 = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _a6.isRequired) && "default" in ((extensionAttribute == null ? void 0 : extensionAttribute.attribute) || {})) {
    spec.default = extensionAttribute.attribute.default;
  }
  if (((_b3 = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _b3.validate) !== void 0) {
    spec.validate = extensionAttribute.attribute.validate;
  }
  return [extensionAttribute.name, spec];
}
function getSchemaByResolvedExtensions(extensions, editor) {
  var _a6;
  const allAttributes = getAttributesFromExtensions(extensions);
  const { nodeExtensions, markExtensions } = splitExtensions(extensions);
  const topNode = (_a6 = nodeExtensions.find((extension) => getExtensionField(extension, "topNode"))) == null ? void 0 : _a6.name;
  const nodes = Object.fromEntries(
    nodeExtensions.map((extension) => {
      const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor
      };
      const extraNodeFields = extensions.reduce((fields, e) => {
        const extendNodeSchema = getExtensionField(e, "extendNodeSchema", context);
        return {
          ...fields,
          ...extendNodeSchema ? extendNodeSchema(extension) : {}
        };
      }, {});
      const schema = cleanUpSchemaItem({
        ...extraNodeFields,
        content: callOrReturn(getExtensionField(extension, "content", context)),
        marks: callOrReturn(getExtensionField(extension, "marks", context)),
        group: callOrReturn(getExtensionField(extension, "group", context)),
        inline: callOrReturn(getExtensionField(extension, "inline", context)),
        atom: callOrReturn(getExtensionField(extension, "atom", context)),
        selectable: callOrReturn(getExtensionField(extension, "selectable", context)),
        draggable: callOrReturn(getExtensionField(extension, "draggable", context)),
        code: callOrReturn(getExtensionField(extension, "code", context)),
        whitespace: callOrReturn(getExtensionField(extension, "whitespace", context)),
        linebreakReplacement: callOrReturn(
          getExtensionField(extension, "linebreakReplacement", context)
        ),
        defining: callOrReturn(getExtensionField(extension, "defining", context)),
        isolating: callOrReturn(getExtensionField(extension, "isolating", context)),
        attrs: Object.fromEntries(extensionAttributes.map(buildAttributeSpec))
      });
      const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
      if (parseHTML) {
        schema.parseDOM = parseHTML.map(
          (parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes)
        );
      }
      const renderHTML = getExtensionField(extension, "renderHTML", context);
      if (renderHTML) {
        schema.toDOM = (node) => renderHTML({
          node,
          HTMLAttributes: getRenderedAttributes(node, extensionAttributes)
        });
      }
      const renderText = getExtensionField(extension, "renderText", context);
      if (renderText) {
        schema.toText = renderText;
      }
      return [extension.name, schema];
    })
  );
  const marks = Object.fromEntries(
    markExtensions.map((extension) => {
      const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor
      };
      const extraMarkFields = extensions.reduce((fields, e) => {
        const extendMarkSchema = getExtensionField(e, "extendMarkSchema", context);
        return {
          ...fields,
          ...extendMarkSchema ? extendMarkSchema(extension) : {}
        };
      }, {});
      const schema = cleanUpSchemaItem({
        ...extraMarkFields,
        inclusive: callOrReturn(getExtensionField(extension, "inclusive", context)),
        excludes: callOrReturn(getExtensionField(extension, "excludes", context)),
        group: callOrReturn(getExtensionField(extension, "group", context)),
        spanning: callOrReturn(getExtensionField(extension, "spanning", context)),
        code: callOrReturn(getExtensionField(extension, "code", context)),
        attrs: Object.fromEntries(extensionAttributes.map(buildAttributeSpec))
      });
      const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
      if (parseHTML) {
        schema.parseDOM = parseHTML.map(
          (parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes)
        );
      }
      const renderHTML = getExtensionField(extension, "renderHTML", context);
      if (renderHTML) {
        schema.toDOM = (mark) => renderHTML({
          mark,
          HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)
        });
      }
      return [extension.name, schema];
    })
  );
  return new Schema({
    topNode,
    nodes,
    marks
  });
}
function findDuplicates(items) {
  const filtered = items.filter((el, index2) => items.indexOf(el) !== index2);
  return Array.from(new Set(filtered));
}
function sortExtensions(extensions) {
  const defaultPriority = 100;
  return extensions.sort((a, b) => {
    const priorityA = getExtensionField(a, "priority") || defaultPriority;
    const priorityB = getExtensionField(b, "priority") || defaultPriority;
    if (priorityA > priorityB) {
      return -1;
    }
    if (priorityA < priorityB) {
      return 1;
    }
    return 0;
  });
}
function resolveExtensions(extensions) {
  const resolvedExtensions = sortExtensions(flattenExtensions(extensions));
  const duplicatedNames = findDuplicates(resolvedExtensions.map((extension) => extension.name));
  if (duplicatedNames.length) {
    console.warn(
      `[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item) => `'${item}'`).join(", ")}]. This can lead to issues.`
    );
  }
  return resolvedExtensions;
}
function getSchema(extensions, editor) {
  const resolvedExtensions = resolveExtensions(extensions);
  return getSchemaByResolvedExtensions(resolvedExtensions, editor);
}
function generateHTML(doc3, extensions) {
  const schema = getSchema(extensions);
  const contentNode = Node2.fromJSON(schema, doc3);
  return getHTMLFromFragment(contentNode.content, schema);
}
function generateJSON(html, extensions) {
  const schema = getSchema(extensions);
  const dom = elementFromString(html);
  return DOMParser2.fromSchema(schema).parse(dom).toJSON();
}
function getTextBetween(startNode, range, options2) {
  const { from: from2, to } = range;
  const { blockSeparator = "\n\n", textSerializers = {} } = options2 || {};
  let text = "";
  startNode.nodesBetween(from2, to, (node, pos, parent, index2) => {
    var _a6;
    if (node.isBlock && pos > from2) {
      text += blockSeparator;
    }
    const textSerializer = textSerializers == null ? void 0 : textSerializers[node.type.name];
    if (textSerializer) {
      if (parent) {
        text += textSerializer({
          node,
          pos,
          parent,
          index: index2,
          range
        });
      }
      return false;
    }
    if (node.isText) {
      text += (_a6 = node == null ? void 0 : node.text) == null ? void 0 : _a6.slice(Math.max(from2, pos) - pos, to - pos);
    }
  });
  return text;
}
function getText2(node, options2) {
  const range = {
    from: 0,
    to: node.content.size
  };
  return getTextBetween(node, range, options2);
}
function getTextSerializersFromSchema(schema) {
  return Object.fromEntries(
    Object.entries(schema.nodes).filter(([, node]) => node.spec.toText).map(([name, node]) => [name, node.spec.toText])
  );
}
function generateText(doc3, extensions, options2) {
  const { blockSeparator = "\n\n", textSerializers = {} } = options2 || {};
  const schema = getSchema(extensions);
  const contentNode = Node2.fromJSON(schema, doc3);
  return getText2(contentNode, {
    blockSeparator,
    textSerializers: {
      ...getTextSerializersFromSchema(schema),
      ...textSerializers
    }
  });
}
function getNodeAttributes(state, typeOrName) {
  const type = getNodeType(typeOrName, state.schema);
  const { from: from2, to } = state.selection;
  const nodes = [];
  state.doc.nodesBetween(from2, to, (node2) => {
    nodes.push(node2);
  });
  const node = nodes.reverse().find((nodeItem) => nodeItem.type.name === type.name);
  if (!node) {
    return {};
  }
  return { ...node.attrs };
}
function getAttributes(state, typeOrName) {
  const schemaType = getSchemaTypeNameByName(
    typeof typeOrName === "string" ? typeOrName : typeOrName.name,
    state.schema
  );
  if (schemaType === "node") {
    return getNodeAttributes(state, typeOrName);
  }
  if (schemaType === "mark") {
    return getMarkAttributes(state, typeOrName);
  }
  return {};
}
function removeDuplicates(array, by = JSON.stringify) {
  const seen = {};
  return array.filter((item) => {
    const key = by(item);
    return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;
  });
}
function simplifyChangedRanges(changes) {
  const uniqueChanges = removeDuplicates(changes);
  return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index2) => {
    const rest = uniqueChanges.filter((_, i) => i !== index2);
    return !rest.some((otherChange) => {
      return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;
    });
  });
}
function getChangedRanges(transform) {
  const { mapping, steps } = transform;
  const changes = [];
  mapping.maps.forEach((stepMap, index2) => {
    const ranges = [];
    if (!stepMap.ranges.length) {
      const { from: from2, to } = steps[index2];
      if (from2 === void 0 || to === void 0) {
        return;
      }
      ranges.push({ from: from2, to });
    } else {
      stepMap.forEach((from2, to) => {
        ranges.push({ from: from2, to });
      });
    }
    ranges.forEach(({ from: from2, to }) => {
      const newStart = mapping.slice(index2).map(from2, -1);
      const newEnd = mapping.slice(index2).map(to);
      const oldStart = mapping.invert().map(newStart, -1);
      const oldEnd = mapping.invert().map(newEnd);
      changes.push({
        oldRange: {
          from: oldStart,
          to: oldEnd
        },
        newRange: {
          from: newStart,
          to: newEnd
        }
      });
    });
  });
  return simplifyChangedRanges(changes);
}
function getMarksBetween(from2, to, doc3) {
  const marks = [];
  if (from2 === to) {
    doc3.resolve(from2).marks().forEach((mark) => {
      const $pos = doc3.resolve(from2);
      const range = getMarkRange($pos, mark.type);
      if (!range) {
        return;
      }
      marks.push({
        mark,
        ...range
      });
    });
  } else {
    doc3.nodesBetween(from2, to, (node, pos) => {
      if (!node || (node == null ? void 0 : node.nodeSize) === void 0) {
        return;
      }
      marks.push(
        ...node.marks.map((mark) => ({
          from: pos,
          to: pos + node.nodeSize,
          mark
        }))
      );
    });
  }
  return marks;
}
var getNodeAtPosition = (state, typeOrName, pos, maxDepth = 20) => {
  const $pos = state.doc.resolve(pos);
  let currentDepth = maxDepth;
  let node = null;
  while (currentDepth > 0 && node === null) {
    const currentNode = $pos.node(currentDepth);
    if ((currentNode == null ? void 0 : currentNode.type.name) === typeOrName) {
      node = currentNode;
    } else {
      currentDepth -= 1;
    }
  }
  return [node, currentDepth];
};
function getSchemaTypeByName(name, schema) {
  return schema.nodes[name] || schema.marks[name] || null;
}
function getSplittedAttributes(extensionAttributes, typeName, attributes) {
  return Object.fromEntries(
    Object.entries(attributes).filter(([name]) => {
      const extensionAttribute = extensionAttributes.find((item) => {
        return item.type === typeName && item.name === name;
      });
      if (!extensionAttribute) {
        return false;
      }
      return extensionAttribute.attribute.keepOnSplit;
    })
  );
}
var getTextContentFromNodes = ($from, maxMatch = 500) => {
  let textBefore = "";
  const sliceEndPos = $from.parentOffset;
  $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index2) => {
    var _a6, _b3;
    const chunk = ((_b3 = (_a6 = node.type.spec).toText) == null ? void 0 : _b3.call(_a6, {
      node,
      pos,
      parent,
      index: index2
    })) || node.textContent || "%leaf%";
    textBefore += node.isAtom && !node.isText ? chunk : chunk.slice(0, Math.max(0, sliceEndPos - pos));
  });
  return textBefore;
};
function isMarkActive(state, typeOrName, attributes = {}) {
  const { empty: empty2, ranges } = state.selection;
  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;
  if (empty2) {
    return !!(state.storedMarks || state.selection.$from.marks()).filter((mark) => {
      if (!type) {
        return true;
      }
      return type.name === mark.type.name;
    }).find((mark) => objectIncludes(mark.attrs, attributes, { strict: false }));
  }
  let selectionRange = 0;
  const markRanges = [];
  ranges.forEach(({ $from, $to }) => {
    const from2 = $from.pos;
    const to = $to.pos;
    state.doc.nodesBetween(from2, to, (node, pos) => {
      if (!node.isText && !node.marks.length) {
        return;
      }
      const relativeFrom = Math.max(from2, pos);
      const relativeTo = Math.min(to, pos + node.nodeSize);
      const range2 = relativeTo - relativeFrom;
      selectionRange += range2;
      markRanges.push(
        ...node.marks.map((mark) => ({
          mark,
          from: relativeFrom,
          to: relativeTo
        }))
      );
    });
  });
  if (selectionRange === 0) {
    return false;
  }
  const matchedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return type.name === markRange.mark.type.name;
  }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const excludedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return markRange.mark.type !== type && markRange.mark.type.excludes(type);
  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
  return range >= selectionRange;
}
function isActive(state, name, attributes = {}) {
  if (!name) {
    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);
  }
  const schemaType = getSchemaTypeNameByName(name, state.schema);
  if (schemaType === "node") {
    return isNodeActive(state, name, attributes);
  }
  if (schemaType === "mark") {
    return isMarkActive(state, name, attributes);
  }
  return false;
}
var isAtEndOfNode = (state, nodeType) => {
  const { $from, $to, $anchor } = state.selection;
  if (nodeType) {
    const parentNode2 = findParentNode((node) => node.type.name === nodeType)(state.selection);
    if (!parentNode2) {
      return false;
    }
    const $parentPos = state.doc.resolve(parentNode2.pos + 1);
    if ($anchor.pos + 1 === $parentPos.end()) {
      return true;
    }
    return false;
  }
  if ($to.parentOffset < $to.parent.nodeSize - 2 || $from.pos !== $to.pos) {
    return false;
  }
  return true;
};
var isAtStartOfNode = (state) => {
  const { $from, $to } = state.selection;
  if ($from.parentOffset > 0 || $from.pos !== $to.pos) {
    return false;
  }
  return true;
};
function isExtensionRulesEnabled(extension, enabled) {
  if (Array.isArray(enabled)) {
    return enabled.some((enabledExtension) => {
      const name = typeof enabledExtension === "string" ? enabledExtension : enabledExtension.name;
      return name === extension.name;
    });
  }
  return enabled;
}
function isList(name, extensions) {
  const { nodeExtensions } = splitExtensions(extensions);
  const extension = nodeExtensions.find((item) => item.name === name);
  if (!extension) {
    return false;
  }
  const context = {
    name: extension.name,
    options: extension.options,
    storage: extension.storage
  };
  const group = callOrReturn(getExtensionField(extension, "group", context));
  if (typeof group !== "string") {
    return false;
  }
  return group.split(" ").includes("list");
}
function isNodeEmpty(node, {
  checkChildren = true,
  ignoreWhitespace = false
} = {}) {
  var _a6;
  if (ignoreWhitespace) {
    if (node.type.name === "hardBreak") {
      return true;
    }
    if (node.isText) {
      return /^\s*$/m.test((_a6 = node.text) != null ? _a6 : "");
    }
  }
  if (node.isText) {
    return !node.text;
  }
  if (node.isAtom || node.isLeaf) {
    return false;
  }
  if (node.content.childCount === 0) {
    return true;
  }
  if (checkChildren) {
    let isContentEmpty = true;
    node.content.forEach((childNode) => {
      if (isContentEmpty === false) {
        return;
      }
      if (!isNodeEmpty(childNode, { ignoreWhitespace, checkChildren })) {
        isContentEmpty = false;
      }
    });
    return isContentEmpty;
  }
  return false;
}
function isNodeSelection(value) {
  return value instanceof NodeSelection;
}
var MappablePosition = class _MappablePosition {
  constructor(position) {
    this.position = position;
  }
  /**
   * Creates a MappablePosition from a JSON object.
   */
  static fromJSON(json) {
    return new _MappablePosition(json.position);
  }
  /**
   * Converts the MappablePosition to a JSON object.
   */
  toJSON() {
    return {
      position: this.position
    };
  }
};
function getUpdatedPosition(position, transaction2) {
  const mapResult = transaction2.mapping.mapResult(position.position);
  return {
    position: new MappablePosition(mapResult.pos),
    mapResult
  };
}
function createMappablePosition(position) {
  return new MappablePosition(position);
}
function canSetMark(state, tr2, newMarkType) {
  var _a6;
  const { selection } = tr2;
  let cursor = null;
  if (isTextSelection(selection)) {
    cursor = selection.$cursor;
  }
  if (cursor) {
    const currentMarks = (_a6 = state.storedMarks) != null ? _a6 : cursor.marks();
    const parentAllowsMarkType = cursor.parent.type.allowsMarkType(newMarkType);
    return parentAllowsMarkType && (!!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark) => mark.type.excludes(newMarkType)));
  }
  const { ranges } = selection;
  return ranges.some(({ $from, $to }) => {
    let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;
    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {
      if (someNodeSupportsMark) {
        return false;
      }
      if (node.isInline) {
        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
        const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark) => otherMark.type.excludes(newMarkType));
        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
      }
      return !someNodeSupportsMark;
    });
    return someNodeSupportsMark;
  });
}
var setMark = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  const { selection } = tr2;
  const { empty: empty2, ranges } = selection;
  const type = getMarkType(typeOrName, state.schema);
  if (dispatch2) {
    if (empty2) {
      const oldAttributes = getMarkAttributes(state, type);
      tr2.addStoredMark(
        type.create({
          ...oldAttributes,
          ...attributes
        })
      );
    } else {
      ranges.forEach((range) => {
        const from2 = range.$from.pos;
        const to = range.$to.pos;
        state.doc.nodesBetween(from2, to, (node, pos) => {
          const trimmedFrom = Math.max(pos, from2);
          const trimmedTo = Math.min(pos + node.nodeSize, to);
          const someHasMark = node.marks.find((mark) => mark.type === type);
          if (someHasMark) {
            node.marks.forEach((mark) => {
              if (type === mark.type) {
                tr2.addMark(
                  trimmedFrom,
                  trimmedTo,
                  type.create({
                    ...mark.attrs,
                    ...attributes
                  })
                );
              }
            });
          } else {
            tr2.addMark(trimmedFrom, trimmedTo, type.create(attributes));
          }
        });
      });
    }
  }
  return canSetMark(state, tr2, type);
};
var setMeta = (key, value) => ({ tr: tr2 }) => {
  tr2.setMeta(key, value);
  return true;
};
var setNode = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2, chain: chain2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  let attributesToCopy;
  if (state.selection.$anchor.sameParent(state.selection.$head)) {
    attributesToCopy = state.selection.$anchor.parent.attrs;
  }
  if (!type.isTextblock) {
    console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
    return false;
  }
  return chain2().command(({ commands }) => {
    const canSetBlock = setBlockType2(type, { ...attributesToCopy, ...attributes })(state);
    if (canSetBlock) {
      return true;
    }
    return commands.clearNodes();
  }).command(({ state: updatedState }) => {
    return setBlockType2(type, { ...attributesToCopy, ...attributes })(updatedState, dispatch2);
  }).run();
};
var setNodeSelection = (position) => ({ tr: tr2, dispatch: dispatch2 }) => {
  if (dispatch2) {
    const { doc: doc3 } = tr2;
    const from2 = minMax(position, 0, doc3.content.size);
    const selection = NodeSelection.create(doc3, from2);
    tr2.setSelection(selection);
  }
  return true;
};
var setTextDirection = (direction, position) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  const { selection } = state;
  let from2;
  let to;
  if (typeof position === "number") {
    from2 = position;
    to = position;
  } else if (position && "from" in position && "to" in position) {
    from2 = position.from;
    to = position.to;
  } else {
    from2 = selection.from;
    to = selection.to;
  }
  if (dispatch2) {
    tr2.doc.nodesBetween(from2, to, (node, pos) => {
      if (node.isText) {
        return;
      }
      tr2.setNodeMarkup(pos, void 0, {
        ...node.attrs,
        dir: direction
      });
    });
  }
  return true;
};
var setTextSelection = (position) => ({ tr: tr2, dispatch: dispatch2 }) => {
  if (dispatch2) {
    const { doc: doc3 } = tr2;
    const { from: from2, to } = typeof position === "number" ? { from: position, to: position } : position;
    const minPos = TextSelection.atStart(doc3).from;
    const maxPos = TextSelection.atEnd(doc3).to;
    const resolvedFrom = minMax(from2, minPos, maxPos);
    const resolvedEnd = minMax(to, minPos, maxPos);
    const selection = TextSelection.create(doc3, resolvedFrom, resolvedEnd);
    tr2.setSelection(selection);
  }
  return true;
};
var sinkListItem2 = (typeOrName) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  return sinkListItem(type)(state, dispatch2);
};
function ensureMarks(state, splittableMarks) {
  const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
  if (marks) {
    const filteredMarks = marks.filter((mark) => splittableMarks == null ? void 0 : splittableMarks.includes(mark.type.name));
    state.tr.ensureMarks(filteredMarks);
  }
}
var splitBlock2 = ({ keepMarks = true } = {}) => ({ tr: tr2, state, dispatch: dispatch2, editor }) => {
  const { selection, doc: doc3 } = tr2;
  const { $from, $to } = selection;
  const extensionAttributes = editor.extensionManager.attributes;
  const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
  if (selection instanceof NodeSelection && selection.node.isBlock) {
    if (!$from.parentOffset || !canSplit(doc3, $from.pos)) {
      return false;
    }
    if (dispatch2) {
      if (keepMarks) {
        ensureMarks(state, editor.extensionManager.splittableMarks);
      }
      tr2.split($from.pos).scrollIntoView();
    }
    return true;
  }
  if (!$from.parent.isBlock) {
    return false;
  }
  const atEnd = $to.parentOffset === $to.parent.content.size;
  const deflt = $from.depth === 0 ? void 0 : defaultBlockAt2($from.node(-1).contentMatchAt($from.indexAfter(-1)));
  let types = atEnd && deflt ? [
    {
      type: deflt,
      attrs: newAttributes
    }
  ] : void 0;
  let can = canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, types);
  if (!types && !can && canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
    can = true;
    types = deflt ? [
      {
        type: deflt,
        attrs: newAttributes
      }
    ] : void 0;
  }
  if (dispatch2) {
    if (can) {
      if (selection instanceof TextSelection) {
        tr2.deleteSelection();
      }
      tr2.split(tr2.mapping.map($from.pos), 1, types);
      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
        const first2 = tr2.mapping.map($from.before());
        const $first = tr2.doc.resolve(first2);
        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
          tr2.setNodeMarkup(tr2.mapping.map($from.before()), deflt);
        }
      }
    }
    if (keepMarks) {
      ensureMarks(state, editor.extensionManager.splittableMarks);
    }
    tr2.scrollIntoView();
  }
  return can;
};
var splitListItem = (typeOrName, overrideAttrs = {}) => ({ tr: tr2, state, dispatch: dispatch2, editor }) => {
  var _a6;
  const type = getNodeType(typeOrName, state.schema);
  const { $from, $to } = state.selection;
  const node = state.selection.node;
  if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
    return false;
  }
  const grandParent = $from.node(-1);
  if (grandParent.type !== type) {
    return false;
  }
  const extensionAttributes = editor.extensionManager.attributes;
  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
    if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
      return false;
    }
    if (dispatch2) {
      let wrap3 = Fragment12.empty;
      const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
      for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {
        wrap3 = Fragment12.from($from.node(d).copy(wrap3));
      }
      const depthAfter = (
        // eslint-disable-next-line no-nested-ternary
        $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3
      );
      const newNextTypeAttributes2 = {
        ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),
        ...overrideAttrs
      };
      const nextType2 = ((_a6 = type.contentMatch.defaultType) == null ? void 0 : _a6.createAndFill(newNextTypeAttributes2)) || void 0;
      wrap3 = wrap3.append(Fragment12.from(type.createAndFill(null, nextType2) || void 0));
      const start = $from.before($from.depth - (depthBefore - 1));
      tr2.replace(start, $from.after(-depthAfter), new Slice(wrap3, 4 - depthBefore, 0));
      let sel = -1;
      tr2.doc.nodesBetween(start, tr2.doc.content.size, (n, pos) => {
        if (sel > -1) {
          return false;
        }
        if (n.isTextblock && n.content.size === 0) {
          sel = pos + 1;
        }
      });
      if (sel > -1) {
        tr2.setSelection(TextSelection.near(tr2.doc.resolve(sel)));
      }
      tr2.scrollIntoView();
    }
    return true;
  }
  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
  const newTypeAttributes = {
    ...getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs),
    ...overrideAttrs
  };
  const newNextTypeAttributes = {
    ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),
    ...overrideAttrs
  };
  tr2.delete($from.pos, $to.pos);
  const types = nextType ? [
    { type, attrs: newTypeAttributes },
    { type: nextType, attrs: newNextTypeAttributes }
  ] : [{ type, attrs: newTypeAttributes }];
  if (!canSplit(tr2.doc, $from.pos, 2)) {
    return false;
  }
  if (dispatch2) {
    const { selection, storedMarks } = state;
    const { splittableMarks } = editor.extensionManager;
    const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
    tr2.split($from.pos, 2, types).scrollIntoView();
    if (!marks || !dispatch2) {
      return true;
    }
    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
    tr2.ensureMarks(filteredMarks);
  }
  return true;
};
var joinListBackwards = (tr2, listType) => {
  const list = findParentNode((node) => node.type === listType)(tr2.selection);
  if (!list) {
    return true;
  }
  const before = tr2.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);
  if (before === void 0) {
    return true;
  }
  const nodeBefore = tr2.doc.nodeAt(before);
  const canJoinBackwards = list.node.type === (nodeBefore == null ? void 0 : nodeBefore.type) && canJoin(tr2.doc, list.pos);
  if (!canJoinBackwards) {
    return true;
  }
  tr2.join(list.pos);
  return true;
};
var joinListForwards = (tr2, listType) => {
  const list = findParentNode((node) => node.type === listType)(tr2.selection);
  if (!list) {
    return true;
  }
  const after = tr2.doc.resolve(list.start).after(list.depth);
  if (after === void 0) {
    return true;
  }
  const nodeAfter = tr2.doc.nodeAt(after);
  const canJoinForwards = list.node.type === (nodeAfter == null ? void 0 : nodeAfter.type) && canJoin(tr2.doc, after);
  if (!canJoinForwards) {
    return true;
  }
  tr2.join(after);
  return true;
};
var toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({ editor, tr: tr2, state, dispatch: dispatch2, chain: chain2, commands, can }) => {
  const { extensions, splittableMarks } = editor.extensionManager;
  const listType = getNodeType(listTypeOrName, state.schema);
  const itemType = getNodeType(itemTypeOrName, state.schema);
  const { selection, storedMarks } = state;
  const { $from, $to } = selection;
  const range = $from.blockRange($to);
  const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
  if (!range) {
    return false;
  }
  const parentList = findParentNode((node) => isList(node.type.name, extensions))(selection);
  if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {
    if (parentList.node.type === listType) {
      return commands.liftListItem(itemType);
    }
    if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch2) {
      return chain2().command(() => {
        tr2.setNodeMarkup(parentList.pos, listType);
        return true;
      }).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
    }
  }
  if (!keepMarks || !marks || !dispatch2) {
    return chain2().command(() => {
      const canWrapInList = can().wrapInList(listType, attributes);
      if (canWrapInList) {
        return true;
      }
      return commands.clearNodes();
    }).wrapInList(listType, attributes).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
  }
  return chain2().command(() => {
    const canWrapInList = can().wrapInList(listType, attributes);
    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
    tr2.ensureMarks(filteredMarks);
    if (canWrapInList) {
      return true;
    }
    return commands.clearNodes();
  }).wrapInList(listType, attributes).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
};
var toggleMark = (typeOrName, attributes = {}, options2 = {}) => ({ state, commands }) => {
  const { extendEmptyMarkRange = false } = options2;
  const type = getMarkType(typeOrName, state.schema);
  const isActive2 = isMarkActive(state, type, attributes);
  if (isActive2) {
    return commands.unsetMark(type, { extendEmptyMarkRange });
  }
  return commands.setMark(type, attributes);
};
var toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands }) => {
  const type = getNodeType(typeOrName, state.schema);
  const toggleType = getNodeType(toggleTypeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  let attributesToCopy;
  if (state.selection.$anchor.sameParent(state.selection.$head)) {
    attributesToCopy = state.selection.$anchor.parent.attrs;
  }
  if (isActive2) {
    return commands.setNode(toggleType, attributesToCopy);
  }
  return commands.setNode(type, { ...attributesToCopy, ...attributes });
};
var toggleWrap = (typeOrName, attributes = {}) => ({ state, commands }) => {
  const type = getNodeType(typeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (isActive2) {
    return commands.lift(type);
  }
  return commands.wrapIn(type, attributes);
};
var undoInputRule = () => ({ state, dispatch: dispatch2 }) => {
  const plugins = state.plugins;
  for (let i = 0; i < plugins.length; i += 1) {
    const plugin = plugins[i];
    let undoable;
    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
      if (dispatch2) {
        const tr2 = state.tr;
        const toUndo = undoable.transform;
        for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {
          tr2.step(toUndo.steps[j].invert(toUndo.docs[j]));
        }
        if (undoable.text) {
          const marks = tr2.doc.resolve(undoable.from).marks();
          tr2.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
        } else {
          tr2.delete(undoable.from, undoable.to);
        }
      }
      return true;
    }
  }
  return false;
};
var unsetAllMarks = () => ({ tr: tr2, dispatch: dispatch2 }) => {
  const { selection } = tr2;
  const { empty: empty2, ranges } = selection;
  if (empty2) {
    return true;
  }
  if (dispatch2) {
    ranges.forEach((range) => {
      tr2.removeMark(range.$from.pos, range.$to.pos);
    });
  }
  return true;
};
var unsetMark = (typeOrName, options2 = {}) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  var _a6;
  const { extendEmptyMarkRange = false } = options2;
  const { selection } = tr2;
  const type = getMarkType(typeOrName, state.schema);
  const { $from, empty: empty2, ranges } = selection;
  if (!dispatch2) {
    return true;
  }
  if (empty2 && extendEmptyMarkRange) {
    let { from: from2, to } = selection;
    const attrs = (_a6 = $from.marks().find((mark) => mark.type === type)) == null ? void 0 : _a6.attrs;
    const range = getMarkRange($from, type, attrs);
    if (range) {
      from2 = range.from;
      to = range.to;
    }
    tr2.removeMark(from2, to, type);
  } else {
    ranges.forEach((range) => {
      tr2.removeMark(range.$from.pos, range.$to.pos, type);
    });
  }
  tr2.removeStoredMark(type);
  return true;
};
var unsetTextDirection = (position) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  const { selection } = state;
  let from2;
  let to;
  if (typeof position === "number") {
    from2 = position;
    to = position;
  } else if (position && "from" in position && "to" in position) {
    from2 = position.from;
    to = position.to;
  } else {
    from2 = selection.from;
    to = selection.to;
  }
  if (dispatch2) {
    tr2.doc.nodesBetween(from2, to, (node, pos) => {
      if (node.isText) {
        return;
      }
      const newAttrs = { ...node.attrs };
      delete newAttrs.dir;
      tr2.setNodeMarkup(pos, void 0, newAttrs);
    });
  }
  return true;
};
var updateAttributes = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(
    typeof typeOrName === "string" ? typeOrName : typeOrName.name,
    state.schema
  );
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  let canUpdate = false;
  tr2.selection.ranges.forEach((range) => {
    const from2 = range.$from.pos;
    const to = range.$to.pos;
    let lastPos;
    let lastNode;
    let trimmedFrom;
    let trimmedTo;
    if (tr2.selection.empty) {
      state.doc.nodesBetween(from2, to, (node, pos) => {
        if (nodeType && nodeType === node.type) {
          canUpdate = true;
          trimmedFrom = Math.max(pos, from2);
          trimmedTo = Math.min(pos + node.nodeSize, to);
          lastPos = pos;
          lastNode = node;
        }
      });
    } else {
      state.doc.nodesBetween(from2, to, (node, pos) => {
        if (pos < from2 && nodeType && nodeType === node.type) {
          canUpdate = true;
          trimmedFrom = Math.max(pos, from2);
          trimmedTo = Math.min(pos + node.nodeSize, to);
          lastPos = pos;
          lastNode = node;
        }
        if (pos >= from2 && pos <= to) {
          if (nodeType && nodeType === node.type) {
            canUpdate = true;
            if (dispatch2) {
              tr2.setNodeMarkup(pos, void 0, {
                ...node.attrs,
                ...attributes
              });
            }
          }
          if (markType && node.marks.length) {
            node.marks.forEach((mark) => {
              if (markType === mark.type) {
                canUpdate = true;
                if (dispatch2) {
                  const trimmedFrom2 = Math.max(pos, from2);
                  const trimmedTo2 = Math.min(pos + node.nodeSize, to);
                  tr2.addMark(
                    trimmedFrom2,
                    trimmedTo2,
                    markType.create({
                      ...mark.attrs,
                      ...attributes
                    })
                  );
                }
              }
            });
          }
        }
      });
    }
    if (lastNode) {
      if (lastPos !== void 0 && dispatch2) {
        tr2.setNodeMarkup(lastPos, void 0, {
          ...lastNode.attrs,
          ...attributes
        });
      }
      if (markType && lastNode.marks.length) {
        lastNode.marks.forEach((mark) => {
          if (markType === mark.type && dispatch2) {
            tr2.addMark(
              trimmedFrom,
              trimmedTo,
              markType.create({
                ...mark.attrs,
                ...attributes
              })
            );
          }
        });
      }
    }
  });
  return canUpdate;
};
var wrapIn2 = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapIn(type, attributes)(state, dispatch2);
};
var wrapInList2 = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapInList(type, attributes)(state, dispatch2);
};
var EventEmitter2 = class {
  constructor() {
    this.callbacks = {};
  }
  on(event, fn) {
    if (!this.callbacks[event]) {
      this.callbacks[event] = [];
    }
    this.callbacks[event].push(fn);
    return this;
  }
  emit(event, ...args) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      callbacks.forEach((callback) => callback.apply(this, args));
    }
    return this;
  }
  off(event, fn) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      if (fn) {
        this.callbacks[event] = callbacks.filter((callback) => callback !== fn);
      } else {
        delete this.callbacks[event];
      }
    }
    return this;
  }
  once(event, fn) {
    const onceFn = (...args) => {
      this.off(event, onceFn);
      fn.apply(this, args);
    };
    return this.on(event, onceFn);
  }
  removeAllListeners() {
    this.callbacks = {};
  }
};
var InputRule = class {
  constructor(config) {
    var _a6;
    this.find = config.find;
    this.handler = config.handler;
    this.undoable = (_a6 = config.undoable) != null ? _a6 : true;
  }
};
var inputRuleMatcherHandler = (text, find2) => {
  if (isRegExp(find2)) {
    return find2.exec(text);
  }
  const inputRuleMatch = find2(text);
  if (!inputRuleMatch) {
    return null;
  }
  const result = [inputRuleMatch.text];
  result.index = inputRuleMatch.index;
  result.input = text;
  result.data = inputRuleMatch.data;
  if (inputRuleMatch.replaceWith) {
    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
      console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
    }
    result.push(inputRuleMatch.replaceWith);
  }
  return result;
};
function run(config) {
  var _a6;
  const { editor, from: from2, to, text, rules, plugin } = config;
  const { view } = editor;
  if (view.composing) {
    return false;
  }
  const $from = view.state.doc.resolve(from2);
  if (
    // check for code node
    $from.parent.type.spec.code || // check for code mark
    !!((_a6 = $from.nodeBefore || $from.nodeAfter) == null ? void 0 : _a6.marks.find((mark) => mark.type.spec.code))
  ) {
    return false;
  }
  let matched = false;
  const textBefore = getTextContentFromNodes($from) + text;
  rules.forEach((rule) => {
    if (matched) {
      return;
    }
    const match = inputRuleMatcherHandler(textBefore, rule.find);
    if (!match) {
      return;
    }
    const tr2 = view.state.tr;
    const state = createChainableState({
      state: view.state,
      transaction: tr2
    });
    const range = {
      from: from2 - (match[0].length - text.length),
      to
    };
    const { commands, chain: chain2, can } = new CommandManager({
      editor,
      state
    });
    const handler = rule.handler({
      state,
      range,
      match,
      commands,
      chain: chain2,
      can
    });
    if (handler === null || !tr2.steps.length) {
      return;
    }
    if (rule.undoable) {
      tr2.setMeta(plugin, {
        transform: tr2,
        from: from2,
        to,
        text
      });
    }
    view.dispatch(tr2);
    matched = true;
  });
  return matched;
}
function inputRulesPlugin(props) {
  const { editor, rules } = props;
  const plugin = new Plugin({
    state: {
      init() {
        return null;
      },
      apply(tr2, prev, state) {
        const stored = tr2.getMeta(plugin);
        if (stored) {
          return stored;
        }
        const simulatedInputMeta = tr2.getMeta("applyInputRules");
        const isSimulatedInput = !!simulatedInputMeta;
        if (isSimulatedInput) {
          setTimeout(() => {
            let { text } = simulatedInputMeta;
            if (typeof text === "string") {
              text = text;
            } else {
              text = getHTMLFromFragment(Fragment12.from(text), state.schema);
            }
            const { from: from2 } = simulatedInputMeta;
            const to = from2 + text.length;
            run({
              editor,
              from: from2,
              to,
              text,
              rules,
              plugin
            });
          });
        }
        return tr2.selectionSet || tr2.docChanged ? null : prev;
      }
    },
    props: {
      handleTextInput(view, from2, to, text) {
        return run({
          editor,
          from: from2,
          to,
          text,
          rules,
          plugin
        });
      },
      handleDOMEvents: {
        compositionend: (view) => {
          setTimeout(() => {
            const { $cursor } = view.state.selection;
            if ($cursor) {
              run({
                editor,
                from: $cursor.pos,
                to: $cursor.pos,
                text: "",
                rules,
                plugin
              });
            }
          });
          return false;
        }
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(view, event) {
        if (event.key !== "Enter") {
          return false;
        }
        const { $cursor } = view.state.selection;
        if ($cursor) {
          return run({
            editor,
            from: $cursor.pos,
            to: $cursor.pos,
            text: "\n",
            rules,
            plugin
          });
        }
        return false;
      }
    },
    // @ts-ignore
    isInputRules: true
  });
  return plugin;
}
function getType(value) {
  return Object.prototype.toString.call(value).slice(8, -1);
}
function isPlainObject(value) {
  if (getType(value) !== "Object") {
    return false;
  }
  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
}
function mergeDeep(target, source) {
  const output = { ...target };
  if (isPlainObject(target) && isPlainObject(source)) {
    Object.keys(source).forEach((key) => {
      if (isPlainObject(source[key]) && isPlainObject(target[key])) {
        output[key] = mergeDeep(target[key], source[key]);
      } else {
        output[key] = source[key];
      }
    });
  }
  return output;
}
var Extendable = class {
  constructor(config = {}) {
    this.type = "extendable";
    this.parent = null;
    this.child = null;
    this.name = "";
    this.config = {
      name: this.name
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
  }
  get options() {
    return {
      ...callOrReturn(
        getExtensionField(this, "addOptions", {
          name: this.name
        })
      ) || {}
    };
  }
  get storage() {
    return {
      ...callOrReturn(
        getExtensionField(this, "addStorage", {
          name: this.name,
          options: this.options
        })
      ) || {}
    };
  }
  configure(options2 = {}) {
    const extension = this.extend({
      ...this.config,
      addOptions: () => {
        return mergeDeep(this.options, options2);
      }
    });
    extension.name = this.name;
    extension.parent = this.parent;
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new this.constructor({ ...this.config, ...extendedConfig });
    extension.parent = this;
    this.child = extension;
    extension.name = "name" in extendedConfig ? extendedConfig.name : extension.parent.name;
    return extension;
  }
};
var Mark2 = class _Mark extends Extendable {
  constructor() {
    super(...arguments);
    this.type = "mark";
  }
  /**
   * Create a new Mark instance
   * @param config - Mark configuration object or a function that returns a configuration object
   */
  static create(config = {}) {
    const resolvedConfig = typeof config === "function" ? config() : config;
    return new _Mark(resolvedConfig);
  }
  static handleExit({ editor, mark }) {
    const { tr: tr2 } = editor.state;
    const currentPos = editor.state.selection.$from;
    const isAtEnd = currentPos.pos === currentPos.end();
    if (isAtEnd) {
      const currentMarks = currentPos.marks();
      const isInMark = !!currentMarks.find((m) => (m == null ? void 0 : m.type.name) === mark.name);
      if (!isInMark) {
        return false;
      }
      const removeMark2 = currentMarks.find((m) => (m == null ? void 0 : m.type.name) === mark.name);
      if (removeMark2) {
        tr2.removeStoredMark(removeMark2);
      }
      tr2.insertText(" ", currentPos.pos);
      editor.view.dispatch(tr2);
      return true;
    }
    return false;
  }
  configure(options2) {
    return super.configure(options2);
  }
  extend(extendedConfig) {
    const resolvedConfig = typeof extendedConfig === "function" ? extendedConfig() : extendedConfig;
    return super.extend(resolvedConfig);
  }
};
function isNumber(value) {
  return typeof value === "number";
}
var PasteRule = class {
  constructor(config) {
    this.find = config.find;
    this.handler = config.handler;
  }
};
var pasteRuleMatcherHandler = (text, find2, event) => {
  if (isRegExp(find2)) {
    return [...text.matchAll(find2)];
  }
  const matches2 = find2(text, event);
  if (!matches2) {
    return [];
  }
  return matches2.map((pasteRuleMatch) => {
    const result = [pasteRuleMatch.text];
    result.index = pasteRuleMatch.index;
    result.input = text;
    result.data = pasteRuleMatch.data;
    if (pasteRuleMatch.replaceWith) {
      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {
        console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');
      }
      result.push(pasteRuleMatch.replaceWith);
    }
    return result;
  });
};
function run2(config) {
  const { editor, state, from: from2, to, rule, pasteEvent, dropEvent } = config;
  const { commands, chain: chain2, can } = new CommandManager({
    editor,
    state
  });
  const handlers2 = [];
  state.doc.nodesBetween(from2, to, (node, pos) => {
    var _a6, _b3, _c, _d, _e;
    if (((_b3 = (_a6 = node.type) == null ? void 0 : _a6.spec) == null ? void 0 : _b3.code) || !(node.isText || node.isTextblock || node.isInline)) {
      return;
    }
    const contentSize = (_e = (_d = (_c = node.content) == null ? void 0 : _c.size) != null ? _d : node.nodeSize) != null ? _e : 0;
    const resolvedFrom = Math.max(from2, pos);
    const resolvedTo = Math.min(to, pos + contentSize);
    if (resolvedFrom >= resolvedTo) {
      return;
    }
    const textToMatch = node.isText ? node.text || "" : node.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, "￼");
    const matches2 = pasteRuleMatcherHandler(textToMatch, rule.find, pasteEvent);
    matches2.forEach((match) => {
      if (match.index === void 0) {
        return;
      }
      const start = resolvedFrom + match.index + 1;
      const end = start + match[0].length;
      const range = {
        from: state.tr.mapping.map(start),
        to: state.tr.mapping.map(end)
      };
      const handler = rule.handler({
        state,
        range,
        match,
        commands,
        chain: chain2,
        can,
        pasteEvent,
        dropEvent
      });
      handlers2.push(handler);
    });
  });
  const success = handlers2.every((handler) => handler !== null);
  return success;
}
var tiptapDragFromOtherEditor = null;
var createClipboardPasteEvent = (text) => {
  var _a6;
  const event = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer()
  });
  (_a6 = event.clipboardData) == null ? void 0 : _a6.setData("text/html", text);
  return event;
};
function pasteRulesPlugin(props) {
  const { editor, rules } = props;
  let dragSourceElement = null;
  let isPastedFromProseMirror = false;
  let isDroppedFromProseMirror = false;
  let pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
  let dropEvent;
  try {
    dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
  } catch {
    dropEvent = null;
  }
  const processEvent = ({
    state,
    from: from2,
    to,
    rule,
    pasteEvt
  }) => {
    const tr2 = state.tr;
    const chainableState = createChainableState({
      state,
      transaction: tr2
    });
    const handler = run2({
      editor,
      state: chainableState,
      from: Math.max(from2 - 1, 0),
      to: to.b - 1,
      rule,
      pasteEvent: pasteEvt,
      dropEvent
    });
    if (!handler || !tr2.steps.length) {
      return;
    }
    try {
      dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
    } catch {
      dropEvent = null;
    }
    pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
    return tr2;
  };
  const plugins = rules.map((rule) => {
    return new Plugin({
      // we register a global drag handler to track the current drag source element
      view(view) {
        const handleDragstart = (event) => {
          var _a6;
          dragSourceElement = ((_a6 = view.dom.parentElement) == null ? void 0 : _a6.contains(event.target)) ? view.dom.parentElement : null;
          if (dragSourceElement) {
            tiptapDragFromOtherEditor = editor;
          }
        };
        const handleDragend = () => {
          if (tiptapDragFromOtherEditor) {
            tiptapDragFromOtherEditor = null;
          }
        };
        window.addEventListener("dragstart", handleDragstart);
        window.addEventListener("dragend", handleDragend);
        return {
          destroy() {
            window.removeEventListener("dragstart", handleDragstart);
            window.removeEventListener("dragend", handleDragend);
          }
        };
      },
      props: {
        handleDOMEvents: {
          drop: (view, event) => {
            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;
            dropEvent = event;
            if (!isDroppedFromProseMirror) {
              const dragFromOtherEditor = tiptapDragFromOtherEditor;
              if (dragFromOtherEditor == null ? void 0 : dragFromOtherEditor.isEditable) {
                setTimeout(() => {
                  const selection = dragFromOtherEditor.state.selection;
                  if (selection) {
                    dragFromOtherEditor.commands.deleteRange({ from: selection.from, to: selection.to });
                  }
                }, 10);
              }
            }
            return false;
          },
          paste: (_view, event) => {
            var _a6;
            const html = (_a6 = event.clipboardData) == null ? void 0 : _a6.getData("text/html");
            pasteEvent = event;
            isPastedFromProseMirror = !!(html == null ? void 0 : html.includes("data-pm-slice"));
            return false;
          }
        }
      },
      appendTransaction: (transactions, oldState, state) => {
        const transaction2 = transactions[0];
        const isPaste = transaction2.getMeta("uiEvent") === "paste" && !isPastedFromProseMirror;
        const isDrop = transaction2.getMeta("uiEvent") === "drop" && !isDroppedFromProseMirror;
        const simulatedPasteMeta = transaction2.getMeta("applyPasteRules");
        const isSimulatedPaste = !!simulatedPasteMeta;
        if (!isPaste && !isDrop && !isSimulatedPaste) {
          return;
        }
        if (isSimulatedPaste) {
          let { text } = simulatedPasteMeta;
          if (typeof text === "string") {
            text = text;
          } else {
            text = getHTMLFromFragment(Fragment12.from(text), state.schema);
          }
          const { from: from22 } = simulatedPasteMeta;
          const to2 = from22 + text.length;
          const pasteEvt = createClipboardPasteEvent(text);
          return processEvent({
            rule,
            state,
            from: from22,
            to: { b: to2 },
            pasteEvt
          });
        }
        const from2 = oldState.doc.content.findDiffStart(state.doc.content);
        const to = oldState.doc.content.findDiffEnd(state.doc.content);
        if (!isNumber(from2) || !to || from2 === to.b) {
          return;
        }
        return processEvent({
          rule,
          state,
          from: from2,
          to,
          pasteEvt: pasteEvent
        });
      }
    });
  });
  return plugins;
}
var ExtensionManager = class {
  constructor(extensions, editor) {
    this.splittableMarks = [];
    this.editor = editor;
    this.baseExtensions = extensions;
    this.extensions = resolveExtensions(extensions);
    this.schema = getSchemaByResolvedExtensions(this.extensions, editor);
    this.setupExtensions();
  }
  /**
   * Get all commands from the extensions.
   * @returns An object with all commands where the key is the command name and the value is the command function
   */
  get commands() {
    return this.extensions.reduce((commands, extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: this.editor.extensionStorage[extension.name],
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const addCommands = getExtensionField(extension, "addCommands", context);
      if (!addCommands) {
        return commands;
      }
      return {
        ...commands,
        ...addCommands()
      };
    }, {});
  }
  /**
   * Get all registered Prosemirror plugins from the extensions.
   * @returns An array of Prosemirror plugins
   */
  get plugins() {
    const { editor } = this;
    const extensions = sortExtensions([...this.extensions].reverse());
    const allPlugins = extensions.flatMap((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: this.editor.extensionStorage[extension.name],
        editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const plugins = [];
      const addKeyboardShortcuts = getExtensionField(
        extension,
        "addKeyboardShortcuts",
        context
      );
      let defaultBindings = {};
      if (extension.type === "mark" && getExtensionField(extension, "exitable", context)) {
        defaultBindings.ArrowRight = () => Mark2.handleExit({ editor, mark: extension });
      }
      if (addKeyboardShortcuts) {
        const bindings = Object.fromEntries(
          Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {
            return [shortcut, () => method({ editor })];
          })
        );
        defaultBindings = { ...defaultBindings, ...bindings };
      }
      const keyMapPlugin = keymap(defaultBindings);
      plugins.push(keyMapPlugin);
      const addInputRules = getExtensionField(extension, "addInputRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {
        const rules = addInputRules();
        if (rules && rules.length) {
          const inputResult = inputRulesPlugin({
            editor,
            rules
          });
          const inputPlugins = Array.isArray(inputResult) ? inputResult : [inputResult];
          plugins.push(...inputPlugins);
        }
      }
      const addPasteRules = getExtensionField(extension, "addPasteRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {
        const rules = addPasteRules();
        if (rules && rules.length) {
          const pasteRules = pasteRulesPlugin({ editor, rules });
          plugins.push(...pasteRules);
        }
      }
      const addProseMirrorPlugins = getExtensionField(
        extension,
        "addProseMirrorPlugins",
        context
      );
      if (addProseMirrorPlugins) {
        const proseMirrorPlugins = addProseMirrorPlugins();
        plugins.push(...proseMirrorPlugins);
      }
      return plugins;
    });
    return allPlugins;
  }
  /**
   * Get all attributes from the extensions.
   * @returns An array of attributes
   */
  get attributes() {
    return getAttributesFromExtensions(this.extensions);
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views where the key is the node name and the value is the node view function
   */
  get nodeViews() {
    const { editor } = this;
    const { nodeExtensions } = splitExtensions(this.extensions);
    return Object.fromEntries(
      nodeExtensions.filter((extension) => !!getExtensionField(extension, "addNodeView")).map((extension) => {
        const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);
        const context = {
          name: extension.name,
          options: extension.options,
          storage: this.editor.extensionStorage[extension.name],
          editor,
          type: getNodeType(extension.name, this.schema)
        };
        const addNodeView = getExtensionField(extension, "addNodeView", context);
        if (!addNodeView) {
          return [];
        }
        const nodeViewResult = addNodeView();
        if (!nodeViewResult) {
          return [];
        }
        const nodeview = (node, view, getPos, decorations, innerDecorations) => {
          const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);
          return nodeViewResult({
            // pass-through
            node,
            view,
            getPos,
            decorations,
            innerDecorations,
            // tiptap-specific
            editor,
            extension,
            HTMLAttributes
          });
        };
        return [extension.name, nodeview];
      })
    );
  }
  /**
   * Get the composed dispatchTransaction function from all extensions.
   * @param baseDispatch The base dispatch function (e.g. from the editor or user props)
   * @returns A composed dispatch function
   */
  dispatchTransaction(baseDispatch) {
    const { editor } = this;
    const extensions = sortExtensions([...this.extensions].reverse());
    return extensions.reduceRight((next, extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: this.editor.extensionStorage[extension.name],
        editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const dispatchTransaction = getExtensionField(
        extension,
        "dispatchTransaction",
        context
      );
      if (!dispatchTransaction) {
        return next;
      }
      return (transaction2) => {
        dispatchTransaction.call(context, { transaction: transaction2, next });
      };
    }, baseDispatch);
  }
  get markViews() {
    const { editor } = this;
    const { markExtensions } = splitExtensions(this.extensions);
    return Object.fromEntries(
      markExtensions.filter((extension) => !!getExtensionField(extension, "addMarkView")).map((extension) => {
        const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);
        const context = {
          name: extension.name,
          options: extension.options,
          storage: this.editor.extensionStorage[extension.name],
          editor,
          type: getMarkType(extension.name, this.schema)
        };
        const addMarkView = getExtensionField(extension, "addMarkView", context);
        if (!addMarkView) {
          return [];
        }
        const markView = (mark, view, inline3) => {
          const HTMLAttributes = getRenderedAttributes(mark, extensionAttributes);
          return addMarkView()({
            // pass-through
            mark,
            view,
            inline: inline3,
            // tiptap-specific
            editor,
            extension,
            HTMLAttributes,
            updateAttributes: (attrs) => {
              updateMarkViewAttributes(mark, editor, attrs);
            }
          });
        };
        return [extension.name, markView];
      })
    );
  }
  /**
   * Go through all extensions, create extension storages & setup marks
   * & bind editor event listener.
   */
  setupExtensions() {
    const extensions = this.extensions;
    this.editor.extensionStorage = Object.fromEntries(
      extensions.map((extension) => [extension.name, extension.storage])
    );
    extensions.forEach((extension) => {
      var _a6;
      const context = {
        name: extension.name,
        options: extension.options,
        storage: this.editor.extensionStorage[extension.name],
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      if (extension.type === "mark") {
        const keepOnSplit = (_a6 = callOrReturn(getExtensionField(extension, "keepOnSplit", context))) != null ? _a6 : true;
        if (keepOnSplit) {
          this.splittableMarks.push(extension.name);
        }
      }
      const onBeforeCreate = getExtensionField(extension, "onBeforeCreate", context);
      const onCreate = getExtensionField(extension, "onCreate", context);
      const onUpdate = getExtensionField(extension, "onUpdate", context);
      const onSelectionUpdate = getExtensionField(
        extension,
        "onSelectionUpdate",
        context
      );
      const onTransaction = getExtensionField(extension, "onTransaction", context);
      const onFocus = getExtensionField(extension, "onFocus", context);
      const onBlur = getExtensionField(extension, "onBlur", context);
      const onDestroy = getExtensionField(extension, "onDestroy", context);
      if (onBeforeCreate) {
        this.editor.on("beforeCreate", onBeforeCreate);
      }
      if (onCreate) {
        this.editor.on("create", onCreate);
      }
      if (onUpdate) {
        this.editor.on("update", onUpdate);
      }
      if (onSelectionUpdate) {
        this.editor.on("selectionUpdate", onSelectionUpdate);
      }
      if (onTransaction) {
        this.editor.on("transaction", onTransaction);
      }
      if (onFocus) {
        this.editor.on("focus", onFocus);
      }
      if (onBlur) {
        this.editor.on("blur", onBlur);
      }
      if (onDestroy) {
        this.editor.on("destroy", onDestroy);
      }
    });
  }
};
ExtensionManager.resolve = resolveExtensions;
ExtensionManager.sort = sortExtensions;
ExtensionManager.flatten = flattenExtensions;
var extensions_exports = {};
__export2(extensions_exports, {
  ClipboardTextSerializer: () => ClipboardTextSerializer,
  Commands: () => Commands,
  Delete: () => Delete,
  Drop: () => Drop,
  Editable: () => Editable,
  FocusEvents: () => FocusEvents,
  Keymap: () => Keymap,
  Paste: () => Paste,
  Tabindex: () => Tabindex,
  TextDirection: () => TextDirection,
  focusEventsPluginKey: () => focusEventsPluginKey
});
var Extension = class _Extension extends Extendable {
  constructor() {
    super(...arguments);
    this.type = "extension";
  }
  /**
   * Create a new Extension instance
   * @param config - Extension configuration object or a function that returns a configuration object
   */
  static create(config = {}) {
    const resolvedConfig = typeof config === "function" ? config() : config;
    return new _Extension(resolvedConfig);
  }
  configure(options2) {
    return super.configure(options2);
  }
  extend(extendedConfig) {
    const resolvedConfig = typeof extendedConfig === "function" ? extendedConfig() : extendedConfig;
    return super.extend(resolvedConfig);
  }
};
var ClipboardTextSerializer = Extension.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor } = this;
            const { state, schema } = editor;
            const { doc: doc3, selection } = state;
            const { ranges } = selection;
            const from2 = Math.min(...ranges.map((range2) => range2.$from.pos));
            const to = Math.max(...ranges.map((range2) => range2.$to.pos));
            const textSerializers = getTextSerializersFromSchema(schema);
            const range = { from: from2, to };
            return getTextBetween(doc3, range, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers
            });
          }
        }
      })
    ];
  }
});
var Commands = Extension.create({
  name: "commands",
  addCommands() {
    return {
      ...commands_exports
    };
  }
});
var Delete = Extension.create({
  name: "delete",
  onUpdate({ transaction: transaction2, appendedTransactions }) {
    var _a6, _b3, _c;
    const callback = () => {
      var _a22, _b22, _c2, _d;
      if ((_d = (_c2 = (_b22 = (_a22 = this.editor.options.coreExtensionOptions) == null ? void 0 : _a22.delete) == null ? void 0 : _b22.filterTransaction) == null ? void 0 : _c2.call(_b22, transaction2)) != null ? _d : transaction2.getMeta("y-sync$")) {
        return;
      }
      const nextTransaction = combineTransactionSteps(transaction2.before, [transaction2, ...appendedTransactions]);
      const changes = getChangedRanges(nextTransaction);
      changes.forEach((change) => {
        if (nextTransaction.mapping.mapResult(change.oldRange.from).deletedAfter && nextTransaction.mapping.mapResult(change.oldRange.to).deletedBefore) {
          nextTransaction.before.nodesBetween(change.oldRange.from, change.oldRange.to, (node, from2) => {
            const to = from2 + node.nodeSize - 2;
            const isFullyWithinRange = change.oldRange.from <= from2 && to <= change.oldRange.to;
            this.editor.emit("delete", {
              type: "node",
              node,
              from: from2,
              to,
              newFrom: nextTransaction.mapping.map(from2),
              newTo: nextTransaction.mapping.map(to),
              deletedRange: change.oldRange,
              newRange: change.newRange,
              partial: !isFullyWithinRange,
              editor: this.editor,
              transaction: transaction2,
              combinedTransform: nextTransaction
            });
          });
        }
      });
      const mapping = nextTransaction.mapping;
      nextTransaction.steps.forEach((step, index2) => {
        var _a32, _b32;
        if (step instanceof RemoveMarkStep) {
          const newStart = mapping.slice(index2).map(step.from, -1);
          const newEnd = mapping.slice(index2).map(step.to);
          const oldStart = mapping.invert().map(newStart, -1);
          const oldEnd = mapping.invert().map(newEnd);
          const foundBeforeMark = (_a32 = nextTransaction.doc.nodeAt(newStart - 1)) == null ? void 0 : _a32.marks.some((mark) => mark.eq(step.mark));
          const foundAfterMark = (_b32 = nextTransaction.doc.nodeAt(newEnd)) == null ? void 0 : _b32.marks.some((mark) => mark.eq(step.mark));
          this.editor.emit("delete", {
            type: "mark",
            mark: step.mark,
            from: step.from,
            to: step.to,
            deletedRange: {
              from: oldStart,
              to: oldEnd
            },
            newRange: {
              from: newStart,
              to: newEnd
            },
            partial: Boolean(foundAfterMark || foundBeforeMark),
            editor: this.editor,
            transaction: transaction2,
            combinedTransform: nextTransaction
          });
        }
      });
    };
    if ((_c = (_b3 = (_a6 = this.editor.options.coreExtensionOptions) == null ? void 0 : _a6.delete) == null ? void 0 : _b3.async) != null ? _c : true) {
      setTimeout(callback, 0);
    } else {
      callback();
    }
  }
});
var Drop = Extension.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tiptapDrop"),
        props: {
          handleDrop: (_, e, slice2, moved) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: e,
              slice: slice2,
              moved
            });
          }
        }
      })
    ];
  }
});
var Editable = Extension.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
});
var focusEventsPluginKey = new PluginKey("focusEvents");
var FocusEvents = Extension.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor } = this;
    return [
      new Plugin({
        key: focusEventsPluginKey,
        props: {
          handleDOMEvents: {
            focus: (view, event) => {
              editor.isFocused = true;
              const transaction2 = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction2);
              return false;
            },
            blur: (view, event) => {
              editor.isFocused = false;
              const transaction2 = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction2);
              return false;
            }
          }
        }
      })
    ];
  }
});
var Keymap = Extension.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const handleBackspace2 = () => this.editor.commands.first(({ commands }) => [
      () => commands.undoInputRule(),
      // maybe convert first text block node to default node
      () => commands.command(({ tr: tr2 }) => {
        const { selection, doc: doc3 } = tr2;
        const { empty: empty2, $anchor } = selection;
        const { pos, parent } = $anchor;
        const $parentPos = $anchor.parent.isTextblock && pos > 0 ? tr2.doc.resolve(pos - 1) : $anchor;
        const parentIsIsolating = $parentPos.parent.type.spec.isolating;
        const parentPos = $anchor.pos - $anchor.parentOffset;
        const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : Selection.atStart(doc3).from === pos;
        if (!empty2 || !parent.type.isTextblock || parent.textContent.length || !isAtStart || isAtStart && $anchor.parent.type.name === "paragraph") {
          return false;
        }
        return commands.clearNodes();
      }),
      () => commands.deleteSelection(),
      () => commands.joinBackward(),
      () => commands.selectNodeBackward()
    ]);
    const handleDelete2 = () => this.editor.commands.first(({ commands }) => [
      () => commands.deleteSelection(),
      () => commands.deleteCurrentNode(),
      () => commands.joinForward(),
      () => commands.selectNodeForward()
    ]);
    const handleEnter = () => this.editor.commands.first(({ commands }) => [
      () => commands.newlineInCode(),
      () => commands.createParagraphNear(),
      () => commands.liftEmptyBlock(),
      () => commands.splitBlock()
    ]);
    const baseKeymap = {
      Enter: handleEnter,
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: handleBackspace2,
      "Mod-Backspace": handleBackspace2,
      "Shift-Backspace": handleBackspace2,
      Delete: handleDelete2,
      "Mod-Delete": handleDelete2,
      "Mod-a": () => this.editor.commands.selectAll()
    };
    const pcKeymap = {
      ...baseKeymap
    };
    const macKeymap = {
      ...baseKeymap,
      "Ctrl-h": handleBackspace2,
      "Alt-Backspace": handleBackspace2,
      "Ctrl-d": handleDelete2,
      "Ctrl-Alt-Backspace": handleDelete2,
      "Alt-Delete": handleDelete2,
      "Alt-d": handleDelete2,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    if (isiOS() || isMacOS()) {
      return macKeymap;
    }
    return pcKeymap;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
      // with many other commands.
      new Plugin({
        key: new PluginKey("clearDocument"),
        appendTransaction: (transactions, oldState, newState) => {
          if (transactions.some((tr22) => tr22.getMeta("composition"))) {
            return;
          }
          const docChanges = transactions.some((transaction2) => transaction2.docChanged) && !oldState.doc.eq(newState.doc);
          const ignoreTr = transactions.some((transaction2) => transaction2.getMeta("preventClearDocument"));
          if (!docChanges || ignoreTr) {
            return;
          }
          const { empty: empty2, from: from2, to } = oldState.selection;
          const allFrom = Selection.atStart(oldState.doc).from;
          const allEnd = Selection.atEnd(oldState.doc).to;
          const allWasSelected = from2 === allFrom && to === allEnd;
          if (empty2 || !allWasSelected) {
            return;
          }
          const isEmpty = isNodeEmpty(newState.doc);
          if (!isEmpty) {
            return;
          }
          const tr2 = newState.tr;
          const state = createChainableState({
            state: newState,
            transaction: tr2
          });
          const { commands } = new CommandManager({
            editor: this.editor,
            state
          });
          commands.clearNodes();
          if (!tr2.steps.length) {
            return;
          }
          return tr2;
        }
      })
    ];
  }
});
var Paste = Extension.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tiptapPaste"),
        props: {
          handlePaste: (_view, e, slice2) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: e,
              slice: slice2
            });
          }
        }
      })
    ];
  }
});
var Tabindex = Extension.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
var TextDirection = Extension.create({
  name: "textDirection",
  addOptions() {
    return {
      direction: void 0
    };
  },
  addGlobalAttributes() {
    if (!this.options.direction) {
      return [];
    }
    const { nodeExtensions } = splitExtensions(this.extensions);
    return [
      {
        types: nodeExtensions.filter((extension) => extension.name !== "text").map((extension) => extension.name),
        attributes: {
          dir: {
            default: this.options.direction,
            parseHTML: (element) => {
              const dir = element.getAttribute("dir");
              if (dir && (dir === "ltr" || dir === "rtl" || dir === "auto")) {
                return dir;
              }
              return this.options.direction;
            },
            renderHTML: (attributes) => {
              if (!attributes.dir) {
                return {};
              }
              return {
                dir: attributes.dir
              };
            }
          }
        }
      }
    ];
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("textDirection"),
        props: {
          attributes: () => {
            const direction = this.options.direction;
            if (!direction) {
              return {};
            }
            return {
              dir: direction
            };
          }
        }
      })
    ];
  }
});
var NodePos = class _NodePos {
  constructor(pos, editor, isBlock = false, node = null) {
    this.currentNode = null;
    this.actualDepth = null;
    this.isBlock = isBlock;
    this.resolvedPos = pos;
    this.editor = editor;
    this.currentNode = node;
  }
  get name() {
    return this.node.type.name;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var _a6;
    return (_a6 = this.actualDepth) != null ? _a6 : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(content) {
    let from2 = this.from;
    let to = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You can’t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      from2 = this.from + 1;
      to = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from: from2, to }, content);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    if (this.isBlock) {
      return this.pos;
    }
    return this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    if (this.isBlock) {
      return this.pos + this.size;
    }
    return this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0) {
      return null;
    }
    const parentPos = this.resolvedPos.start(this.resolvedPos.depth - 1);
    const $pos = this.resolvedPos.doc.resolve(parentPos);
    return new _NodePos($pos, this.editor);
  }
  get before() {
    let $pos = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    if ($pos.depth !== this.depth) {
      $pos = this.resolvedPos.doc.resolve(this.from - 3);
    }
    return new _NodePos($pos, this.editor);
  }
  get after() {
    let $pos = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    if ($pos.depth !== this.depth) {
      $pos = this.resolvedPos.doc.resolve(this.to + 3);
    }
    return new _NodePos($pos, this.editor);
  }
  get children() {
    const children = [];
    this.node.content.forEach((node, offset4) => {
      const isBlock = node.isBlock && !node.isTextblock;
      const isNonTextAtom = node.isAtom && !node.isText;
      const isInline2 = node.isInline;
      const targetPos = this.pos + offset4 + (isNonTextAtom ? 0 : 1);
      if (targetPos < 0 || targetPos > this.resolvedPos.doc.nodeSize - 2) {
        return;
      }
      const $pos = this.resolvedPos.doc.resolve(targetPos);
      if (!isBlock && !isInline2 && $pos.depth <= this.depth) {
        return;
      }
      const childNodePos = new _NodePos($pos, this.editor, isBlock, isBlock || isInline2 ? node : null);
      if (isBlock) {
        childNodePos.actualDepth = this.depth + 1;
      }
      children.push(childNodePos);
    });
    return children;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const children = this.children;
    return children[children.length - 1] || null;
  }
  closest(selector, attributes = {}) {
    let node = null;
    let currentNode = this.parent;
    while (currentNode && !node) {
      if (currentNode.node.type.name === selector) {
        if (Object.keys(attributes).length > 0) {
          const nodeAttributes = currentNode.node.attrs;
          const attrKeys = Object.keys(attributes);
          for (let index2 = 0; index2 < attrKeys.length; index2 += 1) {
            const key = attrKeys[index2];
            if (nodeAttributes[key] !== attributes[key]) {
              break;
            }
          }
        } else {
          node = currentNode;
        }
      }
      currentNode = currentNode.parent;
    }
    return node;
  }
  querySelector(selector, attributes = {}) {
    return this.querySelectorAll(selector, attributes, true)[0] || null;
  }
  querySelectorAll(selector, attributes = {}, firstItemOnly = false) {
    let nodes = [];
    if (!this.children || this.children.length === 0) {
      return nodes;
    }
    const attrKeys = Object.keys(attributes);
    this.children.forEach((childPos) => {
      if (firstItemOnly && nodes.length > 0) {
        return;
      }
      if (childPos.node.type.name === selector) {
        const doesAllAttributesMatch = attrKeys.every((key) => attributes[key] === childPos.node.attrs[key]);
        if (doesAllAttributesMatch) {
          nodes.push(childPos);
        }
      }
      if (firstItemOnly && nodes.length > 0) {
        return;
      }
      nodes = nodes.concat(childPos.querySelectorAll(selector, attributes, firstItemOnly));
    });
    return nodes;
  }
  setAttribute(attributes) {
    const { tr: tr2 } = this.editor.state;
    tr2.setNodeMarkup(this.from, void 0, {
      ...this.node.attrs,
      ...attributes
    });
    this.editor.view.dispatch(tr2);
  }
};
var style = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}`;
function createStyleTag(style2, nonce, suffix) {
  const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${suffix ? `-${suffix}` : ""}]`);
  if (tiptapStyleTag !== null) {
    return tiptapStyleTag;
  }
  const styleNode = document.createElement("style");
  if (nonce) {
    styleNode.setAttribute("nonce", nonce);
  }
  styleNode.setAttribute(`data-tiptap-style${suffix ? `-${suffix}` : ""}`, "");
  styleNode.innerHTML = style2;
  document.getElementsByTagName("head")[0].appendChild(styleNode);
  return styleNode;
}
var Editor2 = class extends EventEmitter2 {
  constructor(options2 = {}) {
    super();
    this.css = null;
    this.className = "tiptap";
    this.editorView = null;
    this.isFocused = false;
    this.isInitialized = false;
    this.extensionStorage = {};
    this.instanceId = Math.random().toString(36).slice(2, 9);
    this.options = {
      element: typeof document !== "undefined" ? document.createElement("div") : null,
      content: "",
      injectCSS: true,
      injectNonce: void 0,
      extensions: [],
      autofocus: false,
      editable: true,
      textDirection: void 0,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: true,
      enablePasteRules: true,
      enableCoreExtensions: true,
      enableContentCheck: false,
      emitContentError: false,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onMount: () => null,
      onUnmount: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error }) => {
        throw error;
      },
      onPaste: () => null,
      onDrop: () => null,
      onDelete: () => null,
      enableExtensionDispatchTransaction: true
    };
    this.isCapturingTransaction = false;
    this.capturedTransaction = null;
    this.utils = {
      getUpdatedPosition,
      createMappablePosition
    };
    this.setOptions(options2);
    this.createExtensionManager();
    this.createCommandManager();
    this.createSchema();
    this.on("beforeCreate", this.options.onBeforeCreate);
    this.emit("beforeCreate", { editor: this });
    this.on("mount", this.options.onMount);
    this.on("unmount", this.options.onUnmount);
    this.on("contentError", this.options.onContentError);
    this.on("create", this.options.onCreate);
    this.on("update", this.options.onUpdate);
    this.on("selectionUpdate", this.options.onSelectionUpdate);
    this.on("transaction", this.options.onTransaction);
    this.on("focus", this.options.onFocus);
    this.on("blur", this.options.onBlur);
    this.on("destroy", this.options.onDestroy);
    this.on("drop", ({ event, slice: slice2, moved }) => this.options.onDrop(event, slice2, moved));
    this.on("paste", ({ event, slice: slice2 }) => this.options.onPaste(event, slice2));
    this.on("delete", this.options.onDelete);
    const initialDoc = this.createDoc();
    const selection = resolveFocusPosition(initialDoc, this.options.autofocus);
    this.editorState = EditorState.create({
      doc: initialDoc,
      schema: this.schema,
      selection: selection || void 0
    });
    if (this.options.element) {
      this.mount(this.options.element);
    }
  }
  /**
   * Attach the editor to the DOM, creating a new editor view.
   */
  mount(el) {
    if (typeof document === "undefined") {
      throw new Error(
        `[tiptap error]: The editor cannot be mounted because there is no 'document' defined in this environment.`
      );
    }
    this.createView(el);
    this.emit("mount", { editor: this });
    if (this.css && !document.head.contains(this.css)) {
      document.head.appendChild(this.css);
    }
    window.setTimeout(() => {
      if (this.isDestroyed) {
        return;
      }
      if (this.options.autofocus !== false && this.options.autofocus !== null) {
        this.commands.focus(this.options.autofocus);
      }
      this.emit("create", { editor: this });
      this.isInitialized = true;
    }, 0);
  }
  /**
   * Remove the editor from the DOM, but still allow remounting at a different point in time
   */
  unmount() {
    if (this.editorView) {
      const dom = this.editorView.dom;
      if (dom == null ? void 0 : dom.editor) {
        delete dom.editor;
      }
      this.editorView.destroy();
    }
    this.editorView = null;
    this.isInitialized = false;
    if (this.css && !document.querySelectorAll(`.${this.className}`).length) {
      try {
        if (typeof this.css.remove === "function") {
          this.css.remove();
        } else if (this.css.parentNode) {
          this.css.parentNode.removeChild(this.css);
        }
      } catch (error) {
        console.warn("Failed to remove CSS element:", error);
      }
    }
    this.css = null;
    this.emit("unmount", { editor: this });
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    if (this.options.injectCSS && typeof document !== "undefined") {
      this.css = createStyleTag(style, this.options.injectNonce);
    }
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(options2 = {}) {
    this.options = {
      ...this.options,
      ...options2
    };
    if (!this.editorView || !this.state || this.isDestroyed) {
      return;
    }
    if (this.options.editorProps) {
      this.view.setProps(this.options.editorProps);
    }
    this.view.updateState(this.state);
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(editable, emitUpdate = true) {
    this.setOptions({ editable });
    if (emitUpdate) {
      this.emit("update", { editor: this, transaction: this.state.tr, appendedTransactions: [] });
    }
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get view() {
    if (this.editorView) {
      return this.editorView;
    }
    return new Proxy(
      {
        state: this.editorState,
        updateState: (state) => {
          this.editorState = state;
        },
        dispatch: (tr2) => {
          this.dispatchTransaction(tr2);
        },
        // Stub some commonly accessed properties to prevent errors
        composing: false,
        dragging: null,
        editable: true,
        isDestroyed: false
      },
      {
        get: (obj, key) => {
          if (this.editorView) {
            return this.editorView[key];
          }
          if (key === "state") {
            return this.editorState;
          }
          if (key in obj) {
            return Reflect.get(obj, key);
          }
          throw new Error(
            `[tiptap error]: The editor view is not available. Cannot access view['${key}']. The editor may not be mounted yet.`
          );
        }
      }
    );
  }
  /**
   * Returns the editor state.
   */
  get state() {
    if (this.editorView) {
      this.editorState = this.view.state;
    }
    return this.editorState;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   * @returns The new editor state
   */
  registerPlugin(plugin, handlePlugins) {
    const plugins = isFunction(handlePlugins) ? handlePlugins(plugin, [...this.state.plugins]) : [...this.state.plugins, plugin];
    const state = this.state.reconfigure({ plugins });
    this.view.updateState(state);
    return state;
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKeyToRemove The plugins name
   * @returns The new editor state or undefined if the editor is destroyed
   */
  unregisterPlugin(nameOrPluginKeyToRemove) {
    if (this.isDestroyed) {
      return void 0;
    }
    const prevPlugins = this.state.plugins;
    let plugins = prevPlugins;
    [].concat(nameOrPluginKeyToRemove).forEach((nameOrPluginKey) => {
      const name = typeof nameOrPluginKey === "string" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;
      plugins = plugins.filter((plugin) => !plugin.key.startsWith(name));
    });
    if (prevPlugins.length === plugins.length) {
      return void 0;
    }
    const state = this.state.reconfigure({
      plugins
    });
    this.view.updateState(state);
    return state;
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    var _a6, _b3;
    const coreExtensions = this.options.enableCoreExtensions ? [
      Editable,
      ClipboardTextSerializer.configure({
        blockSeparator: (_b3 = (_a6 = this.options.coreExtensionOptions) == null ? void 0 : _a6.clipboardTextSerializer) == null ? void 0 : _b3.blockSeparator
      }),
      Commands,
      FocusEvents,
      Keymap,
      Tabindex,
      Drop,
      Paste,
      Delete,
      TextDirection.configure({
        direction: this.options.textDirection
      })
    ].filter((ext) => {
      if (typeof this.options.enableCoreExtensions === "object") {
        return this.options.enableCoreExtensions[ext.name] !== false;
      }
      return true;
    }) : [];
    const allExtensions = [...coreExtensions, ...this.options.extensions].filter((extension) => {
      return ["extension", "node", "mark"].includes(extension == null ? void 0 : extension.type);
    });
    this.extensionManager = new ExtensionManager(allExtensions, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new CommandManager({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates the initial document.
   */
  createDoc() {
    let doc3;
    try {
      doc3 = createDocument(this.options.content, this.schema, this.options.parseOptions, {
        errorOnInvalidContent: this.options.enableContentCheck
      });
    } catch (e) {
      if (!(e instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(e.message)) {
        throw e;
      }
      this.emit("contentError", {
        editor: this,
        error: e,
        disableCollaboration: () => {
          if ("collaboration" in this.storage && typeof this.storage.collaboration === "object" && this.storage.collaboration) {
            ;
            this.storage.collaboration.isDisabled = true;
          }
          this.options.extensions = this.options.extensions.filter((extension) => extension.name !== "collaboration");
          this.createExtensionManager();
        }
      });
      doc3 = createDocument(this.options.content, this.schema, this.options.parseOptions, {
        errorOnInvalidContent: false
      });
    }
    return doc3;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView(element) {
    const { editorProps, enableExtensionDispatchTransaction } = this.options;
    const baseDispatch = editorProps.dispatchTransaction || this.dispatchTransaction.bind(this);
    const dispatch2 = enableExtensionDispatchTransaction ? this.extensionManager.dispatchTransaction(baseDispatch) : baseDispatch;
    this.editorView = new EditorView(element, {
      ...editorProps,
      attributes: {
        // add `role="textbox"` to the editor element
        role: "textbox",
        ...editorProps == null ? void 0 : editorProps.attributes
      },
      dispatchTransaction: dispatch2,
      state: this.editorState,
      markViews: this.extensionManager.markViews,
      nodeViews: this.extensionManager.nodeViews
    });
    const newState = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(newState);
    this.prependClass();
    this.injectCSS();
    const dom = this.view.dom;
    dom.editor = this;
  }
  /**
   * Creates all node and mark views.
   */
  createNodeViews() {
    if (this.view.isDestroyed) {
      return;
    }
    this.view.setProps({
      markViews: this.extensionManager.markViews,
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `${this.className} ${this.view.dom.className}`;
  }
  captureTransaction(fn) {
    this.isCapturingTransaction = true;
    fn();
    this.isCapturingTransaction = false;
    const tr2 = this.capturedTransaction;
    this.capturedTransaction = null;
    return tr2;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(transaction2) {
    if (this.view.isDestroyed) {
      return;
    }
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = transaction2;
        return;
      }
      transaction2.steps.forEach((step) => {
        var _a6;
        return (_a6 = this.capturedTransaction) == null ? void 0 : _a6.step(step);
      });
      return;
    }
    const { state, transactions } = this.state.applyTransaction(transaction2);
    const selectionHasChanged = !this.state.selection.eq(state.selection);
    const rootTrWasApplied = transactions.includes(transaction2);
    const prevState = this.state;
    this.emit("beforeTransaction", {
      editor: this,
      transaction: transaction2,
      nextState: state
    });
    if (!rootTrWasApplied) {
      return;
    }
    this.view.updateState(state);
    this.emit("transaction", {
      editor: this,
      transaction: transaction2,
      appendedTransactions: transactions.slice(1)
    });
    if (selectionHasChanged) {
      this.emit("selectionUpdate", {
        editor: this,
        transaction: transaction2
      });
    }
    const mostRecentFocusTr = transactions.findLast((tr2) => tr2.getMeta("focus") || tr2.getMeta("blur"));
    const focus22 = mostRecentFocusTr == null ? void 0 : mostRecentFocusTr.getMeta("focus");
    const blur2 = mostRecentFocusTr == null ? void 0 : mostRecentFocusTr.getMeta("blur");
    if (focus22) {
      this.emit("focus", {
        editor: this,
        event: focus22.event,
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        transaction: mostRecentFocusTr
      });
    }
    if (blur2) {
      this.emit("blur", {
        editor: this,
        event: blur2.event,
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        transaction: mostRecentFocusTr
      });
    }
    if (transaction2.getMeta("preventUpdate") || !transactions.some((tr2) => tr2.docChanged) || prevState.doc.eq(state.doc)) {
      return;
    }
    this.emit("update", {
      editor: this,
      transaction: transaction2,
      appendedTransactions: transactions.slice(1)
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(nameOrType) {
    return getAttributes(this.state, nameOrType);
  }
  isActive(nameOrAttributes, attributesOrUndefined) {
    const name = typeof nameOrAttributes === "string" ? nameOrAttributes : null;
    const attributes = typeof nameOrAttributes === "string" ? attributesOrUndefined : nameOrAttributes;
    return isActive(this.state, name, attributes);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return getHTMLFromFragment(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(options2) {
    const { blockSeparator = "\n\n", textSerializers = {} } = options2 || {};
    return getText2(this.state.doc, {
      blockSeparator,
      textSerializers: {
        ...getTextSerializersFromSchema(this.schema),
        ...textSerializers
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return isNodeEmpty(this.state.doc);
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    this.emit("destroy");
    this.unmount();
    this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var _a6, _b3;
    return (_b3 = (_a6 = this.editorView) == null ? void 0 : _a6.isDestroyed) != null ? _b3 : true;
  }
  $node(selector, attributes) {
    var _a6;
    return ((_a6 = this.$doc) == null ? void 0 : _a6.querySelector(selector, attributes)) || null;
  }
  $nodes(selector, attributes) {
    var _a6;
    return ((_a6 = this.$doc) == null ? void 0 : _a6.querySelectorAll(selector, attributes)) || null;
  }
  $pos(pos) {
    const $pos = this.state.doc.resolve(pos);
    return new NodePos($pos, this);
  }
  get $doc() {
    return this.$pos(0);
  }
};
function markInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr: tr2 } = state;
      const captureGroup = match[match.length - 1];
      const fullMatch = match[0];
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range.to) {
          tr2.delete(textEnd, range.to);
        }
        if (textStart > range.from) {
          tr2.delete(range.from + startSpaces, textStart);
        }
        const markEnd = range.from + startSpaces + captureGroup.length;
        tr2.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr2.removeStoredMark(config.type);
      }
    },
    undoable: config.undoable
  });
}
function nodeInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      const { tr: tr2 } = state;
      const start = range.from;
      let end = range.to;
      const newNode = config.type.create(attributes);
      if (match[1]) {
        const offset4 = match[0].lastIndexOf(match[1]);
        let matchStart = start + offset4;
        if (matchStart > end) {
          matchStart = end;
        } else {
          end = matchStart + match[1].length;
        }
        const lastChar = match[0][match[0].length - 1];
        tr2.insertText(lastChar, start + match[0].length - 1);
        tr2.replaceWith(matchStart, end, newNode);
      } else if (match[0]) {
        const insertionStart = config.type.isInline ? start : start - 1;
        tr2.insert(insertionStart, config.type.create(attributes)).delete(tr2.mapping.map(start), tr2.mapping.map(end));
      }
      tr2.scrollIntoView();
    },
    undoable: config.undoable
  });
}
function textblockTypeInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const $start = state.doc.resolve(range.from);
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {
        return null;
      }
      state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);
    },
    undoable: config.undoable
  });
}
function wrappingInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match, chain: chain2 }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      const tr2 = state.tr.delete(range.from, range.to);
      const $start = tr2.doc.resolve(range.from);
      const blockRange = $start.blockRange();
      const wrapping = blockRange && findWrapping(blockRange, config.type, attributes);
      if (!wrapping) {
        return null;
      }
      tr2.wrap(blockRange, wrapping);
      if (config.keepMarks && config.editor) {
        const { selection, storedMarks } = state;
        const { splittableMarks } = config.editor.extensionManager;
        const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
        if (marks) {
          const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
          tr2.ensureMarks(filteredMarks);
        }
      }
      if (config.keepAttributes) {
        const nodeType = config.type.name === "bulletList" || config.type.name === "orderedList" ? "listItem" : "taskList";
        chain2().updateAttributes(nodeType, attributes).run();
      }
      const before = tr2.doc.resolve(range.from - 1).nodeBefore;
      if (before && before.type === config.type && canJoin(tr2.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before))) {
        tr2.join(range.from - 1);
      }
    },
    undoable: config.undoable
  });
}
function canInsertNode(state, nodeType) {
  const { selection } = state;
  const { $from } = selection;
  if (selection instanceof NodeSelection) {
    const index2 = $from.index();
    const parent = $from.parent;
    return parent.canReplaceWith(index2, index2 + 1, nodeType);
  }
  let depth = $from.depth;
  while (depth >= 0) {
    const index2 = $from.index(depth);
    const parent = $from.node(depth);
    const match = parent.contentMatchAt(index2);
    if (match.matchType(nodeType)) {
      return true;
    }
    depth -= 1;
  }
  return false;
}
var markdown_exports = {};
__export2(markdown_exports, {
  createAtomBlockMarkdownSpec: () => createAtomBlockMarkdownSpec,
  createBlockMarkdownSpec: () => createBlockMarkdownSpec,
  createInlineMarkdownSpec: () => createInlineMarkdownSpec,
  parseAttributes: () => parseAttributes,
  parseIndentedBlocks: () => parseIndentedBlocks,
  renderNestedMarkdownContent: () => renderNestedMarkdownContent,
  serializeAttributes: () => serializeAttributes
});
function parseAttributes(attrString) {
  if (!(attrString == null ? void 0 : attrString.trim())) {
    return {};
  }
  const attributes = {};
  const quotedStrings = [];
  const tempString = attrString.replace(/["']([^"']*)["']/g, (match) => {
    quotedStrings.push(match);
    return `__QUOTED_${quotedStrings.length - 1}__`;
  });
  const classMatches = tempString.match(/(?:^|\s)\.([a-zA-Z][\w-]*)/g);
  if (classMatches) {
    const classes = classMatches.map((match) => match.trim().slice(1));
    attributes.class = classes.join(" ");
  }
  const idMatch = tempString.match(/(?:^|\s)#([a-zA-Z][\w-]*)/);
  if (idMatch) {
    attributes.id = idMatch[1];
  }
  const kvRegex = /([a-zA-Z][\w-]*)\s*=\s*(__QUOTED_\d+__)/g;
  const kvMatches = Array.from(tempString.matchAll(kvRegex));
  kvMatches.forEach(([, key, quotedRef]) => {
    var _a6;
    const quotedIndex = parseInt(((_a6 = quotedRef.match(/__QUOTED_(\d+)__/)) == null ? void 0 : _a6[1]) || "0", 10);
    const quotedValue = quotedStrings[quotedIndex];
    if (quotedValue) {
      attributes[key] = quotedValue.slice(1, -1);
    }
  });
  const cleanString = tempString.replace(/(?:^|\s)\.([a-zA-Z][\w-]*)/g, "").replace(/(?:^|\s)#([a-zA-Z][\w-]*)/g, "").replace(/([a-zA-Z][\w-]*)\s*=\s*__QUOTED_\d+__/g, "").trim();
  if (cleanString) {
    const booleanAttrs = cleanString.split(/\s+/).filter(Boolean);
    booleanAttrs.forEach((attr) => {
      if (attr.match(/^[a-zA-Z][\w-]*$/)) {
        attributes[attr] = true;
      }
    });
  }
  return attributes;
}
function serializeAttributes(attributes) {
  if (!attributes || Object.keys(attributes).length === 0) {
    return "";
  }
  const parts = [];
  if (attributes.class) {
    const classes = String(attributes.class).split(/\s+/).filter(Boolean);
    classes.forEach((cls) => parts.push(`.${cls}`));
  }
  if (attributes.id) {
    parts.push(`#${attributes.id}`);
  }
  Object.entries(attributes).forEach(([key, value]) => {
    if (key === "class" || key === "id") {
      return;
    }
    if (value === true) {
      parts.push(key);
    } else if (value !== false && value != null) {
      parts.push(`${key}="${String(value)}"`);
    }
  });
  return parts.join(" ");
}
function createAtomBlockMarkdownSpec(options2) {
  const {
    nodeName,
    name: markdownName,
    parseAttributes: parseAttributes2 = parseAttributes,
    serializeAttributes: serializeAttributes2 = serializeAttributes,
    defaultAttributes = {},
    requiredAttributes = [],
    allowedAttributes
  } = options2;
  const blockName = markdownName || nodeName;
  const filterAttributes = (attrs) => {
    if (!allowedAttributes) {
      return attrs;
    }
    const filtered = {};
    allowedAttributes.forEach((key) => {
      if (key in attrs) {
        filtered[key] = attrs[key];
      }
    });
    return filtered;
  };
  return {
    parseMarkdown: (token, h2) => {
      const attrs = { ...defaultAttributes, ...token.attributes };
      return h2.createNode(nodeName, attrs, []);
    },
    markdownTokenizer: {
      name: nodeName,
      level: "block",
      start(src) {
        var _a6;
        const regex = new RegExp(`^:::${blockName}(?:\\s|$)`, "m");
        const index2 = (_a6 = src.match(regex)) == null ? void 0 : _a6.index;
        return index2 !== void 0 ? index2 : -1;
      },
      tokenize(src, _tokens, _lexer) {
        const regex = new RegExp(`^:::${blockName}(?:\\s+\\{([^}]*)\\})?\\s*:::(?:\\n|$)`);
        const match = src.match(regex);
        if (!match) {
          return void 0;
        }
        const attrString = match[1] || "";
        const attributes = parseAttributes2(attrString);
        const missingRequired = requiredAttributes.find((required) => !(required in attributes));
        if (missingRequired) {
          return void 0;
        }
        return {
          type: nodeName,
          raw: match[0],
          attributes
        };
      }
    },
    renderMarkdown: (node) => {
      const filteredAttrs = filterAttributes(node.attrs || {});
      const attrs = serializeAttributes2(filteredAttrs);
      const attrString = attrs ? ` {${attrs}}` : "";
      return `:::${blockName}${attrString} :::`;
    }
  };
}
function createBlockMarkdownSpec(options2) {
  const {
    nodeName,
    name: markdownName,
    getContent,
    parseAttributes: parseAttributes2 = parseAttributes,
    serializeAttributes: serializeAttributes2 = serializeAttributes,
    defaultAttributes = {},
    content = "block",
    allowedAttributes
  } = options2;
  const blockName = markdownName || nodeName;
  const filterAttributes = (attrs) => {
    if (!allowedAttributes) {
      return attrs;
    }
    const filtered = {};
    allowedAttributes.forEach((key) => {
      if (key in attrs) {
        filtered[key] = attrs[key];
      }
    });
    return filtered;
  };
  return {
    parseMarkdown: (token, h2) => {
      let nodeContent;
      if (getContent) {
        const contentResult = getContent(token);
        nodeContent = typeof contentResult === "string" ? [{ type: "text", text: contentResult }] : contentResult;
      } else if (content === "block") {
        nodeContent = h2.parseChildren(token.tokens || []);
      } else {
        nodeContent = h2.parseInline(token.tokens || []);
      }
      const attrs = { ...defaultAttributes, ...token.attributes };
      return h2.createNode(nodeName, attrs, nodeContent);
    },
    markdownTokenizer: {
      name: nodeName,
      level: "block",
      start(src) {
        var _a6;
        const regex = new RegExp(`^:::${blockName}`, "m");
        const index2 = (_a6 = src.match(regex)) == null ? void 0 : _a6.index;
        return index2 !== void 0 ? index2 : -1;
      },
      tokenize(src, _tokens, lexer) {
        var _a6;
        const openingRegex = new RegExp(`^:::${blockName}(?:\\s+\\{([^}]*)\\})?\\s*\\n`);
        const openingMatch = src.match(openingRegex);
        if (!openingMatch) {
          return void 0;
        }
        const [openingTag, attrString = ""] = openingMatch;
        const attributes = parseAttributes2(attrString);
        let level = 1;
        const position = openingTag.length;
        let matchedContent = "";
        const blockPattern = /^:::([\w-]*)(\s.*)?/gm;
        const remaining = src.slice(position);
        blockPattern.lastIndex = 0;
        for (; ; ) {
          const match = blockPattern.exec(remaining);
          if (match === null) {
            break;
          }
          const matchPos = match.index;
          const blockType = match[1];
          if ((_a6 = match[2]) == null ? void 0 : _a6.endsWith(":::")) {
            continue;
          }
          if (blockType) {
            level += 1;
          } else {
            level -= 1;
            if (level === 0) {
              const rawContent = remaining.slice(0, matchPos);
              matchedContent = rawContent.trim();
              const fullMatch = src.slice(0, position + matchPos + match[0].length);
              let contentTokens = [];
              if (matchedContent) {
                if (content === "block") {
                  contentTokens = lexer.blockTokens(rawContent);
                  contentTokens.forEach((token) => {
                    if (token.text && (!token.tokens || token.tokens.length === 0)) {
                      token.tokens = lexer.inlineTokens(token.text);
                    }
                  });
                  while (contentTokens.length > 0) {
                    const lastToken = contentTokens[contentTokens.length - 1];
                    if (lastToken.type === "paragraph" && (!lastToken.text || lastToken.text.trim() === "")) {
                      contentTokens.pop();
                    } else {
                      break;
                    }
                  }
                } else {
                  contentTokens = lexer.inlineTokens(matchedContent);
                }
              }
              return {
                type: nodeName,
                raw: fullMatch,
                attributes,
                content: matchedContent,
                tokens: contentTokens
              };
            }
          }
        }
        return void 0;
      }
    },
    renderMarkdown: (node, h2) => {
      const filteredAttrs = filterAttributes(node.attrs || {});
      const attrs = serializeAttributes2(filteredAttrs);
      const attrString = attrs ? ` {${attrs}}` : "";
      const renderedContent = h2.renderChildren(node.content || [], "\n\n");
      return `:::${blockName}${attrString}

${renderedContent}

:::`;
    }
  };
}
function parseShortcodeAttributes(attrString) {
  if (!attrString.trim()) {
    return {};
  }
  const attributes = {};
  const regex = /(\w+)=(?:"([^"]*)"|'([^']*)')/g;
  let match = regex.exec(attrString);
  while (match !== null) {
    const [, key, doubleQuoted, singleQuoted] = match;
    attributes[key] = doubleQuoted || singleQuoted;
    match = regex.exec(attrString);
  }
  return attributes;
}
function serializeShortcodeAttributes(attrs) {
  return Object.entries(attrs).filter(([, value]) => value !== void 0 && value !== null).map(([key, value]) => `${key}="${value}"`).join(" ");
}
function createInlineMarkdownSpec(options2) {
  const {
    nodeName,
    name: shortcodeName,
    getContent,
    parseAttributes: parseAttributes2 = parseShortcodeAttributes,
    serializeAttributes: serializeAttributes2 = serializeShortcodeAttributes,
    defaultAttributes = {},
    selfClosing = false,
    allowedAttributes
  } = options2;
  const shortcode = shortcodeName || nodeName;
  const filterAttributes = (attrs) => {
    if (!allowedAttributes) {
      return attrs;
    }
    const filtered = {};
    allowedAttributes.forEach((attr) => {
      const attrName = typeof attr === "string" ? attr : attr.name;
      const skipIfDefault = typeof attr === "string" ? void 0 : attr.skipIfDefault;
      if (attrName in attrs) {
        const value = attrs[attrName];
        if (skipIfDefault !== void 0 && value === skipIfDefault) {
          return;
        }
        filtered[attrName] = value;
      }
    });
    return filtered;
  };
  const escapedShortcode = shortcode.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  return {
    parseMarkdown: (token, h2) => {
      const attrs = { ...defaultAttributes, ...token.attributes };
      if (selfClosing) {
        return h2.createNode(nodeName, attrs);
      }
      const content = getContent ? getContent(token) : token.content || "";
      if (content) {
        return h2.createNode(nodeName, attrs, [h2.createTextNode(content)]);
      }
      return h2.createNode(nodeName, attrs, []);
    },
    markdownTokenizer: {
      name: nodeName,
      level: "inline",
      start(src) {
        const startPattern = selfClosing ? new RegExp(`\\[${escapedShortcode}\\s*[^\\]]*\\]`) : new RegExp(`\\[${escapedShortcode}\\s*[^\\]]*\\][\\s\\S]*?\\[\\/${escapedShortcode}\\]`);
        const match = src.match(startPattern);
        const index2 = match == null ? void 0 : match.index;
        return index2 !== void 0 ? index2 : -1;
      },
      tokenize(src, _tokens, _lexer) {
        const tokenPattern = selfClosing ? new RegExp(`^\\[${escapedShortcode}\\s*([^\\]]*)\\]`) : new RegExp(`^\\[${escapedShortcode}\\s*([^\\]]*)\\]([\\s\\S]*?)\\[\\/${escapedShortcode}\\]`);
        const match = src.match(tokenPattern);
        if (!match) {
          return void 0;
        }
        let content = "";
        let attrString = "";
        if (selfClosing) {
          const [, attrs] = match;
          attrString = attrs;
        } else {
          const [, attrs, contentMatch] = match;
          attrString = attrs;
          content = contentMatch || "";
        }
        const attributes = parseAttributes2(attrString.trim());
        return {
          type: nodeName,
          raw: match[0],
          content: content.trim(),
          attributes
        };
      }
    },
    renderMarkdown: (node) => {
      let content = "";
      if (getContent) {
        content = getContent(node);
      } else if (node.content && node.content.length > 0) {
        content = node.content.filter((child) => child.type === "text").map((child) => child.text).join("");
      }
      const filteredAttrs = filterAttributes(node.attrs || {});
      const attrs = serializeAttributes2(filteredAttrs);
      const attrString = attrs ? ` ${attrs}` : "";
      if (selfClosing) {
        return `[${shortcode}${attrString}]`;
      }
      return `[${shortcode}${attrString}]${content}[/${shortcode}]`;
    }
  };
}
function parseIndentedBlocks(src, config, lexer) {
  var _a6, _b3, _c, _d;
  const lines = src.split("\n");
  const items = [];
  let totalRaw = "";
  let i = 0;
  const baseIndentSize = config.baseIndentSize || 2;
  while (i < lines.length) {
    const currentLine = lines[i];
    const itemMatch = currentLine.match(config.itemPattern);
    if (!itemMatch) {
      if (items.length > 0) {
        break;
      } else if (currentLine.trim() === "") {
        i += 1;
        totalRaw = `${totalRaw}${currentLine}
`;
        continue;
      } else {
        return void 0;
      }
    }
    const itemData = config.extractItemData(itemMatch);
    const { indentLevel, mainContent } = itemData;
    totalRaw = `${totalRaw}${currentLine}
`;
    const itemContent = [mainContent];
    i += 1;
    while (i < lines.length) {
      const nextLine = lines[i];
      if (nextLine.trim() === "") {
        const nextNonEmptyIndex = lines.slice(i + 1).findIndex((l) => l.trim() !== "");
        if (nextNonEmptyIndex === -1) {
          break;
        }
        const nextNonEmpty = lines[i + 1 + nextNonEmptyIndex];
        const nextIndent2 = ((_b3 = (_a6 = nextNonEmpty.match(/^(\s*)/)) == null ? void 0 : _a6[1]) == null ? void 0 : _b3.length) || 0;
        if (nextIndent2 > indentLevel) {
          itemContent.push(nextLine);
          totalRaw = `${totalRaw}${nextLine}
`;
          i += 1;
          continue;
        } else {
          break;
        }
      }
      const nextIndent = ((_d = (_c = nextLine.match(/^(\s*)/)) == null ? void 0 : _c[1]) == null ? void 0 : _d.length) || 0;
      if (nextIndent > indentLevel) {
        itemContent.push(nextLine);
        totalRaw = `${totalRaw}${nextLine}
`;
        i += 1;
      } else {
        break;
      }
    }
    let nestedTokens;
    const nestedContent = itemContent.slice(1);
    if (nestedContent.length > 0) {
      const dedentedNested = nestedContent.map((nestedLine) => nestedLine.slice(indentLevel + baseIndentSize)).join("\n");
      if (dedentedNested.trim()) {
        if (config.customNestedParser) {
          nestedTokens = config.customNestedParser(dedentedNested);
        } else {
          nestedTokens = lexer.blockTokens(dedentedNested);
        }
      }
    }
    const token = config.createToken(itemData, nestedTokens);
    items.push(token);
  }
  if (items.length === 0) {
    return void 0;
  }
  return {
    items,
    raw: totalRaw
  };
}
function renderNestedMarkdownContent(node, h2, prefixOrGenerator, ctx) {
  if (!node || !Array.isArray(node.content)) {
    return "";
  }
  const prefix = typeof prefixOrGenerator === "function" ? prefixOrGenerator(ctx) : prefixOrGenerator;
  const [content, ...children] = node.content;
  const mainContent = h2.renderChildren([content]);
  const output = [`${prefix}${mainContent}`];
  if (children && children.length > 0) {
    children.forEach((child) => {
      const childContent = h2.renderChildren([child]);
      if (childContent) {
        const indentedChild = childContent.split("\n").map((line) => line ? h2.indent(line) : "").join("\n");
        output.push(indentedChild);
      }
    });
  }
  return output.join("\n");
}
function updateMarkViewAttributes(checkMark, editor, attrs = {}) {
  const { state } = editor;
  const { doc: doc3, tr: tr2 } = state;
  const thisMark = checkMark;
  doc3.descendants((node, pos) => {
    const from2 = tr2.mapping.map(pos);
    const to = tr2.mapping.map(pos) + node.nodeSize;
    let foundMark = null;
    node.marks.forEach((mark) => {
      if (mark !== thisMark) {
        return false;
      }
      foundMark = mark;
    });
    if (!foundMark) {
      return;
    }
    let needsUpdate = false;
    Object.keys(attrs).forEach((k) => {
      if (attrs[k] !== foundMark.attrs[k]) {
        needsUpdate = true;
      }
    });
    if (needsUpdate) {
      const updatedMark = checkMark.type.create({
        ...checkMark.attrs,
        ...attrs
      });
      tr2.removeMark(from2, to, checkMark.type);
      tr2.addMark(from2, to, updatedMark);
    }
  });
  if (tr2.docChanged) {
    editor.view.dispatch(tr2);
  }
}
var Node3 = class _Node extends Extendable {
  constructor() {
    super(...arguments);
    this.type = "node";
  }
  /**
   * Create a new Node instance
   * @param config - Node configuration object or a function that returns a configuration object
   */
  static create(config = {}) {
    const resolvedConfig = typeof config === "function" ? config() : config;
    return new _Node(resolvedConfig);
  }
  configure(options2) {
    return super.configure(options2);
  }
  extend(extendedConfig) {
    const resolvedConfig = typeof extendedConfig === "function" ? extendedConfig() : extendedConfig;
    return super.extend(resolvedConfig);
  }
};
function markPasteRule(config) {
  return new PasteRule({
    find: config.find,
    handler: ({ state, range, match, pasteEvent }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match, pasteEvent);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr: tr2 } = state;
      const captureGroup = match[match.length - 1];
      const fullMatch = match[0];
      let markEnd = range.to;
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range.to) {
          tr2.delete(textEnd, range.to);
        }
        if (textStart > range.from) {
          tr2.delete(range.from + startSpaces, textStart);
        }
        markEnd = range.from + startSpaces + captureGroup.length;
        tr2.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr2.removeStoredMark(config.type);
      }
    }
  });
}

// ../node_modules/@tldraw/editor/dist-esm/lib/utils/richText.mjs
var schemaCache = new WeakCache();
function getTipTapSchema(tipTapConfig) {
  return schemaCache.get(tipTapConfig, () => getSchema(tipTapConfig.extensions ?? []));
}
function getFontsFromRichText(editor, richText, initialState2) {
  const { tipTapConfig, addFontsFromNode } = editor.getTextOptions();
  assert(tipTapConfig, "textOptions.tipTapConfig must be set to use rich text");
  assert(addFontsFromNode, "textOptions.addFontsFromNode must be set to use rich text");
  const schema = getTipTapSchema(tipTapConfig);
  const rootNode = Node2.fromJSON(schema, richText);
  const fonts = /* @__PURE__ */ new Set();
  function addFont(font) {
    fonts.add(font);
  }
  function visit(node, state) {
    state = addFontsFromNode(node, state, addFont);
    for (const child of node.children) {
      visit(child, state);
    }
  }
  visit(rootNode, initialState2);
  return Array.from(fonts);
}

// ../node_modules/@tldraw/editor/dist-esm/lib/utils/sync/hardReset.mjs
async function hardReset({ shouldReload = true } = {}) {
  clearSessionStorage();
  for (const instance of LocalIndexedDb.connectedInstances) {
    await instance.close();
  }
  await Promise.all(getAllIndexDbNames().map((db) => deleteDB(db)));
  clearLocalStorage();
  if (shouldReload) {
    window.location.reload();
  }
}
if (typeof window !== "undefined") {
  if (true) {
    ;
    window.hardReset = hardReset;
  }
  ;
  window.__tldraw__hardReset = hardReset;
}

// ../node_modules/@tldraw/editor/dist-esm/lib/utils/window-open.mjs
function openWindow(url, target = "_blank", allowReferrer) {
  return runtime.openWindow(url, target, allowReferrer);
}

// ../node_modules/@tldraw/editor/dist-esm/index.mjs
registerTldrawLibraryVersion(
  "@tldraw/editor",
  "4.3.1",
  "esm"
);

// ../node_modules/tldraw/dist-esm/lib/shapes/draw/getPath.mjs
var PEN_EASING = (t2) => t2 * 0.65 + SIN(t2 * PI / 2) * 0.35;
var simulatePressureSettings = (strokeWidth) => {
  return {
    size: strokeWidth,
    thinning: 0.5,
    streamline: modulate(strokeWidth, [9, 16], [0.64, 0.74], true),
    // 0.62 + ((1 + strokeWidth) / 8) * 0.06,
    smoothing: 0.62,
    easing: EASINGS.easeOutSine,
    simulatePressure: true
  };
};
var realPressureSettings = (strokeWidth) => {
  return {
    size: 1 + strokeWidth * 1.2,
    thinning: 0.62,
    streamline: 0.62,
    smoothing: 0.62,
    simulatePressure: false,
    easing: PEN_EASING
  };
};
var solidSettings = (strokeWidth) => {
  return {
    size: strokeWidth,
    thinning: 0,
    streamline: modulate(strokeWidth, [9, 16], [0.64, 0.74], true),
    // 0.62 + ((1 + strokeWidth) / 8) * 0.06,
    smoothing: 0.62,
    simulatePressure: false,
    easing: EASINGS.linear
  };
};
var solidRealPressureSettings = (strokeWidth) => {
  return {
    size: strokeWidth,
    thinning: 0,
    streamline: 0.62,
    smoothing: 0.62,
    simulatePressure: false,
    easing: EASINGS.linear
  };
};
function getHighlightFreehandSettings({
  strokeWidth,
  showAsComplete
}) {
  return {
    size: 1 + strokeWidth,
    thinning: 0,
    streamline: 0.5,
    smoothing: 0.5,
    simulatePressure: false,
    easing: EASINGS.easeOutSine,
    last: showAsComplete
  };
}
function getFreehandOptions(shapeProps, strokeWidth, forceComplete, forceSolid) {
  const last2 = shapeProps.isComplete || forceComplete;
  if (forceSolid) {
    if (shapeProps.isPen) {
      return { ...solidRealPressureSettings(strokeWidth), last: last2 };
    } else {
      return { ...solidSettings(strokeWidth), last: last2 };
    }
  }
  if (shapeProps.dash === "draw") {
    if (shapeProps.isPen) {
      return { ...realPressureSettings(strokeWidth), last: last2 };
    } else {
      return { ...simulatePressureSettings(strokeWidth), last: last2 };
    }
  }
  return { ...solidSettings(strokeWidth), last: last2 };
}
function getPointsFromDrawSegment(segment, scaleX, scaleY, points = []) {
  const _points = b64Vecs.decodePoints(segment.path);
  if (scaleX !== 1 || scaleY !== 1) {
    for (const point of _points) {
      point.x *= scaleX;
      point.y *= scaleY;
    }
  }
  if (segment.type === "free" || _points.length < 2) {
    points.push(..._points.map(Vec.From));
  } else {
    const pointsToInterpolate = Math.max(4, Math.floor(Vec.Dist(_points[0], _points[1]) / 16));
    points.push(...Vec.PointsBetween(_points[0], _points[1], pointsToInterpolate));
  }
  return points;
}
function getPointsFromDrawSegments(segments, scaleX = 1, scaleY = 1) {
  const points = [];
  for (const segment of segments) {
    getPointsFromDrawSegment(segment, scaleX, scaleY, points);
  }
  return points;
}
function getDrawShapeStrokeDashArray(shape, strokeWidth, dotAdjustment) {
  return {
    draw: "none",
    solid: `none`,
    dotted: `${dotAdjustment} ${strokeWidth * 2}`,
    dashed: `${strokeWidth * 2} ${strokeWidth * 2}`
  }[shape.props.dash];
}

// ../node_modules/tldraw/dist-esm/lib/shapes/shared/PathBuilder.mjs
var import_jsx_runtime39 = __toESM(require_jsx_runtime(), 1);
var PathBuilder = class _PathBuilder {
  constructor() {
    /** @internal */
    __publicField(this, "commands", []);
    __publicField(this, "lastMoveTo", null);
  }
  static lineThroughPoints(points, opts) {
    const path = new _PathBuilder();
    path.moveTo(points[0].x, points[0].y, { ...opts, offset: (opts == null ? void 0 : opts.endOffsets) ?? (opts == null ? void 0 : opts.offset) });
    for (let i = 1; i < points.length; i++) {
      const isLast = i === points.length - 1;
      path.lineTo(points[i].x, points[i].y, isLast ? { offset: opts == null ? void 0 : opts.endOffsets } : void 0);
    }
    return path;
  }
  static cubicSplineThroughPoints(points, opts) {
    const path = new _PathBuilder();
    const len = points.length;
    const last2 = len - 2;
    const k = 1.25;
    path.moveTo(points[0].x, points[0].y, { ...opts, offset: (opts == null ? void 0 : opts.endOffsets) ?? (opts == null ? void 0 : opts.offset) });
    for (let i = 0; i < len - 1; i++) {
      const p0 = i === 0 ? points[0] : points[i - 1];
      const p1 = points[i];
      const p2 = points[i + 1];
      const p3 = i === last2 ? p2 : points[i + 2];
      let cp1x, cp1y, cp2x, cp2y;
      if (i === 0) {
        cp1x = p0.x;
        cp1y = p0.y;
      } else {
        cp1x = p1.x + (p2.x - p0.x) / 6 * k;
        cp1y = p1.y + (p2.y - p0.y) / 6 * k;
      }
      let pointOpts = void 0;
      if (i === last2) {
        cp2x = p2.x;
        cp2y = p2.y;
        pointOpts = { offset: opts == null ? void 0 : opts.endOffsets };
      } else {
        cp2x = p2.x - (p3.x - p1.x) / 6 * k;
        cp2y = p2.y - (p3.y - p1.y) / 6 * k;
      }
      path.cubicBezierTo(p2.x, p2.y, cp1x, cp1y, cp2x, cp2y, pointOpts);
    }
    return path;
  }
  assertHasMoveTo() {
    assert(this.lastMoveTo, "Start an SVGPathBuilder with `.moveTo()`");
    return this.lastMoveTo;
  }
  moveTo(x, y, opts) {
    this.lastMoveTo = { type: "move", x, y, closeIdx: null, isClose: false, opts };
    this.commands.push(this.lastMoveTo);
    return this;
  }
  lineTo(x, y, opts) {
    this.assertHasMoveTo();
    this.commands.push({ type: "line", x, y, isClose: false, opts });
    return this;
  }
  circularArcTo(radius, largeArcFlag, sweepFlag, x2, y2, opts) {
    return this.arcTo(radius, radius, largeArcFlag, sweepFlag, 0, x2, y2, opts);
  }
  arcTo(rx, ry, largeArcFlag, sweepFlag, xAxisRotationRadians, x2, y2, opts) {
    this.assertHasMoveTo();
    const x1 = this.commands[this.commands.length - 1].x;
    const y1 = this.commands[this.commands.length - 1].y;
    if (x1 === x2 && y1 === y2) {
      return this;
    }
    if (rx === 0 || ry === 0) {
      return this.lineTo(x2, y2, opts);
    }
    const phi = xAxisRotationRadians;
    const sinPhi = Math.sin(phi);
    const cosPhi = Math.cos(phi);
    let rx1 = Math.abs(rx);
    let ry1 = Math.abs(ry);
    const dx = (x1 - x2) / 2;
    const dy = (y1 - y2) / 2;
    const x1p = cosPhi * dx + sinPhi * dy;
    const y1p = -sinPhi * dx + cosPhi * dy;
    const lambda = x1p * x1p / (rx1 * rx1) + y1p * y1p / (ry1 * ry1);
    if (lambda > 1) {
      const sqrtLambda = Math.sqrt(lambda);
      rx1 *= sqrtLambda;
      ry1 *= sqrtLambda;
    }
    const sign = largeArcFlag !== sweepFlag ? 1 : -1;
    const term = rx1 * rx1 * ry1 * ry1 - rx1 * rx1 * y1p * y1p - ry1 * ry1 * x1p * x1p;
    const numerator = rx1 * rx1 * y1p * y1p + ry1 * ry1 * x1p * x1p;
    let radicand = term / numerator;
    radicand = radicand < 0 ? 0 : radicand;
    const coef = sign * Math.sqrt(radicand);
    const cxp = coef * (rx1 * y1p / ry1);
    const cyp = coef * (-(ry1 * x1p) / rx1);
    const cx = cosPhi * cxp - sinPhi * cyp + (x1 + x2) / 2;
    const cy = sinPhi * cxp + cosPhi * cyp + (y1 + y2) / 2;
    const ux = (x1p - cxp) / rx1;
    const uy = (y1p - cyp) / ry1;
    const vx = (-x1p - cxp) / rx1;
    const vy = (-y1p - cyp) / ry1;
    const startAngle = Math.atan2(uy, ux);
    let endAngle = Math.atan2(vy, vx);
    if (!sweepFlag && endAngle > startAngle) {
      endAngle -= 2 * Math.PI;
    } else if (sweepFlag && endAngle < startAngle) {
      endAngle += 2 * Math.PI;
    }
    const sweepAngle = endAngle - startAngle;
    const approximateArcLength = Math.max(rx1, ry1) * Math.abs(sweepAngle);
    const numSegments = Math.min(4, Math.ceil(Math.abs(sweepAngle) / (Math.PI / 2)));
    const resolutionPerSegment = Math.ceil(
      getVerticesCountForArcLength(approximateArcLength) / numSegments
    );
    const anglePerSegment = sweepAngle / numSegments;
    const ellipsePoint = (angle) => {
      return {
        x: cx + rx1 * Math.cos(angle) * cosPhi - ry1 * Math.sin(angle) * sinPhi,
        y: cy + rx1 * Math.cos(angle) * sinPhi + ry1 * Math.sin(angle) * cosPhi
      };
    };
    const ellipseDerivative = (angle) => {
      return {
        x: -rx1 * Math.sin(angle) * cosPhi - ry1 * Math.cos(angle) * sinPhi,
        y: -rx1 * Math.sin(angle) * sinPhi + ry1 * Math.cos(angle) * cosPhi
      };
    };
    for (let i = 0; i < numSegments; i++) {
      const theta1 = startAngle + i * anglePerSegment;
      const theta2 = startAngle + (i + 1) * anglePerSegment;
      const deltaTheta = theta2 - theta1;
      const start = ellipsePoint(theta1);
      const end = ellipsePoint(theta2);
      const d1 = ellipseDerivative(theta1);
      const d2 = ellipseDerivative(theta2);
      const handleScale = 4 / 3 * Math.tan(deltaTheta / 4);
      const cp1x = start.x + handleScale * d1.x;
      const cp1y = start.y + handleScale * d1.y;
      const cp2x = end.x - handleScale * d2.x;
      const cp2y = end.y - handleScale * d2.y;
      const bezierOpts = i === 0 ? opts : { ...opts, mergeWithPrevious: true };
      this.cubicBezierToWithResolution(
        end.x,
        end.y,
        cp1x,
        cp1y,
        cp2x,
        cp2y,
        bezierOpts,
        resolutionPerSegment
      );
    }
    return this;
  }
  cubicBezierTo(x, y, cp1X, cp1Y, cp2X, cp2Y, opts) {
    return this.cubicBezierToWithResolution(x, y, cp1X, cp1Y, cp2X, cp2Y, opts);
  }
  cubicBezierToWithResolution(x, y, cp1X, cp1Y, cp2X, cp2Y, opts, resolution) {
    this.assertHasMoveTo();
    this.commands.push({
      type: "cubic",
      x,
      y,
      cp1: { x: cp1X, y: cp1Y },
      cp2: { x: cp2X, y: cp2Y },
      isClose: false,
      opts,
      resolution
    });
    return this;
  }
  close() {
    const lastMoveTo = this.assertHasMoveTo();
    const lastCommand = this.commands[this.commands.length - 1];
    if (approximately(lastMoveTo.x, lastCommand.x) && approximately(lastMoveTo.y, lastCommand.y)) {
      lastCommand.isClose = true;
    } else {
      this.commands.push({
        type: "line",
        x: lastMoveTo.x,
        y: lastMoveTo.y,
        isClose: true
      });
    }
    lastMoveTo.closeIdx = this.commands.length - 1;
    this.lastMoveTo = null;
    return this;
  }
  toD(opts = {}) {
    var _a6, _b3, _c;
    const { startIdx = 0, endIdx = this.commands.length, onlyFilled = false } = opts;
    const parts = [];
    let isSkippingCurrentLine = false;
    let didAddMove = false;
    let didAddNaturalMove = false;
    const addMoveIfNeeded = (i) => {
      if (didAddMove || i === 0) return;
      didAddMove = true;
      const command2 = this.commands[i - 1];
      parts.push("M", toDomPrecision(command2.x), toDomPrecision(command2.y));
    };
    for (let i = startIdx; i < endIdx; i++) {
      const command2 = this.commands[i];
      switch (command2.type) {
        case "move": {
          const isFilled = ((_a6 = command2.opts) == null ? void 0 : _a6.geometry) === false ? false : ((_c = (_b3 = command2.opts) == null ? void 0 : _b3.geometry) == null ? void 0 : _c.isFilled) ?? false;
          if (onlyFilled && !isFilled) {
            isSkippingCurrentLine = true;
          } else {
            isSkippingCurrentLine = false;
            didAddMove = true;
            didAddNaturalMove = true;
            parts.push("M", toDomPrecision(command2.x), toDomPrecision(command2.y));
          }
          break;
        }
        case "line":
          if (isSkippingCurrentLine) break;
          addMoveIfNeeded(i);
          if (command2.isClose && didAddNaturalMove) {
            parts.push("Z");
          } else {
            parts.push("L", toDomPrecision(command2.x), toDomPrecision(command2.y));
          }
          break;
        case "cubic":
          if (isSkippingCurrentLine) break;
          addMoveIfNeeded(i);
          parts.push(
            "C",
            toDomPrecision(command2.cp1.x),
            toDomPrecision(command2.cp1.y),
            toDomPrecision(command2.cp2.x),
            toDomPrecision(command2.cp2.y),
            toDomPrecision(command2.x),
            toDomPrecision(command2.y)
          );
          break;
        default:
          exhaustiveSwitchError(command2, "type");
      }
    }
    return parts.join(" ");
  }
  toSvg(opts) {
    if (opts.forceSolid) {
      return this.toSolidSvg(opts);
    }
    switch (opts.style) {
      case "solid":
        return this.toSolidSvg(opts);
      case "dashed":
      case "dotted":
        return this.toDashedSvg(opts);
      case "draw": {
        const d = this.toDrawSvg(opts);
        return d;
      }
      default:
        exhaustiveSwitchError(opts, "style");
    }
  }
  toGeometry() {
    var _a6, _b3, _c, _d, _e, _f, _g, _h;
    const geometries = [];
    let current = null;
    for (let i = 0; i < this.commands.length; i++) {
      const command2 = this.commands[i];
      if (command2.type === "move") {
        if (current && ((_a6 = current.opts) == null ? void 0 : _a6.geometry) !== false) {
          geometries.push(
            new PathBuilderGeometry2d(this, current.startIdx, i, {
              ...(_b3 = current.opts) == null ? void 0 : _b3.geometry,
              isFilled: ((_d = (_c = current.opts) == null ? void 0 : _c.geometry) == null ? void 0 : _d.isFilled) ?? false,
              isClosed: current.moveCommand.closeIdx !== null
            })
          );
        }
        current = { startIdx: i, moveCommand: command2, opts: command2.opts, isClosed: false };
      }
      if (command2.isClose) {
        assert(current, "No current move command");
        current.isClosed = true;
      }
    }
    if (current && ((_e = current.opts) == null ? void 0 : _e.geometry) !== false) {
      geometries.push(
        new PathBuilderGeometry2d(this, current.startIdx, this.commands.length, {
          ...(_f = current.opts) == null ? void 0 : _f.geometry,
          isFilled: ((_h = (_g = current.opts) == null ? void 0 : _g.geometry) == null ? void 0 : _h.isFilled) ?? false,
          isClosed: current.moveCommand.closeIdx !== null
        })
      );
    }
    assert(geometries.length > 0);
    if (geometries.length === 1) return geometries[0];
    return new Group2d({ children: geometries });
  }
  toSolidSvg(opts) {
    const { strokeWidth, props } = opts;
    return (0, import_jsx_runtime39.jsx)("path", { strokeWidth, d: this.toD({ onlyFilled: opts.onlyFilled }), ...props });
  }
  toDashedSvg(opts) {
    var _a6, _b3, _c, _d, _e;
    const {
      style: style2,
      strokeWidth,
      snap,
      lengthRatio,
      props: { markerStart, markerEnd, ...props } = {}
    } = opts;
    const parts = [];
    let isCurrentPathClosed = false;
    let isSkippingCurrentLine = false;
    let currentLineOpts = void 0;
    let currentRun = null;
    const addCurrentRun = () => {
      if (!currentRun) return;
      const { startIdx, endIdx, isFirst, isLast, length, lineOpts, pathIsClosed } = currentRun;
      currentRun = null;
      if (startIdx === endIdx && this.commands[startIdx].type === "move") return;
      const start = (lineOpts == null ? void 0 : lineOpts.dashStart) ?? opts.start;
      const end = (lineOpts == null ? void 0 : lineOpts.dashEnd) ?? opts.end;
      const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(length, strokeWidth, {
        style: style2,
        snap,
        lengthRatio,
        start: isFirst ? start ?? (pathIsClosed ? "outset" : "none") : "outset",
        end: isLast ? end ?? (pathIsClosed ? "outset" : "none") : "outset"
      });
      const d = this.toD({ startIdx, endIdx: endIdx + 1 });
      parts.push(
        (0, import_jsx_runtime39.jsx)(
          "path",
          {
            d,
            strokeDasharray,
            strokeDashoffset,
            markerStart: isFirst ? markerStart : void 0,
            markerEnd: isLast ? markerEnd : void 0
          },
          parts.length
        )
      );
    };
    for (let i = 0; i < this.commands.length; i++) {
      const command2 = this.commands[i];
      const lastCommand = this.commands[i - 1];
      if (command2.type === "move") {
        isCurrentPathClosed = command2.closeIdx !== null;
        const isFilled = ((_a6 = command2.opts) == null ? void 0 : _a6.geometry) === false ? false : ((_c = (_b3 = command2.opts) == null ? void 0 : _b3.geometry) == null ? void 0 : _c.isFilled) ?? false;
        if (opts.onlyFilled && !isFilled) {
          isSkippingCurrentLine = true;
        } else {
          isSkippingCurrentLine = false;
          currentLineOpts = command2.opts;
        }
        continue;
      }
      if (isSkippingCurrentLine) continue;
      const segmentLength = this.calculateSegmentLength(lastCommand, command2);
      const isFirst = lastCommand.type === "move";
      const isLast = command2.isClose || i === this.commands.length - 1 || ((_d = this.commands[i + 1]) == null ? void 0 : _d.type) === "move";
      if (currentRun && ((_e = command2.opts) == null ? void 0 : _e.mergeWithPrevious)) {
        currentRun.length += segmentLength;
        currentRun.endIdx = i;
        currentRun.isLast = isLast;
      } else {
        addCurrentRun();
        currentRun = {
          startIdx: i,
          endIdx: i,
          isFirst,
          isLast,
          length: segmentLength,
          lineOpts: currentLineOpts,
          pathIsClosed: isCurrentPathClosed
        };
      }
    }
    addCurrentRun();
    return (0, import_jsx_runtime39.jsx)("g", { strokeWidth, ...props, children: parts });
  }
  toDrawSvg(opts) {
    return (0, import_jsx_runtime39.jsx)("path", { strokeWidth: opts.strokeWidth, d: this.toDrawD(opts), ...opts.props });
  }
  toDrawD(opts) {
    var _a6, _b3, _c, _d, _e, _f, _g;
    const {
      strokeWidth,
      randomSeed,
      offset: defaultOffset = strokeWidth / 3,
      roundness: defaultRoundness = strokeWidth * 2,
      passes = 2,
      onlyFilled = false
    } = opts;
    const parts = [];
    const commandInfo = this.getCommandInfo();
    const drawCommands = [];
    let lastMoveCommandIdx = null;
    for (let i = 0; i < this.commands.length; i++) {
      const command2 = this.commands[i];
      const offset4 = ((_a6 = command2.opts) == null ? void 0 : _a6.offset) ?? defaultOffset;
      const roundness = ((_b3 = command2.opts) == null ? void 0 : _b3.roundness) ?? defaultRoundness;
      if (command2.type === "move") {
        lastMoveCommandIdx = i;
      }
      const nextIdx = command2.isClose ? assertExists(lastMoveCommandIdx) + 1 : !this.commands[i + 1] || this.commands[i + 1].type === "move" ? void 0 : i + 1;
      const nextInfo = nextIdx !== void 0 && this.commands[nextIdx] && ((_c = this.commands[nextIdx]) == null ? void 0 : _c.type) !== "move" ? commandInfo[nextIdx] : void 0;
      const currentSupportsRoundness = commandsSupportingRoundness[command2.type];
      const nextSupportsRoundness = nextIdx !== void 0 ? commandsSupportingRoundness[this.commands[nextIdx].type] : false;
      const currentInfo = commandInfo[i];
      const tangentToPrev = currentInfo == null ? void 0 : currentInfo.tangentEnd;
      const tangentToNext = nextInfo == null ? void 0 : nextInfo.tangentStart;
      const roundnessClampedForAngle = currentSupportsRoundness && nextSupportsRoundness && tangentToPrev && tangentToNext && Vec.Len2(tangentToPrev) > 0.01 && Vec.Len2(tangentToNext) > 0.01 ? modulate(
        Math.abs(Vec.AngleBetween(tangentToPrev, tangentToNext)),
        [Math.PI / 2, Math.PI],
        [roundness, 0],
        true
      ) : 0;
      const shortestDistance = Math.min(
        (currentInfo == null ? void 0 : currentInfo.length) ?? Infinity,
        (nextInfo == null ? void 0 : nextInfo.length) ?? Infinity
      );
      const offsetLimit = shortestDistance - roundnessClampedForAngle * 2;
      const offsetAmount = clamp(offset4, 0, offsetLimit / 4);
      const roundnessBeforeClampedForLength = Math.min(
        roundnessClampedForAngle,
        ((currentInfo == null ? void 0 : currentInfo.length) ?? Infinity) / 4
      );
      const roundnessAfterClampedForLength = Math.min(
        roundnessClampedForAngle,
        ((nextInfo == null ? void 0 : nextInfo.length) ?? Infinity) / 4
      );
      const drawCommand = {
        command: command2,
        offsetAmount,
        roundnessBefore: roundnessBeforeClampedForLength,
        roundnessAfter: roundnessAfterClampedForLength,
        tangentToPrev: (_d = commandInfo[i]) == null ? void 0 : _d.tangentEnd,
        tangentToNext: nextInfo == null ? void 0 : nextInfo.tangentStart,
        moveDidClose: false
      };
      drawCommands.push(drawCommand);
      if (command2.isClose && lastMoveCommandIdx !== null) {
        const lastMoveCommand = drawCommands[lastMoveCommandIdx];
        lastMoveCommand.moveDidClose = true;
        lastMoveCommand.roundnessAfter = roundnessAfterClampedForLength;
      } else if (command2.type === "move") {
        lastMoveCommandIdx = i;
      }
    }
    for (let pass = 0; pass < passes; pass++) {
      const random = rng(randomSeed + pass);
      let lastMoveToOffset = { x: 0, y: 0 };
      let isSkippingCurrentLine = false;
      for (const {
        command: command2,
        offsetAmount,
        roundnessBefore,
        roundnessAfter,
        tangentToNext,
        tangentToPrev
      } of drawCommands) {
        const offset4 = command2.isClose ? lastMoveToOffset : { x: random() * offsetAmount, y: random() * offsetAmount };
        if (command2.type === "move") {
          lastMoveToOffset = offset4;
          const isFilled = ((_e = command2.opts) == null ? void 0 : _e.geometry) === false ? false : ((_g = (_f = command2.opts) == null ? void 0 : _f.geometry) == null ? void 0 : _g.isFilled) ?? false;
          if (onlyFilled && !isFilled) {
            isSkippingCurrentLine = true;
          } else {
            isSkippingCurrentLine = false;
          }
        }
        if (isSkippingCurrentLine) continue;
        const offsetPoint = Vec.Add(command2, offset4);
        const endPoint = tangentToNext && roundnessAfter > 0 ? Vec.Mul(tangentToNext, -roundnessAfter).add(offsetPoint) : offsetPoint;
        const startPoint = tangentToPrev && roundnessBefore > 0 ? Vec.Mul(tangentToPrev, roundnessBefore).add(offsetPoint) : offsetPoint;
        if (endPoint === offsetPoint || startPoint === offsetPoint) {
          switch (command2.type) {
            case "move":
              parts.push("M", toDomPrecision(endPoint.x), toDomPrecision(endPoint.y));
              break;
            case "line":
              parts.push("L", toDomPrecision(endPoint.x), toDomPrecision(endPoint.y));
              break;
            case "cubic": {
              const offsetCp1 = Vec.Add(command2.cp1, offset4);
              const offsetCp2 = Vec.Add(command2.cp2, offset4);
              parts.push(
                "C",
                toDomPrecision(offsetCp1.x),
                toDomPrecision(offsetCp1.y),
                toDomPrecision(offsetCp2.x),
                toDomPrecision(offsetCp2.y),
                toDomPrecision(endPoint.x),
                toDomPrecision(endPoint.y)
              );
              break;
            }
            default:
              exhaustiveSwitchError(command2, "type");
          }
        } else {
          switch (command2.type) {
            case "move":
              parts.push("M", toDomPrecision(endPoint.x), toDomPrecision(endPoint.y));
              break;
            case "line":
              parts.push(
                "L",
                toDomPrecision(startPoint.x),
                toDomPrecision(startPoint.y),
                "Q",
                toDomPrecision(offsetPoint.x),
                toDomPrecision(offsetPoint.y),
                toDomPrecision(endPoint.x),
                toDomPrecision(endPoint.y)
              );
              break;
            case "cubic": {
              const offsetCp1 = Vec.Add(command2.cp1, offset4);
              const offsetCp2 = Vec.Add(command2.cp2, offset4);
              parts.push(
                "C",
                toDomPrecision(offsetCp1.x),
                toDomPrecision(offsetCp1.y),
                toDomPrecision(offsetCp2.x),
                toDomPrecision(offsetCp2.y),
                toDomPrecision(offsetPoint.x),
                toDomPrecision(offsetPoint.y)
              );
              break;
            }
            default:
              exhaustiveSwitchError(command2, "type");
          }
        }
      }
    }
    return parts.join(" ");
  }
  calculateSegmentLength(lastPoint, command2) {
    switch (command2.type) {
      case "move":
        return 0;
      case "line":
        return Vec.Dist(lastPoint, command2);
      case "cubic":
        return CubicBezier.length(
          lastPoint.x,
          lastPoint.y,
          command2.cp1.x,
          command2.cp1.y,
          command2.cp2.x,
          command2.cp2.y,
          command2.x,
          command2.y
        );
      default:
        exhaustiveSwitchError(command2, "type");
    }
  }
  /** @internal */
  getCommands() {
    return this.commands;
  }
  /** @internal */
  getCommandInfo() {
    const commandInfo = [];
    for (let i = 1; i < this.commands.length; i++) {
      const previous = this.commands[i - 1];
      const current = this.commands[i];
      if (current._info) {
        commandInfo[i] = current._info;
        continue;
      }
      if (current.type === "move") {
        continue;
      }
      let tangentStart, tangentEnd;
      switch (current.type) {
        case "line":
          tangentStart = tangentEnd = Vec.Sub(previous, current).uni();
          break;
        case "cubic": {
          tangentStart = Vec.Sub(current.cp1, previous).uni();
          tangentEnd = Vec.Sub(current.cp2, current).uni();
          break;
        }
        default:
          exhaustiveSwitchError(current, "type");
      }
      current._info = {
        tangentStart,
        tangentEnd,
        length: this.calculateSegmentLength(previous, current)
      };
      commandInfo[i] = current._info;
    }
    return commandInfo;
  }
};
var commandsSupportingRoundness = {
  line: true,
  move: true,
  cubic: false
};
var PathBuilderGeometry2d = class extends Geometry2d {
  constructor(path, startIdx, endIdx, options2) {
    super(options2);
    __publicField(this, "_segments", null);
    this.path = path;
    this.startIdx = startIdx;
    this.endIdx = endIdx;
  }
  getSegments() {
    if (this._segments) return this._segments;
    this._segments = [];
    let last2 = this.path.commands[this.startIdx];
    assert(last2.type === "move");
    for (let i = this.startIdx + 1; i < this.endIdx; i++) {
      const command2 = this.path.commands[i];
      assert(command2.type !== "move");
      switch (command2.type) {
        case "line":
          this._segments.push(new Edge2d({ start: Vec.From(last2), end: Vec.From(command2) }));
          break;
        case "cubic": {
          this._segments.push(
            new CubicBezier2d({
              start: Vec.From(last2),
              cp1: Vec.From(command2.cp1),
              cp2: Vec.From(command2.cp2),
              end: Vec.From(command2),
              resolution: command2.resolution
            })
          );
          break;
        }
        default:
          exhaustiveSwitchError(command2, "type");
      }
      last2 = command2;
    }
    return this._segments;
  }
  getVertices(filters) {
    const vs = this.getSegments().flatMap((s) => s.getVertices(filters)).filter((vertex, i, vertices) => {
      const prev = vertices[i - 1];
      if (!prev) return true;
      return !Vec.Equals(prev, vertex);
    });
    if (this.isClosed) {
      const last2 = vs[vs.length - 1];
      const first2 = vs[0];
      if (!Vec.Equals(last2, first2)) {
        vs.push(first2);
      }
    }
    return vs;
  }
  nearestPoint(point, _filters) {
    let nearest = null;
    let nearestDistance = Infinity;
    for (const segment of this.getSegments()) {
      const candidate = segment.nearestPoint(point);
      const distance = Vec.Dist2(point, candidate);
      if (distance < nearestDistance) {
        nearestDistance = distance;
        nearest = candidate;
      }
    }
    assert(nearest, "No nearest point found");
    return nearest;
  }
  hitTestLineSegment(A, B, distance = 0, filters) {
    return super.hitTestLineSegment(A, B, distance, filters);
  }
  getSvgPathData() {
    return this.path.toD({ startIdx: this.startIdx, endIdx: this.endIdx });
  }
};
var CubicBezier = {
  base3(t2, p1, p2, p3, p4) {
    const t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;
    const t22 = t2 * t1 + 6 * p1 - 12 * p2 + 6 * p3;
    return t2 * t22 - 3 * p1 + 3 * p2;
  },
  /**
   * Calculate the approximate length of a cubic bezier curve from (x1, y1) to (x4, y4) with
   * control points (x2, y2) and (x3, y3).
   */
  length(x1, y1, x2, y2, x3, y3, x4, y4, z = 1) {
    z = z > 1 ? 1 : z < 0 ? 0 : z;
    const z2 = z / 2;
    const n = 12;
    let sum = 0;
    sum = 0;
    for (let i = 0; i < n; i++) {
      const ct = z2 * CubicBezier.Tvalues[i] + z2;
      const xbase = CubicBezier.base3(ct, x1, x2, x3, x4);
      const ybase = CubicBezier.base3(ct, y1, y2, y3, y4);
      const comb = xbase * xbase + ybase * ybase;
      sum += CubicBezier.Cvalues[i] * Math.sqrt(comb);
    }
    return z2 * sum;
  },
  Tvalues: [
    -0.1252,
    0.1252,
    -0.3678,
    0.3678,
    -0.5873,
    0.5873,
    -0.7699,
    0.7699,
    -0.9041,
    0.9041,
    -0.9816,
    0.9816
  ],
  Cvalues: [
    0.2491,
    0.2491,
    0.2335,
    0.2335,
    0.2032,
    0.2032,
    0.1601,
    0.1601,
    0.1069,
    0.1069,
    0.0472,
    0.0472
  ]
};

// ../node_modules/tldraw/dist-esm/lib/shapes/shared/usePrefersReducedMotion.mjs
var import_react51 = __toESM(require_react(), 1);
function usePrefersReducedMotion() {
  const editor = useMaybeEditor();
  const animationSpeed = useValue("animationSpeed", () => editor == null ? void 0 : editor.user.getAnimationSpeed(), [
    editor
  ]);
  const [prefersReducedMotion, setPrefersReducedMotion] = (0, import_react51.useState)(false);
  (0, import_react51.useEffect)(() => {
    if (animationSpeed !== void 0) {
      setPrefersReducedMotion(animationSpeed === 0 ? true : false);
      return;
    }
    if (typeof window === "undefined" || !("matchMedia" in window)) return;
    const mql = window.matchMedia("(prefers-reduced-motion: reduce)");
    const handler = () => {
      setPrefersReducedMotion(mql.matches);
    };
    handler();
    mql.addEventListener("change", handler);
    return () => mql.removeEventListener("change", handler);
  }, [animationSpeed]);
  return prefersReducedMotion;
}

// ../node_modules/tldraw/dist-esm/lib/tools/SelectTool/selectHelpers.mjs
function hasRichText(shape) {
  return "richText" in shape.props && richTextValidator.isValid(shape.props.richText);
}
function startEditingShapeWithRichText(editor, shapeOrId, options2 = {}) {
  const shape = typeof shapeOrId === "string" ? editor.getShape(shapeOrId) : shapeOrId;
  if (!shape) return;
  if (!editor.canEditShape(shape)) return;
  if (!hasRichText(shape)) {
    throw new Error("Shape does not have rich text");
  }
  editor.setEditingShape(shape);
  editor.setCurrentTool("select.editing_shape", {
    ...options2.info,
    target: "shape",
    shape
  });
  if (options2.selectAll) {
    editor.emit("select-all-text", { shapeId: shape.id });
  }
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/A11y.mjs
var import_jsx_runtime44 = __toESM(require_jsx_runtime(), 1);
var import_react54 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/context/a11y.mjs
var import_jsx_runtime40 = __toESM(require_jsx_runtime(), 1);
var import_react52 = __toESM(require_react(), 1);
var A11yContext = (0, import_react52.createContext)(null);
function TldrawUiA11yProvider({ children }) {
  const currentMsg = useAtom("a11y", { msg: "", priority: "assertive" });
  const ctx = (0, import_react52.useContext)(A11yContext);
  const current = (0, import_react52.useMemo)(
    () => ({
      currentMsg,
      announce(msg2) {
        if (!msg2) return;
        currentMsg.set(msg2);
      }
    }),
    [currentMsg]
  );
  if (ctx) {
    return (0, import_jsx_runtime40.jsx)(import_jsx_runtime40.Fragment, { children });
  }
  return (0, import_jsx_runtime40.jsx)(A11yContext.Provider, { value: current, children });
}
function useA11y() {
  const ctx = (0, import_react52.useContext)(A11yContext);
  if (!ctx) {
    throw new Error("useA11y must be used within a A11yContext.Provider");
  }
  return ctx;
}

// ../node_modules/tldraw/dist-esm/lib/ui/hooks/useTranslation/useTranslation.mjs
var import_jsx_runtime42 = __toESM(require_jsx_runtime(), 1);
var React12 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/context/asset-urls.mjs
var import_jsx_runtime41 = __toESM(require_jsx_runtime(), 1);
var import_react53 = __toESM(require_react(), 1);
var AssetUrlsContext = (0, import_react53.createContext)(null);
function AssetUrlsProvider({
  assetUrls,
  children
}) {
  (0, import_react53.useEffect)(() => {
    for (const src of Object.values(assetUrls.icons)) {
      if (!src) continue;
      const image = Image();
      image.crossOrigin = "anonymous";
      image.src = src;
      image.decode();
    }
    for (const src of Object.values(assetUrls.embedIcons)) {
      if (!src) continue;
      const image = Image();
      image.crossOrigin = "anonymous";
      image.src = src;
      image.decode();
    }
  }, [assetUrls]);
  return (0, import_jsx_runtime41.jsx)(AssetUrlsContext.Provider, { value: assetUrls, children });
}
function useAssetUrls() {
  const assetUrls = (0, import_react53.useContext)(AssetUrlsContext);
  if (!assetUrls) {
    throw new Error("useAssetUrls must be used within an AssetUrlsProvider");
  }
  return assetUrls;
}

// ../node_modules/tldraw/dist-esm/lib/ui/hooks/useTranslation/defaultTranslation.mjs
var DEFAULT_TRANSLATION = {
  "action.toggle-auto-pan": "Auto (trackpad)",
  "action.toggle-auto-zoom": "Auto (mouse)",
  "action.toggle-auto-none": "Auto",
  "action.toggle-mouse": "Mouse",
  "action.toggle-trackpad": "Trackpad",
  "action.convert-to-bookmark": "Convert to bookmark",
  "action.convert-to-embed": "Convert to embed",
  "action.open-embed-link": "Open link",
  "action.align-bottom": "Align bottom",
  "action.align-center-horizontal": "Align horizontally",
  "action.align-center-vertical": "Align vertically",
  "action.align-center-horizontal.short": "Align H",
  "action.align-center-vertical.short": "Align V",
  "action.align-left": "Align left",
  "action.align-right": "Align right",
  "action.align-top": "Align top",
  "action.back-to-content": "Back to content",
  "action.bring-forward": "Bring forward",
  "action.bring-to-front": "Bring to front",
  "action.copy-as-png.short": "PNG",
  "action.copy-as-png": "Copy as PNG",
  "action.copy-as-svg.short": "SVG",
  "action.copy-as-svg": "Copy as SVG",
  "action.copy": "Copy",
  "action.cut": "Cut",
  "action.delete": "Delete",
  "action.unlock-all": "Unlock all",
  "action.distribute-horizontal": "Distribute horizontally",
  "action.distribute-vertical": "Distribute vertically",
  "action.distribute-horizontal.short": "Distribute H",
  "action.distribute-vertical.short": "Distribute V",
  "action.download-original": "Download original",
  "action.duplicate": "Duplicate",
  "action.edit-link": "Edit link",
  "action.exit-pen-mode": "Exit pen mode",
  "action.export-as-png.short": "PNG",
  "action.export-as-png": "Export as PNG",
  "action.export-as-svg.short": "SVG",
  "action.export-as-svg": "Export as SVG",
  "action.export-all-as-png.short": "PNG",
  "action.export-all-as-png": "Export as PNG",
  "action.export-all-as-svg.short": "SVG",
  "action.export-all-as-svg": "Export as SVG",
  "action.fit-frame-to-content": "Fit to content",
  "action.flip-horizontal": "Flip horizontally",
  "action.flip-vertical": "Flip vertically",
  "action.flip-horizontal.short": "Flip H",
  "action.flip-vertical.short": "Flip V",
  "action.fork-project": "Fork this project",
  "action.fork-project-on-tldraw": "Fork project on tldraw",
  "action.group": "Group",
  "action.insert-embed": "Insert embed",
  "action.insert-media": "Upload media",
  "action.leave-shared-project": "Leave shared project",
  "action.new-project": "New project",
  "action.new-shared-project": "New shared project",
  "action.open-cursor-chat": "Cursor chat",
  "action.open-kbd-shortcuts": "Open keyboard shortcuts",
  "action.open-file": "Open file",
  "action.pack": "Pack",
  "action.paste": "Paste",
  "action.paste-error-title": "Pasting failed",
  "action.paste-error-description": "Could not paste due to missing clipboard permissions. Please enable the permissions and try again.",
  "action.print": "Print",
  "action.redo": "Redo",
  "action.remove-frame": "Remove frame",
  "action.rename": "Rename",
  "action.rotate-ccw": "Rotate counterclockwise",
  "action.rotate-cw": "Rotate clockwise",
  "action.save-copy": "Save a copy",
  "action.select-all": "Select all",
  "action.select-none": "Select none",
  "action.send-backward": "Send backward",
  "action.send-to-back": "Send to back",
  "action.share-project": "Share this project",
  "action.stack-horizontal": "Stack horizontally",
  "action.stack-vertical": "Stack vertically",
  "action.stack-horizontal.short": "Stack H",
  "action.stack-vertical.short": "Stack V",
  "action.stop-following": "Stop following",
  "action.stretch-horizontal": "Stretch horizontally",
  "action.stretch-vertical": "Stretch vertically",
  "action.stretch-horizontal.short": "Stretch H",
  "action.stretch-vertical.short": "Stretch V",
  "action.toggle-auto-size": "Toggle auto size",
  "action.toggle-dark-mode.menu": "Dark mode",
  "action.toggle-dark-mode": "Toggle dark mode",
  "action.toggle-paste-at-cursor.menu": "Paste at cursor",
  "action.toggle-paste-at-cursor": "Toggle paste at cursor",
  "action.toggle-wrap-mode.menu": "Select on wrap",
  "action.toggle-wrap-mode": "Toggle select on wrap",
  "action.toggle-reduce-motion.menu": "Reduce motion",
  "action.toggle-reduce-motion": "Toggle reduce motion",
  "action.toggle-keyboard-shortcuts.menu": "Enable keyboard shortcuts",
  "action.toggle-keyboard-shortcuts": "Toggle keyboard shortcuts",
  "action.enhanced-a11y-mode.menu": "Enhanced accessibility mode",
  "action.enhanced-a11y-mode": "Toggle enhanced accessibility mode",
  "action.toggle-edge-scrolling.menu": "Edge scrolling",
  "action.toggle-edge-scrolling": "Toggle edge scrolling",
  "action.toggle-debug-mode.menu": "Debug mode",
  "action.toggle-debug-mode": "Toggle debug mode",
  "action.toggle-focus-mode.menu": "Focus mode",
  "action.toggle-focus-mode": "Toggle focus mode",
  "action.toggle-dynamic-size-mode.menu": "Dynamic size",
  "action.toggle-dynamic-size-mode": "Toggle dynamic size",
  "action.toggle-grid.menu": "Show grid",
  "action.toggle-grid": "Toggle grid",
  "action.toggle-lock": "Toggle locked",
  "action.flatten-to-image": "Flatten",
  "action.toggle-snap-mode.menu": "Always snap",
  "action.toggle-snap-mode": "Toggle always snap",
  "action.toggle-tool-lock.menu": "Tool lock",
  "action.toggle-tool-lock": "Toggle tool lock",
  "action.toggle-transparent.context-menu": "Transparent",
  "action.toggle-transparent.menu": "Transparent",
  "action.toggle-transparent": "Toggle transparent background",
  "action.undo": "Undo",
  "action.ungroup": "Ungroup",
  "action.zoom-in": "Zoom in",
  "action.zoom-out": "Zoom out",
  "action.zoom-to-100": "Zoom to 100%",
  "action.zoom-to-fit": "Zoom to fit",
  "action.zoom-to-selection": "Zoom to selection",
  "assets.files.size-too-big": "File size is too big",
  "assets.files.maximum-size": "Maximum file size is {size}",
  "assets.files.type-not-allowed": "File type is not allowed",
  "assets.files.upload-failed": "Upload failed",
  "assets.files.amount-too-many": "Too many files",
  "assets.url.failed": "Couldn’t load URL preview",
  "theme.dark": "Dark",
  "theme.light": "Light",
  "theme.system": "System",
  "color-style.white": "White",
  "color-style.black": "Black",
  "color-style.blue": "Blue",
  "color-style.green": "Green",
  "color-style.grey": "Grey",
  "color-style.light-blue": "Light blue",
  "color-style.light-green": "Light green",
  "color-style.light-red": "Light red",
  "color-style.light-violet": "Light violet",
  "color-style.orange": "Orange",
  "color-style.red": "Red",
  "color-style.violet": "Violet",
  "color-style.yellow": "Yellow",
  "fill-style.none": "None",
  "document.default-name": "Untitled",
  "fill-style.semi": "Semi",
  "fill-style.solid": "Solid",
  "fill-style.pattern": "Pattern",
  "fill-style.fill": "Fill",
  "fill-style.lined-fill": "Lined fill",
  "dash-style.dashed": "Dashed",
  "dash-style.dotted": "Dotted",
  "dash-style.draw": "Draw",
  "dash-style.solid": "Solid",
  "size-style.s": "Small",
  "size-style.m": "Medium",
  "size-style.l": "Large",
  "size-style.xl": "Extra large",
  "opacity-style.0.1": "10%",
  "opacity-style.0.25": "25%",
  "opacity-style.0.5": "50%",
  "opacity-style.0.75": "75%",
  "opacity-style.1": "100%",
  "font-style.draw": "Draw",
  "font-style.sans": "Sans",
  "font-style.serif": "Serif",
  "font-style.mono": "Mono",
  "align-style.start": "Start",
  "align-style.middle": "Middle",
  "align-style.end": "End",
  "align-style.justify": "Justify",
  "verticalAlign-style.start": "Top",
  "verticalAlign-style.middle": "Middle",
  "verticalAlign-style.end": "Bottom",
  "geo-style.arrow-down": "Arrow down",
  "geo-style.arrow-left": "Arrow left",
  "geo-style.arrow-right": "Arrow right",
  "geo-style.arrow-up": "Arrow up",
  "geo-style.cloud": "Cloud",
  "geo-style.diamond": "Diamond",
  "geo-style.ellipse": "Ellipse",
  "geo-style.heart": "Heart",
  "geo-style.hexagon": "Hexagon",
  "geo-style.octagon": "Octagon",
  "geo-style.oval": "Oval",
  "geo-style.pentagon": "Pentagon",
  "geo-style.rectangle": "Rectangle",
  "geo-style.rhombus": "Rhombus",
  "geo-style.rhombus-2": "Rhombus left",
  "geo-style.star": "Star",
  "geo-style.trapezoid": "Trapezoid",
  "geo-style.triangle": "Triangle",
  "geo-style.x-box": "X box",
  "geo-style.check-box": "Check box",
  "arrowheadStart-style.none": "None",
  "arrowheadStart-style.arrow": "Arrow",
  "arrowheadStart-style.bar": "Bar",
  "arrowheadStart-style.diamond": "Diamond",
  "arrowheadStart-style.dot": "Dot",
  "arrowheadStart-style.inverted": "Inverted",
  "arrowheadStart-style.pipe": "Pipe",
  "arrowheadStart-style.square": "Square",
  "arrowheadStart-style.triangle": "Triangle",
  "arrowheadEnd-style.none": "None",
  "arrowheadEnd-style.arrow": "Arrow",
  "arrowheadEnd-style.bar": "Bar",
  "arrowheadEnd-style.diamond": "Diamond",
  "arrowheadEnd-style.dot": "Dot",
  "arrowheadEnd-style.inverted": "Inverted",
  "arrowheadEnd-style.pipe": "Pipe",
  "arrowheadEnd-style.square": "Square",
  "arrowheadEnd-style.triangle": "Triangle",
  "spline-style.line": "Line",
  "spline-style.cubic": "Cubic",
  "arrow-kind-style.arc": "Arc",
  "arrow-kind-style.elbow": "Elbow",
  "tool.select": "Select",
  "tool.hand": "Hand",
  "tool.draw": "Draw",
  "tool.eraser": "Eraser",
  "tool.arrow-down": "Arrow down",
  "tool.arrow-left": "Arrow left",
  "tool.arrow-right": "Arrow right",
  "tool.arrow-up": "Arrow up",
  "tool.arrow": "Arrow",
  "tool.cloud": "Cloud",
  "tool.diamond": "Diamond",
  "tool.ellipse": "Ellipse",
  "tool.heart": "Heart",
  "tool.hexagon": "Hexagon",
  "tool.highlight": "Highlight",
  "tool.line": "Line",
  "tool.octagon": "Octagon",
  "tool.oval": "Oval",
  "tool.pentagon": "Pentagon",
  "tool.rectangle": "Rectangle",
  "tool.rhombus": "Rhombus",
  "tool.star": "Star",
  "tool.trapezoid": "Trapezoid",
  "tool.triangle": "Triangle",
  "tool.x-box": "X box",
  "tool.check-box": "Check box",
  "tool.media": "Media",
  "tool.frame": "Frame",
  "tool.note": "Note",
  "tool.laser": "Laser",
  "tool.embed": "Embed",
  "tool.text": "Text",
  "tool.pointer-down": "Pointer down",
  "tool.image-zoom": "Zoom",
  "tool.replace-media": "Replace media",
  "tool.flip-horz": "Flip horizontally",
  "tool.flip-vert": "Flip vertically",
  "tool.rotate-cw": "Rotate",
  "tool.aspect-ratio": "Aspect ratio",
  "tool.aspect-ratio.original": "Original",
  "tool.aspect-ratio.square": "Square (1:1)",
  "tool.aspect-ratio.circle": "Circle (1:1)",
  "tool.aspect-ratio.landscape": "Landscape (4:3)",
  "tool.aspect-ratio.portrait": "Portrait (3:4)",
  "tool.aspect-ratio.wide": "Wide (16:9)",
  "tool.image-toolbar-title": "Image tools",
  "tool.image-crop": "Crop image",
  "tool.image-crop-confirm": "Confirm",
  "tool.media-alt-text": "Alternative text",
  "tool.media-alt-text-desc": "Give a description…",
  "tool.media-alt-text-confirm": "Confirm",
  "tool.rich-text-bold": "Bold",
  "tool.rich-text-italic": "Italic",
  "tool.rich-text-code": "Code",
  "tool.rich-text-highlight": "Highlight",
  "tool.rich-text-strikethrough": "Strikethrough",
  "tool.rich-text-link": "Link",
  "tool.rich-text-link-visit": "Visit link",
  "tool.rich-text-link-remove": "Remove link",
  "tool.rich-text-header": "Header",
  "tool.rich-text-bulletList": "Bulleted list",
  "tool.rich-text-toolbar-title": "Text formatting",
  "tool.rich-text-orderedList": "Ordered list",
  "tool.bookmark": "Bookmark",
  "a11y.status": "Status",
  "a11y.skip-to-main-content": "Move focus to canvas",
  "a11y.shape-index": "{num} of {total}",
  "a11y.shape-image": "Image",
  "a11y.shape-video": "Video",
  "a11y.multiple-shapes": "{num} shapes selected",
  "a11y.select-shape": "Select next shape",
  "a11y.select-shape-direction": "Select shape in direction",
  "a11y.enter-leave-container": "Enter/leave container",
  "a11y.repeat-shape": "Repeat shape",
  "a11y.move-shape": "Move shape",
  "a11y.move-shape-faster": "Move shape faster",
  "a11y.rotate-shape-cw": "Rotate shape clockwise",
  "a11y.rotate-shape-ccw": "Rotate shape counterclockwise",
  "a11y.rotate-shape-cw-fine": "Rotate shape clockwise (fine)",
  "a11y.rotate-shape-ccw-fine": "Rotate shape counterclockwise (fine)",
  "a11y.enlarge-shape": "Enlarge shape",
  "a11y.shrink-shape": "Shrink shape",
  "a11y.pan-camera": "Pan camera",
  "a11y.adjust-shape-styles": "Adjust shape styles",
  "a11y.open-context-menu": "Open context menu",
  "a11y.open-keyboard-shortcuts": "Open keyboard shortcuts",
  "menu.title": "Menu",
  "menu.theme": "Theme",
  "menu.accessibility": "Accessibility",
  "menu.copy-as": "Copy as",
  "menu.edit": "Edit",
  "menu.export-as": "Export as",
  "menu.file": "File",
  "menu.language": "Language",
  "menu.preferences": "Preferences",
  "menu.view": "View",
  "menu.input-mode": "Input mode",
  "context-menu.title": "Context menu",
  "context-menu.edit": "Edit",
  "context-menu.arrange": "Arrange",
  "context-menu.copy-as": "Copy as",
  "context-menu.export-as": "Export as",
  "context-menu.export-all-as": "Export",
  "context-menu.move-to-page": "Move to page",
  "context-menu.reorder": "Reorder",
  "page-menu.title": "Pages",
  "page-menu.create-new-page": "Create new page",
  "page-menu.max-page-count-reached": "Max pages reached",
  "page-menu.new-page-initial-name": "Page 1",
  "page-menu.edit-start": "Edit",
  "page-menu.edit-done": "Done",
  "page-menu.go-to-page": "Go to page",
  "page-menu.submenu.rename": "Rename",
  "page-menu.submenu.duplicate-page": "Duplicate",
  "page-menu.submenu.title": "Menu",
  "page-menu.submenu.move-down": "Move down",
  "page-menu.submenu.move-up": "Move up",
  "page-menu.submenu.delete": "Delete",
  "share-menu.title": "Share",
  "share-menu.save-note": "Download this project to your computer as a .tldr file.",
  "share-menu.fork-note": "Create a new shared project based on this snapshot.",
  "share-menu.share-project": "Share this project",
  "share-menu.copy-link": "Copy editor link",
  "share-menu.create-snapshot-link": "Copy snapshot link",
  "share-menu.snapshot-link-note": "Capture and share this project as a read-only snapshot link.",
  "share-menu.copy-readonly-link": "Copy viewer link",
  "share-menu.offline-note": "Create a new shared project based on your current project.",
  "share-menu.copy-link-note": "Anyone with the link will be able to view and edit this project.",
  "share-menu.copy-readonly-link-note": "Anyone with the link will be able to access this project.",
  "share-menu.project-too-large": "Sorry, this project can’t be shared because it’s too large. We’re working on it!",
  "share-menu.upload-failed": "Sorry, we couldn’t upload your project at the moment. Please try again or let us know if the problem persists.",
  "share-menu.creating-project": "Creating the new project…",
  "share-menu.copied": "Copied link",
  "document-name-menu.copy-link": "Copy link",
  "status.offline": "Offline",
  "people-menu.title": "People",
  "people-menu.change-name": "Change name",
  "people-menu.avatar-color": "Avatar color",
  "people-menu.change-color": "Change color",
  "people-menu.follow": "Following",
  "people-menu.following": "Following",
  "people-menu.leading": "Following you",
  "people-menu.user": "(You)",
  "people-menu.invite": "Invite others",
  "people-menu.anonymous-user": "New user",
  "help-menu.import-tldr-file": "Import file…",
  "help-menu.title": "Help and resources",
  "help-menu.about": "About tldraw",
  "help-menu.discord": "Discord",
  "help-menu.github": "GitHub",
  "help-menu.keyboard-shortcuts": "Keyboard shortcuts",
  "help-menu.twitter": "Twitter",
  "help-menu.terms": "Terms of service",
  "help-menu.privacy": "Privacy policy",
  "actions-menu.title": "Actions",
  "edit-link-dialog.title": "Edit link",
  "edit-link-dialog.invalid-url": "A link must be a valid URL.",
  "edit-link-dialog.detail": "Links will open in a new tab.",
  "edit-link-dialog.url": "URL",
  "edit-link-dialog.clear": "Clear",
  "edit-link-dialog.save": "Continue",
  "edit-link-dialog.cancel": "Cancel",
  "edit-link-dialog.external-link": "External link",
  "embed-dialog.title": "Insert embed",
  "embed-dialog.back": "Back",
  "embed-dialog.create": "Create",
  "embed-dialog.cancel": "Cancel",
  "embed-dialog.url": "URL",
  "embed-dialog.instruction": "Paste in the site’s URL to create the embed.",
  "embed-dialog.invalid-url": "We could not create an embed from that URL.",
  "shortcuts-dialog.title": "Keyboard shortcuts",
  "shortcuts-dialog.edit": "Edit",
  "shortcuts-dialog.file": "File",
  "shortcuts-dialog.preferences": "Preferences",
  "shortcuts-dialog.tools": "Tools",
  "shortcuts-dialog.transform": "Transform",
  "shortcuts-dialog.view": "View",
  "shortcuts-dialog.collaboration": "Collaboration",
  "shortcuts-dialog.a11y": "Accessibility",
  "shortcuts-dialog.text-formatting": "Text formatting",
  "style-panel.title": "Styles",
  "style-panel.align": "Align",
  "style-panel.label-align": "Label align",
  "style-panel.vertical-align": "Vertical align",
  "style-panel.position": "Position",
  "style-panel.arrowheads": "Arrows",
  "style-panel.arrowhead-start": "Start",
  "style-panel.arrowhead-end": "End",
  "style-panel.arrow-kind": "Line",
  "style-panel.color": "Color",
  "style-panel.dash": "Dash",
  "style-panel.fill": "Fill",
  "style-panel.font": "Font",
  "style-panel.geo": "Shape",
  "style-panel.mixed": "Mixed",
  "style-panel.opacity": "Opacity",
  "style-panel.size": "Size",
  "style-panel.spline": "Spline",
  "style-panel.selected": "selected",
  "tool-panel.title": "Tools",
  "tool-panel.more": "More",
  "navigation-zone.title": "Navigation",
  "navigation-zone.minimap": "Minimap",
  "navigation-zone.toggle-minimap": "Toggle minimap",
  "navigation-zone.zoom": "Zoom",
  "focus-mode.toggle-focus-mode": "Toggle focus mode",
  "toast.close": "Close",
  "toast.success": "Success",
  "toast.error": "Error",
  "toast.info": "Info",
  "toast.warning": "Warning",
  "file-system.file-open-error.title": "Could not open file",
  "file-system.file-open-error.not-a-tldraw-file": "The file you tried to open doesn’t look like a tldraw file.",
  "file-system.file-open-error.file-format-version-too-new": "The file you tried to open is from a newer version of tldraw. Please reload the page and try again.",
  "file-system.file-open-error.generic-corrupted-file": "The file you tried to open is corrupted.",
  "file-system.confirm-open.title": "Overwrite current project?",
  "file-system.confirm-open.description": "Opening a file will replace your current project and any unsaved changes will be lost. Are you sure you want to continue?",
  "file-system.confirm-open.cancel": "Cancel",
  "file-system.confirm-open.open": "Open file",
  "file-system.confirm-open.dont-show-again": "Don’t ask again",
  "file-system.confirm-clear.title": "Clear current project?",
  "file-system.confirm-clear.description": "Creating a new project will clear your current project and any unsaved changes will be lost. Are you sure you want to continue?",
  "file-system.confirm-clear.cancel": "Cancel",
  "file-system.confirm-clear.continue": "Continue",
  "file-system.confirm-clear.dont-show-again": "Don’t ask again",
  "file-system.shared-document-file-open-error.title": "Could not open file",
  "file-system.shared-document-file-open-error.description": "Opening files from shared projects is not supported.",
  "sharing.confirm-leave.title": "Leave current project?",
  "sharing.confirm-leave.description": "Are you sure you want to leave this shared project? You can return to it by navigating to its URL.",
  "sharing.confirm-leave.cancel": "Cancel",
  "sharing.confirm-leave.leave": "Leave",
  "sharing.confirm-leave.dont-show-again": "Don’t ask again",
  "toast.error.export-fail.title": "Failed export",
  "toast.error.export-fail.desc": "Failed to export image",
  "toast.error.copy-fail.title": "Failed copy",
  "toast.error.copy-fail.desc": "Failed to copy image",
  "context.pages.new-page": "New page",
  "vscode.file-open.desc": "We’ve updated this document to work with the current version of tldraw. If you’d like to keep the original version (which will work on old.tldraw.com), click below to create a backup.",
  "vscode.file-open.open": "Continue",
  "vscode.file-open.backup": "Backup",
  "vscode.file-open.backup-saved": "Backup saved",
  "vscode.file-open.backup-failed": "Backup failed: this is not a .tldr file.",
  "vscode.file-open.dont-show-again": "Don’t ask again",
  "cursor-chat.type-to-chat": "Type to chat…",
  "app.loading": "Loading tldraw…",
  "handle.resize-top": "Resize top",
  "handle.resize-bottom": "Resize bottom",
  "handle.resize-left": "Resize left",
  "handle.resize-right": "Resize right",
  "handle.resize-top-left": "Resize top left",
  "handle.resize-top-right": "Resize top right",
  "handle.resize-bottom-left": "Resize bottom left",
  "handle.resize-bottom-right": "Resize bottom right",
  "handle.rotate.top_left_rotate": "Rotate top left",
  "handle.rotate.top_right_rotate": "Rotate top right",
  "handle.rotate.bottom_left_rotate": "Rotate bottom left",
  "handle.rotate.bottom_right_rotate": "Rotate bottom right",
  "handle.rotate.mobile_rotate": "Rotate",
  "handle.crop.top": "Crop top",
  "handle.crop.bottom": "Crop bottom",
  "handle.crop.left": "Crop left",
  "handle.crop.right": "Crop right",
  "handle.crop.top-left": "Crop top left",
  "handle.crop.top-right": "Crop top right",
  "handle.crop.bottom-left": "Crop bottom left",
  "handle.crop.bottom-right": "Crop bottom right",
  "ui.close": "Close",
  "ui.checked": "Checked",
  "ui.unchecked": "Unchecked"
};

// ../node_modules/tldraw/dist-esm/lib/ui/hooks/useTranslation/translations.mjs
var RTL_LANGUAGES = /* @__PURE__ */ new Set(["ar", "fa", "he", "ur", "ku"]);
var EN_TRANSLATION = {
  locale: "en",
  label: "English",
  messages: DEFAULT_TRANSLATION,
  dir: "ltr"
};
async function fetchTranslation(locale, assetUrls) {
  const mainRes = await fetch2(assetUrls.translations.en);
  if (!mainRes.ok) {
    console.warn(`No main translations found.`);
    return EN_TRANSLATION;
  }
  if (locale === "en") {
    return EN_TRANSLATION;
  }
  const language = LANGUAGES.find((t2) => t2.locale === locale);
  if (!language) {
    console.warn(`No translation found for locale ${locale}`);
    return EN_TRANSLATION;
  }
  const res = await fetch2(assetUrls.translations[language.locale]);
  const messages = await res.json();
  if (!messages) {
    console.warn(`No messages found for locale ${locale}`);
    return EN_TRANSLATION;
  }
  const missing = [];
  for (const key in EN_TRANSLATION.messages) {
    if (!messages[key]) {
      missing.push(key);
    }
  }
  if (missing.length > 0 && true) {
    console.warn(`Language ${locale}: missing messages for keys:
${missing.join("\n")}`);
  }
  return {
    locale,
    label: language.label,
    dir: RTL_LANGUAGES.has(language.locale) ? "rtl" : "ltr",
    messages: { ...EN_TRANSLATION.messages, ...messages }
  };
}

// ../node_modules/tldraw/dist-esm/lib/ui/hooks/useTranslation/useTranslation.mjs
var TranslationsContext = React12.createContext(null);
function useCurrentTranslation() {
  const translations = React12.useContext(TranslationsContext);
  if (!translations) {
    throw new Error("useCurrentTranslation must be used inside of <TldrawUiContextProvider />");
  }
  return translations;
}
function TldrawUiTranslationProvider({
  overrides,
  locale,
  children
}) {
  const getAssetUrl = useAssetUrls();
  const [currentTranslation, setCurrentTranslation] = React12.useState(() => {
    if (overrides && overrides["en"]) {
      return {
        locale: "en",
        label: "English",
        dir: "ltr",
        messages: { ...DEFAULT_TRANSLATION, ...overrides["en"] }
      };
    }
    return {
      locale: "en",
      label: "English",
      dir: "ltr",
      messages: DEFAULT_TRANSLATION
    };
  });
  React12.useEffect(() => {
    let isCancelled = false;
    async function loadTranslation() {
      const translation = await fetchTranslation(locale, getAssetUrl);
      if (translation && !isCancelled) {
        if (overrides && overrides[locale]) {
          setCurrentTranslation({
            ...translation,
            messages: { ...translation.messages, ...overrides[locale] }
          });
        } else {
          setCurrentTranslation(translation);
        }
      }
    }
    loadTranslation();
    return () => {
      isCancelled = true;
    };
  }, [getAssetUrl, locale, overrides]);
  return (0, import_jsx_runtime42.jsx)(TranslationsContext.Provider, { value: currentTranslation, children });
}
function useTranslation() {
  const translation = useCurrentTranslation();
  return React12.useCallback(
    function msg2(id) {
      return translation.messages[id] ?? id;
    },
    [translation]
  );
}
function untranslated(string) {
  return string;
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/primitives/Button/TldrawUiButton.mjs
var import_jsx_runtime43 = __toESM(require_jsx_runtime(), 1);
var import_classnames15 = __toESM(require_classnames(), 1);
var React13 = __toESM(require_react(), 1);
var namedClassNamesSoThatICanGrepForThis = {
  normal: "tlui-button__normal",
  primary: "tlui-button__primary",
  danger: "tlui-button__danger",
  low: "tlui-button__low",
  icon: "tlui-button__icon",
  tool: "tlui-button__tool",
  menu: "tlui-button__menu",
  help: "tlui-button__help"
};
var TldrawUiButton = React13.forwardRef(
  function TldrawUiButton2({ children, type, htmlButtonType, isActive: isActive2, ...props }, ref) {
    return (0, import_jsx_runtime43.jsx)(
      "button",
      {
        ref,
        type: htmlButtonType || "button",
        draggable: false,
        "data-isactive": isActive2,
        ...props,
        className: (0, import_classnames15.default)(
          "tlui-button",
          namedClassNamesSoThatICanGrepForThis[type],
          props.className
        ),
        children
      }
    );
  }
);

// ../node_modules/tldraw/dist-esm/lib/ui/components/A11y.mjs
function SkipToMainContent() {
  const editor = useEditor();
  const msg2 = useTranslation();
  const button = (0, import_react54.useRef)(null);
  const handleNavigateToFirstShape = (0, import_react54.useCallback)(
    (e) => {
      var _a6;
      editor.markEventAsHandled(e);
      (_a6 = button.current) == null ? void 0 : _a6.blur();
      const shapes = editor.getCurrentPageShapesInReadingOrder();
      if (!shapes.length) return;
      editor.setSelectedShapes([shapes[0].id]);
      editor.zoomToSelectionIfOffscreen(256, {
        animation: {
          duration: editor.options.animationMediumMs
        },
        inset: 0
      });
      editor.timers.setTimeout(() => editor.getContainer().focus(), 100);
    },
    [editor]
  );
  return (0, import_jsx_runtime44.jsx)(
    TldrawUiButton,
    {
      ref: button,
      type: "low",
      tabIndex: 0,
      className: "tl-skip-to-main-content",
      onClick: handleNavigateToFirstShape,
      children: msg2("a11y.skip-to-main-content")
    }
  );
}
var DefaultA11yAnnouncer = (0, import_react54.memo)(function TldrawUiA11yAnnouncer() {
  const a11y = useA11y();
  const translation = useTranslation();
  const msg2 = useValue("a11y-msg", () => a11y.currentMsg.get(), []);
  useA11yDebug(msg2.msg);
  useSelectedShapesAnnouncer();
  return msg2.msg && (0, import_jsx_runtime44.jsx)(
    "div",
    {
      "aria-label": translation("a11y.status"),
      "aria-live": msg2.priority || "assertive",
      role: "status",
      "aria-hidden": "false",
      style: {
        position: "absolute",
        top: "-10000px",
        left: "-10000px"
      },
      children: msg2.msg
    }
  );
});
function generateShapeAnnouncementMessage(args) {
  const { editor, selectedShapeIds, msg: msg2 } = args;
  let a11yLive = "";
  const numShapes = selectedShapeIds.length;
  if (numShapes > 1) {
    a11yLive = msg2("a11y.multiple-shapes").replace("{num}", numShapes.toString());
  } else if (numShapes === 1) {
    const shapeId = selectedShapeIds[0];
    const shape = editor.getShape(shapeId);
    if (!shape) return "";
    const shapeUtil = editor.getShapeUtil(shape.type);
    const isMedia = ["image", "video"].includes(shape.type);
    let shapeType = "";
    if (shape.type === "geo") {
      shapeType = msg2(`geo-style.${shape.props.geo}`);
    } else if (isMedia) {
      shapeType = msg2(`a11y.shape-${shape.type}`);
    } else {
      shapeType = msg2(`tool.${shape.type}`);
    }
    const readingOrderShapes = editor.getCurrentPageShapesInReadingOrder();
    const currentShapeIndex = (readingOrderShapes.findIndex((s) => s.id === shapeId) + 1).toString();
    const totalShapes = readingOrderShapes.length.toString();
    const shapeIndex = msg2("a11y.shape-index").replace("{num}", currentShapeIndex).replace("{total}", totalShapes);
    const describingText = shapeUtil.getAriaDescriptor(shape) || shapeUtil.getText(shape) || "";
    a11yLive = (describingText ? `${describingText}, ` : "") + `${shapeType}. ${shapeIndex}`;
  }
  return a11yLive;
}
var useSelectedShapesAnnouncer = () => {
  const editor = useMaybeEditor();
  const a11y = useA11y();
  const msg2 = useTranslation();
  const rPrevSelectedShapeIds = (0, import_react54.useRef)([]);
  useReactor(
    "announce selection",
    () => {
      if (!editor) return;
      const isInSelecting = editor.isIn("select.idle");
      if (isInSelecting) {
        const selectedShapeIds = editor.getSelectedShapeIds();
        if (selectedShapeIds !== rPrevSelectedShapeIds.current) {
          rPrevSelectedShapeIds.current = selectedShapeIds;
          unsafe__withoutCapture(() => {
            const a11yLive = generateShapeAnnouncementMessage({
              editor,
              selectedShapeIds,
              msg: msg2
            });
            if (a11yLive) {
              a11y.announce({ msg: a11yLive });
            }
          });
        }
      }
    },
    [editor, a11y, msg2]
  );
};
var useA11yDebug = (msg2) => {
  const container = useContainer();
  (0, import_react54.useEffect)(() => {
    if (debugFlags.a11y.get()) {
      const log = (msg22) => {
        console.debug(
          `%ca11y%c: ${msg22}`,
          `color: white; background: #40C057; padding: 2px;border-radius: 3px;`,
          "font-weight: normal"
        );
      };
      const handleKeyUp = (e) => {
        const el = document.activeElement;
        if (e.key === "Tab" && el && el !== document.body && !el.classList.contains("tl-container")) {
          const label = el.getAttribute("aria-label") || el.getAttribute("title") || el.textContent;
          if (label) {
            log(label);
          }
        }
      };
      if (msg2) {
        log(msg2);
      }
      document.addEventListener("keyup", handleKeyUp);
      return () => document.removeEventListener("keyup", handleKeyUp);
    }
  }, [container, msg2]);
};

// ../node_modules/tldraw/dist-esm/lib/ui/components/AccessibilityMenu.mjs
var import_jsx_runtime186 = __toESM(require_jsx_runtime(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/components/menu-items.mjs
var import_jsx_runtime185 = __toESM(require_jsx_runtime(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/context/actions.mjs
var import_jsx_runtime183 = __toESM(require_jsx_runtime(), 1);
var React97 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/shapes/bookmark/bookmarks.mjs
var BOOKMARK_WIDTH = 300;
var BOOKMARK_HEIGHT = 320;
var BOOKMARK_JUST_URL_HEIGHT = 46;
var SHORT_BOOKMARK_HEIGHT = 101;
function getBookmarkHeight(editor, assetId) {
  const asset = assetId ? editor.getAsset(assetId) : null;
  if (asset) {
    if (!asset.props.image) {
      if (!asset.props.title) {
        return BOOKMARK_JUST_URL_HEIGHT;
      } else {
        return SHORT_BOOKMARK_HEIGHT;
      }
    }
  }
  return BOOKMARK_HEIGHT;
}
function setBookmarkHeight(editor, shape) {
  return {
    ...shape,
    props: { ...shape.props, h: getBookmarkHeight(editor, shape.props.assetId) }
  };
}
var getHumanReadableAddress = (url) => {
  try {
    const objUrl = new URL(url);
    return objUrl.hostname.replace(/^www\./, "");
  } catch {
    return url;
  }
};
function updateBookmarkAssetOnUrlChange(editor, shape) {
  const { url } = shape.props;
  const assetId = AssetRecordType.createId(getHashForString(url));
  if (editor.getAsset(assetId)) {
    if (shape.props.assetId !== assetId) {
      editor.updateShapes([
        {
          id: shape.id,
          type: shape.type,
          props: { assetId }
        }
      ]);
    }
  } else {
    editor.updateShapes([
      {
        id: shape.id,
        type: shape.type,
        props: { assetId: null }
      }
    ]);
    createBookmarkAssetOnUrlChange(editor, shape);
  }
}
var createBookmarkAssetOnUrlChange = debounce(async (editor, shape) => {
  if (editor.isDisposed) return;
  const { url } = shape.props;
  const asset = await editor.getAssetForExternalContent({ type: "url", url });
  if (!asset) {
    return;
  }
  editor.run(() => {
    editor.createAssets([asset]);
    editor.updateShapes([
      {
        id: shape.id,
        type: shape.type,
        props: { assetId: asset.id }
      }
    ]);
  });
}, 500);
async function createBookmarkFromUrl(editor, {
  url,
  center = editor.getViewportPageBounds().center
}) {
  try {
    const asset = await editor.getAssetForExternalContent({ type: "url", url });
    const shapeId = createShapeId();
    const shapePartial = {
      id: shapeId,
      type: "bookmark",
      x: center.x - BOOKMARK_WIDTH / 2,
      y: center.y - BOOKMARK_HEIGHT / 2,
      rotation: 0,
      opacity: 1,
      props: {
        url,
        assetId: (asset == null ? void 0 : asset.id) || null,
        w: BOOKMARK_WIDTH,
        h: getBookmarkHeight(editor, asset == null ? void 0 : asset.id)
      }
    };
    editor.run(() => {
      if (asset) {
        editor.createAssets([asset]);
      }
      editor.createShapes([shapePartial]);
    });
    const createdShape = editor.getShape(shapeId);
    return Result.ok(createdShape);
  } catch (error) {
    return Result.err(error instanceof Error ? error.message : "Failed to create bookmark");
  }
}

// ../node_modules/tldraw/dist-esm/lib/utils/frames/frames.mjs
function removeFrame(editor, ids) {
  const frames = compact(
    ids.map((id) => editor.getShape(id)).filter((f) => f && editor.isShapeOfType(f, "frame"))
  );
  if (!frames.length) return;
  const allChildren = [];
  editor.run(() => {
    frames.map((frame) => {
      const children = editor.getSortedChildIdsForParent(frame.id);
      if (children.length) {
        kickoutOccludedShapes(editor, children, {
          filter: (s) => !frames.find((f) => f.id === s.id)
        });
        allChildren.push(...children);
      }
    });
    editor.setSelectedShapes(allChildren);
    editor.deleteShapes(ids);
  });
}
var DEFAULT_FRAME_PADDING = 50;
function getFrameChildrenBounds(children, editor, opts = { padding: DEFAULT_FRAME_PADDING }) {
  const bounds = Box.FromPoints(
    children.flatMap((shape) => {
      if (!shape) return [];
      const geometry = editor.getShapeGeometry(shape.id);
      const transform = editor.getShapeLocalTransform(shape);
      return (transform == null ? void 0 : transform.applyToPoints(geometry.vertices)) ?? [];
    })
  );
  const padding = opts.padding ?? DEFAULT_FRAME_PADDING;
  const w = bounds.w + 2 * padding;
  const h2 = bounds.h + 2 * padding;
  const dx = padding - bounds.minX;
  const dy = padding - bounds.minY;
  return { w, h: h2, dx, dy };
}
function fitFrameToContent(editor, id, opts = {}) {
  const frame = editor.getShape(id);
  if (!frame) return;
  const childIds = editor.getSortedChildIdsForParent(frame.id);
  const children = compact(childIds.map((id2) => editor.getShape(id2)));
  if (!children.length) return;
  const { w, h: h2, dx, dy } = getFrameChildrenBounds(children, editor, opts);
  if (dx === 0 && dy === 0 && frame.props.w === w && frame.props.h === h2) return;
  const diff = new Vec(dx, dy).rot(frame.rotation);
  editor.run(() => {
    const changes = childIds.map((child) => {
      const shape = editor.getShape(child);
      return {
        id: shape.id,
        type: shape.type,
        x: shape.x + dx,
        y: shape.y + dy
      };
    });
    changes.push({
      id: frame.id,
      type: frame.type,
      x: frame.x - diff.x,
      y: frame.y - diff.y,
      props: {
        w,
        h: h2
      }
    });
    editor.updateShapes(changes);
  });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/EditLinkDialog.mjs
var import_jsx_runtime96 = __toESM(require_jsx_runtime(), 1);
var import_react64 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/components/primitives/Button/TldrawUiButtonLabel.mjs
var import_jsx_runtime45 = __toESM(require_jsx_runtime(), 1);
function TldrawUiButtonLabel({ children }) {
  return (0, import_jsx_runtime45.jsx)("span", { className: "tlui-button__label", children });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/primitives/TldrawUiDialog.mjs
var import_jsx_runtime94 = __toESM(require_jsx_runtime(), 1);
var import_classnames17 = __toESM(require_classnames(), 1);

// ../node_modules/@radix-ui/react-accessible-icon/dist/index.mjs
var React18 = __toESM(require_react(), 1);

// ../node_modules/@radix-ui/react-visually-hidden/dist/index.mjs
var React17 = __toESM(require_react(), 1);

// ../node_modules/@radix-ui/react-primitive/dist/index.mjs
var React16 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);

// ../node_modules/@radix-ui/react-slot/dist/index.mjs
var dist_exports = {};
__export(dist_exports, {
  Root: () => Slot,
  Slot: () => Slot,
  Slottable: () => Slottable,
  createSlot: () => createSlot,
  createSlottable: () => createSlottable
});
var React15 = __toESM(require_react(), 1);

// ../node_modules/@radix-ui/react-compose-refs/dist/index.mjs
var React14 = __toESM(require_react(), 1);
function setRef(ref, value) {
  if (typeof ref === "function") {
    return ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef(ref, node);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i = 0; i < cleanups.length; i++) {
          const cleanup = cleanups[i];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef(refs[i], null);
          }
        }
      };
    }
  };
}
function useComposedRefs(...refs) {
  return React14.useCallback(composeRefs(...refs), refs);
}

// ../node_modules/@radix-ui/react-slot/dist/index.mjs
var import_jsx_runtime46 = __toESM(require_jsx_runtime(), 1);
function createSlot(ownerName) {
  const SlotClone = createSlotClone(ownerName);
  const Slot22 = React15.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = React15.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React15.Children.count(newElement) > 1) return React15.Children.only(null);
          return React15.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return (0, import_jsx_runtime46.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React15.isValidElement(newElement) ? React15.cloneElement(newElement, void 0, newChildren) : null });
    }
    return (0, import_jsx_runtime46.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot22.displayName = `${ownerName}.Slot`;
  return Slot22;
}
var Slot = createSlot("Slot");
function createSlotClone(ownerName) {
  const SlotClone = React15.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (React15.isValidElement(children)) {
      const childrenRef = getElementRef(children);
      const props2 = mergeProps(slotProps, children.props);
      if (children.type !== React15.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return React15.cloneElement(children, props2);
    }
    return React15.Children.count(children) > 1 ? React15.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
function createSlottable(ownerName) {
  const Slottable22 = ({ children }) => {
    return (0, import_jsx_runtime46.jsx)(import_jsx_runtime46.Fragment, { children });
  };
  Slottable22.displayName = `${ownerName}.Slottable`;
  Slottable22.__radixId = SLOTTABLE_IDENTIFIER;
  return Slottable22;
}
var Slottable = createSlottable("Slottable");
function isSlottable(child) {
  return React15.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef(element) {
  var _a6, _b3;
  let getter = (_a6 = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a6.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b3 = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b3.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// ../node_modules/@radix-ui/react-primitive/dist/index.mjs
var import_jsx_runtime47 = __toESM(require_jsx_runtime(), 1);
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Slot6 = createSlot(`Primitive.${node}`);
  const Node4 = React16.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot6 : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return (0, import_jsx_runtime47.jsx)(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node4.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node4 };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
  if (target) ReactDOM.flushSync(() => target.dispatchEvent(event));
}
var Root = Primitive;

// ../node_modules/@radix-ui/react-visually-hidden/dist/index.mjs
var import_jsx_runtime48 = __toESM(require_jsx_runtime(), 1);
var VISUALLY_HIDDEN_STYLES = Object.freeze({
  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
});
var NAME = "VisuallyHidden";
var VisuallyHidden = React17.forwardRef(
  (props, forwardedRef) => {
    return (0, import_jsx_runtime48.jsx)(
      Primitive.span,
      {
        ...props,
        ref: forwardedRef,
        style: { ...VISUALLY_HIDDEN_STYLES, ...props.style }
      }
    );
  }
);
VisuallyHidden.displayName = NAME;
var Root2 = VisuallyHidden;

// ../node_modules/@radix-ui/react-accessible-icon/dist/index.mjs
var import_jsx_runtime49 = __toESM(require_jsx_runtime(), 1);
var NAME2 = "AccessibleIcon";
var AccessibleIcon = ({ children, label }) => {
  const child = React18.Children.only(children);
  return (0, import_jsx_runtime49.jsxs)(import_jsx_runtime49.Fragment, { children: [
    React18.cloneElement(child, {
      // accessibility
      "aria-hidden": "true",
      focusable: "false"
      // See: https://allyjs.io/tutorials/focusing-in-svg.html#making-svg-elements-focusable
    }),
    (0, import_jsx_runtime49.jsx)(Root2, { children: label })
  ] });
};
AccessibleIcon.displayName = NAME2;

// ../node_modules/@radix-ui/react-accordion/dist/index.mjs
var import_react57 = __toESM(require_react(), 1);

// ../node_modules/@radix-ui/react-context/dist/index.mjs
var React19 = __toESM(require_react(), 1);
var import_jsx_runtime50 = __toESM(require_jsx_runtime(), 1);
function createContext22(rootComponentName, defaultContext) {
  const Context2 = React19.createContext(defaultContext);
  const Provider3 = (props) => {
    const { children, ...context } = props;
    const value = React19.useMemo(() => context, Object.values(context));
    return (0, import_jsx_runtime50.jsx)(Context2.Provider, { value, children });
  };
  Provider3.displayName = rootComponentName + "Provider";
  function useContext27(consumerName) {
    const context = React19.useContext(Context2);
    if (context) return context;
    if (defaultContext !== void 0) return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  return [Provider3, useContext27];
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext33(rootComponentName, defaultContext) {
    const BaseContext = React19.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider3 = (props) => {
      var _a6;
      const { scope, children, ...context } = props;
      const Context2 = ((_a6 = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a6[index2]) || BaseContext;
      const value = React19.useMemo(() => context, Object.values(context));
      return (0, import_jsx_runtime50.jsx)(Context2.Provider, { value, children });
    };
    Provider3.displayName = rootComponentName + "Provider";
    function useContext27(consumerName, scope) {
      var _a6;
      const Context2 = ((_a6 = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a6[index2]) || BaseContext;
      const context = React19.useContext(Context2);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider3, useContext27];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return React19.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope == null ? void 0 : scope[scopeName]) || scopeContexts;
      return React19.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext33, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return React19.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}

// ../node_modules/@radix-ui/react-collection/dist/index.mjs
var import_react55 = __toESM(require_react(), 1);
var import_jsx_runtime51 = __toESM(require_jsx_runtime(), 1);
var import_react56 = __toESM(require_react(), 1);
var import_jsx_runtime52 = __toESM(require_jsx_runtime(), 1);
function createCollection(name) {
  const PROVIDER_NAME3 = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope10] = createContextScope(PROVIDER_NAME3);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(
    PROVIDER_NAME3,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  );
  const CollectionProvider = (props) => {
    const { scope, children } = props;
    const ref = import_react55.default.useRef(null);
    const itemMap = import_react55.default.useRef(/* @__PURE__ */ new Map()).current;
    return (0, import_jsx_runtime51.jsx)(CollectionProviderImpl, { scope, itemMap, collectionRef: ref, children });
  };
  CollectionProvider.displayName = PROVIDER_NAME3;
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlotImpl = createSlot(COLLECTION_SLOT_NAME);
  const CollectionSlot = import_react55.default.forwardRef(
    (props, forwardedRef) => {
      const { scope, children } = props;
      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);
      return (0, import_jsx_runtime51.jsx)(CollectionSlotImpl, { ref: composedRefs, children });
    }
  );
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlotImpl = createSlot(ITEM_SLOT_NAME);
  const CollectionItemSlot = import_react55.default.forwardRef(
    (props, forwardedRef) => {
      const { scope, children, ...itemData } = props;
      const ref = import_react55.default.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, ref);
      const context = useCollectionContext(ITEM_SLOT_NAME, scope);
      import_react55.default.useEffect(() => {
        context.itemMap.set(ref, { ref, ...itemData });
        return () => void context.itemMap.delete(ref);
      });
      return (0, import_jsx_runtime51.jsx)(CollectionItemSlotImpl, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
    }
  );
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useCollection10(scope) {
    const context = useCollectionContext(name + "CollectionConsumer", scope);
    const getItems = import_react55.default.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode) return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort(
        (a, b) => orderedNodes.indexOf(a.ref.current) - orderedNodes.indexOf(b.ref.current)
      );
      return orderedItems;
    }, [context.collectionRef, context.itemMap]);
    return getItems;
  }
  return [
    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
    useCollection10,
    createCollectionScope10
  ];
}
var __instanciated = /* @__PURE__ */ new WeakMap();
var _keys, _a4;
var OrderedDict = (_a4 = class extends Map {
  constructor(entries) {
    super(entries);
    __privateAdd(this, _keys);
    __privateSet(this, _keys, [...super.keys()]);
    __instanciated.set(this, true);
  }
  set(key, value) {
    if (__instanciated.get(this)) {
      if (this.has(key)) {
        __privateGet(this, _keys)[__privateGet(this, _keys).indexOf(key)] = key;
      } else {
        __privateGet(this, _keys).push(key);
      }
    }
    super.set(key, value);
    return this;
  }
  insert(index2, key, value) {
    const has = this.has(key);
    const length = __privateGet(this, _keys).length;
    const relativeIndex = toSafeInteger(index2);
    let actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;
    const safeIndex = actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;
    if (safeIndex === this.size || has && safeIndex === this.size - 1 || safeIndex === -1) {
      this.set(key, value);
      return this;
    }
    const size4 = this.size + (has ? 0 : 1);
    if (relativeIndex < 0) {
      actualIndex++;
    }
    const keys3 = [...__privateGet(this, _keys)];
    let nextValue;
    let shouldSkip = false;
    for (let i = actualIndex; i < size4; i++) {
      if (actualIndex === i) {
        let nextKey = keys3[i];
        if (keys3[i] === key) {
          nextKey = keys3[i + 1];
        }
        if (has) {
          this.delete(key);
        }
        nextValue = this.get(nextKey);
        this.set(key, value);
      } else {
        if (!shouldSkip && keys3[i - 1] === key) {
          shouldSkip = true;
        }
        const currentKey = keys3[shouldSkip ? i : i - 1];
        const currentValue = nextValue;
        nextValue = this.get(currentKey);
        this.delete(currentKey);
        this.set(currentKey, currentValue);
      }
    }
    return this;
  }
  with(index2, key, value) {
    const copy2 = new _a4(this);
    copy2.insert(index2, key, value);
    return copy2;
  }
  before(key) {
    const index2 = __privateGet(this, _keys).indexOf(key) - 1;
    if (index2 < 0) {
      return void 0;
    }
    return this.entryAt(index2);
  }
  /**
   * Sets a new key-value pair at the position before the given key.
   */
  setBefore(key, newKey, value) {
    const index2 = __privateGet(this, _keys).indexOf(key);
    if (index2 === -1) {
      return this;
    }
    return this.insert(index2, newKey, value);
  }
  after(key) {
    let index2 = __privateGet(this, _keys).indexOf(key);
    index2 = index2 === -1 || index2 === this.size - 1 ? -1 : index2 + 1;
    if (index2 === -1) {
      return void 0;
    }
    return this.entryAt(index2);
  }
  /**
   * Sets a new key-value pair at the position after the given key.
   */
  setAfter(key, newKey, value) {
    const index2 = __privateGet(this, _keys).indexOf(key);
    if (index2 === -1) {
      return this;
    }
    return this.insert(index2 + 1, newKey, value);
  }
  first() {
    return this.entryAt(0);
  }
  last() {
    return this.entryAt(-1);
  }
  clear() {
    __privateSet(this, _keys, []);
    return super.clear();
  }
  delete(key) {
    const deleted = super.delete(key);
    if (deleted) {
      __privateGet(this, _keys).splice(__privateGet(this, _keys).indexOf(key), 1);
    }
    return deleted;
  }
  deleteAt(index2) {
    const key = this.keyAt(index2);
    if (key !== void 0) {
      return this.delete(key);
    }
    return false;
  }
  at(index2) {
    const key = at(__privateGet(this, _keys), index2);
    if (key !== void 0) {
      return this.get(key);
    }
  }
  entryAt(index2) {
    const key = at(__privateGet(this, _keys), index2);
    if (key !== void 0) {
      return [key, this.get(key)];
    }
  }
  indexOf(key) {
    return __privateGet(this, _keys).indexOf(key);
  }
  keyAt(index2) {
    return at(__privateGet(this, _keys), index2);
  }
  from(key, offset4) {
    const index2 = this.indexOf(key);
    if (index2 === -1) {
      return void 0;
    }
    let dest = index2 + offset4;
    if (dest < 0) dest = 0;
    if (dest >= this.size) dest = this.size - 1;
    return this.at(dest);
  }
  keyFrom(key, offset4) {
    const index2 = this.indexOf(key);
    if (index2 === -1) {
      return void 0;
    }
    let dest = index2 + offset4;
    if (dest < 0) dest = 0;
    if (dest >= this.size) dest = this.size - 1;
    return this.keyAt(dest);
  }
  find(predicate, thisArg) {
    let index2 = 0;
    for (const entry of this) {
      if (Reflect.apply(predicate, thisArg, [entry, index2, this])) {
        return entry;
      }
      index2++;
    }
    return void 0;
  }
  findIndex(predicate, thisArg) {
    let index2 = 0;
    for (const entry of this) {
      if (Reflect.apply(predicate, thisArg, [entry, index2, this])) {
        return index2;
      }
      index2++;
    }
    return -1;
  }
  filter(predicate, thisArg) {
    const entries = [];
    let index2 = 0;
    for (const entry of this) {
      if (Reflect.apply(predicate, thisArg, [entry, index2, this])) {
        entries.push(entry);
      }
      index2++;
    }
    return new _a4(entries);
  }
  map(callbackfn, thisArg) {
    const entries = [];
    let index2 = 0;
    for (const entry of this) {
      entries.push([entry[0], Reflect.apply(callbackfn, thisArg, [entry, index2, this])]);
      index2++;
    }
    return new _a4(entries);
  }
  reduce(...args) {
    const [callbackfn, initialValue] = args;
    let index2 = 0;
    let accumulator = initialValue ?? this.at(0);
    for (const entry of this) {
      if (index2 === 0 && args.length === 1) {
        accumulator = entry;
      } else {
        accumulator = Reflect.apply(callbackfn, this, [accumulator, entry, index2, this]);
      }
      index2++;
    }
    return accumulator;
  }
  reduceRight(...args) {
    const [callbackfn, initialValue] = args;
    let accumulator = initialValue ?? this.at(-1);
    for (let index2 = this.size - 1; index2 >= 0; index2--) {
      const entry = this.at(index2);
      if (index2 === this.size - 1 && args.length === 1) {
        accumulator = entry;
      } else {
        accumulator = Reflect.apply(callbackfn, this, [accumulator, entry, index2, this]);
      }
    }
    return accumulator;
  }
  toSorted(compareFn) {
    const entries = [...this.entries()].sort(compareFn);
    return new _a4(entries);
  }
  toReversed() {
    const reversed = new _a4();
    for (let index2 = this.size - 1; index2 >= 0; index2--) {
      const key = this.keyAt(index2);
      const element = this.get(key);
      reversed.set(key, element);
    }
    return reversed;
  }
  toSpliced(...args) {
    const entries = [...this.entries()];
    entries.splice(...args);
    return new _a4(entries);
  }
  slice(start, end) {
    const result = new _a4();
    let stop = this.size - 1;
    if (start === void 0) {
      return result;
    }
    if (start < 0) {
      start = start + this.size;
    }
    if (end !== void 0 && end > 0) {
      stop = end - 1;
    }
    for (let index2 = start; index2 <= stop; index2++) {
      const key = this.keyAt(index2);
      const element = this.get(key);
      result.set(key, element);
    }
    return result;
  }
  every(predicate, thisArg) {
    let index2 = 0;
    for (const entry of this) {
      if (!Reflect.apply(predicate, thisArg, [entry, index2, this])) {
        return false;
      }
      index2++;
    }
    return true;
  }
  some(predicate, thisArg) {
    let index2 = 0;
    for (const entry of this) {
      if (Reflect.apply(predicate, thisArg, [entry, index2, this])) {
        return true;
      }
      index2++;
    }
    return false;
  }
}, _keys = new WeakMap(), _a4);
function at(array, index2) {
  if ("at" in Array.prototype) {
    return Array.prototype.at.call(array, index2);
  }
  const actualIndex = toSafeIndex(array, index2);
  return actualIndex === -1 ? void 0 : array[actualIndex];
}
function toSafeIndex(array, index2) {
  const length = array.length;
  const relativeIndex = toSafeInteger(index2);
  const actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;
  return actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;
}
function toSafeInteger(number) {
  return number !== number || number === 0 ? 0 : Math.trunc(number);
}
function createCollection2(name) {
  const PROVIDER_NAME3 = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope10] = createContextScope(PROVIDER_NAME3);
  const [CollectionContextProvider, useCollectionContext] = createCollectionContext(
    PROVIDER_NAME3,
    {
      collectionElement: null,
      collectionRef: { current: null },
      collectionRefObject: { current: null },
      itemMap: new OrderedDict(),
      setItemMap: () => void 0
    }
  );
  const CollectionProvider = ({ state, ...props }) => {
    return state ? (0, import_jsx_runtime52.jsx)(CollectionProviderImpl, { ...props, state }) : (0, import_jsx_runtime52.jsx)(CollectionInit, { ...props });
  };
  CollectionProvider.displayName = PROVIDER_NAME3;
  const CollectionInit = (props) => {
    const state = useInitCollection2();
    return (0, import_jsx_runtime52.jsx)(CollectionProviderImpl, { ...props, state });
  };
  CollectionInit.displayName = PROVIDER_NAME3 + "Init";
  const CollectionProviderImpl = (props) => {
    const { scope, children, state } = props;
    const ref = import_react56.default.useRef(null);
    const [collectionElement, setCollectionElement] = import_react56.default.useState(
      null
    );
    const composeRefs2 = useComposedRefs(ref, setCollectionElement);
    const [itemMap, setItemMap] = state;
    import_react56.default.useEffect(() => {
      if (!collectionElement) return;
      const observer = getChildListObserver(() => {
      });
      observer.observe(collectionElement, {
        childList: true,
        subtree: true
      });
      return () => {
        observer.disconnect();
      };
    }, [collectionElement]);
    return (0, import_jsx_runtime52.jsx)(
      CollectionContextProvider,
      {
        scope,
        itemMap,
        setItemMap,
        collectionRef: composeRefs2,
        collectionRefObject: ref,
        collectionElement,
        children
      }
    );
  };
  CollectionProviderImpl.displayName = PROVIDER_NAME3 + "Impl";
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlotImpl = createSlot(COLLECTION_SLOT_NAME);
  const CollectionSlot = import_react56.default.forwardRef(
    (props, forwardedRef) => {
      const { scope, children } = props;
      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);
      return (0, import_jsx_runtime52.jsx)(CollectionSlotImpl, { ref: composedRefs, children });
    }
  );
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlotImpl = createSlot(ITEM_SLOT_NAME);
  const CollectionItemSlot = import_react56.default.forwardRef(
    (props, forwardedRef) => {
      const { scope, children, ...itemData } = props;
      const ref = import_react56.default.useRef(null);
      const [element, setElement] = import_react56.default.useState(null);
      const composedRefs = useComposedRefs(forwardedRef, ref, setElement);
      const context = useCollectionContext(ITEM_SLOT_NAME, scope);
      const { setItemMap } = context;
      const itemDataRef = import_react56.default.useRef(itemData);
      if (!shallowEqual(itemDataRef.current, itemData)) {
        itemDataRef.current = itemData;
      }
      const memoizedItemData = itemDataRef.current;
      import_react56.default.useEffect(() => {
        const itemData2 = memoizedItemData;
        setItemMap((map2) => {
          if (!element) {
            return map2;
          }
          if (!map2.has(element)) {
            map2.set(element, { ...itemData2, element });
            return map2.toSorted(sortByDocumentPosition);
          }
          return map2.set(element, { ...itemData2, element }).toSorted(sortByDocumentPosition);
        });
        return () => {
          setItemMap((map2) => {
            if (!element || !map2.has(element)) {
              return map2;
            }
            map2.delete(element);
            return new OrderedDict(map2);
          });
        };
      }, [element, memoizedItemData, setItemMap]);
      return (0, import_jsx_runtime52.jsx)(CollectionItemSlotImpl, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
    }
  );
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useInitCollection2() {
    return import_react56.default.useState(new OrderedDict());
  }
  function useCollection10(scope) {
    const { itemMap } = useCollectionContext(name + "CollectionConsumer", scope);
    return itemMap;
  }
  const functions = {
    createCollectionScope: createCollectionScope10,
    useCollection: useCollection10,
    useInitCollection: useInitCollection2
  };
  return [
    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
    functions
  ];
}
function shallowEqual(a, b) {
  if (a === b) return true;
  if (typeof a !== "object" || typeof b !== "object") return false;
  if (a == null || b == null) return false;
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  if (keysA.length !== keysB.length) return false;
  for (const key of keysA) {
    if (!Object.prototype.hasOwnProperty.call(b, key)) return false;
    if (a[key] !== b[key]) return false;
  }
  return true;
}
function isElementPreceding(a, b) {
  return !!(b.compareDocumentPosition(a) & Node.DOCUMENT_POSITION_PRECEDING);
}
function sortByDocumentPosition(a, b) {
  return !a[1].element || !b[1].element ? 0 : isElementPreceding(a[1].element, b[1].element) ? -1 : 1;
}
function getChildListObserver(callback) {
  const observer = new MutationObserver((mutationsList) => {
    for (const mutation of mutationsList) {
      if (mutation.type === "childList") {
        callback();
        return;
      }
    }
  });
  return observer;
}

// ../node_modules/@radix-ui/primitive/dist/index.mjs
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler == null ? void 0 : originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler == null ? void 0 : ourEventHandler(event);
    }
  };
}

// ../node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
var React24 = __toESM(require_react(), 1);

// ../node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs
var React21 = __toESM(require_react(), 1);
var useLayoutEffect22 = (globalThis == null ? void 0 : globalThis.document) ? React21.useLayoutEffect : () => {
};

// ../node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
var React25 = __toESM(require_react(), 1);

// ../node_modules/@radix-ui/react-use-effect-event/dist/index.mjs
var React23 = __toESM(require_react(), 1);
var useReactEffectEvent = React23[" useEffectEvent ".trim().toString()];
var useReactInsertionEffect = React23[" useInsertionEffect ".trim().toString()];
function useEffectEvent(callback) {
  if (typeof useReactEffectEvent === "function") {
    return useReactEffectEvent(callback);
  }
  const ref = React23.useRef(() => {
    throw new Error("Cannot call an event handler while rendering.");
  });
  if (typeof useReactInsertionEffect === "function") {
    useReactInsertionEffect(() => {
      ref.current = callback;
    });
  } else {
    useLayoutEffect22(() => {
      ref.current = callback;
    });
  }
  return React23.useMemo(() => (...args) => {
    var _a6;
    return (_a6 = ref.current) == null ? void 0 : _a6.call(ref, ...args);
  }, []);
}

// ../node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
var useInsertionEffect = React24[" useInsertionEffect ".trim().toString()] || useLayoutEffect22;
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {
  },
  caller
}) {
  const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState({
    defaultProp,
    onChange
  });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  if (true) {
    const isControlledRef = React24.useRef(prop !== void 0);
    React24.useEffect(() => {
      const wasControlled = isControlledRef.current;
      if (wasControlled !== isControlled) {
        const from2 = wasControlled ? "controlled" : "uncontrolled";
        const to = isControlled ? "controlled" : "uncontrolled";
        console.warn(
          `${caller} is changing from ${from2} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
        );
      }
      isControlledRef.current = isControlled;
    }, [isControlled, caller]);
  }
  const setValue = React24.useCallback(
    (nextValue) => {
      var _a6;
      if (isControlled) {
        const value2 = isFunction2(nextValue) ? nextValue(prop) : nextValue;
        if (value2 !== prop) {
          (_a6 = onChangeRef.current) == null ? void 0 : _a6.call(onChangeRef, value2);
        }
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, onChangeRef]
  );
  return [value, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const [value, setValue] = React24.useState(defaultProp);
  const prevValueRef = React24.useRef(value);
  const onChangeRef = React24.useRef(onChange);
  useInsertionEffect(() => {
    onChangeRef.current = onChange;
  }, [onChange]);
  React24.useEffect(() => {
    var _a6;
    if (prevValueRef.current !== value) {
      (_a6 = onChangeRef.current) == null ? void 0 : _a6.call(onChangeRef, value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef]);
  return [value, setValue, onChangeRef];
}
function isFunction2(value) {
  return typeof value === "function";
}
var SYNC_STATE = Symbol("RADIX:SYNC_STATE");

// ../node_modules/@radix-ui/react-collapsible/dist/index.mjs
var React29 = __toESM(require_react(), 1);

// ../node_modules/@radix-ui/react-presence/dist/index.mjs
var React26 = __toESM(require_react(), 1);
var React27 = __toESM(require_react(), 1);
function useStateMachine(initialState2, machine) {
  return React27.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState2);
}
var Presence = (props) => {
  const { present, children } = props;
  const presence = usePresence2(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : React26.Children.only(children);
  const ref = useComposedRefs(presence.ref, getElementRef2(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? React26.cloneElement(child, { ref }) : null;
};
Presence.displayName = "Presence";
function usePresence2(present) {
  const [node, setNode2] = React26.useState();
  const stylesRef = React26.useRef(null);
  const prevPresentRef = React26.useRef(present);
  const prevAnimationNameRef = React26.useRef("none");
  const initialState2 = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine(initialState2, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  React26.useEffect(() => {
    const currentAnimationName = getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect22(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName(styles);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || (styles == null ? void 0 : styles.display) === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect22(() => {
    if (node) {
      let timeoutId;
      const ownerWindow = node.ownerDocument.defaultView ?? window;
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(CSS.escape(event.animationName));
        if (event.target === node && isCurrentAnimation) {
          send("ANIMATION_END");
          if (!prevPresentRef.current) {
            const currentFillMode = node.style.animationFillMode;
            node.style.animationFillMode = "forwards";
            timeoutId = ownerWindow.setTimeout(() => {
              if (node.style.animationFillMode === "forwards") {
                node.style.animationFillMode = currentFillMode;
              }
            });
          }
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node) {
          prevAnimationNameRef.current = getAnimationName(stylesRef.current);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      return () => {
        ownerWindow.clearTimeout(timeoutId);
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: React26.useCallback((node2) => {
      stylesRef.current = node2 ? getComputedStyle(node2) : null;
      setNode2(node2);
    }, [])
  };
}
function getAnimationName(styles) {
  return (styles == null ? void 0 : styles.animationName) || "none";
}
function getElementRef2(element) {
  var _a6, _b3;
  let getter = (_a6 = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a6.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b3 = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b3.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// ../node_modules/@radix-ui/react-id/dist/index.mjs
var React28 = __toESM(require_react(), 1);
var useReactId = React28[" useId ".trim().toString()] || (() => void 0);
var count = 0;
function useId2(deterministicId) {
  const [id, setId] = React28.useState(useReactId());
  useLayoutEffect22(() => {
    if (!deterministicId) setId((reactId) => reactId ?? String(count++));
  }, [deterministicId]);
  return deterministicId || (id ? `radix-${id}` : "");
}

// ../node_modules/@radix-ui/react-collapsible/dist/index.mjs
var import_jsx_runtime53 = __toESM(require_jsx_runtime(), 1);
var COLLAPSIBLE_NAME = "Collapsible";
var [createCollapsibleContext, createCollapsibleScope] = createContextScope(COLLAPSIBLE_NAME);
var [CollapsibleProvider, useCollapsibleContext] = createCollapsibleContext(COLLAPSIBLE_NAME);
var Collapsible = React29.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeCollapsible,
      open: openProp,
      defaultOpen,
      disabled,
      onOpenChange,
      ...collapsibleProps
    } = props;
    const [open, setOpen] = useControllableState({
      prop: openProp,
      defaultProp: defaultOpen ?? false,
      onChange: onOpenChange,
      caller: COLLAPSIBLE_NAME
    });
    return (0, import_jsx_runtime53.jsx)(
      CollapsibleProvider,
      {
        scope: __scopeCollapsible,
        disabled,
        contentId: useId2(),
        open,
        onOpenToggle: React29.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
        children: (0, import_jsx_runtime53.jsx)(
          Primitive.div,
          {
            "data-state": getState(open),
            "data-disabled": disabled ? "" : void 0,
            ...collapsibleProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
Collapsible.displayName = COLLAPSIBLE_NAME;
var TRIGGER_NAME = "CollapsibleTrigger";
var CollapsibleTrigger = React29.forwardRef(
  (props, forwardedRef) => {
    const { __scopeCollapsible, ...triggerProps } = props;
    const context = useCollapsibleContext(TRIGGER_NAME, __scopeCollapsible);
    return (0, import_jsx_runtime53.jsx)(
      Primitive.button,
      {
        type: "button",
        "aria-controls": context.contentId,
        "aria-expanded": context.open || false,
        "data-state": getState(context.open),
        "data-disabled": context.disabled ? "" : void 0,
        disabled: context.disabled,
        ...triggerProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
  }
);
CollapsibleTrigger.displayName = TRIGGER_NAME;
var CONTENT_NAME = "CollapsibleContent";
var CollapsibleContent = React29.forwardRef(
  (props, forwardedRef) => {
    const { forceMount, ...contentProps } = props;
    const context = useCollapsibleContext(CONTENT_NAME, props.__scopeCollapsible);
    return (0, import_jsx_runtime53.jsx)(Presence, { present: forceMount || context.open, children: ({ present }) => (0, import_jsx_runtime53.jsx)(CollapsibleContentImpl, { ...contentProps, ref: forwardedRef, present }) });
  }
);
CollapsibleContent.displayName = CONTENT_NAME;
var CollapsibleContentImpl = React29.forwardRef((props, forwardedRef) => {
  const { __scopeCollapsible, present, children, ...contentProps } = props;
  const context = useCollapsibleContext(CONTENT_NAME, __scopeCollapsible);
  const [isPresent, setIsPresent] = React29.useState(present);
  const ref = React29.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const heightRef = React29.useRef(0);
  const height = heightRef.current;
  const widthRef = React29.useRef(0);
  const width = widthRef.current;
  const isOpen = context.open || isPresent;
  const isMountAnimationPreventedRef = React29.useRef(isOpen);
  const originalStylesRef = React29.useRef(void 0);
  React29.useEffect(() => {
    const rAF = requestAnimationFrame(() => isMountAnimationPreventedRef.current = false);
    return () => cancelAnimationFrame(rAF);
  }, []);
  useLayoutEffect22(() => {
    const node = ref.current;
    if (node) {
      originalStylesRef.current = originalStylesRef.current || {
        transitionDuration: node.style.transitionDuration,
        animationName: node.style.animationName
      };
      node.style.transitionDuration = "0s";
      node.style.animationName = "none";
      const rect = node.getBoundingClientRect();
      heightRef.current = rect.height;
      widthRef.current = rect.width;
      if (!isMountAnimationPreventedRef.current) {
        node.style.transitionDuration = originalStylesRef.current.transitionDuration;
        node.style.animationName = originalStylesRef.current.animationName;
      }
      setIsPresent(present);
    }
  }, [context.open, present]);
  return (0, import_jsx_runtime53.jsx)(
    Primitive.div,
    {
      "data-state": getState(context.open),
      "data-disabled": context.disabled ? "" : void 0,
      id: context.contentId,
      hidden: !isOpen,
      ...contentProps,
      ref: composedRefs,
      style: {
        [`--radix-collapsible-content-height`]: height ? `${height}px` : void 0,
        [`--radix-collapsible-content-width`]: width ? `${width}px` : void 0,
        ...props.style
      },
      children: isOpen && children
    }
  );
});
function getState(open) {
  return open ? "open" : "closed";
}
var Root3 = Collapsible;
var Trigger = CollapsibleTrigger;
var Content = CollapsibleContent;

// ../node_modules/@radix-ui/react-direction/dist/index.mjs
var React30 = __toESM(require_react(), 1);
var import_jsx_runtime54 = __toESM(require_jsx_runtime(), 1);
var DirectionContext = React30.createContext(void 0);
function useDirection(localDir) {
  const globalDir = React30.useContext(DirectionContext);
  return localDir || globalDir || "ltr";
}

// ../node_modules/@radix-ui/react-accordion/dist/index.mjs
var import_jsx_runtime55 = __toESM(require_jsx_runtime(), 1);
var ACCORDION_NAME = "Accordion";
var ACCORDION_KEYS = ["Home", "End", "ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight"];
var [Collection, useCollection, createCollectionScope] = createCollection(ACCORDION_NAME);
var [createAccordionContext, createAccordionScope] = createContextScope(ACCORDION_NAME, [
  createCollectionScope,
  createCollapsibleScope
]);
var useCollapsibleScope = createCollapsibleScope();
var Accordion = import_react57.default.forwardRef(
  (props, forwardedRef) => {
    const { type, ...accordionProps } = props;
    const singleProps = accordionProps;
    const multipleProps = accordionProps;
    return (0, import_jsx_runtime55.jsx)(Collection.Provider, { scope: props.__scopeAccordion, children: type === "multiple" ? (0, import_jsx_runtime55.jsx)(AccordionImplMultiple, { ...multipleProps, ref: forwardedRef }) : (0, import_jsx_runtime55.jsx)(AccordionImplSingle, { ...singleProps, ref: forwardedRef }) });
  }
);
Accordion.displayName = ACCORDION_NAME;
var [AccordionValueProvider, useAccordionValueContext] = createAccordionContext(ACCORDION_NAME);
var [AccordionCollapsibleProvider, useAccordionCollapsibleContext] = createAccordionContext(
  ACCORDION_NAME,
  { collapsible: false }
);
var AccordionImplSingle = import_react57.default.forwardRef(
  (props, forwardedRef) => {
    const {
      value: valueProp,
      defaultValue,
      onValueChange = () => {
      },
      collapsible = false,
      ...accordionSingleProps
    } = props;
    const [value, setValue] = useControllableState({
      prop: valueProp,
      defaultProp: defaultValue ?? "",
      onChange: onValueChange,
      caller: ACCORDION_NAME
    });
    return (0, import_jsx_runtime55.jsx)(
      AccordionValueProvider,
      {
        scope: props.__scopeAccordion,
        value: import_react57.default.useMemo(() => value ? [value] : [], [value]),
        onItemOpen: setValue,
        onItemClose: import_react57.default.useCallback(() => collapsible && setValue(""), [collapsible, setValue]),
        children: (0, import_jsx_runtime55.jsx)(AccordionCollapsibleProvider, { scope: props.__scopeAccordion, collapsible, children: (0, import_jsx_runtime55.jsx)(AccordionImpl, { ...accordionSingleProps, ref: forwardedRef }) })
      }
    );
  }
);
var AccordionImplMultiple = import_react57.default.forwardRef((props, forwardedRef) => {
  const {
    value: valueProp,
    defaultValue,
    onValueChange = () => {
    },
    ...accordionMultipleProps
  } = props;
  const [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue ?? [],
    onChange: onValueChange,
    caller: ACCORDION_NAME
  });
  const handleItemOpen = import_react57.default.useCallback(
    (itemValue) => setValue((prevValue = []) => [...prevValue, itemValue]),
    [setValue]
  );
  const handleItemClose = import_react57.default.useCallback(
    (itemValue) => setValue((prevValue = []) => prevValue.filter((value2) => value2 !== itemValue)),
    [setValue]
  );
  return (0, import_jsx_runtime55.jsx)(
    AccordionValueProvider,
    {
      scope: props.__scopeAccordion,
      value,
      onItemOpen: handleItemOpen,
      onItemClose: handleItemClose,
      children: (0, import_jsx_runtime55.jsx)(AccordionCollapsibleProvider, { scope: props.__scopeAccordion, collapsible: true, children: (0, import_jsx_runtime55.jsx)(AccordionImpl, { ...accordionMultipleProps, ref: forwardedRef }) })
    }
  );
});
var [AccordionImplProvider, useAccordionContext] = createAccordionContext(ACCORDION_NAME);
var AccordionImpl = import_react57.default.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAccordion, disabled, dir, orientation = "vertical", ...accordionProps } = props;
    const accordionRef = import_react57.default.useRef(null);
    const composedRefs = useComposedRefs(accordionRef, forwardedRef);
    const getItems = useCollection(__scopeAccordion);
    const direction = useDirection(dir);
    const isDirectionLTR = direction === "ltr";
    const handleKeyDown2 = composeEventHandlers(props.onKeyDown, (event) => {
      var _a6;
      if (!ACCORDION_KEYS.includes(event.key)) return;
      const target = event.target;
      const triggerCollection = getItems().filter((item) => {
        var _a7;
        return !((_a7 = item.ref.current) == null ? void 0 : _a7.disabled);
      });
      const triggerIndex = triggerCollection.findIndex((item) => item.ref.current === target);
      const triggerCount = triggerCollection.length;
      if (triggerIndex === -1) return;
      event.preventDefault();
      let nextIndex = triggerIndex;
      const homeIndex = 0;
      const endIndex = triggerCount - 1;
      const moveNext = () => {
        nextIndex = triggerIndex + 1;
        if (nextIndex > endIndex) {
          nextIndex = homeIndex;
        }
      };
      const movePrev = () => {
        nextIndex = triggerIndex - 1;
        if (nextIndex < homeIndex) {
          nextIndex = endIndex;
        }
      };
      switch (event.key) {
        case "Home":
          nextIndex = homeIndex;
          break;
        case "End":
          nextIndex = endIndex;
          break;
        case "ArrowRight":
          if (orientation === "horizontal") {
            if (isDirectionLTR) {
              moveNext();
            } else {
              movePrev();
            }
          }
          break;
        case "ArrowDown":
          if (orientation === "vertical") {
            moveNext();
          }
          break;
        case "ArrowLeft":
          if (orientation === "horizontal") {
            if (isDirectionLTR) {
              movePrev();
            } else {
              moveNext();
            }
          }
          break;
        case "ArrowUp":
          if (orientation === "vertical") {
            movePrev();
          }
          break;
      }
      const clampedIndex = nextIndex % triggerCount;
      (_a6 = triggerCollection[clampedIndex].ref.current) == null ? void 0 : _a6.focus();
    });
    return (0, import_jsx_runtime55.jsx)(
      AccordionImplProvider,
      {
        scope: __scopeAccordion,
        disabled,
        direction: dir,
        orientation,
        children: (0, import_jsx_runtime55.jsx)(Collection.Slot, { scope: __scopeAccordion, children: (0, import_jsx_runtime55.jsx)(
          Primitive.div,
          {
            ...accordionProps,
            "data-orientation": orientation,
            ref: composedRefs,
            onKeyDown: disabled ? void 0 : handleKeyDown2
          }
        ) })
      }
    );
  }
);
var ITEM_NAME = "AccordionItem";
var [AccordionItemProvider, useAccordionItemContext] = createAccordionContext(ITEM_NAME);
var AccordionItem = import_react57.default.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAccordion, value, ...accordionItemProps } = props;
    const accordionContext = useAccordionContext(ITEM_NAME, __scopeAccordion);
    const valueContext = useAccordionValueContext(ITEM_NAME, __scopeAccordion);
    const collapsibleScope = useCollapsibleScope(__scopeAccordion);
    const triggerId = useId2();
    const open = value && valueContext.value.includes(value) || false;
    const disabled = accordionContext.disabled || props.disabled;
    return (0, import_jsx_runtime55.jsx)(
      AccordionItemProvider,
      {
        scope: __scopeAccordion,
        open,
        disabled,
        triggerId,
        children: (0, import_jsx_runtime55.jsx)(
          Root3,
          {
            "data-orientation": accordionContext.orientation,
            "data-state": getState2(open),
            ...collapsibleScope,
            ...accordionItemProps,
            ref: forwardedRef,
            disabled,
            open,
            onOpenChange: (open2) => {
              if (open2) {
                valueContext.onItemOpen(value);
              } else {
                valueContext.onItemClose(value);
              }
            }
          }
        )
      }
    );
  }
);
AccordionItem.displayName = ITEM_NAME;
var HEADER_NAME = "AccordionHeader";
var AccordionHeader = import_react57.default.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAccordion, ...headerProps } = props;
    const accordionContext = useAccordionContext(ACCORDION_NAME, __scopeAccordion);
    const itemContext = useAccordionItemContext(HEADER_NAME, __scopeAccordion);
    return (0, import_jsx_runtime55.jsx)(
      Primitive.h3,
      {
        "data-orientation": accordionContext.orientation,
        "data-state": getState2(itemContext.open),
        "data-disabled": itemContext.disabled ? "" : void 0,
        ...headerProps,
        ref: forwardedRef
      }
    );
  }
);
AccordionHeader.displayName = HEADER_NAME;
var TRIGGER_NAME2 = "AccordionTrigger";
var AccordionTrigger = import_react57.default.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAccordion, ...triggerProps } = props;
    const accordionContext = useAccordionContext(ACCORDION_NAME, __scopeAccordion);
    const itemContext = useAccordionItemContext(TRIGGER_NAME2, __scopeAccordion);
    const collapsibleContext = useAccordionCollapsibleContext(TRIGGER_NAME2, __scopeAccordion);
    const collapsibleScope = useCollapsibleScope(__scopeAccordion);
    return (0, import_jsx_runtime55.jsx)(Collection.ItemSlot, { scope: __scopeAccordion, children: (0, import_jsx_runtime55.jsx)(
      Trigger,
      {
        "aria-disabled": itemContext.open && !collapsibleContext.collapsible || void 0,
        "data-orientation": accordionContext.orientation,
        id: itemContext.triggerId,
        ...collapsibleScope,
        ...triggerProps,
        ref: forwardedRef
      }
    ) });
  }
);
AccordionTrigger.displayName = TRIGGER_NAME2;
var CONTENT_NAME2 = "AccordionContent";
var AccordionContent = import_react57.default.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAccordion, ...contentProps } = props;
    const accordionContext = useAccordionContext(ACCORDION_NAME, __scopeAccordion);
    const itemContext = useAccordionItemContext(CONTENT_NAME2, __scopeAccordion);
    const collapsibleScope = useCollapsibleScope(__scopeAccordion);
    return (0, import_jsx_runtime55.jsx)(
      Content,
      {
        role: "region",
        "aria-labelledby": itemContext.triggerId,
        "data-orientation": accordionContext.orientation,
        ...collapsibleScope,
        ...contentProps,
        ref: forwardedRef,
        style: {
          ["--radix-accordion-content-height"]: "var(--radix-collapsible-content-height)",
          ["--radix-accordion-content-width"]: "var(--radix-collapsible-content-width)",
          ...props.style
        }
      }
    );
  }
);
AccordionContent.displayName = CONTENT_NAME2;
function getState2(open) {
  return open ? "open" : "closed";
}

// ../node_modules/@radix-ui/react-alert-dialog/dist/index.mjs
var React48 = __toESM(require_react(), 1);

// ../node_modules/@radix-ui/react-dialog/dist/index.mjs
var dist_exports4 = {};
__export(dist_exports4, {
  Close: () => Close,
  Content: () => Content2,
  Description: () => Description,
  Dialog: () => Dialog,
  DialogClose: () => DialogClose,
  DialogContent: () => DialogContent,
  DialogDescription: () => DialogDescription,
  DialogOverlay: () => DialogOverlay,
  DialogPortal: () => DialogPortal,
  DialogTitle: () => DialogTitle,
  DialogTrigger: () => DialogTrigger,
  Overlay: () => Overlay,
  Portal: () => Portal2,
  Root: () => Root5,
  Title: () => Title,
  Trigger: () => Trigger2,
  WarningProvider: () => WarningProvider,
  createDialogScope: () => createDialogScope
});
var React47 = __toESM(require_react(), 1);

// ../node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
var React34 = __toESM(require_react(), 1);

// ../node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs
var React32 = __toESM(require_react(), 1);
function useCallbackRef(callback) {
  const callbackRef = React32.useRef(callback);
  React32.useEffect(() => {
    callbackRef.current = callback;
  });
  return React32.useMemo(() => (...args) => {
    var _a6;
    return (_a6 = callbackRef.current) == null ? void 0 : _a6.call(callbackRef, ...args);
  }, []);
}

// ../node_modules/@radix-ui/react-use-escape-keydown/dist/index.mjs
var React33 = __toESM(require_react(), 1);
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const onEscapeKeyDown = useCallbackRef(onEscapeKeyDownProp);
  React33.useEffect(() => {
    const handleKeyDown2 = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown2, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown2, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}

// ../node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
var import_jsx_runtime56 = __toESM(require_jsx_runtime(), 1);
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = React34.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer = React34.forwardRef(
  (props, forwardedRef) => {
    const {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      ...layerProps
    } = props;
    const context = React34.useContext(DismissableLayerContext);
    const [node, setNode2] = React34.useState(null);
    const ownerDocument = (node == null ? void 0 : node.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document);
    const [, force] = React34.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode2(node2));
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index2 = node ? layers.indexOf(node) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
      onPointerDownOutside == null ? void 0 : onPointerDownOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    const focusOutside = useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch) return;
      onFocusOutside == null ? void 0 : onFocusOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    useEscapeKeydown((event) => {
      const isHighestLayer = index2 === context.layers.size - 1;
      if (!isHighestLayer) return;
      onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    React34.useEffect(() => {
      if (!node) return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node);
      }
      context.layers.add(node);
      dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [node, ownerDocument, disableOutsidePointerEvents, context]);
    React34.useEffect(() => {
      return () => {
        if (!node) return;
        context.layers.delete(node);
        context.layersWithOutsidePointerEventsDisabled.delete(node);
        dispatchUpdate();
      };
    }, [node, context]);
    React34.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return (0, import_jsx_runtime56.jsx)(
      Primitive.div,
      {
        ...layerProps,
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
          ...props.style
        },
        onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers(
          props.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      }
    );
  }
);
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = React34.forwardRef((props, forwardedRef) => {
  const context = React34.useContext(DismissableLayerContext);
  const ref = React34.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  React34.useEffect(() => {
    const node = ref.current;
    if (node) {
      context.branches.add(node);
      return () => {
        context.branches.delete(node);
      };
    }
  }, [context.branches]);
  return (0, import_jsx_runtime56.jsx)(Primitive.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handlePointerDownOutside = useCallbackRef(onPointerDownOutside);
  const isPointerInsideReactTreeRef = React34.useRef(false);
  const handleClickRef = React34.useRef(() => {
  });
  React34.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent(
            POINTER_DOWN_OUTSIDE,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        var handleAndDispatchPointerDownOutsideEvent = handleAndDispatchPointerDownOutsideEvent2;
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handleFocusOutside = useCallbackRef(onFocusOutside);
  const isFocusInsideReactTreeRef = React34.useRef(false);
  React34.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
  if (handler) target.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}
var Root4 = DismissableLayer;
var Branch = DismissableLayerBranch;

// ../node_modules/@radix-ui/react-focus-scope/dist/index.mjs
var React35 = __toESM(require_react(), 1);
var import_jsx_runtime57 = __toESM(require_jsx_runtime(), 1);
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = React35.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = React35.useState(null);
  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);
  const lastFocusedElementRef = React35.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
  const focusScope = React35.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  React35.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container) return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus2(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container) return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null) return;
        if (!container.contains(relatedTarget)) {
          focus2(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body) return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0) focus2(container);
        }
      };
      var handleFocusIn = handleFocusIn2, handleFocusOut = handleFocusOut2, handleMutations = handleMutations2;
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container) mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  React35.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus2(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus2(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown2 = React35.useCallback(
    (event) => {
      if (!loop && !trapped) return;
      if (focusScope.paused) return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first2, last2] = getTabbableEdges(container2);
        const hasTabbableElementsInside = first2 && last2;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2) event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last2) {
            event.preventDefault();
            if (loop) focus2(first2, { select: true });
          } else if (event.shiftKey && focusedElement === first2) {
            event.preventDefault();
            if (loop) focus2(last2, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return (0, import_jsx_runtime57.jsx)(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown2 });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus2(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement) return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first2 = findVisible(candidates, container);
  const last2 = findVisible(candidates.reverse(), container);
  return [first2, last2];
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container })) return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden") return true;
  while (node) {
    if (upTo !== void 0 && node === upTo) return false;
    if (getComputedStyle(node).display === "none") return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus2(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
      element.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack2 = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack2[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope == null ? void 0 : activeFocusScope.pause();
      }
      stack2 = arrayRemove(stack2, focusScope);
      stack2.unshift(focusScope);
    },
    remove(focusScope) {
      var _a6;
      stack2 = arrayRemove(stack2, focusScope);
      (_a6 = stack2[0]) == null ? void 0 : _a6.resume();
    }
  };
}
function arrayRemove(array, item) {
  const updatedArray = [...array];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1) {
    updatedArray.splice(index2, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}

// ../node_modules/@radix-ui/react-portal/dist/index.mjs
var React36 = __toESM(require_react(), 1);
var import_react_dom3 = __toESM(require_react_dom(), 1);
var import_jsx_runtime58 = __toESM(require_jsx_runtime(), 1);
var PORTAL_NAME = "Portal";
var Portal = React36.forwardRef((props, forwardedRef) => {
  var _a6;
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = React36.useState(false);
  useLayoutEffect22(() => setMounted(true), []);
  const container = containerProp || mounted && ((_a6 = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a6.body);
  return container ? import_react_dom3.default.createPortal((0, import_jsx_runtime58.jsx)(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal.displayName = PORTAL_NAME;

// ../node_modules/@radix-ui/react-focus-guards/dist/index.mjs
var React37 = __toESM(require_react(), 1);
var count2 = 0;
function useFocusGuards() {
  React37.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count2++;
    return () => {
      if (count2 === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count2--;
    };
  }, []);
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.outline = "none";
  element.style.opacity = "0";
  element.style.position = "fixed";
  element.style.pointerEvents = "none";
  return element;
}

// ../node_modules/tslib/tslib.es6.mjs
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t2[p] = s[p];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t2 = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from2.length, ar; i < l; i++) {
    if (ar || !(i in from2)) {
      if (!ar) ar = Array.prototype.slice.call(from2, 0, i);
      ar[i] = from2[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from2));
}

// ../node_modules/react-remove-scroll/dist/es2015/Combination.js
var React46 = __toESM(require_react());

// ../node_modules/react-remove-scroll/dist/es2015/UI.js
var React42 = __toESM(require_react());

// ../node_modules/react-remove-scroll-bar/dist/es2015/constants.js
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";

// ../node_modules/use-callback-ref/dist/es2015/assignRef.js
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}

// ../node_modules/use-callback-ref/dist/es2015/useRef.js
var import_react58 = __toESM(require_react());
function useCallbackRef2(initialValue, callback) {
  var ref = (0, import_react58.useState)(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last2 = ref.value;
          if (last2 !== value) {
            ref.value = value;
            ref.callback(value, last2);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}

// ../node_modules/use-callback-ref/dist/es2015/useMergeRef.js
var React38 = __toESM(require_react());
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? React38.useLayoutEffect : React38.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef2(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}

// ../node_modules/use-sidecar/dist/es2015/hoc.js
var React39 = __toESM(require_react());

// ../node_modules/use-sidecar/dist/es2015/hook.js
var import_react59 = __toESM(require_react());

// ../node_modules/use-sidecar/dist/es2015/medium.js
function ItoI(a) {
  return a;
}
function innerCreateMedium(defaults2, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults2;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x) {
          return x !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x) {
          return cb(x);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x) {
          pendingQueue.push(x);
          cycle();
        },
        filter: function(filter2) {
          pendingQueue = pendingQueue.filter(filter2);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options2);
  return medium;
}

// ../node_modules/use-sidecar/dist/es2015/renderProp.js
var React40 = __toESM(require_react());
var import_react60 = __toESM(require_react());

// ../node_modules/use-sidecar/dist/es2015/exports.js
var React41 = __toESM(require_react());
var SideCar = function(_a6) {
  var sideCar = _a6.sideCar, rest = __rest(_a6, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React41.createElement(Target, __assign({}, rest));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar;
}

// ../node_modules/react-remove-scroll/dist/es2015/medium.js
var effectCar = createSidecarMedium();

// ../node_modules/react-remove-scroll/dist/es2015/UI.js
var nothing = function() {
  return;
};
var RemoveScroll = React42.forwardRef(function(props, parentRef) {
  var ref = React42.useRef(null);
  var _a6 = React42.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a6[0], setCallbacks = _a6[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noRelative = props.noRelative, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b3 = props.as, Container = _b3 === void 0 ? "div" : _b3, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return React42.createElement(
    React42.Fragment,
    null,
    enabled && React42.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noRelative, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? React42.cloneElement(React42.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React42.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};

// ../node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var React45 = __toESM(require_react());

// ../node_modules/react-remove-scroll-bar/dist/es2015/component.js
var React44 = __toESM(require_react());

// ../node_modules/react-style-singleton/dist/es2015/hook.js
var React43 = __toESM(require_react());

// ../node_modules/get-nonce/dist/es2015/index.js
var currentNonce;
var getNonce = function() {
  if (currentNonce) {
    return currentNonce;
  }
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};

// ../node_modules/react-style-singleton/dist/es2015/singleton.js
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style2) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style2);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};

// ../node_modules/react-style-singleton/dist/es2015/hook.js
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React43.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};

// ../node_modules/react-style-singleton/dist/es2015/component.js
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a6) {
    var styles = _a6.styles, dynamic = _a6.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};

// ../node_modules/react-remove-scroll-bar/dist/es2015/utils.js
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse2 = function(x) {
  return parseInt(x || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse2(left), parse2(top), parse2(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};

// ../node_modules/react-remove-scroll-bar/dist/es2015/component.js
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a6, allowRelative, gapMode, important) {
  var left = _a6.left, top = _a6.top, right = _a6.right, gap = _a6.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  React44.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a6) {
  var noRelative = _a6.noRelative, noImportant = _a6.noImportant, _b3 = _a6.gapMode, gapMode = _b3 === void 0 ? "margin" : _b3;
  useLockAttribute();
  var gap = React44.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React44.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};

// ../node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    options2 = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options2, options2);
    window.removeEventListener("test", options2, options2);
  } catch (err) {
    passiveSupported = false;
  }
}
var options2;
var nonPassive = passiveSupported ? { passive: false } : false;

// ../node_modules/react-remove-scroll/dist/es2015/handleScroll.js
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  if (!(node instanceof Element)) {
    return false;
  }
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a6 = getScrollVariables(axis, current), scrollHeight = _a6[1], clientHeight = _a6[2];
      if (scrollHeight > clientHeight) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a6) {
  var scrollTop = _a6.scrollTop, scrollHeight = _a6.scrollHeight, clientHeight = _a6.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a6) {
  var scrollLeft = _a6.scrollLeft, scrollWidth = _a6.scrollWidth, clientWidth = _a6.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    if (!target) {
      break;
    }
    var _a6 = getScrollVariables(axis, target), position = _a6[0], scroll_1 = _a6[1], capacity = _a6[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    var parent_1 = target.parentNode;
    target = parent_1 && parent_1.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? parent_1.host : parent_1;
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};

// ../node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x, y) {
  return x[0] === y[0] && x[1] === y[1];
};
var generateStyle = function(id) {
  return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter2 = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React45.useRef([]);
  var touchStartRef = React45.useRef([0, 0]);
  var activeAxis = React45.useRef();
  var id = React45.useState(idCounter2++)[0];
  var Style2 = React45.useState(styleSingleton)[0];
  var lastProps = React45.useRef(props);
  React45.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React45.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React45.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var selection = window.getSelection();
    var anchorNode = selection && selection.anchorNode;
    var isTouchingSelection = anchorNode ? anchorNode === target || anchorNode.contains(target) : false;
    if (isTouchingSelection) {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React45.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e) {
      return e.name === event.type && (e.target === event.target || event.target === e.shadowParent) && deltaCompare(e.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React45.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e) {
        return e !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React45.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React45.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React45.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React45.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst3) {
        return inst3 !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React45.createElement(
    React45.Fragment,
    null,
    inert ? React45.createElement(Style2, { styles: generateStyle(id) }) : null,
    removeScrollBar ? React45.createElement(RemoveScrollBar, { noRelative: props.noRelative, gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}

// ../node_modules/react-remove-scroll/dist/es2015/sidecar.js
var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);

// ../node_modules/react-remove-scroll/dist/es2015/Combination.js
var ReactRemoveScroll = React46.forwardRef(function(props, ref) {
  return React46.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: sidecar_default }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var Combination_default = ReactRemoveScroll;

// ../node_modules/aria-hidden/dist/es2015/index.js
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x) {
    return Boolean(x);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode2, markerName, controlAttribute) {
  var targets = correctTargets(parentNode2, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e) {
          console.error("aria-hidden: cannot operate on ", node, e);
        }
      }
    });
  };
  deep(parentNode2);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode2, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = parentNode2 || getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live], script")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};

// ../node_modules/@radix-ui/react-dialog/dist/index.mjs
var import_jsx_runtime59 = __toESM(require_jsx_runtime(), 1);
var DIALOG_NAME = "Dialog";
var [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME);
var [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
var Dialog = (props) => {
  const {
    __scopeDialog,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const triggerRef = React47.useRef(null);
  const contentRef = React47.useRef(null);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: DIALOG_NAME
  });
  return (0, import_jsx_runtime59.jsx)(
    DialogProvider,
    {
      scope: __scopeDialog,
      triggerRef,
      contentRef,
      contentId: useId2(),
      titleId: useId2(),
      descriptionId: useId2(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: React47.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children
    }
  );
};
Dialog.displayName = DIALOG_NAME;
var TRIGGER_NAME3 = "DialogTrigger";
var DialogTrigger = React47.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...triggerProps } = props;
    const context = useDialogContext(TRIGGER_NAME3, __scopeDialog);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    return (0, import_jsx_runtime59.jsx)(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState3(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
  }
);
DialogTrigger.displayName = TRIGGER_NAME3;
var PORTAL_NAME2 = "DialogPortal";
var [PortalProvider, usePortalContext] = createDialogContext(PORTAL_NAME2, {
  forceMount: void 0
});
var DialogPortal = (props) => {
  const { __scopeDialog, forceMount, children, container } = props;
  const context = useDialogContext(PORTAL_NAME2, __scopeDialog);
  return (0, import_jsx_runtime59.jsx)(PortalProvider, { scope: __scopeDialog, forceMount, children: React47.Children.map(children, (child) => (0, import_jsx_runtime59.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime59.jsx)(Portal, { asChild: true, container, children: child }) })) });
};
DialogPortal.displayName = PORTAL_NAME2;
var OVERLAY_NAME = "DialogOverlay";
var DialogOverlay = React47.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(OVERLAY_NAME, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, props.__scopeDialog);
    return context.modal ? (0, import_jsx_runtime59.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime59.jsx)(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;
  }
);
DialogOverlay.displayName = OVERLAY_NAME;
var Slot2 = createSlot("DialogOverlay.RemoveScroll");
var DialogOverlayImpl = React47.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, __scopeDialog);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      (0, import_jsx_runtime59.jsx)(Combination_default, { as: Slot2, allowPinchZoom: true, shards: [context.contentRef], children: (0, import_jsx_runtime59.jsx)(
        Primitive.div,
        {
          "data-state": getState3(context.open),
          ...overlayProps,
          ref: forwardedRef,
          style: { pointerEvents: "auto", ...overlayProps.style }
        }
      ) })
    );
  }
);
var CONTENT_NAME3 = "DialogContent";
var DialogContent = React47.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(CONTENT_NAME3, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME3, props.__scopeDialog);
    return (0, import_jsx_runtime59.jsx)(Presence, { present: forceMount || context.open, children: context.modal ? (0, import_jsx_runtime59.jsx)(DialogContentModal, { ...contentProps, ref: forwardedRef }) : (0, import_jsx_runtime59.jsx)(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
DialogContent.displayName = CONTENT_NAME3;
var DialogContentModal = React47.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME3, props.__scopeDialog);
    const contentRef = React47.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);
    React47.useEffect(() => {
      const content = contentRef.current;
      if (content) return hideOthers(content);
    }, []);
    return (0, import_jsx_runtime59.jsx)(
      DialogContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          var _a6;
          event.preventDefault();
          (_a6 = context.triggerRef.current) == null ? void 0 : _a6.focus();
        }),
        onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (isRightClick) event.preventDefault();
        }),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault()
        )
      }
    );
  }
);
var DialogContentNonModal = React47.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME3, props.__scopeDialog);
    const hasInteractedOutsideRef = React47.useRef(false);
    const hasPointerDownOutsideRef = React47.useRef(false);
    return (0, import_jsx_runtime59.jsx)(
      DialogContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          var _a6, _b3;
          (_a6 = props.onCloseAutoFocus) == null ? void 0 : _a6.call(props, event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) (_b3 = context.triggerRef.current) == null ? void 0 : _b3.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          var _a6, _b3;
          (_a6 = props.onInteractOutside) == null ? void 0 : _a6.call(props, event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = (_b3 = context.triggerRef.current) == null ? void 0 : _b3.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var DialogContentImpl = React47.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME3, __scopeDialog);
    const contentRef = React47.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    useFocusGuards();
    return (0, import_jsx_runtime59.jsxs)(import_jsx_runtime59.Fragment, { children: [
      (0, import_jsx_runtime59.jsx)(
        FocusScope,
        {
          asChild: true,
          loop: true,
          trapped: trapFocus,
          onMountAutoFocus: onOpenAutoFocus,
          onUnmountAutoFocus: onCloseAutoFocus,
          children: (0, import_jsx_runtime59.jsx)(
            DismissableLayer,
            {
              role: "dialog",
              id: context.contentId,
              "aria-describedby": context.descriptionId,
              "aria-labelledby": context.titleId,
              "data-state": getState3(context.open),
              ...contentProps,
              ref: composedRefs,
              onDismiss: () => context.onOpenChange(false)
            }
          )
        }
      ),
      (0, import_jsx_runtime59.jsxs)(import_jsx_runtime59.Fragment, { children: [
        (0, import_jsx_runtime59.jsx)(TitleWarning, { titleId: context.titleId }),
        (0, import_jsx_runtime59.jsx)(DescriptionWarning, { contentRef, descriptionId: context.descriptionId })
      ] })
    ] });
  }
);
var TITLE_NAME = "DialogTitle";
var DialogTitle = React47.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...titleProps } = props;
    const context = useDialogContext(TITLE_NAME, __scopeDialog);
    return (0, import_jsx_runtime59.jsx)(Primitive.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });
  }
);
DialogTitle.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "DialogDescription";
var DialogDescription = React47.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...descriptionProps } = props;
    const context = useDialogContext(DESCRIPTION_NAME, __scopeDialog);
    return (0, import_jsx_runtime59.jsx)(Primitive.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });
  }
);
DialogDescription.displayName = DESCRIPTION_NAME;
var CLOSE_NAME = "DialogClose";
var DialogClose = React47.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...closeProps } = props;
    const context = useDialogContext(CLOSE_NAME, __scopeDialog);
    return (0, import_jsx_runtime59.jsx)(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
DialogClose.displayName = CLOSE_NAME;
function getState3(open) {
  return open ? "open" : "closed";
}
var TITLE_WARNING_NAME = "DialogTitleWarning";
var [WarningProvider, useWarningContext] = createContext22(TITLE_WARNING_NAME, {
  contentName: CONTENT_NAME3,
  titleName: TITLE_NAME,
  docsSlug: "dialog"
});
var TitleWarning = ({ titleId }) => {
  const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
  const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
  React47.useEffect(() => {
    if (titleId) {
      const hasTitle = document.getElementById(titleId);
      if (!hasTitle) console.error(MESSAGE);
    }
  }, [MESSAGE, titleId]);
  return null;
};
var DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
var DescriptionWarning = ({ contentRef, descriptionId }) => {
  const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
  const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
  React47.useEffect(() => {
    var _a6;
    const describedById = (_a6 = contentRef.current) == null ? void 0 : _a6.getAttribute("aria-describedby");
    if (descriptionId && describedById) {
      const hasDescription = document.getElementById(descriptionId);
      if (!hasDescription) console.warn(MESSAGE);
    }
  }, [MESSAGE, contentRef, descriptionId]);
  return null;
};
var Root5 = Dialog;
var Trigger2 = DialogTrigger;
var Portal2 = DialogPortal;
var Overlay = DialogOverlay;
var Content2 = DialogContent;
var Title = DialogTitle;
var Description = DialogDescription;
var Close = DialogClose;

// ../node_modules/@radix-ui/react-alert-dialog/dist/index.mjs
var import_jsx_runtime60 = __toESM(require_jsx_runtime(), 1);
var ROOT_NAME = "AlertDialog";
var [createAlertDialogContext, createAlertDialogScope] = createContextScope(ROOT_NAME, [
  createDialogScope
]);
var useDialogScope = createDialogScope();
var AlertDialog = (props) => {
  const { __scopeAlertDialog, ...alertDialogProps } = props;
  const dialogScope = useDialogScope(__scopeAlertDialog);
  return (0, import_jsx_runtime60.jsx)(Root5, { ...dialogScope, ...alertDialogProps, modal: true });
};
AlertDialog.displayName = ROOT_NAME;
var TRIGGER_NAME4 = "AlertDialogTrigger";
var AlertDialogTrigger = React48.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAlertDialog, ...triggerProps } = props;
    const dialogScope = useDialogScope(__scopeAlertDialog);
    return (0, import_jsx_runtime60.jsx)(Trigger2, { ...dialogScope, ...triggerProps, ref: forwardedRef });
  }
);
AlertDialogTrigger.displayName = TRIGGER_NAME4;
var PORTAL_NAME3 = "AlertDialogPortal";
var AlertDialogPortal = (props) => {
  const { __scopeAlertDialog, ...portalProps } = props;
  const dialogScope = useDialogScope(__scopeAlertDialog);
  return (0, import_jsx_runtime60.jsx)(Portal2, { ...dialogScope, ...portalProps });
};
AlertDialogPortal.displayName = PORTAL_NAME3;
var OVERLAY_NAME2 = "AlertDialogOverlay";
var AlertDialogOverlay = React48.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAlertDialog, ...overlayProps } = props;
    const dialogScope = useDialogScope(__scopeAlertDialog);
    return (0, import_jsx_runtime60.jsx)(Overlay, { ...dialogScope, ...overlayProps, ref: forwardedRef });
  }
);
AlertDialogOverlay.displayName = OVERLAY_NAME2;
var CONTENT_NAME4 = "AlertDialogContent";
var [AlertDialogContentProvider, useAlertDialogContentContext] = createAlertDialogContext(CONTENT_NAME4);
var Slottable2 = createSlottable("AlertDialogContent");
var AlertDialogContent = React48.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAlertDialog, children, ...contentProps } = props;
    const dialogScope = useDialogScope(__scopeAlertDialog);
    const contentRef = React48.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    const cancelRef = React48.useRef(null);
    return (0, import_jsx_runtime60.jsx)(
      WarningProvider,
      {
        contentName: CONTENT_NAME4,
        titleName: TITLE_NAME2,
        docsSlug: "alert-dialog",
        children: (0, import_jsx_runtime60.jsx)(AlertDialogContentProvider, { scope: __scopeAlertDialog, cancelRef, children: (0, import_jsx_runtime60.jsxs)(
          Content2,
          {
            role: "alertdialog",
            ...dialogScope,
            ...contentProps,
            ref: composedRefs,
            onOpenAutoFocus: composeEventHandlers(contentProps.onOpenAutoFocus, (event) => {
              var _a6;
              event.preventDefault();
              (_a6 = cancelRef.current) == null ? void 0 : _a6.focus({ preventScroll: true });
            }),
            onPointerDownOutside: (event) => event.preventDefault(),
            onInteractOutside: (event) => event.preventDefault(),
            children: [
              (0, import_jsx_runtime60.jsx)(Slottable2, { children }),
              (0, import_jsx_runtime60.jsx)(DescriptionWarning2, { contentRef })
            ]
          }
        ) })
      }
    );
  }
);
AlertDialogContent.displayName = CONTENT_NAME4;
var TITLE_NAME2 = "AlertDialogTitle";
var AlertDialogTitle = React48.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAlertDialog, ...titleProps } = props;
    const dialogScope = useDialogScope(__scopeAlertDialog);
    return (0, import_jsx_runtime60.jsx)(Title, { ...dialogScope, ...titleProps, ref: forwardedRef });
  }
);
AlertDialogTitle.displayName = TITLE_NAME2;
var DESCRIPTION_NAME2 = "AlertDialogDescription";
var AlertDialogDescription = React48.forwardRef((props, forwardedRef) => {
  const { __scopeAlertDialog, ...descriptionProps } = props;
  const dialogScope = useDialogScope(__scopeAlertDialog);
  return (0, import_jsx_runtime60.jsx)(Description, { ...dialogScope, ...descriptionProps, ref: forwardedRef });
});
AlertDialogDescription.displayName = DESCRIPTION_NAME2;
var ACTION_NAME = "AlertDialogAction";
var AlertDialogAction = React48.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAlertDialog, ...actionProps } = props;
    const dialogScope = useDialogScope(__scopeAlertDialog);
    return (0, import_jsx_runtime60.jsx)(Close, { ...dialogScope, ...actionProps, ref: forwardedRef });
  }
);
AlertDialogAction.displayName = ACTION_NAME;
var CANCEL_NAME = "AlertDialogCancel";
var AlertDialogCancel = React48.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAlertDialog, ...cancelProps } = props;
    const { cancelRef } = useAlertDialogContentContext(CANCEL_NAME, __scopeAlertDialog);
    const dialogScope = useDialogScope(__scopeAlertDialog);
    const ref = useComposedRefs(forwardedRef, cancelRef);
    return (0, import_jsx_runtime60.jsx)(Close, { ...dialogScope, ...cancelProps, ref });
  }
);
AlertDialogCancel.displayName = CANCEL_NAME;
var DescriptionWarning2 = ({ contentRef }) => {
  const MESSAGE = `\`${CONTENT_NAME4}\` requires a description for the component to be accessible for screen reader users.

You can add a description to the \`${CONTENT_NAME4}\` by passing a \`${DESCRIPTION_NAME2}\` component as a child, which also benefits sighted users by adding visible context to the dialog.

Alternatively, you can use your own component as a description by assigning it an \`id\` and passing the same value to the \`aria-describedby\` prop in \`${CONTENT_NAME4}\`. If the description is confusing or duplicative for sighted users, you can use the \`@radix-ui/react-visually-hidden\` primitive as a wrapper around your description component.

For more information, see https://radix-ui.com/primitives/docs/components/alert-dialog`;
  React48.useEffect(() => {
    var _a6;
    const hasDescription = document.getElementById(
      (_a6 = contentRef.current) == null ? void 0 : _a6.getAttribute("aria-describedby")
    );
    if (!hasDescription) console.warn(MESSAGE);
  }, [MESSAGE, contentRef]);
  return null;
};

// ../node_modules/@radix-ui/react-aspect-ratio/dist/index.mjs
var React49 = __toESM(require_react(), 1);
var import_jsx_runtime61 = __toESM(require_jsx_runtime(), 1);
var NAME3 = "AspectRatio";
var AspectRatio = React49.forwardRef(
  (props, forwardedRef) => {
    const { ratio = 1 / 1, style: style2, ...aspectRatioProps } = props;
    return (0, import_jsx_runtime61.jsx)(
      "div",
      {
        style: {
          // ensures inner element is contained
          position: "relative",
          // ensures padding bottom trick maths works
          width: "100%",
          paddingBottom: `${100 / ratio}%`
        },
        "data-radix-aspect-ratio-wrapper": "",
        children: (0, import_jsx_runtime61.jsx)(
          Primitive.div,
          {
            ...aspectRatioProps,
            ref: forwardedRef,
            style: {
              ...style2,
              // ensures children expand in ratio
              position: "absolute",
              top: 0,
              right: 0,
              bottom: 0,
              left: 0
            }
          }
        )
      }
    );
  }
);
AspectRatio.displayName = NAME3;

// ../node_modules/@radix-ui/react-avatar/dist/index.mjs
var React50 = __toESM(require_react(), 1);

// ../node_modules/@radix-ui/react-use-is-hydrated/dist/index.mjs
var import_shim = __toESM(require_shim(), 1);
function useIsHydrated() {
  return (0, import_shim.useSyncExternalStore)(
    subscribe,
    () => true,
    () => false
  );
}
function subscribe() {
  return () => {
  };
}

// ../node_modules/@radix-ui/react-avatar/dist/index.mjs
var import_jsx_runtime62 = __toESM(require_jsx_runtime(), 1);
var AVATAR_NAME = "Avatar";
var [createAvatarContext, createAvatarScope] = createContextScope(AVATAR_NAME);
var [AvatarProvider, useAvatarContext] = createAvatarContext(AVATAR_NAME);
var Avatar = React50.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAvatar, ...avatarProps } = props;
    const [imageLoadingStatus, setImageLoadingStatus] = React50.useState("idle");
    return (0, import_jsx_runtime62.jsx)(
      AvatarProvider,
      {
        scope: __scopeAvatar,
        imageLoadingStatus,
        onImageLoadingStatusChange: setImageLoadingStatus,
        children: (0, import_jsx_runtime62.jsx)(Primitive.span, { ...avatarProps, ref: forwardedRef })
      }
    );
  }
);
Avatar.displayName = AVATAR_NAME;
var IMAGE_NAME = "AvatarImage";
var AvatarImage = React50.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAvatar, src, onLoadingStatusChange = () => {
    }, ...imageProps } = props;
    const context = useAvatarContext(IMAGE_NAME, __scopeAvatar);
    const imageLoadingStatus = useImageLoadingStatus(src, imageProps);
    const handleLoadingStatusChange = useCallbackRef((status) => {
      onLoadingStatusChange(status);
      context.onImageLoadingStatusChange(status);
    });
    useLayoutEffect22(() => {
      if (imageLoadingStatus !== "idle") {
        handleLoadingStatusChange(imageLoadingStatus);
      }
    }, [imageLoadingStatus, handleLoadingStatusChange]);
    return imageLoadingStatus === "loaded" ? (0, import_jsx_runtime62.jsx)(Primitive.img, { ...imageProps, ref: forwardedRef, src }) : null;
  }
);
AvatarImage.displayName = IMAGE_NAME;
var FALLBACK_NAME = "AvatarFallback";
var AvatarFallback = React50.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAvatar, delayMs, ...fallbackProps } = props;
    const context = useAvatarContext(FALLBACK_NAME, __scopeAvatar);
    const [canRender, setCanRender] = React50.useState(delayMs === void 0);
    React50.useEffect(() => {
      if (delayMs !== void 0) {
        const timerId = window.setTimeout(() => setCanRender(true), delayMs);
        return () => window.clearTimeout(timerId);
      }
    }, [delayMs]);
    return canRender && context.imageLoadingStatus !== "loaded" ? (0, import_jsx_runtime62.jsx)(Primitive.span, { ...fallbackProps, ref: forwardedRef }) : null;
  }
);
AvatarFallback.displayName = FALLBACK_NAME;
function resolveLoadingStatus(image, src) {
  if (!image) {
    return "idle";
  }
  if (!src) {
    return "error";
  }
  if (image.src !== src) {
    image.src = src;
  }
  return image.complete && image.naturalWidth > 0 ? "loaded" : "loading";
}
function useImageLoadingStatus(src, { referrerPolicy, crossOrigin }) {
  const isHydrated = useIsHydrated();
  const imageRef = React50.useRef(null);
  const image = (() => {
    if (!isHydrated) return null;
    if (!imageRef.current) {
      imageRef.current = new window.Image();
    }
    return imageRef.current;
  })();
  const [loadingStatus, setLoadingStatus] = React50.useState(
    () => resolveLoadingStatus(image, src)
  );
  useLayoutEffect22(() => {
    setLoadingStatus(resolveLoadingStatus(image, src));
  }, [image, src]);
  useLayoutEffect22(() => {
    const updateStatus = (status) => () => {
      setLoadingStatus(status);
    };
    if (!image) return;
    const handleLoad = updateStatus("loaded");
    const handleError = updateStatus("error");
    image.addEventListener("load", handleLoad);
    image.addEventListener("error", handleError);
    if (referrerPolicy) {
      image.referrerPolicy = referrerPolicy;
    }
    if (typeof crossOrigin === "string") {
      image.crossOrigin = crossOrigin;
    }
    return () => {
      image.removeEventListener("load", handleLoad);
      image.removeEventListener("error", handleError);
    };
  }, [image, crossOrigin, referrerPolicy]);
  return loadingStatus;
}

// ../node_modules/@radix-ui/react-checkbox/dist/index.mjs
var React53 = __toESM(require_react(), 1);

// ../node_modules/@radix-ui/react-use-previous/dist/index.mjs
var React51 = __toESM(require_react(), 1);
function usePrevious(value) {
  const ref = React51.useRef({ value, previous: value });
  return React51.useMemo(() => {
    if (ref.current.value !== value) {
      ref.current.previous = ref.current.value;
      ref.current.value = value;
    }
    return ref.current.previous;
  }, [value]);
}

// ../node_modules/@radix-ui/react-use-size/dist/index.mjs
var React52 = __toESM(require_react(), 1);
function useSize(element) {
  const [size4, setSize] = React52.useState(void 0);
  useLayoutEffect22(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(void 0);
    }
  }, [element]);
  return size4;
}

// ../node_modules/@radix-ui/react-checkbox/dist/index.mjs
var import_jsx_runtime63 = __toESM(require_jsx_runtime(), 1);
var CHECKBOX_NAME = "Checkbox";
var [createCheckboxContext, createCheckboxScope] = createContextScope(CHECKBOX_NAME);
var [CheckboxProviderImpl, useCheckboxContext] = createCheckboxContext(CHECKBOX_NAME);
function CheckboxProvider(props) {
  const {
    __scopeCheckbox,
    checked: checkedProp,
    children,
    defaultChecked,
    disabled,
    form,
    name,
    onCheckedChange,
    required,
    value = "on",
    // @ts-expect-error
    internal_do_not_use_render
  } = props;
  const [checked, setChecked] = useControllableState({
    prop: checkedProp,
    defaultProp: defaultChecked ?? false,
    onChange: onCheckedChange,
    caller: CHECKBOX_NAME
  });
  const [control, setControl] = React53.useState(null);
  const [bubbleInput, setBubbleInput] = React53.useState(null);
  const hasConsumerStoppedPropagationRef = React53.useRef(false);
  const isFormControl2 = control ? !!form || !!control.closest("form") : (
    // We set this to true by default so that events bubble to forms without JS (SSR)
    true
  );
  const context = {
    checked,
    disabled,
    setChecked,
    control,
    setControl,
    name,
    form,
    value,
    hasConsumerStoppedPropagationRef,
    required,
    defaultChecked: isIndeterminate(defaultChecked) ? false : defaultChecked,
    isFormControl: isFormControl2,
    bubbleInput,
    setBubbleInput
  };
  return (0, import_jsx_runtime63.jsx)(
    CheckboxProviderImpl,
    {
      scope: __scopeCheckbox,
      ...context,
      children: isFunction3(internal_do_not_use_render) ? internal_do_not_use_render(context) : children
    }
  );
}
var TRIGGER_NAME5 = "CheckboxTrigger";
var CheckboxTrigger = React53.forwardRef(
  ({ __scopeCheckbox, onKeyDown, onClick, ...checkboxProps }, forwardedRef) => {
    const {
      control,
      value,
      disabled,
      checked,
      required,
      setControl,
      setChecked,
      hasConsumerStoppedPropagationRef,
      isFormControl: isFormControl2,
      bubbleInput
    } = useCheckboxContext(TRIGGER_NAME5, __scopeCheckbox);
    const composedRefs = useComposedRefs(forwardedRef, setControl);
    const initialCheckedStateRef = React53.useRef(checked);
    React53.useEffect(() => {
      const form = control == null ? void 0 : control.form;
      if (form) {
        const reset2 = () => setChecked(initialCheckedStateRef.current);
        form.addEventListener("reset", reset2);
        return () => form.removeEventListener("reset", reset2);
      }
    }, [control, setChecked]);
    return (0, import_jsx_runtime63.jsx)(
      Primitive.button,
      {
        type: "button",
        role: "checkbox",
        "aria-checked": isIndeterminate(checked) ? "mixed" : checked,
        "aria-required": required,
        "data-state": getState4(checked),
        "data-disabled": disabled ? "" : void 0,
        disabled,
        value,
        ...checkboxProps,
        ref: composedRefs,
        onKeyDown: composeEventHandlers(onKeyDown, (event) => {
          if (event.key === "Enter") event.preventDefault();
        }),
        onClick: composeEventHandlers(onClick, (event) => {
          setChecked((prevChecked) => isIndeterminate(prevChecked) ? true : !prevChecked);
          if (bubbleInput && isFormControl2) {
            hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
            if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();
          }
        })
      }
    );
  }
);
CheckboxTrigger.displayName = TRIGGER_NAME5;
var Checkbox = React53.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeCheckbox,
      name,
      checked,
      defaultChecked,
      required,
      disabled,
      value,
      onCheckedChange,
      form,
      ...checkboxProps
    } = props;
    return (0, import_jsx_runtime63.jsx)(
      CheckboxProvider,
      {
        __scopeCheckbox,
        checked,
        defaultChecked,
        disabled,
        required,
        onCheckedChange,
        name,
        form,
        value,
        internal_do_not_use_render: ({ isFormControl: isFormControl2 }) => (0, import_jsx_runtime63.jsxs)(import_jsx_runtime63.Fragment, { children: [
          (0, import_jsx_runtime63.jsx)(
            CheckboxTrigger,
            {
              ...checkboxProps,
              ref: forwardedRef,
              __scopeCheckbox
            }
          ),
          isFormControl2 && (0, import_jsx_runtime63.jsx)(
            CheckboxBubbleInput,
            {
              __scopeCheckbox
            }
          )
        ] })
      }
    );
  }
);
Checkbox.displayName = CHECKBOX_NAME;
var INDICATOR_NAME = "CheckboxIndicator";
var CheckboxIndicator = React53.forwardRef(
  (props, forwardedRef) => {
    const { __scopeCheckbox, forceMount, ...indicatorProps } = props;
    const context = useCheckboxContext(INDICATOR_NAME, __scopeCheckbox);
    return (0, import_jsx_runtime63.jsx)(
      Presence,
      {
        present: forceMount || isIndeterminate(context.checked) || context.checked === true,
        children: (0, import_jsx_runtime63.jsx)(
          Primitive.span,
          {
            "data-state": getState4(context.checked),
            "data-disabled": context.disabled ? "" : void 0,
            ...indicatorProps,
            ref: forwardedRef,
            style: { pointerEvents: "none", ...props.style }
          }
        )
      }
    );
  }
);
CheckboxIndicator.displayName = INDICATOR_NAME;
var BUBBLE_INPUT_NAME = "CheckboxBubbleInput";
var CheckboxBubbleInput = React53.forwardRef(
  ({ __scopeCheckbox, ...props }, forwardedRef) => {
    const {
      control,
      hasConsumerStoppedPropagationRef,
      checked,
      defaultChecked,
      required,
      disabled,
      name,
      value,
      form,
      bubbleInput,
      setBubbleInput
    } = useCheckboxContext(BUBBLE_INPUT_NAME, __scopeCheckbox);
    const composedRefs = useComposedRefs(forwardedRef, setBubbleInput);
    const prevChecked = usePrevious(checked);
    const controlSize = useSize(control);
    React53.useEffect(() => {
      const input = bubbleInput;
      if (!input) return;
      const inputProto = window.HTMLInputElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        inputProto,
        "checked"
      );
      const setChecked = descriptor.set;
      const bubbles = !hasConsumerStoppedPropagationRef.current;
      if (prevChecked !== checked && setChecked) {
        const event = new Event("click", { bubbles });
        input.indeterminate = isIndeterminate(checked);
        setChecked.call(input, isIndeterminate(checked) ? false : checked);
        input.dispatchEvent(event);
      }
    }, [bubbleInput, prevChecked, checked, hasConsumerStoppedPropagationRef]);
    const defaultCheckedRef = React53.useRef(isIndeterminate(checked) ? false : checked);
    return (0, import_jsx_runtime63.jsx)(
      Primitive.input,
      {
        type: "checkbox",
        "aria-hidden": true,
        defaultChecked: defaultChecked ?? defaultCheckedRef.current,
        required,
        disabled,
        name,
        value,
        form,
        ...props,
        tabIndex: -1,
        ref: composedRefs,
        style: {
          ...props.style,
          ...controlSize,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0,
          // We transform because the input is absolutely positioned but we have
          // rendered it **after** the button. This pulls it back to sit on top
          // of the button.
          transform: "translateX(-100%)"
        }
      }
    );
  }
);
CheckboxBubbleInput.displayName = BUBBLE_INPUT_NAME;
function isFunction3(value) {
  return typeof value === "function";
}
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function getState4(checked) {
  return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}

// ../node_modules/@radix-ui/react-context-menu/dist/index.mjs
var dist_exports8 = {};
__export(dist_exports8, {
  Arrow: () => Arrow23,
  CheckboxItem: () => CheckboxItem2,
  Content: () => Content23,
  ContextMenu: () => ContextMenu,
  ContextMenuArrow: () => ContextMenuArrow,
  ContextMenuCheckboxItem: () => ContextMenuCheckboxItem,
  ContextMenuContent: () => ContextMenuContent,
  ContextMenuGroup: () => ContextMenuGroup,
  ContextMenuItem: () => ContextMenuItem,
  ContextMenuItemIndicator: () => ContextMenuItemIndicator,
  ContextMenuLabel: () => ContextMenuLabel,
  ContextMenuPortal: () => ContextMenuPortal,
  ContextMenuRadioGroup: () => ContextMenuRadioGroup,
  ContextMenuRadioItem: () => ContextMenuRadioItem,
  ContextMenuSeparator: () => ContextMenuSeparator,
  ContextMenuSub: () => ContextMenuSub,
  ContextMenuSubContent: () => ContextMenuSubContent,
  ContextMenuSubTrigger: () => ContextMenuSubTrigger,
  ContextMenuTrigger: () => ContextMenuTrigger,
  Group: () => Group2,
  Item: () => Item22,
  ItemIndicator: () => ItemIndicator2,
  Label: () => Label2,
  Portal: () => Portal22,
  RadioGroup: () => RadioGroup2,
  RadioItem: () => RadioItem2,
  Root: () => Root23,
  Separator: () => Separator2,
  Sub: () => Sub2,
  SubContent: () => SubContent2,
  SubTrigger: () => SubTrigger2,
  Trigger: () => Trigger3,
  createContextMenuScope: () => createContextMenuScope
});
var React59 = __toESM(require_react(), 1);

// ../node_modules/@radix-ui/react-menu/dist/index.mjs
var React58 = __toESM(require_react(), 1);

// ../node_modules/@radix-ui/react-popper/dist/index.mjs
var React56 = __toESM(require_react(), 1);

// ../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round2 = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp3(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide2(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
var yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide2(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
var lrPlacement = ["left", "right"];
var rlPlacement = ["right", "left"];
var tbPlacement = ["top", "bottom"];
var btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rlPlacement : lrPlacement;
      return isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide2(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// ../node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide2(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
async function detectOverflow(state, options2) {
  var _await$platform$isEle;
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options2, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    var _platform$detectOverf;
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset: reset2
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: {
        ...platform2,
        detectOverflow: (_platform$detectOverf = platform2.detectOverflow) != null ? _platform$detectOverf : detectOverflow
      },
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset2 && resetCount <= 50) {
      resetCount++;
      if (typeof reset2 === "object") {
        if (reset2.placement) {
          statefulPlacement = reset2.placement;
        }
        if (reset2.rects) {
          rects = reset2.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset2.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
var arrow = (options2) => ({
  name: "arrow",
  options: options2,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options2, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset4 = clamp3(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset4 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset4,
        centerOffset: center - offset4 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    name: "flip",
    options: options2,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options2, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide2(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide2(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await platform2.detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          overflowsData.every((d) => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    name: "hide",
    options: options2,
    async fn(state) {
      const {
        rects,
        platform: platform2
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options2, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await platform2.detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await platform2.detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
var originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state, options2) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide2(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = originSides.has(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options2, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options2) {
  if (options2 === void 0) {
    options2 = 0;
  }
  return {
    name: "offset",
    options: options2,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options2);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift2 = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    name: "shift",
    options: options2,
    async fn(state) {
      const {
        x,
        y,
        placement,
        platform: platform2
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options2, state);
      const coords = {
        x,
        y
      };
      const overflow = await platform2.detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide2(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min3 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp3(min3, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min3 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp3(min3, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var limitShift = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    options: options2,
    fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset4 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options2, state);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset4, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = originSides.has(getSide2(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    name: "size",
    options: options2,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply: apply2 = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options2, state);
      const overflow = await platform2.detectOverflow(state, detectOverflowOptions);
      const side = getSide2(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply2({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// ../node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode2(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow2(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode2(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode2(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow2(value).Node;
}
function isElement2(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow2(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow2(value).HTMLElement;
}
function isShadowRoot2(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow2(value).ShadowRoot;
}
var invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle3(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
var tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element) {
  return tableElements.has(getNodeName(element));
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (_e) {
      return false;
    }
  });
}
var transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
var willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
var containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit2 = isWebKit();
  const css = isElement2(elementOrCss) ? getComputedStyle3(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit2 && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit2 && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
var lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node) {
  return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle3(element) {
  return getWindow2(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement2(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot2(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot2(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode2 = getParentNode(node);
  if (isLastTraversableNode(parentNode2)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode2) && isOverflowElement(parentNode2)) {
    return parentNode2;
  }
  return getNearestOverflowAncestor(parentNode2);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow2(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// ../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle3(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round2(width) !== offsetWidth || round2(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement2(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round2(rect.width) : rect.width) / width;
  let y = ($ ? round2(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow2(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow2(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect2 = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement2(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect2.left + visualOffsets.x) / scale.x;
  let y = (clientRect2.top + visualOffsets.y) / scale.y;
  let width = clientRect2.width / scale.x;
  let height = clientRect2.height / scale.y;
  if (domElement) {
    const win = getWindow2(domElement);
    const offsetWin = offsetParent && isElement2(offsetParent) ? getWindow2(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle3(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow2(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll) {
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle3(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
var SCROLLBAR_MAX = 25;
function getViewportRect(element, strategy) {
  const win = getWindow2(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  const windowScrollbarX = getWindowScrollBarX(html);
  if (windowScrollbarX <= 0) {
    const doc3 = html.ownerDocument;
    const body = doc3.body;
    const bodyStyles = getComputedStyle(body);
    const bodyMarginInline = doc3.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
    const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);
    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
      width -= clippingStableScrollbarWidth;
    }
  } else if (windowScrollbarX <= SCROLLBAR_MAX) {
    width += windowScrollbarX;
  }
  return {
    width,
    height,
    x,
    y
  };
}
var absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element, strategy) {
  const clientRect2 = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect2.top + element.clientTop;
  const left = clientRect2.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement2(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode2 = getParentNode(element);
  if (parentNode2 === stopNode || !isElement2(parentNode2) || isLastTraversableNode(parentNode2)) {
    return false;
  }
  return getComputedStyle3(parentNode2).position === "fixed" || hasFixedPositionAncestor(parentNode2, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult2 = cache.get(element);
  if (cachedResult2) {
    return cachedResult2;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement2(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle3(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement2(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle3(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle3(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle3(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow2(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement2(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle3(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement: isElement2,
  isRTL
};
function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options2 = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options2,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (_e) {
      io = new IntersectionObserver(handleObserve, options2);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options2;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift3 = shift2;
var flip2 = flip;
var size2 = size;
var hide2 = hide;
var arrow2 = arrow;
var limitShift2 = limitShift;
var computePosition2 = (reference, floating, options2) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options2
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// ../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
var React54 = __toESM(require_react(), 1);
var import_react61 = __toESM(require_react(), 1);
var ReactDOM3 = __toESM(require_react_dom(), 1);
var isClient = typeof document !== "undefined";
var noop3 = function noop4() {
};
var index = isClient ? import_react61.useLayoutEffect : noop3;
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b.toString()) {
    return true;
  }
  let length;
  let i;
  let keys3;
  if (a && b && typeof a === "object") {
    if (Array.isArray(a)) {
      length = a.length;
      if (length !== b.length) return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys3 = Object.keys(a);
    length = keys3.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys3[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key = keys3[i];
      if (key === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React54.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options2;
  const [data, setData] = React54.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React54.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React54.useState(null);
  const [_floating, _setFloating] = React54.useState(null);
  const setReference = React54.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = React54.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React54.useRef(null);
  const floatingRef = React54.useRef(null);
  const dataRef = React54.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = React54.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM3.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React54.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React54.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React54.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React54.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x = roundByDPR(elements.floating, data.x);
    const y = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x + "px, " + y + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x,
      top: y
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React54.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
var arrow$1 = (options2) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options: options2,
    fn(state) {
      const {
        element,
        padding
      } = typeof options2 === "function" ? options2(state) : options2;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
var offset3 = (options2, deps) => ({
  ...offset2(options2),
  options: [options2, deps]
});
var shift4 = (options2, deps) => ({
  ...shift3(options2),
  options: [options2, deps]
});
var limitShift3 = (options2, deps) => ({
  ...limitShift2(options2),
  options: [options2, deps]
});
var flip3 = (options2, deps) => ({
  ...flip2(options2),
  options: [options2, deps]
});
var size3 = (options2, deps) => ({
  ...size2(options2),
  options: [options2, deps]
});
var hide3 = (options2, deps) => ({
  ...hide2(options2),
  options: [options2, deps]
});
var arrow3 = (options2, deps) => ({
  ...arrow$1(options2),
  options: [options2, deps]
});

// ../node_modules/@radix-ui/react-arrow/dist/index.mjs
var React55 = __toESM(require_react(), 1);
var import_jsx_runtime64 = __toESM(require_jsx_runtime(), 1);
var NAME4 = "Arrow";
var Arrow = React55.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return (0, import_jsx_runtime64.jsx)(
    Primitive.svg,
    {
      ...arrowProps,
      ref: forwardedRef,
      width,
      height,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: props.asChild ? children : (0, import_jsx_runtime64.jsx)("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Arrow.displayName = NAME4;
var Root6 = Arrow;

// ../node_modules/@radix-ui/react-popper/dist/index.mjs
var import_jsx_runtime65 = __toESM(require_jsx_runtime(), 1);
var POPPER_NAME = "Popper";
var [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);
var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
var Popper = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = React56.useState(null);
  return (0, import_jsx_runtime65.jsx)(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME = "PopperAnchor";
var PopperAnchor = React56.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const context = usePopperContext(ANCHOR_NAME, __scopePopper);
    const ref = React56.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const anchorRef = React56.useRef(null);
    React56.useEffect(() => {
      const previousAnchor = anchorRef.current;
      anchorRef.current = (virtualRef == null ? void 0 : virtualRef.current) || ref.current;
      if (previousAnchor !== anchorRef.current) {
        context.onAnchorChange(anchorRef.current);
      }
    });
    return virtualRef ? null : (0, import_jsx_runtime65.jsx)(Primitive.div, { ...anchorProps, ref: composedRefs });
  }
);
PopperAnchor.displayName = ANCHOR_NAME;
var CONTENT_NAME5 = "PopperContent";
var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME5);
var PopperContent = React56.forwardRef(
  (props, forwardedRef) => {
    var _a6, _b3, _c, _d, _e, _f;
    const {
      __scopePopper,
      side = "bottom",
      sideOffset = 0,
      align = "center",
      alignOffset = 0,
      arrowPadding = 0,
      avoidCollisions = true,
      collisionBoundary = [],
      collisionPadding: collisionPaddingProp = 0,
      sticky = "partial",
      hideWhenDetached = false,
      updatePositionStrategy = "optimized",
      onPlaced,
      ...contentProps
    } = props;
    const context = usePopperContext(CONTENT_NAME5, __scopePopper);
    const [content, setContent2] = React56.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent2(node));
    const [arrow5, setArrow] = React56.useState(null);
    const arrowSize = useSize(arrow5);
    const arrowWidth = (arrowSize == null ? void 0 : arrowSize.width) ?? 0;
    const arrowHeight = (arrowSize == null ? void 0 : arrowSize.height) ?? 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter(isNotNull),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate(...args, {
          animationFrame: updatePositionStrategy === "always"
        });
        return cleanup;
      },
      elements: {
        reference: context.anchor
      },
      middleware: [
        offset3({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
        avoidCollisions && shift4({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift3() : void 0,
          ...detectOverflowOptions
        }),
        avoidCollisions && flip3({ ...detectOverflowOptions }),
        size3({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow5 && arrow3({ element: arrow5, padding: arrowPadding }),
        transformOrigin({ arrowWidth, arrowHeight }),
        hideWhenDetached && hide3({ strategy: "referenceHidden", ...detectOverflowOptions })
      ]
    });
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const handlePlaced = useCallbackRef(onPlaced);
    useLayoutEffect22(() => {
      if (isPositioned) {
        handlePlaced == null ? void 0 : handlePlaced();
      }
    }, [isPositioned, handlePlaced]);
    const arrowX = (_a6 = middlewareData.arrow) == null ? void 0 : _a6.x;
    const arrowY = (_b3 = middlewareData.arrow) == null ? void 0 : _b3.y;
    const cannotCenterArrow = ((_c = middlewareData.arrow) == null ? void 0 : _c.centerOffset) !== 0;
    const [contentZIndex, setContentZIndex] = React56.useState();
    useLayoutEffect22(() => {
      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [content]);
    return (0, import_jsx_runtime65.jsx)(
      "div",
      {
        ref: refs.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...floatingStyles,
          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex,
          ["--radix-popper-transform-origin"]: [
            (_d = middlewareData.transformOrigin) == null ? void 0 : _d.x,
            (_e = middlewareData.transformOrigin) == null ? void 0 : _e.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((_f = middlewareData.hide) == null ? void 0 : _f.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: props.dir,
        children: (0, import_jsx_runtime65.jsx)(
          PopperContentProvider,
          {
            scope: __scopePopper,
            placedSide,
            onArrowChange: setArrow,
            arrowX,
            arrowY,
            shouldHideArrow: cannotCenterArrow,
            children: (0, import_jsx_runtime65.jsx)(
              Primitive.div,
              {
                "data-side": placedSide,
                "data-align": placedAlign,
                ...contentProps,
                ref: composedRefs,
                style: {
                  ...contentProps.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: !isPositioned ? "none" : void 0
                }
              }
            )
          }
        )
      }
    );
  }
);
PopperContent.displayName = CONTENT_NAME5;
var ARROW_NAME = "PopperArrow";
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow = React56.forwardRef(function PopperArrow2(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = useContentContext(ARROW_NAME, __scopePopper);
  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    (0, import_jsx_runtime65.jsx)(
      "span",
      {
        ref: contentContext.onArrowChange,
        style: {
          position: "absolute",
          left: contentContext.arrowX,
          top: contentContext.arrowY,
          [baseSide]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[contentContext.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[contentContext.placedSide],
          visibility: contentContext.shouldHideArrow ? "hidden" : void 0
        },
        children: (0, import_jsx_runtime65.jsx)(
          Root6,
          {
            ...arrowProps,
            ref: forwardedRef,
            style: {
              ...arrowProps.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
PopperArrow.displayName = ARROW_NAME;
function isNotNull(value) {
  return value !== null;
}
var transformOrigin = (options2) => ({
  name: "transformOrigin",
  options: options2,
  fn(data) {
    var _a6, _b3, _c;
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = ((_a6 = middlewareData.arrow) == null ? void 0 : _a6.centerOffset) !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options2.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options2.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (((_b3 = middlewareData.arrow) == null ? void 0 : _b3.x) ?? 0) + arrowWidth / 2;
    const arrowYCenter = (((_c = middlewareData.arrow) == null ? void 0 : _c.y) ?? 0) + arrowHeight / 2;
    let x = "";
    let y = "";
    if (placedSide === "bottom") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x = `${-arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x = `${rects.floating.width + arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x, y } };
  }
});
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root22 = Popper;
var Anchor = PopperAnchor;
var Content3 = PopperContent;
var Arrow2 = PopperArrow;

// ../node_modules/@radix-ui/react-roving-focus/dist/index.mjs
var React57 = __toESM(require_react(), 1);
var import_jsx_runtime66 = __toESM(require_jsx_runtime(), 1);
var ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
var EVENT_OPTIONS2 = { bubbles: false, cancelable: true };
var GROUP_NAME = "RovingFocusGroup";
var [Collection2, useCollection2, createCollectionScope2] = createCollection(GROUP_NAME);
var [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(
  GROUP_NAME,
  [createCollectionScope2]
);
var [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME);
var RovingFocusGroup = React57.forwardRef(
  (props, forwardedRef) => {
    return (0, import_jsx_runtime66.jsx)(Collection2.Provider, { scope: props.__scopeRovingFocusGroup, children: (0, import_jsx_runtime66.jsx)(Collection2.Slot, { scope: props.__scopeRovingFocusGroup, children: (0, import_jsx_runtime66.jsx)(RovingFocusGroupImpl, { ...props, ref: forwardedRef }) }) });
  }
);
RovingFocusGroup.displayName = GROUP_NAME;
var RovingFocusGroupImpl = React57.forwardRef((props, forwardedRef) => {
  const {
    __scopeRovingFocusGroup,
    orientation,
    loop = false,
    dir,
    currentTabStopId: currentTabStopIdProp,
    defaultCurrentTabStopId,
    onCurrentTabStopIdChange,
    onEntryFocus,
    preventScrollOnEntryFocus = false,
    ...groupProps
  } = props;
  const ref = React57.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const direction = useDirection(dir);
  const [currentTabStopId, setCurrentTabStopId] = useControllableState({
    prop: currentTabStopIdProp,
    defaultProp: defaultCurrentTabStopId ?? null,
    onChange: onCurrentTabStopIdChange,
    caller: GROUP_NAME
  });
  const [isTabbingBackOut, setIsTabbingBackOut] = React57.useState(false);
  const handleEntryFocus = useCallbackRef(onEntryFocus);
  const getItems = useCollection2(__scopeRovingFocusGroup);
  const isClickFocusRef = React57.useRef(false);
  const [focusableItemsCount, setFocusableItemsCount] = React57.useState(0);
  React57.useEffect(() => {
    const node = ref.current;
    if (node) {
      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);
      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);
    }
  }, [handleEntryFocus]);
  return (0, import_jsx_runtime66.jsx)(
    RovingFocusProvider,
    {
      scope: __scopeRovingFocusGroup,
      orientation,
      dir: direction,
      loop,
      currentTabStopId,
      onItemFocus: React57.useCallback(
        (tabStopId) => setCurrentTabStopId(tabStopId),
        [setCurrentTabStopId]
      ),
      onItemShiftTab: React57.useCallback(() => setIsTabbingBackOut(true), []),
      onFocusableItemAdd: React57.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount + 1),
        []
      ),
      onFocusableItemRemove: React57.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount - 1),
        []
      ),
      children: (0, import_jsx_runtime66.jsx)(
        Primitive.div,
        {
          tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
          "data-orientation": orientation,
          ...groupProps,
          ref: composedRefs,
          style: { outline: "none", ...props.style },
          onMouseDown: composeEventHandlers(props.onMouseDown, () => {
            isClickFocusRef.current = true;
          }),
          onFocus: composeEventHandlers(props.onFocus, (event) => {
            const isKeyboardFocus = !isClickFocusRef.current;
            if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
              const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS2);
              event.currentTarget.dispatchEvent(entryFocusEvent);
              if (!entryFocusEvent.defaultPrevented) {
                const items = getItems().filter((item) => item.focusable);
                const activeItem = items.find((item) => item.active);
                const currentItem = items.find((item) => item.id === currentTabStopId);
                const candidateItems = [activeItem, currentItem, ...items].filter(
                  Boolean
                );
                const candidateNodes = candidateItems.map((item) => item.ref.current);
                focusFirst2(candidateNodes, preventScrollOnEntryFocus);
              }
            }
            isClickFocusRef.current = false;
          }),
          onBlur: composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))
        }
      )
    }
  );
});
var ITEM_NAME2 = "RovingFocusGroupItem";
var RovingFocusGroupItem = React57.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeRovingFocusGroup,
      focusable = true,
      active = false,
      tabStopId,
      children,
      ...itemProps
    } = props;
    const autoId = useId2();
    const id = tabStopId || autoId;
    const context = useRovingFocusContext(ITEM_NAME2, __scopeRovingFocusGroup);
    const isCurrentTabStop = context.currentTabStopId === id;
    const getItems = useCollection2(__scopeRovingFocusGroup);
    const { onFocusableItemAdd, onFocusableItemRemove, currentTabStopId } = context;
    React57.useEffect(() => {
      if (focusable) {
        onFocusableItemAdd();
        return () => onFocusableItemRemove();
      }
    }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);
    return (0, import_jsx_runtime66.jsx)(
      Collection2.ItemSlot,
      {
        scope: __scopeRovingFocusGroup,
        id,
        focusable,
        active,
        children: (0, import_jsx_runtime66.jsx)(
          Primitive.span,
          {
            tabIndex: isCurrentTabStop ? 0 : -1,
            "data-orientation": context.orientation,
            ...itemProps,
            ref: forwardedRef,
            onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {
              if (!focusable) event.preventDefault();
              else context.onItemFocus(id);
            }),
            onFocus: composeEventHandlers(props.onFocus, () => context.onItemFocus(id)),
            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
              if (event.key === "Tab" && event.shiftKey) {
                context.onItemShiftTab();
                return;
              }
              if (event.target !== event.currentTarget) return;
              const focusIntent = getFocusIntent(event, context.orientation, context.dir);
              if (focusIntent !== void 0) {
                if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;
                event.preventDefault();
                const items = getItems().filter((item) => item.focusable);
                let candidateNodes = items.map((item) => item.ref.current);
                if (focusIntent === "last") candidateNodes.reverse();
                else if (focusIntent === "prev" || focusIntent === "next") {
                  if (focusIntent === "prev") candidateNodes.reverse();
                  const currentIndex = candidateNodes.indexOf(event.currentTarget);
                  candidateNodes = context.loop ? wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
                }
                setTimeout(() => focusFirst2(candidateNodes));
              }
            }),
            children: typeof children === "function" ? children({ isCurrentTabStop, hasTabStop: currentTabStopId != null }) : children
          }
        )
      }
    );
  }
);
RovingFocusGroupItem.displayName = ITEM_NAME2;
var MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function getDirectionAwareKey(key, dir) {
  if (dir !== "rtl") return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function getFocusIntent(event, orientation, dir) {
  const key = getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key)) return void 0;
  if (orientation === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key)) return void 0;
  return MAP_KEY_TO_FOCUS_INTENT[key];
}
function focusFirst2(candidates, preventScroll = false) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus({ preventScroll });
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function wrapArray(array, startIndex) {
  return array.map((_, index2) => array[(startIndex + index2) % array.length]);
}
var Root7 = RovingFocusGroup;
var Item = RovingFocusGroupItem;

// ../node_modules/@radix-ui/react-menu/dist/index.mjs
var import_jsx_runtime67 = __toESM(require_jsx_runtime(), 1);
var SELECTION_KEYS = ["Enter", " "];
var FIRST_KEYS = ["ArrowDown", "PageUp", "Home"];
var LAST_KEYS = ["ArrowUp", "PageDown", "End"];
var FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
var SUB_OPEN_KEYS = {
  ltr: [...SELECTION_KEYS, "ArrowRight"],
  rtl: [...SELECTION_KEYS, "ArrowLeft"]
};
var SUB_CLOSE_KEYS = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
var MENU_NAME = "Menu";
var [Collection3, useCollection3, createCollectionScope3] = createCollection(MENU_NAME);
var [createMenuContext, createMenuScope] = createContextScope(MENU_NAME, [
  createCollectionScope3,
  createPopperScope,
  createRovingFocusGroupScope
]);
var usePopperScope = createPopperScope();
var useRovingFocusGroupScope = createRovingFocusGroupScope();
var [MenuProvider, useMenuContext] = createMenuContext(MENU_NAME);
var [MenuRootProvider, useMenuRootContext] = createMenuContext(MENU_NAME);
var Menu = (props) => {
  const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props;
  const popperScope = usePopperScope(__scopeMenu);
  const [content, setContent2] = React58.useState(null);
  const isUsingKeyboardRef = React58.useRef(false);
  const handleOpenChange = useCallbackRef(onOpenChange);
  const direction = useDirection(dir);
  React58.useEffect(() => {
    const handleKeyDown2 = () => {
      isUsingKeyboardRef.current = true;
      document.addEventListener("pointerdown", handlePointer, { capture: true, once: true });
      document.addEventListener("pointermove", handlePointer, { capture: true, once: true });
    };
    const handlePointer = () => isUsingKeyboardRef.current = false;
    document.addEventListener("keydown", handleKeyDown2, { capture: true });
    return () => {
      document.removeEventListener("keydown", handleKeyDown2, { capture: true });
      document.removeEventListener("pointerdown", handlePointer, { capture: true });
      document.removeEventListener("pointermove", handlePointer, { capture: true });
    };
  }, []);
  return (0, import_jsx_runtime67.jsx)(Root22, { ...popperScope, children: (0, import_jsx_runtime67.jsx)(
    MenuProvider,
    {
      scope: __scopeMenu,
      open,
      onOpenChange: handleOpenChange,
      content,
      onContentChange: setContent2,
      children: (0, import_jsx_runtime67.jsx)(
        MenuRootProvider,
        {
          scope: __scopeMenu,
          onClose: React58.useCallback(() => handleOpenChange(false), [handleOpenChange]),
          isUsingKeyboardRef,
          dir: direction,
          modal,
          children
        }
      )
    }
  ) });
};
Menu.displayName = MENU_NAME;
var ANCHOR_NAME2 = "MenuAnchor";
var MenuAnchor = React58.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...anchorProps } = props;
    const popperScope = usePopperScope(__scopeMenu);
    return (0, import_jsx_runtime67.jsx)(Anchor, { ...popperScope, ...anchorProps, ref: forwardedRef });
  }
);
MenuAnchor.displayName = ANCHOR_NAME2;
var PORTAL_NAME4 = "MenuPortal";
var [PortalProvider2, usePortalContext2] = createMenuContext(PORTAL_NAME4, {
  forceMount: void 0
});
var MenuPortal = (props) => {
  const { __scopeMenu, forceMount, children, container } = props;
  const context = useMenuContext(PORTAL_NAME4, __scopeMenu);
  return (0, import_jsx_runtime67.jsx)(PortalProvider2, { scope: __scopeMenu, forceMount, children: (0, import_jsx_runtime67.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime67.jsx)(Portal, { asChild: true, container, children }) }) });
};
MenuPortal.displayName = PORTAL_NAME4;
var CONTENT_NAME6 = "MenuContent";
var [MenuContentProvider, useMenuContentContext] = createMenuContext(CONTENT_NAME6);
var MenuContent = React58.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext2(CONTENT_NAME6, props.__scopeMenu);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useMenuContext(CONTENT_NAME6, props.__scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME6, props.__scopeMenu);
    return (0, import_jsx_runtime67.jsx)(Collection3.Provider, { scope: props.__scopeMenu, children: (0, import_jsx_runtime67.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime67.jsx)(Collection3.Slot, { scope: props.__scopeMenu, children: rootContext.modal ? (0, import_jsx_runtime67.jsx)(MenuRootContentModal, { ...contentProps, ref: forwardedRef }) : (0, import_jsx_runtime67.jsx)(MenuRootContentNonModal, { ...contentProps, ref: forwardedRef }) }) }) });
  }
);
var MenuRootContentModal = React58.forwardRef(
  (props, forwardedRef) => {
    const context = useMenuContext(CONTENT_NAME6, props.__scopeMenu);
    const ref = React58.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    React58.useEffect(() => {
      const content = ref.current;
      if (content) return hideOthers(content);
    }, []);
    return (0, import_jsx_runtime67.jsx)(
      MenuContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: context.open,
        disableOutsideScroll: true,
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault(),
          { checkForDefaultPrevented: false }
        ),
        onDismiss: () => context.onOpenChange(false)
      }
    );
  }
);
var MenuRootContentNonModal = React58.forwardRef((props, forwardedRef) => {
  const context = useMenuContext(CONTENT_NAME6, props.__scopeMenu);
  return (0, import_jsx_runtime67.jsx)(
    MenuContentImpl,
    {
      ...props,
      ref: forwardedRef,
      trapFocus: false,
      disableOutsidePointerEvents: false,
      disableOutsideScroll: false,
      onDismiss: () => context.onOpenChange(false)
    }
  );
});
var Slot3 = createSlot("MenuContent.ScrollLock");
var MenuContentImpl = React58.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeMenu,
      loop = false,
      trapFocus,
      onOpenAutoFocus,
      onCloseAutoFocus,
      disableOutsidePointerEvents,
      onEntryFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      disableOutsideScroll,
      ...contentProps
    } = props;
    const context = useMenuContext(CONTENT_NAME6, __scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME6, __scopeMenu);
    const popperScope = usePopperScope(__scopeMenu);
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);
    const getItems = useCollection3(__scopeMenu);
    const [currentItemId, setCurrentItemId] = React58.useState(null);
    const contentRef = React58.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef, context.onContentChange);
    const timerRef = React58.useRef(0);
    const searchRef = React58.useRef("");
    const pointerGraceTimerRef = React58.useRef(0);
    const pointerGraceIntentRef = React58.useRef(null);
    const pointerDirRef = React58.useRef("right");
    const lastPointerXRef = React58.useRef(0);
    const ScrollLockWrapper = disableOutsideScroll ? Combination_default : React58.Fragment;
    const scrollLockWrapperProps = disableOutsideScroll ? { as: Slot3, allowPinchZoom: true } : void 0;
    const handleTypeaheadSearch = (key) => {
      var _a6, _b3;
      const search = searchRef.current + key;
      const items = getItems().filter((item) => !item.disabled);
      const currentItem = document.activeElement;
      const currentMatch = (_a6 = items.find((item) => item.ref.current === currentItem)) == null ? void 0 : _a6.textValue;
      const values = items.map((item) => item.textValue);
      const nextMatch = getNextMatch(values, search, currentMatch);
      const newItem = (_b3 = items.find((item) => item.textValue === nextMatch)) == null ? void 0 : _b3.ref.current;
      (function updateSearch(value) {
        searchRef.current = value;
        window.clearTimeout(timerRef.current);
        if (value !== "") timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search);
      if (newItem) {
        setTimeout(() => newItem.focus());
      }
    };
    React58.useEffect(() => {
      return () => window.clearTimeout(timerRef.current);
    }, []);
    useFocusGuards();
    const isPointerMovingToSubmenu = React58.useCallback((event) => {
      var _a6, _b3;
      const isMovingTowards = pointerDirRef.current === ((_a6 = pointerGraceIntentRef.current) == null ? void 0 : _a6.side);
      return isMovingTowards && isPointerInGraceArea(event, (_b3 = pointerGraceIntentRef.current) == null ? void 0 : _b3.area);
    }, []);
    return (0, import_jsx_runtime67.jsx)(
      MenuContentProvider,
      {
        scope: __scopeMenu,
        searchRef,
        onItemEnter: React58.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event)) event.preventDefault();
          },
          [isPointerMovingToSubmenu]
        ),
        onItemLeave: React58.useCallback(
          (event) => {
            var _a6;
            if (isPointerMovingToSubmenu(event)) return;
            (_a6 = contentRef.current) == null ? void 0 : _a6.focus();
            setCurrentItemId(null);
          },
          [isPointerMovingToSubmenu]
        ),
        onTriggerLeave: React58.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event)) event.preventDefault();
          },
          [isPointerMovingToSubmenu]
        ),
        pointerGraceTimerRef,
        onPointerGraceIntentChange: React58.useCallback((intent) => {
          pointerGraceIntentRef.current = intent;
        }, []),
        children: (0, import_jsx_runtime67.jsx)(ScrollLockWrapper, { ...scrollLockWrapperProps, children: (0, import_jsx_runtime67.jsx)(
          FocusScope,
          {
            asChild: true,
            trapped: trapFocus,
            onMountAutoFocus: composeEventHandlers(onOpenAutoFocus, (event) => {
              var _a6;
              event.preventDefault();
              (_a6 = contentRef.current) == null ? void 0 : _a6.focus({ preventScroll: true });
            }),
            onUnmountAutoFocus: onCloseAutoFocus,
            children: (0, import_jsx_runtime67.jsx)(
              DismissableLayer,
              {
                asChild: true,
                disableOutsidePointerEvents,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside,
                onInteractOutside,
                onDismiss,
                children: (0, import_jsx_runtime67.jsx)(
                  Root7,
                  {
                    asChild: true,
                    ...rovingFocusGroupScope,
                    dir: rootContext.dir,
                    orientation: "vertical",
                    loop,
                    currentTabStopId: currentItemId,
                    onCurrentTabStopIdChange: setCurrentItemId,
                    onEntryFocus: composeEventHandlers(onEntryFocus, (event) => {
                      if (!rootContext.isUsingKeyboardRef.current) event.preventDefault();
                    }),
                    preventScrollOnEntryFocus: true,
                    children: (0, import_jsx_runtime67.jsx)(
                      Content3,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": getOpenState(context.open),
                        "data-radix-menu-content": "",
                        dir: rootContext.dir,
                        ...popperScope,
                        ...contentProps,
                        ref: composedRefs,
                        style: { outline: "none", ...contentProps.style },
                        onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                          const target = event.target;
                          const isKeyDownInside = target.closest("[data-radix-menu-content]") === event.currentTarget;
                          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                          const isCharacterKey = event.key.length === 1;
                          if (isKeyDownInside) {
                            if (event.key === "Tab") event.preventDefault();
                            if (!isModifierKey && isCharacterKey) handleTypeaheadSearch(event.key);
                          }
                          const content = contentRef.current;
                          if (event.target !== content) return;
                          if (!FIRST_LAST_KEYS.includes(event.key)) return;
                          event.preventDefault();
                          const items = getItems().filter((item) => !item.disabled);
                          const candidateNodes = items.map((item) => item.ref.current);
                          if (LAST_KEYS.includes(event.key)) candidateNodes.reverse();
                          focusFirst3(candidateNodes);
                        }),
                        onBlur: composeEventHandlers(props.onBlur, (event) => {
                          if (!event.currentTarget.contains(event.target)) {
                            window.clearTimeout(timerRef.current);
                            searchRef.current = "";
                          }
                        }),
                        onPointerMove: composeEventHandlers(
                          props.onPointerMove,
                          whenMouse((event) => {
                            const target = event.target;
                            const pointerXHasChanged = lastPointerXRef.current !== event.clientX;
                            if (event.currentTarget.contains(target) && pointerXHasChanged) {
                              const newDir = event.clientX > lastPointerXRef.current ? "right" : "left";
                              pointerDirRef.current = newDir;
                              lastPointerXRef.current = event.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
MenuContent.displayName = CONTENT_NAME6;
var GROUP_NAME2 = "MenuGroup";
var MenuGroup = React58.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...groupProps } = props;
    return (0, import_jsx_runtime67.jsx)(Primitive.div, { role: "group", ...groupProps, ref: forwardedRef });
  }
);
MenuGroup.displayName = GROUP_NAME2;
var LABEL_NAME = "MenuLabel";
var MenuLabel = React58.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...labelProps } = props;
    return (0, import_jsx_runtime67.jsx)(Primitive.div, { ...labelProps, ref: forwardedRef });
  }
);
MenuLabel.displayName = LABEL_NAME;
var ITEM_NAME3 = "MenuItem";
var ITEM_SELECT = "menu.itemSelect";
var MenuItem = React58.forwardRef(
  (props, forwardedRef) => {
    const { disabled = false, onSelect, ...itemProps } = props;
    const ref = React58.useRef(null);
    const rootContext = useMenuRootContext(ITEM_NAME3, props.__scopeMenu);
    const contentContext = useMenuContentContext(ITEM_NAME3, props.__scopeMenu);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const isPointerDownRef = React58.useRef(false);
    const handleSelect = () => {
      const menuItem = ref.current;
      if (!disabled && menuItem) {
        const itemSelectEvent = new CustomEvent(ITEM_SELECT, { bubbles: true, cancelable: true });
        menuItem.addEventListener(ITEM_SELECT, (event) => onSelect == null ? void 0 : onSelect(event), { once: true });
        dispatchDiscreteCustomEvent(menuItem, itemSelectEvent);
        if (itemSelectEvent.defaultPrevented) {
          isPointerDownRef.current = false;
        } else {
          rootContext.onClose();
        }
      }
    };
    return (0, import_jsx_runtime67.jsx)(
      MenuItemImpl,
      {
        ...itemProps,
        ref: composedRefs,
        disabled,
        onClick: composeEventHandlers(props.onClick, handleSelect),
        onPointerDown: (event) => {
          var _a6;
          (_a6 = props.onPointerDown) == null ? void 0 : _a6.call(props, event);
          isPointerDownRef.current = true;
        },
        onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
          var _a6;
          if (!isPointerDownRef.current) (_a6 = event.currentTarget) == null ? void 0 : _a6.click();
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          const isTypingAhead = contentContext.searchRef.current !== "";
          if (disabled || isTypingAhead && event.key === " ") return;
          if (SELECTION_KEYS.includes(event.key)) {
            event.currentTarget.click();
            event.preventDefault();
          }
        })
      }
    );
  }
);
MenuItem.displayName = ITEM_NAME3;
var MenuItemImpl = React58.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;
    const contentContext = useMenuContentContext(ITEM_NAME3, __scopeMenu);
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);
    const ref = React58.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const [isFocused, setIsFocused] = React58.useState(false);
    const [textContent, setTextContent] = React58.useState("");
    React58.useEffect(() => {
      const menuItem = ref.current;
      if (menuItem) {
        setTextContent((menuItem.textContent ?? "").trim());
      }
    }, [itemProps.children]);
    return (0, import_jsx_runtime67.jsx)(
      Collection3.ItemSlot,
      {
        scope: __scopeMenu,
        disabled,
        textValue: textValue ?? textContent,
        children: (0, import_jsx_runtime67.jsx)(Item, { asChild: true, ...rovingFocusGroupScope, focusable: !disabled, children: (0, import_jsx_runtime67.jsx)(
          Primitive.div,
          {
            role: "menuitem",
            "data-highlighted": isFocused ? "" : void 0,
            "aria-disabled": disabled || void 0,
            "data-disabled": disabled ? "" : void 0,
            ...itemProps,
            ref: composedRefs,
            onPointerMove: composeEventHandlers(
              props.onPointerMove,
              whenMouse((event) => {
                if (disabled) {
                  contentContext.onItemLeave(event);
                } else {
                  contentContext.onItemEnter(event);
                  if (!event.defaultPrevented) {
                    const item = event.currentTarget;
                    item.focus({ preventScroll: true });
                  }
                }
              })
            ),
            onPointerLeave: composeEventHandlers(
              props.onPointerLeave,
              whenMouse((event) => contentContext.onItemLeave(event))
            ),
            onFocus: composeEventHandlers(props.onFocus, () => setIsFocused(true)),
            onBlur: composeEventHandlers(props.onBlur, () => setIsFocused(false))
          }
        ) })
      }
    );
  }
);
var CHECKBOX_ITEM_NAME = "MenuCheckboxItem";
var MenuCheckboxItem = React58.forwardRef(
  (props, forwardedRef) => {
    const { checked = false, onCheckedChange, ...checkboxItemProps } = props;
    return (0, import_jsx_runtime67.jsx)(ItemIndicatorProvider, { scope: props.__scopeMenu, checked, children: (0, import_jsx_runtime67.jsx)(
      MenuItem,
      {
        role: "menuitemcheckbox",
        "aria-checked": isIndeterminate2(checked) ? "mixed" : checked,
        ...checkboxItemProps,
        ref: forwardedRef,
        "data-state": getCheckedState(checked),
        onSelect: composeEventHandlers(
          checkboxItemProps.onSelect,
          () => onCheckedChange == null ? void 0 : onCheckedChange(isIndeterminate2(checked) ? true : !checked),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
MenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME;
var RADIO_GROUP_NAME = "MenuRadioGroup";
var [RadioGroupProvider, useRadioGroupContext] = createMenuContext(
  RADIO_GROUP_NAME,
  { value: void 0, onValueChange: () => {
  } }
);
var MenuRadioGroup = React58.forwardRef(
  (props, forwardedRef) => {
    const { value, onValueChange, ...groupProps } = props;
    const handleValueChange = useCallbackRef(onValueChange);
    return (0, import_jsx_runtime67.jsx)(RadioGroupProvider, { scope: props.__scopeMenu, value, onValueChange: handleValueChange, children: (0, import_jsx_runtime67.jsx)(MenuGroup, { ...groupProps, ref: forwardedRef }) });
  }
);
MenuRadioGroup.displayName = RADIO_GROUP_NAME;
var RADIO_ITEM_NAME = "MenuRadioItem";
var MenuRadioItem = React58.forwardRef(
  (props, forwardedRef) => {
    const { value, ...radioItemProps } = props;
    const context = useRadioGroupContext(RADIO_ITEM_NAME, props.__scopeMenu);
    const checked = value === context.value;
    return (0, import_jsx_runtime67.jsx)(ItemIndicatorProvider, { scope: props.__scopeMenu, checked, children: (0, import_jsx_runtime67.jsx)(
      MenuItem,
      {
        role: "menuitemradio",
        "aria-checked": checked,
        ...radioItemProps,
        ref: forwardedRef,
        "data-state": getCheckedState(checked),
        onSelect: composeEventHandlers(
          radioItemProps.onSelect,
          () => {
            var _a6;
            return (_a6 = context.onValueChange) == null ? void 0 : _a6.call(context, value);
          },
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
MenuRadioItem.displayName = RADIO_ITEM_NAME;
var ITEM_INDICATOR_NAME = "MenuItemIndicator";
var [ItemIndicatorProvider, useItemIndicatorContext] = createMenuContext(
  ITEM_INDICATOR_NAME,
  { checked: false }
);
var MenuItemIndicator = React58.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, forceMount, ...itemIndicatorProps } = props;
    const indicatorContext = useItemIndicatorContext(ITEM_INDICATOR_NAME, __scopeMenu);
    return (0, import_jsx_runtime67.jsx)(
      Presence,
      {
        present: forceMount || isIndeterminate2(indicatorContext.checked) || indicatorContext.checked === true,
        children: (0, import_jsx_runtime67.jsx)(
          Primitive.span,
          {
            ...itemIndicatorProps,
            ref: forwardedRef,
            "data-state": getCheckedState(indicatorContext.checked)
          }
        )
      }
    );
  }
);
MenuItemIndicator.displayName = ITEM_INDICATOR_NAME;
var SEPARATOR_NAME = "MenuSeparator";
var MenuSeparator = React58.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...separatorProps } = props;
    return (0, import_jsx_runtime67.jsx)(
      Primitive.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...separatorProps,
        ref: forwardedRef
      }
    );
  }
);
MenuSeparator.displayName = SEPARATOR_NAME;
var ARROW_NAME2 = "MenuArrow";
var MenuArrow = React58.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...arrowProps } = props;
    const popperScope = usePopperScope(__scopeMenu);
    return (0, import_jsx_runtime67.jsx)(Arrow2, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
MenuArrow.displayName = ARROW_NAME2;
var SUB_NAME = "MenuSub";
var [MenuSubProvider, useMenuSubContext] = createMenuContext(SUB_NAME);
var MenuSub = (props) => {
  const { __scopeMenu, children, open = false, onOpenChange } = props;
  const parentMenuContext = useMenuContext(SUB_NAME, __scopeMenu);
  const popperScope = usePopperScope(__scopeMenu);
  const [trigger2, setTrigger] = React58.useState(null);
  const [content, setContent2] = React58.useState(null);
  const handleOpenChange = useCallbackRef(onOpenChange);
  React58.useEffect(() => {
    if (parentMenuContext.open === false) handleOpenChange(false);
    return () => handleOpenChange(false);
  }, [parentMenuContext.open, handleOpenChange]);
  return (0, import_jsx_runtime67.jsx)(Root22, { ...popperScope, children: (0, import_jsx_runtime67.jsx)(
    MenuProvider,
    {
      scope: __scopeMenu,
      open,
      onOpenChange: handleOpenChange,
      content,
      onContentChange: setContent2,
      children: (0, import_jsx_runtime67.jsx)(
        MenuSubProvider,
        {
          scope: __scopeMenu,
          contentId: useId2(),
          triggerId: useId2(),
          trigger: trigger2,
          onTriggerChange: setTrigger,
          children
        }
      )
    }
  ) });
};
MenuSub.displayName = SUB_NAME;
var SUB_TRIGGER_NAME = "MenuSubTrigger";
var MenuSubTrigger = React58.forwardRef(
  (props, forwardedRef) => {
    const context = useMenuContext(SUB_TRIGGER_NAME, props.__scopeMenu);
    const rootContext = useMenuRootContext(SUB_TRIGGER_NAME, props.__scopeMenu);
    const subContext = useMenuSubContext(SUB_TRIGGER_NAME, props.__scopeMenu);
    const contentContext = useMenuContentContext(SUB_TRIGGER_NAME, props.__scopeMenu);
    const openTimerRef = React58.useRef(null);
    const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;
    const scope = { __scopeMenu: props.__scopeMenu };
    const clearOpenTimer = React58.useCallback(() => {
      if (openTimerRef.current) window.clearTimeout(openTimerRef.current);
      openTimerRef.current = null;
    }, []);
    React58.useEffect(() => clearOpenTimer, [clearOpenTimer]);
    React58.useEffect(() => {
      const pointerGraceTimer = pointerGraceTimerRef.current;
      return () => {
        window.clearTimeout(pointerGraceTimer);
        onPointerGraceIntentChange(null);
      };
    }, [pointerGraceTimerRef, onPointerGraceIntentChange]);
    return (0, import_jsx_runtime67.jsx)(MenuAnchor, { asChild: true, ...scope, children: (0, import_jsx_runtime67.jsx)(
      MenuItemImpl,
      {
        id: subContext.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context.open,
        "aria-controls": subContext.contentId,
        "data-state": getOpenState(context.open),
        ...props,
        ref: composeRefs(forwardedRef, subContext.onTriggerChange),
        onClick: (event) => {
          var _a6;
          (_a6 = props.onClick) == null ? void 0 : _a6.call(props, event);
          if (props.disabled || event.defaultPrevented) return;
          event.currentTarget.focus();
          if (!context.open) context.onOpenChange(true);
        },
        onPointerMove: composeEventHandlers(
          props.onPointerMove,
          whenMouse((event) => {
            contentContext.onItemEnter(event);
            if (event.defaultPrevented) return;
            if (!props.disabled && !context.open && !openTimerRef.current) {
              contentContext.onPointerGraceIntentChange(null);
              openTimerRef.current = window.setTimeout(() => {
                context.onOpenChange(true);
                clearOpenTimer();
              }, 100);
            }
          })
        ),
        onPointerLeave: composeEventHandlers(
          props.onPointerLeave,
          whenMouse((event) => {
            var _a6, _b3;
            clearOpenTimer();
            const contentRect = (_a6 = context.content) == null ? void 0 : _a6.getBoundingClientRect();
            if (contentRect) {
              const side = (_b3 = context.content) == null ? void 0 : _b3.dataset.side;
              const rightSide = side === "right";
              const bleed = rightSide ? -5 : 5;
              const contentNearEdge = contentRect[rightSide ? "left" : "right"];
              const contentFarEdge = contentRect[rightSide ? "right" : "left"];
              contentContext.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: event.clientX + bleed, y: event.clientY },
                  { x: contentNearEdge, y: contentRect.top },
                  { x: contentFarEdge, y: contentRect.top },
                  { x: contentFarEdge, y: contentRect.bottom },
                  { x: contentNearEdge, y: contentRect.bottom }
                ],
                side
              });
              window.clearTimeout(pointerGraceTimerRef.current);
              pointerGraceTimerRef.current = window.setTimeout(
                () => contentContext.onPointerGraceIntentChange(null),
                300
              );
            } else {
              contentContext.onTriggerLeave(event);
              if (event.defaultPrevented) return;
              contentContext.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          var _a6;
          const isTypingAhead = contentContext.searchRef.current !== "";
          if (props.disabled || isTypingAhead && event.key === " ") return;
          if (SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {
            context.onOpenChange(true);
            (_a6 = context.content) == null ? void 0 : _a6.focus();
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
MenuSubTrigger.displayName = SUB_TRIGGER_NAME;
var SUB_CONTENT_NAME = "MenuSubContent";
var MenuSubContent = React58.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext2(CONTENT_NAME6, props.__scopeMenu);
    const { forceMount = portalContext.forceMount, ...subContentProps } = props;
    const context = useMenuContext(CONTENT_NAME6, props.__scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME6, props.__scopeMenu);
    const subContext = useMenuSubContext(SUB_CONTENT_NAME, props.__scopeMenu);
    const ref = React58.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    return (0, import_jsx_runtime67.jsx)(Collection3.Provider, { scope: props.__scopeMenu, children: (0, import_jsx_runtime67.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime67.jsx)(Collection3.Slot, { scope: props.__scopeMenu, children: (0, import_jsx_runtime67.jsx)(
      MenuContentImpl,
      {
        id: subContext.contentId,
        "aria-labelledby": subContext.triggerId,
        ...subContentProps,
        ref: composedRefs,
        align: "start",
        side: rootContext.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: false,
        disableOutsideScroll: false,
        trapFocus: false,
        onOpenAutoFocus: (event) => {
          var _a6;
          if (rootContext.isUsingKeyboardRef.current) (_a6 = ref.current) == null ? void 0 : _a6.focus();
          event.preventDefault();
        },
        onCloseAutoFocus: (event) => event.preventDefault(),
        onFocusOutside: composeEventHandlers(props.onFocusOutside, (event) => {
          if (event.target !== subContext.trigger) context.onOpenChange(false);
        }),
        onEscapeKeyDown: composeEventHandlers(props.onEscapeKeyDown, (event) => {
          rootContext.onClose();
          event.preventDefault();
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          var _a6;
          const isKeyDownInside = event.currentTarget.contains(event.target);
          const isCloseKey = SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);
          if (isKeyDownInside && isCloseKey) {
            context.onOpenChange(false);
            (_a6 = subContext.trigger) == null ? void 0 : _a6.focus();
            event.preventDefault();
          }
        })
      }
    ) }) }) });
  }
);
MenuSubContent.displayName = SUB_CONTENT_NAME;
function getOpenState(open) {
  return open ? "open" : "closed";
}
function isIndeterminate2(checked) {
  return checked === "indeterminate";
}
function getCheckedState(checked) {
  return isIndeterminate2(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
function focusFirst3(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus();
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function wrapArray2(array, startIndex) {
  return array.map((_, index2) => array[(startIndex + index2) % array.length]);
}
function getNextMatch(values, search, currentMatch) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
  let wrappedValues = wrapArray2(values, Math.max(currentMatchIndex, 0));
  const excludeCurrentMatch = normalizedSearch.length === 1;
  if (excludeCurrentMatch) wrappedValues = wrappedValues.filter((v) => v !== currentMatch);
  const nextMatch = wrappedValues.find(
    (value) => value.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextMatch !== currentMatch ? nextMatch : void 0;
}
function isPointInPolygon(point, polygon) {
  const { x, y } = point;
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const ii = polygon[i];
    const jj = polygon[j];
    const xi = ii.x;
    const yi = ii.y;
    const xj = jj.x;
    const yj = jj.y;
    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect) inside = !inside;
  }
  return inside;
}
function isPointerInGraceArea(event, area) {
  if (!area) return false;
  const cursorPos = { x: event.clientX, y: event.clientY };
  return isPointInPolygon(cursorPos, area);
}
function whenMouse(handler) {
  return (event) => event.pointerType === "mouse" ? handler(event) : void 0;
}
var Root32 = Menu;
var Anchor2 = MenuAnchor;
var Portal3 = MenuPortal;
var Content22 = MenuContent;
var Group = MenuGroup;
var Label = MenuLabel;
var Item2 = MenuItem;
var CheckboxItem = MenuCheckboxItem;
var RadioGroup = MenuRadioGroup;
var RadioItem = MenuRadioItem;
var ItemIndicator = MenuItemIndicator;
var Separator = MenuSeparator;
var Arrow22 = MenuArrow;
var Sub = MenuSub;
var SubTrigger = MenuSubTrigger;
var SubContent = MenuSubContent;

// ../node_modules/@radix-ui/react-context-menu/dist/index.mjs
var import_jsx_runtime68 = __toESM(require_jsx_runtime(), 1);
var CONTEXT_MENU_NAME = "ContextMenu";
var [createContextMenuContext, createContextMenuScope] = createContextScope(CONTEXT_MENU_NAME, [
  createMenuScope
]);
var useMenuScope = createMenuScope();
var [ContextMenuProvider, useContextMenuContext] = createContextMenuContext(CONTEXT_MENU_NAME);
var ContextMenu = (props) => {
  const { __scopeContextMenu, children, onOpenChange, dir, modal = true } = props;
  const [open, setOpen] = React59.useState(false);
  const menuScope = useMenuScope(__scopeContextMenu);
  const handleOpenChangeProp = useCallbackRef(onOpenChange);
  const handleOpenChange = React59.useCallback(
    (open2) => {
      setOpen(open2);
      handleOpenChangeProp(open2);
    },
    [handleOpenChangeProp]
  );
  return (0, import_jsx_runtime68.jsx)(
    ContextMenuProvider,
    {
      scope: __scopeContextMenu,
      open,
      onOpenChange: handleOpenChange,
      modal,
      children: (0, import_jsx_runtime68.jsx)(
        Root32,
        {
          ...menuScope,
          dir,
          open,
          onOpenChange: handleOpenChange,
          modal,
          children
        }
      )
    }
  );
};
ContextMenu.displayName = CONTEXT_MENU_NAME;
var TRIGGER_NAME6 = "ContextMenuTrigger";
var ContextMenuTrigger = React59.forwardRef(
  (props, forwardedRef) => {
    const { __scopeContextMenu, disabled = false, ...triggerProps } = props;
    const context = useContextMenuContext(TRIGGER_NAME6, __scopeContextMenu);
    const menuScope = useMenuScope(__scopeContextMenu);
    const pointRef = React59.useRef({ x: 0, y: 0 });
    const virtualRef = React59.useRef({
      getBoundingClientRect: () => DOMRect.fromRect({ width: 0, height: 0, ...pointRef.current })
    });
    const longPressTimerRef = React59.useRef(0);
    const clearLongPress = React59.useCallback(
      () => window.clearTimeout(longPressTimerRef.current),
      []
    );
    const handleOpen = (event) => {
      pointRef.current = { x: event.clientX, y: event.clientY };
      context.onOpenChange(true);
    };
    React59.useEffect(() => clearLongPress, [clearLongPress]);
    React59.useEffect(() => void (disabled && clearLongPress()), [disabled, clearLongPress]);
    return (0, import_jsx_runtime68.jsxs)(import_jsx_runtime68.Fragment, { children: [
      (0, import_jsx_runtime68.jsx)(Anchor2, { ...menuScope, virtualRef }),
      (0, import_jsx_runtime68.jsx)(
        Primitive.span,
        {
          "data-state": context.open ? "open" : "closed",
          "data-disabled": disabled ? "" : void 0,
          ...triggerProps,
          ref: forwardedRef,
          style: { WebkitTouchCallout: "none", ...props.style },
          onContextMenu: disabled ? props.onContextMenu : composeEventHandlers(props.onContextMenu, (event) => {
            clearLongPress();
            handleOpen(event);
            event.preventDefault();
          }),
          onPointerDown: disabled ? props.onPointerDown : composeEventHandlers(
            props.onPointerDown,
            whenTouchOrPen((event) => {
              clearLongPress();
              longPressTimerRef.current = window.setTimeout(() => handleOpen(event), 700);
            })
          ),
          onPointerMove: disabled ? props.onPointerMove : composeEventHandlers(props.onPointerMove, whenTouchOrPen(clearLongPress)),
          onPointerCancel: disabled ? props.onPointerCancel : composeEventHandlers(props.onPointerCancel, whenTouchOrPen(clearLongPress)),
          onPointerUp: disabled ? props.onPointerUp : composeEventHandlers(props.onPointerUp, whenTouchOrPen(clearLongPress))
        }
      )
    ] });
  }
);
ContextMenuTrigger.displayName = TRIGGER_NAME6;
var PORTAL_NAME5 = "ContextMenuPortal";
var ContextMenuPortal = (props) => {
  const { __scopeContextMenu, ...portalProps } = props;
  const menuScope = useMenuScope(__scopeContextMenu);
  return (0, import_jsx_runtime68.jsx)(Portal3, { ...menuScope, ...portalProps });
};
ContextMenuPortal.displayName = PORTAL_NAME5;
var CONTENT_NAME7 = "ContextMenuContent";
var ContextMenuContent = React59.forwardRef(
  (props, forwardedRef) => {
    const { __scopeContextMenu, ...contentProps } = props;
    const context = useContextMenuContext(CONTENT_NAME7, __scopeContextMenu);
    const menuScope = useMenuScope(__scopeContextMenu);
    const hasInteractedOutsideRef = React59.useRef(false);
    return (0, import_jsx_runtime68.jsx)(
      Content22,
      {
        ...menuScope,
        ...contentProps,
        ref: forwardedRef,
        side: "right",
        sideOffset: 2,
        align: "start",
        onCloseAutoFocus: (event) => {
          var _a6;
          (_a6 = props.onCloseAutoFocus) == null ? void 0 : _a6.call(props, event);
          if (!event.defaultPrevented && hasInteractedOutsideRef.current) {
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          var _a6;
          (_a6 = props.onInteractOutside) == null ? void 0 : _a6.call(props, event);
          if (!event.defaultPrevented && !context.modal) hasInteractedOutsideRef.current = true;
        },
        style: {
          ...props.style,
          // re-namespace exposed content custom properties
          ...{
            "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
            "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
            "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      }
    );
  }
);
ContextMenuContent.displayName = CONTENT_NAME7;
var GROUP_NAME3 = "ContextMenuGroup";
var ContextMenuGroup = React59.forwardRef(
  (props, forwardedRef) => {
    const { __scopeContextMenu, ...groupProps } = props;
    const menuScope = useMenuScope(__scopeContextMenu);
    return (0, import_jsx_runtime68.jsx)(Group, { ...menuScope, ...groupProps, ref: forwardedRef });
  }
);
ContextMenuGroup.displayName = GROUP_NAME3;
var LABEL_NAME2 = "ContextMenuLabel";
var ContextMenuLabel = React59.forwardRef(
  (props, forwardedRef) => {
    const { __scopeContextMenu, ...labelProps } = props;
    const menuScope = useMenuScope(__scopeContextMenu);
    return (0, import_jsx_runtime68.jsx)(Label, { ...menuScope, ...labelProps, ref: forwardedRef });
  }
);
ContextMenuLabel.displayName = LABEL_NAME2;
var ITEM_NAME4 = "ContextMenuItem";
var ContextMenuItem = React59.forwardRef(
  (props, forwardedRef) => {
    const { __scopeContextMenu, ...itemProps } = props;
    const menuScope = useMenuScope(__scopeContextMenu);
    return (0, import_jsx_runtime68.jsx)(Item2, { ...menuScope, ...itemProps, ref: forwardedRef });
  }
);
ContextMenuItem.displayName = ITEM_NAME4;
var CHECKBOX_ITEM_NAME2 = "ContextMenuCheckboxItem";
var ContextMenuCheckboxItem = React59.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...checkboxItemProps } = props;
  const menuScope = useMenuScope(__scopeContextMenu);
  return (0, import_jsx_runtime68.jsx)(CheckboxItem, { ...menuScope, ...checkboxItemProps, ref: forwardedRef });
});
ContextMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME2;
var RADIO_GROUP_NAME2 = "ContextMenuRadioGroup";
var ContextMenuRadioGroup = React59.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...radioGroupProps } = props;
  const menuScope = useMenuScope(__scopeContextMenu);
  return (0, import_jsx_runtime68.jsx)(RadioGroup, { ...menuScope, ...radioGroupProps, ref: forwardedRef });
});
ContextMenuRadioGroup.displayName = RADIO_GROUP_NAME2;
var RADIO_ITEM_NAME2 = "ContextMenuRadioItem";
var ContextMenuRadioItem = React59.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...radioItemProps } = props;
  const menuScope = useMenuScope(__scopeContextMenu);
  return (0, import_jsx_runtime68.jsx)(RadioItem, { ...menuScope, ...radioItemProps, ref: forwardedRef });
});
ContextMenuRadioItem.displayName = RADIO_ITEM_NAME2;
var INDICATOR_NAME2 = "ContextMenuItemIndicator";
var ContextMenuItemIndicator = React59.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...itemIndicatorProps } = props;
  const menuScope = useMenuScope(__scopeContextMenu);
  return (0, import_jsx_runtime68.jsx)(ItemIndicator, { ...menuScope, ...itemIndicatorProps, ref: forwardedRef });
});
ContextMenuItemIndicator.displayName = INDICATOR_NAME2;
var SEPARATOR_NAME2 = "ContextMenuSeparator";
var ContextMenuSeparator = React59.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...separatorProps } = props;
  const menuScope = useMenuScope(__scopeContextMenu);
  return (0, import_jsx_runtime68.jsx)(Separator, { ...menuScope, ...separatorProps, ref: forwardedRef });
});
ContextMenuSeparator.displayName = SEPARATOR_NAME2;
var ARROW_NAME3 = "ContextMenuArrow";
var ContextMenuArrow = React59.forwardRef(
  (props, forwardedRef) => {
    const { __scopeContextMenu, ...arrowProps } = props;
    const menuScope = useMenuScope(__scopeContextMenu);
    return (0, import_jsx_runtime68.jsx)(Arrow22, { ...menuScope, ...arrowProps, ref: forwardedRef });
  }
);
ContextMenuArrow.displayName = ARROW_NAME3;
var SUB_NAME2 = "ContextMenuSub";
var ContextMenuSub = (props) => {
  const { __scopeContextMenu, children, onOpenChange, open: openProp, defaultOpen } = props;
  const menuScope = useMenuScope(__scopeContextMenu);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: SUB_NAME2
  });
  return (0, import_jsx_runtime68.jsx)(Sub, { ...menuScope, open, onOpenChange: setOpen, children });
};
ContextMenuSub.displayName = SUB_NAME2;
var SUB_TRIGGER_NAME2 = "ContextMenuSubTrigger";
var ContextMenuSubTrigger = React59.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...triggerItemProps } = props;
  const menuScope = useMenuScope(__scopeContextMenu);
  return (0, import_jsx_runtime68.jsx)(SubTrigger, { ...menuScope, ...triggerItemProps, ref: forwardedRef });
});
ContextMenuSubTrigger.displayName = SUB_TRIGGER_NAME2;
var SUB_CONTENT_NAME2 = "ContextMenuSubContent";
var ContextMenuSubContent = React59.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...subContentProps } = props;
  const menuScope = useMenuScope(__scopeContextMenu);
  return (0, import_jsx_runtime68.jsx)(
    SubContent,
    {
      ...menuScope,
      ...subContentProps,
      ref: forwardedRef,
      style: {
        ...props.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
ContextMenuSubContent.displayName = SUB_CONTENT_NAME2;
function whenTouchOrPen(handler) {
  return (event) => event.pointerType !== "mouse" ? handler(event) : void 0;
}
var Root23 = ContextMenu;
var Trigger3 = ContextMenuTrigger;
var Portal22 = ContextMenuPortal;
var Content23 = ContextMenuContent;
var Group2 = ContextMenuGroup;
var Label2 = ContextMenuLabel;
var Item22 = ContextMenuItem;
var CheckboxItem2 = ContextMenuCheckboxItem;
var RadioGroup2 = ContextMenuRadioGroup;
var RadioItem2 = ContextMenuRadioItem;
var ItemIndicator2 = ContextMenuItemIndicator;
var Separator2 = ContextMenuSeparator;
var Arrow23 = ContextMenuArrow;
var Sub2 = ContextMenuSub;
var SubTrigger2 = ContextMenuSubTrigger;
var SubContent2 = ContextMenuSubContent;

// ../node_modules/@radix-ui/react-dropdown-menu/dist/index.mjs
var dist_exports10 = {};
__export(dist_exports10, {
  Arrow: () => Arrow24,
  CheckboxItem: () => CheckboxItem22,
  Content: () => Content24,
  DropdownMenu: () => DropdownMenu,
  DropdownMenuArrow: () => DropdownMenuArrow,
  DropdownMenuCheckboxItem: () => DropdownMenuCheckboxItem,
  DropdownMenuContent: () => DropdownMenuContent,
  DropdownMenuGroup: () => DropdownMenuGroup,
  DropdownMenuItem: () => DropdownMenuItem,
  DropdownMenuItemIndicator: () => DropdownMenuItemIndicator,
  DropdownMenuLabel: () => DropdownMenuLabel,
  DropdownMenuPortal: () => DropdownMenuPortal,
  DropdownMenuRadioGroup: () => DropdownMenuRadioGroup,
  DropdownMenuRadioItem: () => DropdownMenuRadioItem,
  DropdownMenuSeparator: () => DropdownMenuSeparator,
  DropdownMenuSub: () => DropdownMenuSub,
  DropdownMenuSubContent: () => DropdownMenuSubContent,
  DropdownMenuSubTrigger: () => DropdownMenuSubTrigger,
  DropdownMenuTrigger: () => DropdownMenuTrigger,
  Group: () => Group22,
  Item: () => Item23,
  ItemIndicator: () => ItemIndicator22,
  Label: () => Label22,
  Portal: () => Portal23,
  RadioGroup: () => RadioGroup22,
  RadioItem: () => RadioItem22,
  Root: () => Root24,
  Separator: () => Separator22,
  Sub: () => Sub22,
  SubContent: () => SubContent22,
  SubTrigger: () => SubTrigger22,
  Trigger: () => Trigger4,
  createDropdownMenuScope: () => createDropdownMenuScope
});
var React60 = __toESM(require_react(), 1);
var import_jsx_runtime69 = __toESM(require_jsx_runtime(), 1);
var DROPDOWN_MENU_NAME = "DropdownMenu";
var [createDropdownMenuContext, createDropdownMenuScope] = createContextScope(
  DROPDOWN_MENU_NAME,
  [createMenuScope]
);
var useMenuScope2 = createMenuScope();
var [DropdownMenuProvider, useDropdownMenuContext] = createDropdownMenuContext(DROPDOWN_MENU_NAME);
var DropdownMenu = (props) => {
  const {
    __scopeDropdownMenu,
    children,
    dir,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  const triggerRef = React60.useRef(null);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: DROPDOWN_MENU_NAME
  });
  return (0, import_jsx_runtime69.jsx)(
    DropdownMenuProvider,
    {
      scope: __scopeDropdownMenu,
      triggerId: useId2(),
      triggerRef,
      contentId: useId2(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: React60.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children: (0, import_jsx_runtime69.jsx)(Root32, { ...menuScope, open, onOpenChange: setOpen, dir, modal, children })
    }
  );
};
DropdownMenu.displayName = DROPDOWN_MENU_NAME;
var TRIGGER_NAME7 = "DropdownMenuTrigger";
var DropdownMenuTrigger = React60.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, disabled = false, ...triggerProps } = props;
    const context = useDropdownMenuContext(TRIGGER_NAME7, __scopeDropdownMenu);
    const menuScope = useMenuScope2(__scopeDropdownMenu);
    return (0, import_jsx_runtime69.jsx)(Anchor2, { asChild: true, ...menuScope, children: (0, import_jsx_runtime69.jsx)(
      Primitive.button,
      {
        type: "button",
        id: context.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context.open,
        "aria-controls": context.open ? context.contentId : void 0,
        "data-state": context.open ? "open" : "closed",
        "data-disabled": disabled ? "" : void 0,
        disabled,
        ...triggerProps,
        ref: composeRefs(forwardedRef, context.triggerRef),
        onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
          if (!disabled && event.button === 0 && event.ctrlKey === false) {
            context.onOpenToggle();
            if (!context.open) event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          if (disabled) return;
          if (["Enter", " "].includes(event.key)) context.onOpenToggle();
          if (event.key === "ArrowDown") context.onOpenChange(true);
          if (["Enter", " ", "ArrowDown"].includes(event.key)) event.preventDefault();
        })
      }
    ) });
  }
);
DropdownMenuTrigger.displayName = TRIGGER_NAME7;
var PORTAL_NAME6 = "DropdownMenuPortal";
var DropdownMenuPortal = (props) => {
  const { __scopeDropdownMenu, ...portalProps } = props;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return (0, import_jsx_runtime69.jsx)(Portal3, { ...menuScope, ...portalProps });
};
DropdownMenuPortal.displayName = PORTAL_NAME6;
var CONTENT_NAME8 = "DropdownMenuContent";
var DropdownMenuContent = React60.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...contentProps } = props;
    const context = useDropdownMenuContext(CONTENT_NAME8, __scopeDropdownMenu);
    const menuScope = useMenuScope2(__scopeDropdownMenu);
    const hasInteractedOutsideRef = React60.useRef(false);
    return (0, import_jsx_runtime69.jsx)(
      Content22,
      {
        id: context.contentId,
        "aria-labelledby": context.triggerId,
        ...menuScope,
        ...contentProps,
        ref: forwardedRef,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          var _a6;
          if (!hasInteractedOutsideRef.current) (_a6 = context.triggerRef.current) == null ? void 0 : _a6.focus();
          hasInteractedOutsideRef.current = false;
          event.preventDefault();
        }),
        onInteractOutside: composeEventHandlers(props.onInteractOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (!context.modal || isRightClick) hasInteractedOutsideRef.current = true;
        }),
        style: {
          ...props.style,
          // re-namespace exposed content custom properties
          ...{
            "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
            "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
            "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      }
    );
  }
);
DropdownMenuContent.displayName = CONTENT_NAME8;
var GROUP_NAME4 = "DropdownMenuGroup";
var DropdownMenuGroup = React60.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...groupProps } = props;
    const menuScope = useMenuScope2(__scopeDropdownMenu);
    return (0, import_jsx_runtime69.jsx)(Group, { ...menuScope, ...groupProps, ref: forwardedRef });
  }
);
DropdownMenuGroup.displayName = GROUP_NAME4;
var LABEL_NAME3 = "DropdownMenuLabel";
var DropdownMenuLabel = React60.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...labelProps } = props;
    const menuScope = useMenuScope2(__scopeDropdownMenu);
    return (0, import_jsx_runtime69.jsx)(Label, { ...menuScope, ...labelProps, ref: forwardedRef });
  }
);
DropdownMenuLabel.displayName = LABEL_NAME3;
var ITEM_NAME5 = "DropdownMenuItem";
var DropdownMenuItem = React60.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...itemProps } = props;
    const menuScope = useMenuScope2(__scopeDropdownMenu);
    return (0, import_jsx_runtime69.jsx)(Item2, { ...menuScope, ...itemProps, ref: forwardedRef });
  }
);
DropdownMenuItem.displayName = ITEM_NAME5;
var CHECKBOX_ITEM_NAME3 = "DropdownMenuCheckboxItem";
var DropdownMenuCheckboxItem = React60.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...checkboxItemProps } = props;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return (0, import_jsx_runtime69.jsx)(CheckboxItem, { ...menuScope, ...checkboxItemProps, ref: forwardedRef });
});
DropdownMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME3;
var RADIO_GROUP_NAME3 = "DropdownMenuRadioGroup";
var DropdownMenuRadioGroup = React60.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioGroupProps } = props;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return (0, import_jsx_runtime69.jsx)(RadioGroup, { ...menuScope, ...radioGroupProps, ref: forwardedRef });
});
DropdownMenuRadioGroup.displayName = RADIO_GROUP_NAME3;
var RADIO_ITEM_NAME3 = "DropdownMenuRadioItem";
var DropdownMenuRadioItem = React60.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioItemProps } = props;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return (0, import_jsx_runtime69.jsx)(RadioItem, { ...menuScope, ...radioItemProps, ref: forwardedRef });
});
DropdownMenuRadioItem.displayName = RADIO_ITEM_NAME3;
var INDICATOR_NAME3 = "DropdownMenuItemIndicator";
var DropdownMenuItemIndicator = React60.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...itemIndicatorProps } = props;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return (0, import_jsx_runtime69.jsx)(ItemIndicator, { ...menuScope, ...itemIndicatorProps, ref: forwardedRef });
});
DropdownMenuItemIndicator.displayName = INDICATOR_NAME3;
var SEPARATOR_NAME3 = "DropdownMenuSeparator";
var DropdownMenuSeparator = React60.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...separatorProps } = props;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return (0, import_jsx_runtime69.jsx)(Separator, { ...menuScope, ...separatorProps, ref: forwardedRef });
});
DropdownMenuSeparator.displayName = SEPARATOR_NAME3;
var ARROW_NAME4 = "DropdownMenuArrow";
var DropdownMenuArrow = React60.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...arrowProps } = props;
    const menuScope = useMenuScope2(__scopeDropdownMenu);
    return (0, import_jsx_runtime69.jsx)(Arrow22, { ...menuScope, ...arrowProps, ref: forwardedRef });
  }
);
DropdownMenuArrow.displayName = ARROW_NAME4;
var DropdownMenuSub = (props) => {
  const { __scopeDropdownMenu, children, open: openProp, onOpenChange, defaultOpen } = props;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: "DropdownMenuSub"
  });
  return (0, import_jsx_runtime69.jsx)(Sub, { ...menuScope, open, onOpenChange: setOpen, children });
};
var SUB_TRIGGER_NAME3 = "DropdownMenuSubTrigger";
var DropdownMenuSubTrigger = React60.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subTriggerProps } = props;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return (0, import_jsx_runtime69.jsx)(SubTrigger, { ...menuScope, ...subTriggerProps, ref: forwardedRef });
});
DropdownMenuSubTrigger.displayName = SUB_TRIGGER_NAME3;
var SUB_CONTENT_NAME3 = "DropdownMenuSubContent";
var DropdownMenuSubContent = React60.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subContentProps } = props;
  const menuScope = useMenuScope2(__scopeDropdownMenu);
  return (0, import_jsx_runtime69.jsx)(
    SubContent,
    {
      ...menuScope,
      ...subContentProps,
      ref: forwardedRef,
      style: {
        ...props.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
DropdownMenuSubContent.displayName = SUB_CONTENT_NAME3;
var Root24 = DropdownMenu;
var Trigger4 = DropdownMenuTrigger;
var Portal23 = DropdownMenuPortal;
var Content24 = DropdownMenuContent;
var Group22 = DropdownMenuGroup;
var Label22 = DropdownMenuLabel;
var Item23 = DropdownMenuItem;
var CheckboxItem22 = DropdownMenuCheckboxItem;
var RadioGroup22 = DropdownMenuRadioGroup;
var RadioItem22 = DropdownMenuRadioItem;
var ItemIndicator22 = DropdownMenuItemIndicator;
var Separator22 = DropdownMenuSeparator;
var Arrow24 = DropdownMenuArrow;
var Sub22 = DropdownMenuSub;
var SubTrigger22 = DropdownMenuSubTrigger;
var SubContent22 = DropdownMenuSubContent;

// ../node_modules/@radix-ui/react-form/dist/index.mjs
var React62 = __toESM(require_react(), 1);

// ../node_modules/@radix-ui/react-label/dist/index.mjs
var React61 = __toESM(require_react(), 1);
var import_jsx_runtime70 = __toESM(require_jsx_runtime(), 1);
var NAME5 = "Label";
var Label3 = React61.forwardRef((props, forwardedRef) => {
  return (0, import_jsx_runtime70.jsx)(
    Primitive.label,
    {
      ...props,
      ref: forwardedRef,
      onMouseDown: (event) => {
        var _a6;
        const target = event.target;
        if (target.closest("button, input, select, textarea")) return;
        (_a6 = props.onMouseDown) == null ? void 0 : _a6.call(props, event);
        if (!event.defaultPrevented && event.detail > 1) event.preventDefault();
      }
    }
  );
});
Label3.displayName = NAME5;

// ../node_modules/@radix-ui/react-form/dist/index.mjs
var import_jsx_runtime71 = __toESM(require_jsx_runtime(), 1);
var [createFormContext, createFormScope] = createContextScope("Form");
var FORM_NAME = "Form";
var [ValidationProvider, useValidationContext] = createFormContext(FORM_NAME);
var [AriaDescriptionProvider, useAriaDescriptionContext] = createFormContext(FORM_NAME);
var Form = React62.forwardRef(
  (props, forwardedRef) => {
    const { __scopeForm, onClearServerErrors = () => {
    }, ...rootProps } = props;
    const formRef = React62.useRef(null);
    const composedFormRef = useComposedRefs(forwardedRef, formRef);
    const [validityMap, setValidityMap] = React62.useState({});
    const getFieldValidity = React62.useCallback(
      (fieldName) => validityMap[fieldName],
      [validityMap]
    );
    const handleFieldValidityChange = React62.useCallback(
      (fieldName, validity) => setValidityMap((prevValidityMap) => ({
        ...prevValidityMap,
        [fieldName]: { ...prevValidityMap[fieldName] ?? {}, ...validity }
      })),
      []
    );
    const handleFieldValiditionClear = React62.useCallback((fieldName) => {
      setValidityMap((prevValidityMap) => ({ ...prevValidityMap, [fieldName]: void 0 }));
      setCustomErrorsMap((prevCustomErrorsMap) => ({ ...prevCustomErrorsMap, [fieldName]: {} }));
    }, []);
    const [customMatcherEntriesMap, setCustomMatcherEntriesMap] = React62.useState({});
    const getFieldCustomMatcherEntries = React62.useCallback(
      (fieldName) => customMatcherEntriesMap[fieldName] ?? [],
      [customMatcherEntriesMap]
    );
    const handleFieldCustomMatcherAdd = React62.useCallback((fieldName, matcherEntry) => {
      setCustomMatcherEntriesMap((prevCustomMatcherEntriesMap) => ({
        ...prevCustomMatcherEntriesMap,
        [fieldName]: [...prevCustomMatcherEntriesMap[fieldName] ?? [], matcherEntry]
      }));
    }, []);
    const handleFieldCustomMatcherRemove = React62.useCallback((fieldName, matcherEntryId) => {
      setCustomMatcherEntriesMap((prevCustomMatcherEntriesMap) => ({
        ...prevCustomMatcherEntriesMap,
        [fieldName]: (prevCustomMatcherEntriesMap[fieldName] ?? []).filter(
          (matcherEntry) => matcherEntry.id !== matcherEntryId
        )
      }));
    }, []);
    const [customErrorsMap, setCustomErrorsMap] = React62.useState({});
    const getFieldCustomErrors = React62.useCallback(
      (fieldName) => customErrorsMap[fieldName] ?? {},
      [customErrorsMap]
    );
    const handleFieldCustomErrorsChange = React62.useCallback((fieldName, customErrors) => {
      setCustomErrorsMap((prevCustomErrorsMap) => ({
        ...prevCustomErrorsMap,
        [fieldName]: { ...prevCustomErrorsMap[fieldName] ?? {}, ...customErrors }
      }));
    }, []);
    const [messageIdsMap, setMessageIdsMap] = React62.useState({});
    const handleFieldMessageIdAdd = React62.useCallback((fieldName, id) => {
      setMessageIdsMap((prevMessageIdsMap) => {
        const fieldDescriptionIds = new Set(prevMessageIdsMap[fieldName]).add(id);
        return { ...prevMessageIdsMap, [fieldName]: fieldDescriptionIds };
      });
    }, []);
    const handleFieldMessageIdRemove = React62.useCallback((fieldName, id) => {
      setMessageIdsMap((prevMessageIdsMap) => {
        const fieldDescriptionIds = new Set(prevMessageIdsMap[fieldName]);
        fieldDescriptionIds.delete(id);
        return { ...prevMessageIdsMap, [fieldName]: fieldDescriptionIds };
      });
    }, []);
    const getFieldDescription = React62.useCallback(
      (fieldName) => Array.from(messageIdsMap[fieldName] ?? []).join(" ") || void 0,
      [messageIdsMap]
    );
    return (0, import_jsx_runtime71.jsx)(
      ValidationProvider,
      {
        scope: __scopeForm,
        getFieldValidity,
        onFieldValidityChange: handleFieldValidityChange,
        getFieldCustomMatcherEntries,
        onFieldCustomMatcherEntryAdd: handleFieldCustomMatcherAdd,
        onFieldCustomMatcherEntryRemove: handleFieldCustomMatcherRemove,
        getFieldCustomErrors,
        onFieldCustomErrorsChange: handleFieldCustomErrorsChange,
        onFieldValiditionClear: handleFieldValiditionClear,
        children: (0, import_jsx_runtime71.jsx)(
          AriaDescriptionProvider,
          {
            scope: __scopeForm,
            onFieldMessageIdAdd: handleFieldMessageIdAdd,
            onFieldMessageIdRemove: handleFieldMessageIdRemove,
            getFieldDescription,
            children: (0, import_jsx_runtime71.jsx)(
              Primitive.form,
              {
                ...rootProps,
                ref: composedFormRef,
                onInvalid: composeEventHandlers(props.onInvalid, (event) => {
                  const firstInvalidControl = getFirstInvalidControl(event.currentTarget);
                  if (firstInvalidControl === event.target) firstInvalidControl.focus();
                  event.preventDefault();
                }),
                onSubmit: composeEventHandlers(props.onSubmit, onClearServerErrors, {
                  checkForDefaultPrevented: false
                }),
                onReset: composeEventHandlers(props.onReset, onClearServerErrors)
              }
            )
          }
        )
      }
    );
  }
);
Form.displayName = FORM_NAME;
var FIELD_NAME = "FormField";
var [FormFieldProvider, useFormFieldContext] = createFormContext(FIELD_NAME);
var FormField = React62.forwardRef(
  (props, forwardedRef) => {
    const { __scopeForm, name, serverInvalid = false, ...fieldProps } = props;
    const validationContext = useValidationContext(FIELD_NAME, __scopeForm);
    const validity = validationContext.getFieldValidity(name);
    const id = useId2();
    return (0, import_jsx_runtime71.jsx)(FormFieldProvider, { scope: __scopeForm, id, name, serverInvalid, children: (0, import_jsx_runtime71.jsx)(
      Primitive.div,
      {
        "data-valid": getValidAttribute(validity, serverInvalid),
        "data-invalid": getInvalidAttribute(validity, serverInvalid),
        ...fieldProps,
        ref: forwardedRef
      }
    ) });
  }
);
FormField.displayName = FIELD_NAME;
var LABEL_NAME4 = "FormLabel";
var FormLabel = React62.forwardRef(
  (props, forwardedRef) => {
    const { __scopeForm, ...labelProps } = props;
    const validationContext = useValidationContext(LABEL_NAME4, __scopeForm);
    const fieldContext = useFormFieldContext(LABEL_NAME4, __scopeForm);
    const htmlFor = labelProps.htmlFor || fieldContext.id;
    const validity = validationContext.getFieldValidity(fieldContext.name);
    return (0, import_jsx_runtime71.jsx)(
      Label3,
      {
        "data-valid": getValidAttribute(validity, fieldContext.serverInvalid),
        "data-invalid": getInvalidAttribute(validity, fieldContext.serverInvalid),
        ...labelProps,
        ref: forwardedRef,
        htmlFor
      }
    );
  }
);
FormLabel.displayName = LABEL_NAME4;
var CONTROL_NAME = "FormControl";
var FormControl = React62.forwardRef(
  (props, forwardedRef) => {
    const { __scopeForm, ...controlProps } = props;
    const validationContext = useValidationContext(CONTROL_NAME, __scopeForm);
    const fieldContext = useFormFieldContext(CONTROL_NAME, __scopeForm);
    const ariaDescriptionContext = useAriaDescriptionContext(CONTROL_NAME, __scopeForm);
    const ref = React62.useRef(null);
    const composedRef = useComposedRefs(forwardedRef, ref);
    const name = controlProps.name || fieldContext.name;
    const id = controlProps.id || fieldContext.id;
    const customMatcherEntries = validationContext.getFieldCustomMatcherEntries(name);
    const { onFieldValidityChange, onFieldCustomErrorsChange, onFieldValiditionClear } = validationContext;
    const updateControlValidity = React62.useCallback(
      async (control) => {
        if (hasBuiltInError(control.validity)) {
          const controlValidity2 = validityStateToObject(control.validity);
          onFieldValidityChange(name, controlValidity2);
          return;
        }
        const formData = control.form ? new FormData(control.form) : new FormData();
        const matcherArgs = [control.value, formData];
        const syncCustomMatcherEntries = [];
        const ayncCustomMatcherEntries = [];
        customMatcherEntries.forEach((customMatcherEntry) => {
          if (isAsyncCustomMatcherEntry(customMatcherEntry, matcherArgs)) {
            ayncCustomMatcherEntries.push(customMatcherEntry);
          } else if (isSyncCustomMatcherEntry(customMatcherEntry)) {
            syncCustomMatcherEntries.push(customMatcherEntry);
          }
        });
        const syncCustomErrors = syncCustomMatcherEntries.map(({ id: id2, match }) => {
          return [id2, match(...matcherArgs)];
        });
        const syncCustomErrorsById = Object.fromEntries(syncCustomErrors);
        const hasSyncCustomErrors = Object.values(syncCustomErrorsById).some(Boolean);
        const hasCustomError = hasSyncCustomErrors;
        control.setCustomValidity(hasCustomError ? DEFAULT_INVALID_MESSAGE : "");
        const controlValidity = validityStateToObject(control.validity);
        onFieldValidityChange(name, controlValidity);
        onFieldCustomErrorsChange(name, syncCustomErrorsById);
        if (!hasSyncCustomErrors && ayncCustomMatcherEntries.length > 0) {
          const promisedCustomErrors = ayncCustomMatcherEntries.map(
            ({ id: id2, match }) => match(...matcherArgs).then((matches2) => [id2, matches2])
          );
          const asyncCustomErrors = await Promise.all(promisedCustomErrors);
          const asyncCustomErrorsById = Object.fromEntries(asyncCustomErrors);
          const hasAsyncCustomErrors = Object.values(asyncCustomErrorsById).some(Boolean);
          const hasCustomError2 = hasAsyncCustomErrors;
          control.setCustomValidity(hasCustomError2 ? DEFAULT_INVALID_MESSAGE : "");
          const controlValidity2 = validityStateToObject(control.validity);
          onFieldValidityChange(name, controlValidity2);
          onFieldCustomErrorsChange(name, asyncCustomErrorsById);
        }
      },
      [customMatcherEntries, name, onFieldCustomErrorsChange, onFieldValidityChange]
    );
    React62.useEffect(() => {
      const control = ref.current;
      if (control) {
        const handleChange = () => updateControlValidity(control);
        control.addEventListener("change", handleChange);
        return () => control.removeEventListener("change", handleChange);
      }
    }, [updateControlValidity]);
    const resetControlValidity = React62.useCallback(() => {
      const control = ref.current;
      if (control) {
        control.setCustomValidity("");
        onFieldValiditionClear(name);
      }
    }, [name, onFieldValiditionClear]);
    React62.useEffect(() => {
      var _a6;
      const form = (_a6 = ref.current) == null ? void 0 : _a6.form;
      if (form) {
        form.addEventListener("reset", resetControlValidity);
        return () => form.removeEventListener("reset", resetControlValidity);
      }
    }, [resetControlValidity]);
    React62.useEffect(() => {
      const control = ref.current;
      const form = control == null ? void 0 : control.closest("form");
      if (form && fieldContext.serverInvalid) {
        const firstInvalidControl = getFirstInvalidControl(form);
        if (firstInvalidControl === control) firstInvalidControl.focus();
      }
    }, [fieldContext.serverInvalid]);
    const validity = validationContext.getFieldValidity(name);
    return (0, import_jsx_runtime71.jsx)(
      Primitive.input,
      {
        "data-valid": getValidAttribute(validity, fieldContext.serverInvalid),
        "data-invalid": getInvalidAttribute(validity, fieldContext.serverInvalid),
        "aria-invalid": fieldContext.serverInvalid ? true : void 0,
        "aria-describedby": ariaDescriptionContext.getFieldDescription(name),
        title: "",
        ...controlProps,
        ref: composedRef,
        id,
        name,
        onInvalid: composeEventHandlers(props.onInvalid, (event) => {
          const control = event.currentTarget;
          updateControlValidity(control);
        }),
        onChange: composeEventHandlers(props.onChange, (_event) => {
          resetControlValidity();
        })
      }
    );
  }
);
FormControl.displayName = CONTROL_NAME;
var DEFAULT_INVALID_MESSAGE = "This value is not valid";
var DEFAULT_BUILT_IN_MESSAGES = {
  badInput: DEFAULT_INVALID_MESSAGE,
  patternMismatch: "This value does not match the required pattern",
  rangeOverflow: "This value is too large",
  rangeUnderflow: "This value is too small",
  stepMismatch: "This value does not match the required step",
  tooLong: "This value is too long",
  tooShort: "This value is too short",
  typeMismatch: "This value does not match the required type",
  valid: void 0,
  valueMissing: "This value is missing"
};
var MESSAGE_NAME = "FormMessage";
var FormMessage = React62.forwardRef(
  (props, forwardedRef) => {
    const { match, name: nameProp, ...messageProps } = props;
    const fieldContext = useFormFieldContext(MESSAGE_NAME, props.__scopeForm);
    const name = nameProp ?? fieldContext.name;
    if (match === void 0) {
      return (0, import_jsx_runtime71.jsx)(FormMessageImpl, { ...messageProps, ref: forwardedRef, name, children: props.children || DEFAULT_INVALID_MESSAGE });
    } else if (typeof match === "function") {
      return (0, import_jsx_runtime71.jsx)(FormCustomMessage, { match, ...messageProps, ref: forwardedRef, name });
    } else {
      return (0, import_jsx_runtime71.jsx)(FormBuiltInMessage, { match, ...messageProps, ref: forwardedRef, name });
    }
  }
);
FormMessage.displayName = MESSAGE_NAME;
var FormBuiltInMessage = React62.forwardRef(
  (props, forwardedRef) => {
    const { match, forceMatch = false, name, children, ...messageProps } = props;
    const validationContext = useValidationContext(MESSAGE_NAME, messageProps.__scopeForm);
    const validity = validationContext.getFieldValidity(name);
    const matches2 = forceMatch || (validity == null ? void 0 : validity[match]);
    if (matches2) {
      return (0, import_jsx_runtime71.jsx)(FormMessageImpl, { ref: forwardedRef, ...messageProps, name, children: children ?? DEFAULT_BUILT_IN_MESSAGES[match] });
    }
    return null;
  }
);
var FormCustomMessage = React62.forwardRef(
  (props, forwardedRef) => {
    const { match, forceMatch = false, name, id: idProp, children, ...messageProps } = props;
    const validationContext = useValidationContext(MESSAGE_NAME, messageProps.__scopeForm);
    const ref = React62.useRef(null);
    const composedRef = useComposedRefs(forwardedRef, ref);
    const _id = useId2();
    const id = idProp ?? _id;
    const customMatcherEntry = React62.useMemo(() => ({ id, match }), [id, match]);
    const { onFieldCustomMatcherEntryAdd, onFieldCustomMatcherEntryRemove } = validationContext;
    React62.useEffect(() => {
      onFieldCustomMatcherEntryAdd(name, customMatcherEntry);
      return () => onFieldCustomMatcherEntryRemove(name, customMatcherEntry.id);
    }, [customMatcherEntry, name, onFieldCustomMatcherEntryAdd, onFieldCustomMatcherEntryRemove]);
    const validity = validationContext.getFieldValidity(name);
    const customErrors = validationContext.getFieldCustomErrors(name);
    const hasMatchingCustomError = customErrors[id];
    const matches2 = forceMatch || validity && !hasBuiltInError(validity) && hasMatchingCustomError;
    if (matches2) {
      return (0, import_jsx_runtime71.jsx)(FormMessageImpl, { id, ref: composedRef, ...messageProps, name, children: children ?? DEFAULT_INVALID_MESSAGE });
    }
    return null;
  }
);
var FormMessageImpl = React62.forwardRef(
  (props, forwardedRef) => {
    const { __scopeForm, id: idProp, name, ...messageProps } = props;
    const ariaDescriptionContext = useAriaDescriptionContext(MESSAGE_NAME, __scopeForm);
    const _id = useId2();
    const id = idProp ?? _id;
    const { onFieldMessageIdAdd, onFieldMessageIdRemove } = ariaDescriptionContext;
    React62.useEffect(() => {
      onFieldMessageIdAdd(name, id);
      return () => onFieldMessageIdRemove(name, id);
    }, [name, id, onFieldMessageIdAdd, onFieldMessageIdRemove]);
    return (0, import_jsx_runtime71.jsx)(Primitive.span, { id, ...messageProps, ref: forwardedRef });
  }
);
var VALIDITY_STATE_NAME = "FormValidityState";
var FormValidityState = (props) => {
  const { __scopeForm, name: nameProp, children } = props;
  const validationContext = useValidationContext(VALIDITY_STATE_NAME, __scopeForm);
  const fieldContext = useFormFieldContext(VALIDITY_STATE_NAME, __scopeForm);
  const name = nameProp ?? fieldContext.name;
  const validity = validationContext.getFieldValidity(name);
  return (0, import_jsx_runtime71.jsx)(import_jsx_runtime71.Fragment, { children: children(validity) });
};
FormValidityState.displayName = VALIDITY_STATE_NAME;
var SUBMIT_NAME = "FormSubmit";
var FormSubmit = React62.forwardRef(
  (props, forwardedRef) => {
    const { __scopeForm, ...submitProps } = props;
    return (0, import_jsx_runtime71.jsx)(Primitive.button, { type: "submit", ...submitProps, ref: forwardedRef });
  }
);
FormSubmit.displayName = SUBMIT_NAME;
function validityStateToObject(validity) {
  const object = {};
  for (const key in validity) {
    object[key] = validity[key];
  }
  return object;
}
function isHTMLElement2(element) {
  return element instanceof HTMLElement;
}
function isFormControl(element) {
  return "validity" in element;
}
function isInvalid(control) {
  return isFormControl(control) && (control.validity.valid === false || control.getAttribute("aria-invalid") === "true");
}
function getFirstInvalidControl(form) {
  const elements = form.elements;
  const [firstInvalidControl] = Array.from(elements).filter(isHTMLElement2).filter(isInvalid);
  return firstInvalidControl;
}
function isAsyncCustomMatcherEntry(entry, args) {
  return entry.match.constructor.name === "AsyncFunction" || returnsPromise(entry.match, args);
}
function isSyncCustomMatcherEntry(entry) {
  return entry.match.constructor.name === "Function";
}
function returnsPromise(func, args) {
  return func(...args) instanceof Promise;
}
function hasBuiltInError(validity) {
  let error = false;
  for (const validityKey in validity) {
    const key = validityKey;
    if (key !== "valid" && key !== "customError" && validity[key]) {
      error = true;
      break;
    }
  }
  return error;
}
function getValidAttribute(validity, serverInvalid) {
  if ((validity == null ? void 0 : validity.valid) === true && !serverInvalid) return true;
  return void 0;
}
function getInvalidAttribute(validity, serverInvalid) {
  if ((validity == null ? void 0 : validity.valid) === false || serverInvalid) return true;
  return void 0;
}

// ../node_modules/@radix-ui/react-hover-card/dist/index.mjs
var React63 = __toESM(require_react(), 1);
var import_jsx_runtime72 = __toESM(require_jsx_runtime(), 1);
var originalBodyUserSelect;
var HOVERCARD_NAME = "HoverCard";
var [createHoverCardContext, createHoverCardScope] = createContextScope(HOVERCARD_NAME, [
  createPopperScope
]);
var usePopperScope2 = createPopperScope();
var [HoverCardProvider, useHoverCardContext] = createHoverCardContext(HOVERCARD_NAME);
var HoverCard = (props) => {
  const {
    __scopeHoverCard,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    openDelay = 700,
    closeDelay = 300
  } = props;
  const popperScope = usePopperScope2(__scopeHoverCard);
  const openTimerRef = React63.useRef(0);
  const closeTimerRef = React63.useRef(0);
  const hasSelectionRef = React63.useRef(false);
  const isPointerDownOnContentRef = React63.useRef(false);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: HOVERCARD_NAME
  });
  const handleOpen = React63.useCallback(() => {
    clearTimeout(closeTimerRef.current);
    openTimerRef.current = window.setTimeout(() => setOpen(true), openDelay);
  }, [openDelay, setOpen]);
  const handleClose = React63.useCallback(() => {
    clearTimeout(openTimerRef.current);
    if (!hasSelectionRef.current && !isPointerDownOnContentRef.current) {
      closeTimerRef.current = window.setTimeout(() => setOpen(false), closeDelay);
    }
  }, [closeDelay, setOpen]);
  const handleDismiss = React63.useCallback(() => setOpen(false), [setOpen]);
  React63.useEffect(() => {
    return () => {
      clearTimeout(openTimerRef.current);
      clearTimeout(closeTimerRef.current);
    };
  }, []);
  return (0, import_jsx_runtime72.jsx)(
    HoverCardProvider,
    {
      scope: __scopeHoverCard,
      open,
      onOpenChange: setOpen,
      onOpen: handleOpen,
      onClose: handleClose,
      onDismiss: handleDismiss,
      hasSelectionRef,
      isPointerDownOnContentRef,
      children: (0, import_jsx_runtime72.jsx)(Root22, { ...popperScope, children })
    }
  );
};
HoverCard.displayName = HOVERCARD_NAME;
var TRIGGER_NAME8 = "HoverCardTrigger";
var HoverCardTrigger = React63.forwardRef(
  (props, forwardedRef) => {
    const { __scopeHoverCard, ...triggerProps } = props;
    const context = useHoverCardContext(TRIGGER_NAME8, __scopeHoverCard);
    const popperScope = usePopperScope2(__scopeHoverCard);
    return (0, import_jsx_runtime72.jsx)(Anchor, { asChild: true, ...popperScope, children: (0, import_jsx_runtime72.jsx)(
      Primitive.a,
      {
        "data-state": context.open ? "open" : "closed",
        ...triggerProps,
        ref: forwardedRef,
        onPointerEnter: composeEventHandlers(props.onPointerEnter, excludeTouch(context.onOpen)),
        onPointerLeave: composeEventHandlers(props.onPointerLeave, excludeTouch(context.onClose)),
        onFocus: composeEventHandlers(props.onFocus, context.onOpen),
        onBlur: composeEventHandlers(props.onBlur, context.onClose),
        onTouchStart: composeEventHandlers(props.onTouchStart, (event) => event.preventDefault())
      }
    ) });
  }
);
HoverCardTrigger.displayName = TRIGGER_NAME8;
var PORTAL_NAME7 = "HoverCardPortal";
var [PortalProvider3, usePortalContext3] = createHoverCardContext(PORTAL_NAME7, {
  forceMount: void 0
});
var HoverCardPortal = (props) => {
  const { __scopeHoverCard, forceMount, children, container } = props;
  const context = useHoverCardContext(PORTAL_NAME7, __scopeHoverCard);
  return (0, import_jsx_runtime72.jsx)(PortalProvider3, { scope: __scopeHoverCard, forceMount, children: (0, import_jsx_runtime72.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime72.jsx)(Portal, { asChild: true, container, children }) }) });
};
HoverCardPortal.displayName = PORTAL_NAME7;
var CONTENT_NAME9 = "HoverCardContent";
var HoverCardContent = React63.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext3(CONTENT_NAME9, props.__scopeHoverCard);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useHoverCardContext(CONTENT_NAME9, props.__scopeHoverCard);
    return (0, import_jsx_runtime72.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime72.jsx)(
      HoverCardContentImpl,
      {
        "data-state": context.open ? "open" : "closed",
        ...contentProps,
        onPointerEnter: composeEventHandlers(props.onPointerEnter, excludeTouch(context.onOpen)),
        onPointerLeave: composeEventHandlers(props.onPointerLeave, excludeTouch(context.onClose)),
        ref: forwardedRef
      }
    ) });
  }
);
HoverCardContent.displayName = CONTENT_NAME9;
var HoverCardContentImpl = React63.forwardRef((props, forwardedRef) => {
  const {
    __scopeHoverCard,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside,
    onInteractOutside,
    ...contentProps
  } = props;
  const context = useHoverCardContext(CONTENT_NAME9, __scopeHoverCard);
  const popperScope = usePopperScope2(__scopeHoverCard);
  const ref = React63.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const [containSelection, setContainSelection] = React63.useState(false);
  React63.useEffect(() => {
    if (containSelection) {
      const body = document.body;
      originalBodyUserSelect = body.style.userSelect || body.style.webkitUserSelect;
      body.style.userSelect = "none";
      body.style.webkitUserSelect = "none";
      return () => {
        body.style.userSelect = originalBodyUserSelect;
        body.style.webkitUserSelect = originalBodyUserSelect;
      };
    }
  }, [containSelection]);
  React63.useEffect(() => {
    if (ref.current) {
      const handlePointerUp = () => {
        setContainSelection(false);
        context.isPointerDownOnContentRef.current = false;
        setTimeout(() => {
          var _a6;
          const hasSelection2 = ((_a6 = document.getSelection()) == null ? void 0 : _a6.toString()) !== "";
          if (hasSelection2) context.hasSelectionRef.current = true;
        });
      };
      document.addEventListener("pointerup", handlePointerUp);
      return () => {
        document.removeEventListener("pointerup", handlePointerUp);
        context.hasSelectionRef.current = false;
        context.isPointerDownOnContentRef.current = false;
      };
    }
  }, [context.isPointerDownOnContentRef, context.hasSelectionRef]);
  React63.useEffect(() => {
    if (ref.current) {
      const tabbables = getTabbableNodes(ref.current);
      tabbables.forEach((tabbable) => tabbable.setAttribute("tabindex", "-1"));
    }
  });
  return (0, import_jsx_runtime72.jsx)(
    DismissableLayer,
    {
      asChild: true,
      disableOutsidePointerEvents: false,
      onInteractOutside,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside: composeEventHandlers(onFocusOutside, (event) => {
        event.preventDefault();
      }),
      onDismiss: context.onDismiss,
      children: (0, import_jsx_runtime72.jsx)(
        Content3,
        {
          ...popperScope,
          ...contentProps,
          onPointerDown: composeEventHandlers(contentProps.onPointerDown, (event) => {
            if (event.currentTarget.contains(event.target)) {
              setContainSelection(true);
            }
            context.hasSelectionRef.current = false;
            context.isPointerDownOnContentRef.current = true;
          }),
          ref: composedRefs,
          style: {
            ...contentProps.style,
            userSelect: containSelection ? "text" : void 0,
            // Safari requires prefix
            WebkitUserSelect: containSelection ? "text" : void 0,
            // re-namespace exposed content custom properties
            ...{
              "--radix-hover-card-content-transform-origin": "var(--radix-popper-transform-origin)",
              "--radix-hover-card-content-available-width": "var(--radix-popper-available-width)",
              "--radix-hover-card-content-available-height": "var(--radix-popper-available-height)",
              "--radix-hover-card-trigger-width": "var(--radix-popper-anchor-width)",
              "--radix-hover-card-trigger-height": "var(--radix-popper-anchor-height)"
            }
          }
        }
      )
    }
  );
});
var ARROW_NAME5 = "HoverCardArrow";
var HoverCardArrow = React63.forwardRef(
  (props, forwardedRef) => {
    const { __scopeHoverCard, ...arrowProps } = props;
    const popperScope = usePopperScope2(__scopeHoverCard);
    return (0, import_jsx_runtime72.jsx)(Arrow2, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
HoverCardArrow.displayName = ARROW_NAME5;
function excludeTouch(eventHandler2) {
  return (event) => event.pointerType === "touch" ? void 0 : eventHandler2();
}
function getTabbableNodes(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}

// ../node_modules/@radix-ui/react-menubar/dist/index.mjs
var React64 = __toESM(require_react(), 1);
var import_jsx_runtime73 = __toESM(require_jsx_runtime(), 1);
var MENUBAR_NAME = "Menubar";
var [Collection4, useCollection4, createCollectionScope4] = createCollection(MENUBAR_NAME);
var [createMenubarContext, createMenubarScope] = createContextScope(MENUBAR_NAME, [
  createCollectionScope4,
  createRovingFocusGroupScope
]);
var useMenuScope3 = createMenuScope();
var useRovingFocusGroupScope2 = createRovingFocusGroupScope();
var [MenubarContextProvider, useMenubarContext] = createMenubarContext(MENUBAR_NAME);
var Menubar = React64.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeMenubar,
      value: valueProp,
      onValueChange,
      defaultValue,
      loop = true,
      dir,
      ...menubarProps
    } = props;
    const direction = useDirection(dir);
    const rovingFocusGroupScope = useRovingFocusGroupScope2(__scopeMenubar);
    const [value, setValue] = useControllableState({
      prop: valueProp,
      onChange: onValueChange,
      defaultProp: defaultValue ?? "",
      caller: MENUBAR_NAME
    });
    const [currentTabStopId, setCurrentTabStopId] = React64.useState(null);
    return (0, import_jsx_runtime73.jsx)(
      MenubarContextProvider,
      {
        scope: __scopeMenubar,
        value,
        onMenuOpen: React64.useCallback(
          (value2) => {
            setValue(value2);
            setCurrentTabStopId(value2);
          },
          [setValue]
        ),
        onMenuClose: React64.useCallback(() => setValue(""), [setValue]),
        onMenuToggle: React64.useCallback(
          (value2) => {
            setValue((prevValue) => prevValue ? "" : value2);
            setCurrentTabStopId(value2);
          },
          [setValue]
        ),
        dir: direction,
        loop,
        children: (0, import_jsx_runtime73.jsx)(Collection4.Provider, { scope: __scopeMenubar, children: (0, import_jsx_runtime73.jsx)(Collection4.Slot, { scope: __scopeMenubar, children: (0, import_jsx_runtime73.jsx)(
          Root7,
          {
            asChild: true,
            ...rovingFocusGroupScope,
            orientation: "horizontal",
            loop,
            dir: direction,
            currentTabStopId,
            onCurrentTabStopIdChange: setCurrentTabStopId,
            children: (0, import_jsx_runtime73.jsx)(Primitive.div, { role: "menubar", ...menubarProps, ref: forwardedRef })
          }
        ) }) })
      }
    );
  }
);
Menubar.displayName = MENUBAR_NAME;
var MENU_NAME2 = "MenubarMenu";
var [MenubarMenuProvider, useMenubarMenuContext] = createMenubarContext(MENU_NAME2);
var MenubarMenu = (props) => {
  const { __scopeMenubar, value: valueProp, ...menuProps } = props;
  const autoValue = useId2();
  const value = valueProp || autoValue || "LEGACY_REACT_AUTO_VALUE";
  const context = useMenubarContext(MENU_NAME2, __scopeMenubar);
  const menuScope = useMenuScope3(__scopeMenubar);
  const triggerRef = React64.useRef(null);
  const wasKeyboardTriggerOpenRef = React64.useRef(false);
  const open = context.value === value;
  React64.useEffect(() => {
    if (!open) wasKeyboardTriggerOpenRef.current = false;
  }, [open]);
  return (0, import_jsx_runtime73.jsx)(
    MenubarMenuProvider,
    {
      scope: __scopeMenubar,
      value,
      triggerId: useId2(),
      triggerRef,
      contentId: useId2(),
      wasKeyboardTriggerOpenRef,
      children: (0, import_jsx_runtime73.jsx)(
        Root32,
        {
          ...menuScope,
          open,
          onOpenChange: (open2) => {
            if (!open2) context.onMenuClose();
          },
          modal: false,
          dir: context.dir,
          ...menuProps
        }
      )
    }
  );
};
MenubarMenu.displayName = MENU_NAME2;
var TRIGGER_NAME9 = "MenubarTrigger";
var MenubarTrigger = React64.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, disabled = false, ...triggerProps } = props;
    const rovingFocusGroupScope = useRovingFocusGroupScope2(__scopeMenubar);
    const menuScope = useMenuScope3(__scopeMenubar);
    const context = useMenubarContext(TRIGGER_NAME9, __scopeMenubar);
    const menuContext2 = useMenubarMenuContext(TRIGGER_NAME9, __scopeMenubar);
    const ref = React64.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, menuContext2.triggerRef);
    const [isFocused, setIsFocused] = React64.useState(false);
    const open = context.value === menuContext2.value;
    return (0, import_jsx_runtime73.jsx)(Collection4.ItemSlot, { scope: __scopeMenubar, value: menuContext2.value, disabled, children: (0, import_jsx_runtime73.jsx)(
      Item,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        focusable: !disabled,
        tabStopId: menuContext2.value,
        children: (0, import_jsx_runtime73.jsx)(Anchor2, { asChild: true, ...menuScope, children: (0, import_jsx_runtime73.jsx)(
          Primitive.button,
          {
            type: "button",
            role: "menuitem",
            id: menuContext2.triggerId,
            "aria-haspopup": "menu",
            "aria-expanded": open,
            "aria-controls": open ? menuContext2.contentId : void 0,
            "data-highlighted": isFocused ? "" : void 0,
            "data-state": open ? "open" : "closed",
            "data-disabled": disabled ? "" : void 0,
            disabled,
            ...triggerProps,
            ref: composedRefs,
            onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
              if (!disabled && event.button === 0 && event.ctrlKey === false) {
                context.onMenuOpen(menuContext2.value);
                if (!open) event.preventDefault();
              }
            }),
            onPointerEnter: composeEventHandlers(props.onPointerEnter, () => {
              var _a6;
              const menubarOpen = Boolean(context.value);
              if (menubarOpen && !open) {
                context.onMenuOpen(menuContext2.value);
                (_a6 = ref.current) == null ? void 0 : _a6.focus();
              }
            }),
            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
              if (disabled) return;
              if (["Enter", " "].includes(event.key)) context.onMenuToggle(menuContext2.value);
              if (event.key === "ArrowDown") context.onMenuOpen(menuContext2.value);
              if (["Enter", " ", "ArrowDown"].includes(event.key)) {
                menuContext2.wasKeyboardTriggerOpenRef.current = true;
                event.preventDefault();
              }
            }),
            onFocus: composeEventHandlers(props.onFocus, () => setIsFocused(true)),
            onBlur: composeEventHandlers(props.onBlur, () => setIsFocused(false))
          }
        ) })
      }
    ) });
  }
);
MenubarTrigger.displayName = TRIGGER_NAME9;
var PORTAL_NAME8 = "MenubarPortal";
var MenubarPortal = (props) => {
  const { __scopeMenubar, ...portalProps } = props;
  const menuScope = useMenuScope3(__scopeMenubar);
  return (0, import_jsx_runtime73.jsx)(Portal3, { ...menuScope, ...portalProps });
};
MenubarPortal.displayName = PORTAL_NAME8;
var CONTENT_NAME10 = "MenubarContent";
var MenubarContent = React64.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, align = "start", ...contentProps } = props;
    const menuScope = useMenuScope3(__scopeMenubar);
    const context = useMenubarContext(CONTENT_NAME10, __scopeMenubar);
    const menuContext2 = useMenubarMenuContext(CONTENT_NAME10, __scopeMenubar);
    const getItems = useCollection4(__scopeMenubar);
    const hasInteractedOutsideRef = React64.useRef(false);
    return (0, import_jsx_runtime73.jsx)(
      Content22,
      {
        id: menuContext2.contentId,
        "aria-labelledby": menuContext2.triggerId,
        "data-radix-menubar-content": "",
        ...menuScope,
        ...contentProps,
        ref: forwardedRef,
        align,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          var _a6;
          const menubarOpen = Boolean(context.value);
          if (!menubarOpen && !hasInteractedOutsideRef.current) {
            (_a6 = menuContext2.triggerRef.current) == null ? void 0 : _a6.focus();
          }
          hasInteractedOutsideRef.current = false;
          event.preventDefault();
        }),
        onFocusOutside: composeEventHandlers(props.onFocusOutside, (event) => {
          const target = event.target;
          const isMenubarTrigger = getItems().some((item) => {
            var _a6;
            return (_a6 = item.ref.current) == null ? void 0 : _a6.contains(target);
          });
          if (isMenubarTrigger) event.preventDefault();
        }),
        onInteractOutside: composeEventHandlers(props.onInteractOutside, () => {
          hasInteractedOutsideRef.current = true;
        }),
        onEntryFocus: (event) => {
          if (!menuContext2.wasKeyboardTriggerOpenRef.current) event.preventDefault();
        },
        onKeyDown: composeEventHandlers(
          props.onKeyDown,
          (event) => {
            if (["ArrowRight", "ArrowLeft"].includes(event.key)) {
              const target = event.target;
              const targetIsSubTrigger = target.hasAttribute("data-radix-menubar-subtrigger");
              const isKeyDownInsideSubMenu = target.closest("[data-radix-menubar-content]") !== event.currentTarget;
              const prevMenuKey = context.dir === "rtl" ? "ArrowRight" : "ArrowLeft";
              const isPrevKey = prevMenuKey === event.key;
              const isNextKey = !isPrevKey;
              if (isNextKey && targetIsSubTrigger) return;
              if (isKeyDownInsideSubMenu && isPrevKey) return;
              const items = getItems().filter((item) => !item.disabled);
              let candidateValues = items.map((item) => item.value);
              if (isPrevKey) candidateValues.reverse();
              const currentIndex = candidateValues.indexOf(menuContext2.value);
              candidateValues = context.loop ? wrapArray3(candidateValues, currentIndex + 1) : candidateValues.slice(currentIndex + 1);
              const [nextValue] = candidateValues;
              if (nextValue) context.onMenuOpen(nextValue);
            }
          },
          { checkForDefaultPrevented: false }
        ),
        style: {
          ...props.style,
          // re-namespace exposed content custom properties
          ...{
            "--radix-menubar-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-menubar-content-available-width": "var(--radix-popper-available-width)",
            "--radix-menubar-content-available-height": "var(--radix-popper-available-height)",
            "--radix-menubar-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-menubar-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      }
    );
  }
);
MenubarContent.displayName = CONTENT_NAME10;
var GROUP_NAME5 = "MenubarGroup";
var MenubarGroup = React64.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, ...groupProps } = props;
    const menuScope = useMenuScope3(__scopeMenubar);
    return (0, import_jsx_runtime73.jsx)(Group, { ...menuScope, ...groupProps, ref: forwardedRef });
  }
);
MenubarGroup.displayName = GROUP_NAME5;
var LABEL_NAME5 = "MenubarLabel";
var MenubarLabel = React64.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, ...labelProps } = props;
    const menuScope = useMenuScope3(__scopeMenubar);
    return (0, import_jsx_runtime73.jsx)(Label, { ...menuScope, ...labelProps, ref: forwardedRef });
  }
);
MenubarLabel.displayName = LABEL_NAME5;
var ITEM_NAME6 = "MenubarItem";
var MenubarItem = React64.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, ...itemProps } = props;
    const menuScope = useMenuScope3(__scopeMenubar);
    return (0, import_jsx_runtime73.jsx)(Item2, { ...menuScope, ...itemProps, ref: forwardedRef });
  }
);
MenubarItem.displayName = ITEM_NAME6;
var CHECKBOX_ITEM_NAME4 = "MenubarCheckboxItem";
var MenubarCheckboxItem = React64.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, ...checkboxItemProps } = props;
    const menuScope = useMenuScope3(__scopeMenubar);
    return (0, import_jsx_runtime73.jsx)(CheckboxItem, { ...menuScope, ...checkboxItemProps, ref: forwardedRef });
  }
);
MenubarCheckboxItem.displayName = CHECKBOX_ITEM_NAME4;
var RADIO_GROUP_NAME4 = "MenubarRadioGroup";
var MenubarRadioGroup = React64.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, ...radioGroupProps } = props;
    const menuScope = useMenuScope3(__scopeMenubar);
    return (0, import_jsx_runtime73.jsx)(RadioGroup, { ...menuScope, ...radioGroupProps, ref: forwardedRef });
  }
);
MenubarRadioGroup.displayName = RADIO_GROUP_NAME4;
var RADIO_ITEM_NAME4 = "MenubarRadioItem";
var MenubarRadioItem = React64.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, ...radioItemProps } = props;
    const menuScope = useMenuScope3(__scopeMenubar);
    return (0, import_jsx_runtime73.jsx)(RadioItem, { ...menuScope, ...radioItemProps, ref: forwardedRef });
  }
);
MenubarRadioItem.displayName = RADIO_ITEM_NAME4;
var INDICATOR_NAME4 = "MenubarItemIndicator";
var MenubarItemIndicator = React64.forwardRef((props, forwardedRef) => {
  const { __scopeMenubar, ...itemIndicatorProps } = props;
  const menuScope = useMenuScope3(__scopeMenubar);
  return (0, import_jsx_runtime73.jsx)(ItemIndicator, { ...menuScope, ...itemIndicatorProps, ref: forwardedRef });
});
MenubarItemIndicator.displayName = INDICATOR_NAME4;
var SEPARATOR_NAME4 = "MenubarSeparator";
var MenubarSeparator = React64.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, ...separatorProps } = props;
    const menuScope = useMenuScope3(__scopeMenubar);
    return (0, import_jsx_runtime73.jsx)(Separator, { ...menuScope, ...separatorProps, ref: forwardedRef });
  }
);
MenubarSeparator.displayName = SEPARATOR_NAME4;
var ARROW_NAME6 = "MenubarArrow";
var MenubarArrow = React64.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, ...arrowProps } = props;
    const menuScope = useMenuScope3(__scopeMenubar);
    return (0, import_jsx_runtime73.jsx)(Arrow22, { ...menuScope, ...arrowProps, ref: forwardedRef });
  }
);
MenubarArrow.displayName = ARROW_NAME6;
var SUB_NAME3 = "MenubarSub";
var MenubarSub = (props) => {
  const { __scopeMenubar, children, open: openProp, onOpenChange, defaultOpen } = props;
  const menuScope = useMenuScope3(__scopeMenubar);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: SUB_NAME3
  });
  return (0, import_jsx_runtime73.jsx)(Sub, { ...menuScope, open, onOpenChange: setOpen, children });
};
MenubarSub.displayName = SUB_NAME3;
var SUB_TRIGGER_NAME4 = "MenubarSubTrigger";
var MenubarSubTrigger = React64.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, ...subTriggerProps } = props;
    const menuScope = useMenuScope3(__scopeMenubar);
    return (0, import_jsx_runtime73.jsx)(
      SubTrigger,
      {
        "data-radix-menubar-subtrigger": "",
        ...menuScope,
        ...subTriggerProps,
        ref: forwardedRef
      }
    );
  }
);
MenubarSubTrigger.displayName = SUB_TRIGGER_NAME4;
var SUB_CONTENT_NAME4 = "MenubarSubContent";
var MenubarSubContent = React64.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenubar, ...subContentProps } = props;
    const menuScope = useMenuScope3(__scopeMenubar);
    return (0, import_jsx_runtime73.jsx)(
      SubContent,
      {
        ...menuScope,
        "data-radix-menubar-content": "",
        ...subContentProps,
        ref: forwardedRef,
        style: {
          ...props.style,
          // re-namespace exposed content custom properties
          ...{
            "--radix-menubar-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-menubar-content-available-width": "var(--radix-popper-available-width)",
            "--radix-menubar-content-available-height": "var(--radix-popper-available-height)",
            "--radix-menubar-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-menubar-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      }
    );
  }
);
MenubarSubContent.displayName = SUB_CONTENT_NAME4;
function wrapArray3(array, startIndex) {
  return array.map((_, index2) => array[(startIndex + index2) % array.length]);
}

// ../node_modules/@radix-ui/react-navigation-menu/dist/index.mjs
var React65 = __toESM(require_react(), 1);
var import_react_dom5 = __toESM(require_react_dom(), 1);
var import_jsx_runtime74 = __toESM(require_jsx_runtime(), 1);
var NAVIGATION_MENU_NAME = "NavigationMenu";
var [Collection5, useCollection5, createCollectionScope5] = createCollection(NAVIGATION_MENU_NAME);
var [FocusGroupCollection, useFocusGroupCollection, createFocusGroupCollectionScope] = createCollection(NAVIGATION_MENU_NAME);
var [createNavigationMenuContext, createNavigationMenuScope] = createContextScope(
  NAVIGATION_MENU_NAME,
  [createCollectionScope5, createFocusGroupCollectionScope]
);
var [NavigationMenuProviderImpl, useNavigationMenuContext] = createNavigationMenuContext(NAVIGATION_MENU_NAME);
var [ViewportContentProvider, useViewportContentContext] = createNavigationMenuContext(NAVIGATION_MENU_NAME);
var NavigationMenu = React65.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeNavigationMenu,
      value: valueProp,
      onValueChange,
      defaultValue,
      delayDuration = 200,
      skipDelayDuration = 300,
      orientation = "horizontal",
      dir,
      ...NavigationMenuProps
    } = props;
    const [navigationMenu, setNavigationMenu] = React65.useState(null);
    const composedRef = useComposedRefs(forwardedRef, (node) => setNavigationMenu(node));
    const direction = useDirection(dir);
    const openTimerRef = React65.useRef(0);
    const closeTimerRef = React65.useRef(0);
    const skipDelayTimerRef = React65.useRef(0);
    const [isOpenDelayed, setIsOpenDelayed] = React65.useState(true);
    const [value, setValue] = useControllableState({
      prop: valueProp,
      onChange: (value2) => {
        const isOpen = value2 !== "";
        const hasSkipDelayDuration = skipDelayDuration > 0;
        if (isOpen) {
          window.clearTimeout(skipDelayTimerRef.current);
          if (hasSkipDelayDuration) setIsOpenDelayed(false);
        } else {
          window.clearTimeout(skipDelayTimerRef.current);
          skipDelayTimerRef.current = window.setTimeout(
            () => setIsOpenDelayed(true),
            skipDelayDuration
          );
        }
        onValueChange == null ? void 0 : onValueChange(value2);
      },
      defaultProp: defaultValue ?? "",
      caller: NAVIGATION_MENU_NAME
    });
    const startCloseTimer = React65.useCallback(() => {
      window.clearTimeout(closeTimerRef.current);
      closeTimerRef.current = window.setTimeout(() => setValue(""), 150);
    }, [setValue]);
    const handleOpen = React65.useCallback(
      (itemValue) => {
        window.clearTimeout(closeTimerRef.current);
        setValue(itemValue);
      },
      [setValue]
    );
    const handleDelayedOpen = React65.useCallback(
      (itemValue) => {
        const isOpenItem = value === itemValue;
        if (isOpenItem) {
          window.clearTimeout(closeTimerRef.current);
        } else {
          openTimerRef.current = window.setTimeout(() => {
            window.clearTimeout(closeTimerRef.current);
            setValue(itemValue);
          }, delayDuration);
        }
      },
      [value, setValue, delayDuration]
    );
    React65.useEffect(() => {
      return () => {
        window.clearTimeout(openTimerRef.current);
        window.clearTimeout(closeTimerRef.current);
        window.clearTimeout(skipDelayTimerRef.current);
      };
    }, []);
    return (0, import_jsx_runtime74.jsx)(
      NavigationMenuProvider,
      {
        scope: __scopeNavigationMenu,
        isRootMenu: true,
        value,
        dir: direction,
        orientation,
        rootNavigationMenu: navigationMenu,
        onTriggerEnter: (itemValue) => {
          window.clearTimeout(openTimerRef.current);
          if (isOpenDelayed) handleDelayedOpen(itemValue);
          else handleOpen(itemValue);
        },
        onTriggerLeave: () => {
          window.clearTimeout(openTimerRef.current);
          startCloseTimer();
        },
        onContentEnter: () => window.clearTimeout(closeTimerRef.current),
        onContentLeave: startCloseTimer,
        onItemSelect: (itemValue) => {
          setValue((prevValue) => prevValue === itemValue ? "" : itemValue);
        },
        onItemDismiss: () => setValue(""),
        children: (0, import_jsx_runtime74.jsx)(
          Primitive.nav,
          {
            "aria-label": "Main",
            "data-orientation": orientation,
            dir: direction,
            ...NavigationMenuProps,
            ref: composedRef
          }
        )
      }
    );
  }
);
NavigationMenu.displayName = NAVIGATION_MENU_NAME;
var SUB_NAME4 = "NavigationMenuSub";
var NavigationMenuSub = React65.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeNavigationMenu,
      value: valueProp,
      onValueChange,
      defaultValue,
      orientation = "horizontal",
      ...subProps
    } = props;
    const context = useNavigationMenuContext(SUB_NAME4, __scopeNavigationMenu);
    const [value, setValue] = useControllableState({
      prop: valueProp,
      onChange: onValueChange,
      defaultProp: defaultValue ?? "",
      caller: SUB_NAME4
    });
    return (0, import_jsx_runtime74.jsx)(
      NavigationMenuProvider,
      {
        scope: __scopeNavigationMenu,
        isRootMenu: false,
        value,
        dir: context.dir,
        orientation,
        rootNavigationMenu: context.rootNavigationMenu,
        onTriggerEnter: (itemValue) => setValue(itemValue),
        onItemSelect: (itemValue) => setValue(itemValue),
        onItemDismiss: () => setValue(""),
        children: (0, import_jsx_runtime74.jsx)(Primitive.div, { "data-orientation": orientation, ...subProps, ref: forwardedRef })
      }
    );
  }
);
NavigationMenuSub.displayName = SUB_NAME4;
var NavigationMenuProvider = (props) => {
  const {
    scope,
    isRootMenu,
    rootNavigationMenu,
    dir,
    orientation,
    children,
    value,
    onItemSelect,
    onItemDismiss,
    onTriggerEnter,
    onTriggerLeave,
    onContentEnter,
    onContentLeave
  } = props;
  const [viewport, setViewport] = React65.useState(null);
  const [viewportContent, setViewportContent] = React65.useState(/* @__PURE__ */ new Map());
  const [indicatorTrack, setIndicatorTrack] = React65.useState(null);
  return (0, import_jsx_runtime74.jsx)(
    NavigationMenuProviderImpl,
    {
      scope,
      isRootMenu,
      rootNavigationMenu,
      value,
      previousValue: usePrevious(value),
      baseId: useId2(),
      dir,
      orientation,
      viewport,
      onViewportChange: setViewport,
      indicatorTrack,
      onIndicatorTrackChange: setIndicatorTrack,
      onTriggerEnter: useCallbackRef(onTriggerEnter),
      onTriggerLeave: useCallbackRef(onTriggerLeave),
      onContentEnter: useCallbackRef(onContentEnter),
      onContentLeave: useCallbackRef(onContentLeave),
      onItemSelect: useCallbackRef(onItemSelect),
      onItemDismiss: useCallbackRef(onItemDismiss),
      onViewportContentChange: React65.useCallback((contentValue, contentData) => {
        setViewportContent((prevContent) => {
          prevContent.set(contentValue, contentData);
          return new Map(prevContent);
        });
      }, []),
      onViewportContentRemove: React65.useCallback((contentValue) => {
        setViewportContent((prevContent) => {
          if (!prevContent.has(contentValue)) return prevContent;
          prevContent.delete(contentValue);
          return new Map(prevContent);
        });
      }, []),
      children: (0, import_jsx_runtime74.jsx)(Collection5.Provider, { scope, children: (0, import_jsx_runtime74.jsx)(ViewportContentProvider, { scope, items: viewportContent, children }) })
    }
  );
};
var LIST_NAME = "NavigationMenuList";
var NavigationMenuList = React65.forwardRef(
  (props, forwardedRef) => {
    const { __scopeNavigationMenu, ...listProps } = props;
    const context = useNavigationMenuContext(LIST_NAME, __scopeNavigationMenu);
    const list = (0, import_jsx_runtime74.jsx)(Primitive.ul, { "data-orientation": context.orientation, ...listProps, ref: forwardedRef });
    return (0, import_jsx_runtime74.jsx)(Primitive.div, { style: { position: "relative" }, ref: context.onIndicatorTrackChange, children: (0, import_jsx_runtime74.jsx)(Collection5.Slot, { scope: __scopeNavigationMenu, children: context.isRootMenu ? (0, import_jsx_runtime74.jsx)(FocusGroup, { asChild: true, children: list }) : list }) });
  }
);
NavigationMenuList.displayName = LIST_NAME;
var ITEM_NAME7 = "NavigationMenuItem";
var [NavigationMenuItemContextProvider, useNavigationMenuItemContext] = createNavigationMenuContext(ITEM_NAME7);
var NavigationMenuItem = React65.forwardRef(
  (props, forwardedRef) => {
    const { __scopeNavigationMenu, value: valueProp, ...itemProps } = props;
    const autoValue = useId2();
    const value = valueProp || autoValue || "LEGACY_REACT_AUTO_VALUE";
    const contentRef = React65.useRef(null);
    const triggerRef = React65.useRef(null);
    const focusProxyRef = React65.useRef(null);
    const restoreContentTabOrderRef = React65.useRef(() => {
    });
    const wasEscapeCloseRef = React65.useRef(false);
    const handleContentEntry = React65.useCallback((side = "start") => {
      if (contentRef.current) {
        restoreContentTabOrderRef.current();
        const candidates = getTabbableCandidates2(contentRef.current);
        if (candidates.length) focusFirst4(side === "start" ? candidates : candidates.reverse());
      }
    }, []);
    const handleContentExit = React65.useCallback(() => {
      if (contentRef.current) {
        const candidates = getTabbableCandidates2(contentRef.current);
        if (candidates.length) restoreContentTabOrderRef.current = removeFromTabOrder(candidates);
      }
    }, []);
    return (0, import_jsx_runtime74.jsx)(
      NavigationMenuItemContextProvider,
      {
        scope: __scopeNavigationMenu,
        value,
        triggerRef,
        contentRef,
        focusProxyRef,
        wasEscapeCloseRef,
        onEntryKeyDown: handleContentEntry,
        onFocusProxyEnter: handleContentEntry,
        onRootContentClose: handleContentExit,
        onContentFocusOutside: handleContentExit,
        children: (0, import_jsx_runtime74.jsx)(Primitive.li, { ...itemProps, ref: forwardedRef })
      }
    );
  }
);
NavigationMenuItem.displayName = ITEM_NAME7;
var TRIGGER_NAME10 = "NavigationMenuTrigger";
var NavigationMenuTrigger = React65.forwardRef((props, forwardedRef) => {
  const { __scopeNavigationMenu, disabled, ...triggerProps } = props;
  const context = useNavigationMenuContext(TRIGGER_NAME10, props.__scopeNavigationMenu);
  const itemContext = useNavigationMenuItemContext(TRIGGER_NAME10, props.__scopeNavigationMenu);
  const ref = React65.useRef(null);
  const composedRefs = useComposedRefs(ref, itemContext.triggerRef, forwardedRef);
  const triggerId = makeTriggerId(context.baseId, itemContext.value);
  const contentId = makeContentId(context.baseId, itemContext.value);
  const hasPointerMoveOpenedRef = React65.useRef(false);
  const wasClickCloseRef = React65.useRef(false);
  const open = itemContext.value === context.value;
  return (0, import_jsx_runtime74.jsxs)(import_jsx_runtime74.Fragment, { children: [
    (0, import_jsx_runtime74.jsx)(Collection5.ItemSlot, { scope: __scopeNavigationMenu, value: itemContext.value, children: (0, import_jsx_runtime74.jsx)(FocusGroupItem, { asChild: true, children: (0, import_jsx_runtime74.jsx)(
      Primitive.button,
      {
        id: triggerId,
        disabled,
        "data-disabled": disabled ? "" : void 0,
        "data-state": getOpenState2(open),
        "aria-expanded": open,
        "aria-controls": contentId,
        ...triggerProps,
        ref: composedRefs,
        onPointerEnter: composeEventHandlers(props.onPointerEnter, () => {
          wasClickCloseRef.current = false;
          itemContext.wasEscapeCloseRef.current = false;
        }),
        onPointerMove: composeEventHandlers(
          props.onPointerMove,
          whenMouse2(() => {
            if (disabled || wasClickCloseRef.current || itemContext.wasEscapeCloseRef.current || hasPointerMoveOpenedRef.current)
              return;
            context.onTriggerEnter(itemContext.value);
            hasPointerMoveOpenedRef.current = true;
          })
        ),
        onPointerLeave: composeEventHandlers(
          props.onPointerLeave,
          whenMouse2(() => {
            if (disabled) return;
            context.onTriggerLeave();
            hasPointerMoveOpenedRef.current = false;
          })
        ),
        onClick: composeEventHandlers(props.onClick, () => {
          context.onItemSelect(itemContext.value);
          wasClickCloseRef.current = open;
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          const verticalEntryKey = context.dir === "rtl" ? "ArrowLeft" : "ArrowRight";
          const entryKey = { horizontal: "ArrowDown", vertical: verticalEntryKey }[context.orientation];
          if (open && event.key === entryKey) {
            itemContext.onEntryKeyDown();
            event.preventDefault();
          }
        })
      }
    ) }) }),
    open && (0, import_jsx_runtime74.jsxs)(import_jsx_runtime74.Fragment, { children: [
      (0, import_jsx_runtime74.jsx)(
        Root2,
        {
          "aria-hidden": true,
          tabIndex: 0,
          ref: itemContext.focusProxyRef,
          onFocus: (event) => {
            const content = itemContext.contentRef.current;
            const prevFocusedElement = event.relatedTarget;
            const wasTriggerFocused = prevFocusedElement === ref.current;
            const wasFocusFromContent = content == null ? void 0 : content.contains(prevFocusedElement);
            if (wasTriggerFocused || !wasFocusFromContent) {
              itemContext.onFocusProxyEnter(wasTriggerFocused ? "start" : "end");
            }
          }
        }
      ),
      context.viewport && (0, import_jsx_runtime74.jsx)("span", { "aria-owns": contentId })
    ] })
  ] });
});
NavigationMenuTrigger.displayName = TRIGGER_NAME10;
var LINK_NAME = "NavigationMenuLink";
var LINK_SELECT = "navigationMenu.linkSelect";
var NavigationMenuLink = React65.forwardRef(
  (props, forwardedRef) => {
    const { __scopeNavigationMenu, active, onSelect, ...linkProps } = props;
    return (0, import_jsx_runtime74.jsx)(FocusGroupItem, { asChild: true, children: (0, import_jsx_runtime74.jsx)(
      Primitive.a,
      {
        "data-active": active ? "" : void 0,
        "aria-current": active ? "page" : void 0,
        ...linkProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(
          props.onClick,
          (event) => {
            const target = event.target;
            const linkSelectEvent = new CustomEvent(LINK_SELECT, {
              bubbles: true,
              cancelable: true
            });
            target.addEventListener(LINK_SELECT, (event2) => onSelect == null ? void 0 : onSelect(event2), { once: true });
            dispatchDiscreteCustomEvent(target, linkSelectEvent);
            if (!linkSelectEvent.defaultPrevented && !event.metaKey) {
              const rootContentDismissEvent = new CustomEvent(ROOT_CONTENT_DISMISS, {
                bubbles: true,
                cancelable: true
              });
              dispatchDiscreteCustomEvent(target, rootContentDismissEvent);
            }
          },
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
NavigationMenuLink.displayName = LINK_NAME;
var INDICATOR_NAME5 = "NavigationMenuIndicator";
var NavigationMenuIndicator = React65.forwardRef((props, forwardedRef) => {
  const { forceMount, ...indicatorProps } = props;
  const context = useNavigationMenuContext(INDICATOR_NAME5, props.__scopeNavigationMenu);
  const isVisible = Boolean(context.value);
  return context.indicatorTrack ? import_react_dom5.default.createPortal(
    (0, import_jsx_runtime74.jsx)(Presence, { present: forceMount || isVisible, children: (0, import_jsx_runtime74.jsx)(NavigationMenuIndicatorImpl, { ...indicatorProps, ref: forwardedRef }) }),
    context.indicatorTrack
  ) : null;
});
NavigationMenuIndicator.displayName = INDICATOR_NAME5;
var NavigationMenuIndicatorImpl = React65.forwardRef((props, forwardedRef) => {
  const { __scopeNavigationMenu, ...indicatorProps } = props;
  const context = useNavigationMenuContext(INDICATOR_NAME5, __scopeNavigationMenu);
  const getItems = useCollection5(__scopeNavigationMenu);
  const [activeTrigger, setActiveTrigger] = React65.useState(
    null
  );
  const [position, setPosition] = React65.useState(null);
  const isHorizontal = context.orientation === "horizontal";
  const isVisible = Boolean(context.value);
  React65.useEffect(() => {
    var _a6;
    const items = getItems();
    const triggerNode = (_a6 = items.find((item) => item.value === context.value)) == null ? void 0 : _a6.ref.current;
    if (triggerNode) setActiveTrigger(triggerNode);
  }, [getItems, context.value]);
  const handlePositionChange = () => {
    if (activeTrigger) {
      setPosition({
        size: isHorizontal ? activeTrigger.offsetWidth : activeTrigger.offsetHeight,
        offset: isHorizontal ? activeTrigger.offsetLeft : activeTrigger.offsetTop
      });
    }
  };
  useResizeObserver(activeTrigger, handlePositionChange);
  useResizeObserver(context.indicatorTrack, handlePositionChange);
  return position ? (0, import_jsx_runtime74.jsx)(
    Primitive.div,
    {
      "aria-hidden": true,
      "data-state": isVisible ? "visible" : "hidden",
      "data-orientation": context.orientation,
      ...indicatorProps,
      ref: forwardedRef,
      style: {
        position: "absolute",
        ...isHorizontal ? {
          left: 0,
          width: position.size + "px",
          transform: `translateX(${position.offset}px)`
        } : {
          top: 0,
          height: position.size + "px",
          transform: `translateY(${position.offset}px)`
        },
        ...indicatorProps.style
      }
    }
  ) : null;
});
var CONTENT_NAME11 = "NavigationMenuContent";
var NavigationMenuContent = React65.forwardRef((props, forwardedRef) => {
  const { forceMount, ...contentProps } = props;
  const context = useNavigationMenuContext(CONTENT_NAME11, props.__scopeNavigationMenu);
  const itemContext = useNavigationMenuItemContext(CONTENT_NAME11, props.__scopeNavigationMenu);
  const composedRefs = useComposedRefs(itemContext.contentRef, forwardedRef);
  const open = itemContext.value === context.value;
  const commonProps = {
    value: itemContext.value,
    triggerRef: itemContext.triggerRef,
    focusProxyRef: itemContext.focusProxyRef,
    wasEscapeCloseRef: itemContext.wasEscapeCloseRef,
    onContentFocusOutside: itemContext.onContentFocusOutside,
    onRootContentClose: itemContext.onRootContentClose,
    ...contentProps
  };
  return !context.viewport ? (0, import_jsx_runtime74.jsx)(Presence, { present: forceMount || open, children: (0, import_jsx_runtime74.jsx)(
    NavigationMenuContentImpl,
    {
      "data-state": getOpenState2(open),
      ...commonProps,
      ref: composedRefs,
      onPointerEnter: composeEventHandlers(props.onPointerEnter, context.onContentEnter),
      onPointerLeave: composeEventHandlers(
        props.onPointerLeave,
        whenMouse2(context.onContentLeave)
      ),
      style: {
        // Prevent interaction when animating out
        pointerEvents: !open && context.isRootMenu ? "none" : void 0,
        ...commonProps.style
      }
    }
  ) }) : (0, import_jsx_runtime74.jsx)(ViewportContentMounter, { forceMount, ...commonProps, ref: composedRefs });
});
NavigationMenuContent.displayName = CONTENT_NAME11;
var ViewportContentMounter = React65.forwardRef((props, forwardedRef) => {
  const context = useNavigationMenuContext(CONTENT_NAME11, props.__scopeNavigationMenu);
  const { onViewportContentChange, onViewportContentRemove } = context;
  useLayoutEffect22(() => {
    onViewportContentChange(props.value, {
      ref: forwardedRef,
      ...props
    });
  }, [props, forwardedRef, onViewportContentChange]);
  useLayoutEffect22(() => {
    return () => onViewportContentRemove(props.value);
  }, [props.value, onViewportContentRemove]);
  return null;
});
var ROOT_CONTENT_DISMISS = "navigationMenu.rootContentDismiss";
var NavigationMenuContentImpl = React65.forwardRef((props, forwardedRef) => {
  const {
    __scopeNavigationMenu,
    value,
    triggerRef,
    focusProxyRef,
    wasEscapeCloseRef,
    onRootContentClose,
    onContentFocusOutside,
    ...contentProps
  } = props;
  const context = useNavigationMenuContext(CONTENT_NAME11, __scopeNavigationMenu);
  const ref = React65.useRef(null);
  const composedRefs = useComposedRefs(ref, forwardedRef);
  const triggerId = makeTriggerId(context.baseId, value);
  const contentId = makeContentId(context.baseId, value);
  const getItems = useCollection5(__scopeNavigationMenu);
  const prevMotionAttributeRef = React65.useRef(null);
  const { onItemDismiss } = context;
  React65.useEffect(() => {
    const content = ref.current;
    if (context.isRootMenu && content) {
      const handleClose = () => {
        var _a6;
        onItemDismiss();
        onRootContentClose();
        if (content.contains(document.activeElement)) (_a6 = triggerRef.current) == null ? void 0 : _a6.focus();
      };
      content.addEventListener(ROOT_CONTENT_DISMISS, handleClose);
      return () => content.removeEventListener(ROOT_CONTENT_DISMISS, handleClose);
    }
  }, [context.isRootMenu, props.value, triggerRef, onItemDismiss, onRootContentClose]);
  const motionAttribute = React65.useMemo(() => {
    const items = getItems();
    const values = items.map((item) => item.value);
    if (context.dir === "rtl") values.reverse();
    const index2 = values.indexOf(context.value);
    const prevIndex = values.indexOf(context.previousValue);
    const isSelected = value === context.value;
    const wasSelected = prevIndex === values.indexOf(value);
    if (!isSelected && !wasSelected) return prevMotionAttributeRef.current;
    const attribute = (() => {
      if (index2 !== prevIndex) {
        if (isSelected && prevIndex !== -1) return index2 > prevIndex ? "from-end" : "from-start";
        if (wasSelected && index2 !== -1) return index2 > prevIndex ? "to-start" : "to-end";
      }
      return null;
    })();
    prevMotionAttributeRef.current = attribute;
    return attribute;
  }, [context.previousValue, context.value, context.dir, getItems, value]);
  return (0, import_jsx_runtime74.jsx)(FocusGroup, { asChild: true, children: (0, import_jsx_runtime74.jsx)(
    DismissableLayer,
    {
      id: contentId,
      "aria-labelledby": triggerId,
      "data-motion": motionAttribute,
      "data-orientation": context.orientation,
      ...contentProps,
      ref: composedRefs,
      disableOutsidePointerEvents: false,
      onDismiss: () => {
        var _a6;
        const rootContentDismissEvent = new Event(ROOT_CONTENT_DISMISS, {
          bubbles: true,
          cancelable: true
        });
        (_a6 = ref.current) == null ? void 0 : _a6.dispatchEvent(rootContentDismissEvent);
      },
      onFocusOutside: composeEventHandlers(props.onFocusOutside, (event) => {
        var _a6;
        onContentFocusOutside();
        const target = event.target;
        if ((_a6 = context.rootNavigationMenu) == null ? void 0 : _a6.contains(target)) event.preventDefault();
      }),
      onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {
        var _a6;
        const target = event.target;
        const isTrigger = getItems().some((item) => {
          var _a7;
          return (_a7 = item.ref.current) == null ? void 0 : _a7.contains(target);
        });
        const isRootViewport = context.isRootMenu && ((_a6 = context.viewport) == null ? void 0 : _a6.contains(target));
        if (isTrigger || isRootViewport || !context.isRootMenu) event.preventDefault();
      }),
      onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
        var _a6;
        const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
        const isTabKey = event.key === "Tab" && !isMetaKey;
        if (isTabKey) {
          const candidates = getTabbableCandidates2(event.currentTarget);
          const focusedElement = document.activeElement;
          const index2 = candidates.findIndex((candidate) => candidate === focusedElement);
          const isMovingBackwards = event.shiftKey;
          const nextCandidates = isMovingBackwards ? candidates.slice(0, index2).reverse() : candidates.slice(index2 + 1, candidates.length);
          if (focusFirst4(nextCandidates)) {
            event.preventDefault();
          } else {
            (_a6 = focusProxyRef.current) == null ? void 0 : _a6.focus();
          }
        }
      }),
      onEscapeKeyDown: composeEventHandlers(props.onEscapeKeyDown, (_event) => {
        wasEscapeCloseRef.current = true;
      })
    }
  ) });
});
var VIEWPORT_NAME = "NavigationMenuViewport";
var NavigationMenuViewport = React65.forwardRef((props, forwardedRef) => {
  const { forceMount, ...viewportProps } = props;
  const context = useNavigationMenuContext(VIEWPORT_NAME, props.__scopeNavigationMenu);
  const open = Boolean(context.value);
  return (0, import_jsx_runtime74.jsx)(Presence, { present: forceMount || open, children: (0, import_jsx_runtime74.jsx)(NavigationMenuViewportImpl, { ...viewportProps, ref: forwardedRef }) });
});
NavigationMenuViewport.displayName = VIEWPORT_NAME;
var NavigationMenuViewportImpl = React65.forwardRef((props, forwardedRef) => {
  const { __scopeNavigationMenu, children, ...viewportImplProps } = props;
  const context = useNavigationMenuContext(VIEWPORT_NAME, __scopeNavigationMenu);
  const composedRefs = useComposedRefs(forwardedRef, context.onViewportChange);
  const viewportContentContext = useViewportContentContext(
    CONTENT_NAME11,
    props.__scopeNavigationMenu
  );
  const [size4, setSize] = React65.useState(null);
  const [content, setContent2] = React65.useState(null);
  const viewportWidth = size4 ? (size4 == null ? void 0 : size4.width) + "px" : void 0;
  const viewportHeight = size4 ? (size4 == null ? void 0 : size4.height) + "px" : void 0;
  const open = Boolean(context.value);
  const activeContentValue = open ? context.value : context.previousValue;
  const handleSizeChange = () => {
    if (content) setSize({ width: content.offsetWidth, height: content.offsetHeight });
  };
  useResizeObserver(content, handleSizeChange);
  return (0, import_jsx_runtime74.jsx)(
    Primitive.div,
    {
      "data-state": getOpenState2(open),
      "data-orientation": context.orientation,
      ...viewportImplProps,
      ref: composedRefs,
      style: {
        // Prevent interaction when animating out
        pointerEvents: !open && context.isRootMenu ? "none" : void 0,
        ["--radix-navigation-menu-viewport-width"]: viewportWidth,
        ["--radix-navigation-menu-viewport-height"]: viewportHeight,
        ...viewportImplProps.style
      },
      onPointerEnter: composeEventHandlers(props.onPointerEnter, context.onContentEnter),
      onPointerLeave: composeEventHandlers(props.onPointerLeave, whenMouse2(context.onContentLeave)),
      children: Array.from(viewportContentContext.items).map(([value, { ref, forceMount, ...props2 }]) => {
        const isActive2 = activeContentValue === value;
        return (0, import_jsx_runtime74.jsx)(Presence, { present: forceMount || isActive2, children: (0, import_jsx_runtime74.jsx)(
          NavigationMenuContentImpl,
          {
            ...props2,
            ref: composeRefs(ref, (node) => {
              if (isActive2 && node) setContent2(node);
            })
          }
        ) }, value);
      })
    }
  );
});
var FOCUS_GROUP_NAME = "FocusGroup";
var FocusGroup = React65.forwardRef(
  (props, forwardedRef) => {
    const { __scopeNavigationMenu, ...groupProps } = props;
    const context = useNavigationMenuContext(FOCUS_GROUP_NAME, __scopeNavigationMenu);
    return (0, import_jsx_runtime74.jsx)(FocusGroupCollection.Provider, { scope: __scopeNavigationMenu, children: (0, import_jsx_runtime74.jsx)(FocusGroupCollection.Slot, { scope: __scopeNavigationMenu, children: (0, import_jsx_runtime74.jsx)(Primitive.div, { dir: context.dir, ...groupProps, ref: forwardedRef }) }) });
  }
);
var ARROW_KEYS = ["ArrowRight", "ArrowLeft", "ArrowUp", "ArrowDown"];
var FOCUS_GROUP_ITEM_NAME = "FocusGroupItem";
var FocusGroupItem = React65.forwardRef(
  (props, forwardedRef) => {
    const { __scopeNavigationMenu, ...groupProps } = props;
    const getItems = useFocusGroupCollection(__scopeNavigationMenu);
    const context = useNavigationMenuContext(FOCUS_GROUP_ITEM_NAME, __scopeNavigationMenu);
    return (0, import_jsx_runtime74.jsx)(FocusGroupCollection.ItemSlot, { scope: __scopeNavigationMenu, children: (0, import_jsx_runtime74.jsx)(
      Primitive.button,
      {
        ...groupProps,
        ref: forwardedRef,
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          const isFocusNavigationKey = ["Home", "End", ...ARROW_KEYS].includes(event.key);
          if (isFocusNavigationKey) {
            let candidateNodes = getItems().map((item) => item.ref.current);
            const prevItemKey = context.dir === "rtl" ? "ArrowRight" : "ArrowLeft";
            const prevKeys = [prevItemKey, "ArrowUp", "End"];
            if (prevKeys.includes(event.key)) candidateNodes.reverse();
            if (ARROW_KEYS.includes(event.key)) {
              const currentIndex = candidateNodes.indexOf(event.currentTarget);
              candidateNodes = candidateNodes.slice(currentIndex + 1);
            }
            setTimeout(() => focusFirst4(candidateNodes));
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
function getTabbableCandidates2(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function focusFirst4(candidates) {
  const previouslyFocusedElement = document.activeElement;
  return candidates.some((candidate) => {
    if (candidate === previouslyFocusedElement) return true;
    candidate.focus();
    return document.activeElement !== previouslyFocusedElement;
  });
}
function removeFromTabOrder(candidates) {
  candidates.forEach((candidate) => {
    candidate.dataset.tabindex = candidate.getAttribute("tabindex") || "";
    candidate.setAttribute("tabindex", "-1");
  });
  return () => {
    candidates.forEach((candidate) => {
      const prevTabIndex = candidate.dataset.tabindex;
      candidate.setAttribute("tabindex", prevTabIndex);
    });
  };
}
function useResizeObserver(element, onResize) {
  const handleResize = useCallbackRef(onResize);
  useLayoutEffect22(() => {
    let rAF = 0;
    if (element) {
      const resizeObserver = new ResizeObserver(() => {
        cancelAnimationFrame(rAF);
        rAF = window.requestAnimationFrame(handleResize);
      });
      resizeObserver.observe(element);
      return () => {
        window.cancelAnimationFrame(rAF);
        resizeObserver.unobserve(element);
      };
    }
  }, [element, handleResize]);
}
function getOpenState2(open) {
  return open ? "open" : "closed";
}
function makeTriggerId(baseId, value) {
  return `${baseId}-trigger-${value}`;
}
function makeContentId(baseId, value) {
  return `${baseId}-content-${value}`;
}
function whenMouse2(handler) {
  return (event) => event.pointerType === "mouse" ? handler(event) : void 0;
}

// ../node_modules/@radix-ui/react-one-time-password-field/dist/index.mjs
var React66 = __toESM(require_react(), 1);
var import_react_dom6 = __toESM(require_react_dom(), 1);

// ../node_modules/@radix-ui/number/dist/index.mjs
function clamp4(value, [min3, max2]) {
  return Math.min(max2, Math.max(min3, value));
}

// ../node_modules/@radix-ui/react-one-time-password-field/dist/index.mjs
var import_jsx_runtime75 = __toESM(require_jsx_runtime(), 1);
var INPUT_VALIDATION_MAP = {
  numeric: {
    type: "numeric",
    regexp: /[^\d]/g,
    pattern: "\\d{1}",
    inputMode: "numeric"
  },
  alpha: {
    type: "alpha",
    regexp: /[^a-zA-Z]/g,
    pattern: "[a-zA-Z]{1}",
    inputMode: "text"
  },
  alphanumeric: {
    type: "alphanumeric",
    regexp: /[^a-zA-Z0-9]/g,
    pattern: "[a-zA-Z0-9]{1}",
    inputMode: "text"
  },
  none: null
};
var ONE_TIME_PASSWORD_FIELD_NAME = "OneTimePasswordField";
var [Collection6, { useCollection: useCollection6, createCollectionScope: createCollectionScope6, useInitCollection }] = createCollection2(ONE_TIME_PASSWORD_FIELD_NAME);
var [createOneTimePasswordFieldContext] = createContextScope(ONE_TIME_PASSWORD_FIELD_NAME, [
  createCollectionScope6,
  createRovingFocusGroupScope
]);
var useRovingFocusGroupScope3 = createRovingFocusGroupScope();
var [OneTimePasswordFieldContext, useOneTimePasswordFieldContext] = createOneTimePasswordFieldContext(ONE_TIME_PASSWORD_FIELD_NAME);
var OneTimePasswordField = React66.forwardRef(
  function OneTimePasswordFieldImpl({
    __scopeOneTimePasswordField,
    defaultValue,
    value: valueProp,
    onValueChange,
    autoSubmit = false,
    children,
    onPaste,
    onAutoSubmit,
    disabled = false,
    readOnly = false,
    autoComplete = "one-time-code",
    autoFocus = false,
    form,
    name,
    placeholder,
    type = "text",
    // TODO: Change default to vertical when inputs use vertical writing mode
    orientation = "horizontal",
    dir,
    validationType = "numeric",
    sanitizeValue: sanitizeValueProp,
    ...domProps
  }, forwardedRef) {
    var _a6;
    const rovingFocusGroupScope = useRovingFocusGroupScope3(__scopeOneTimePasswordField);
    const direction = useDirection(dir);
    const collectionState = useInitCollection();
    const [collection] = collectionState;
    const validation = INPUT_VALIDATION_MAP[validationType] ? INPUT_VALIDATION_MAP[validationType] : null;
    const sanitizeValue = React66.useCallback(
      (value2) => {
        if (Array.isArray(value2)) {
          value2 = value2.map(removeWhitespace).join("");
        } else {
          value2 = removeWhitespace(value2);
        }
        if (validation) {
          const regexp2 = new RegExp(validation.regexp);
          value2 = value2.replace(regexp2, "");
        } else if (sanitizeValueProp) {
          value2 = sanitizeValueProp(value2);
        }
        return value2.split("");
      },
      [validation, sanitizeValueProp]
    );
    const controlledValue = React66.useMemo(() => {
      return valueProp != null ? sanitizeValue(valueProp) : void 0;
    }, [valueProp, sanitizeValue]);
    const [value, setValue] = useControllableState({
      caller: "OneTimePasswordField",
      prop: controlledValue,
      defaultProp: defaultValue != null ? sanitizeValue(defaultValue) : [],
      onChange: React66.useCallback(
        (value2) => onValueChange == null ? void 0 : onValueChange(value2.join("")),
        [onValueChange]
      )
    });
    const dispatch2 = useEffectEvent((action) => {
      var _a7, _b3, _c, _d, _e, _f, _g, _h, _i;
      switch (action.type) {
        case "SET_CHAR": {
          const { index: index2, char } = action;
          const currentTarget = (_a7 = collection.at(index2)) == null ? void 0 : _a7.element;
          if (value[index2] === char) {
            const next = currentTarget && ((_b3 = collection.from(currentTarget, 1)) == null ? void 0 : _b3.element);
            focusInput(next);
            return;
          }
          if (char === "") {
            return;
          }
          if (validation) {
            const regexp2 = new RegExp(validation.regexp);
            const clean = char.replace(regexp2, "");
            if (clean !== char) {
              return;
            }
          }
          if (value.length >= collection.size) {
            const newValue2 = [...value];
            newValue2[index2] = char;
            (0, import_react_dom6.flushSync)(() => setValue(newValue2));
            const next = currentTarget && ((_c = collection.from(currentTarget, 1)) == null ? void 0 : _c.element);
            focusInput(next);
            return;
          }
          const newValue = [...value];
          newValue[index2] = char;
          const lastElement = (_d = collection.at(-1)) == null ? void 0 : _d.element;
          (0, import_react_dom6.flushSync)(() => setValue(newValue));
          if (currentTarget !== lastElement) {
            const next = currentTarget && ((_e = collection.from(currentTarget, 1)) == null ? void 0 : _e.element);
            focusInput(next);
          } else {
            currentTarget == null ? void 0 : currentTarget.select();
          }
          return;
        }
        case "CLEAR_CHAR": {
          const { index: index2, reason } = action;
          if (!value[index2]) {
            return;
          }
          const newValue = value.filter((_, i) => i !== index2);
          const currentTarget = (_f = collection.at(index2)) == null ? void 0 : _f.element;
          const previous = currentTarget && ((_g = collection.from(currentTarget, -1)) == null ? void 0 : _g.element);
          (0, import_react_dom6.flushSync)(() => setValue(newValue));
          if (reason === "Backspace") {
            focusInput(previous);
          } else if (reason === "Delete" || reason === "Cut") {
            focusInput(currentTarget);
          }
          return;
        }
        case "CLEAR": {
          if (value.length === 0) {
            return;
          }
          if (action.reason === "Backspace" || action.reason === "Delete") {
            (0, import_react_dom6.flushSync)(() => setValue([]));
            focusInput((_h = collection.at(0)) == null ? void 0 : _h.element);
          } else {
            setValue([]);
          }
          return;
        }
        case "PASTE": {
          const { value: pastedValue } = action;
          const value2 = sanitizeValue(pastedValue);
          if (!value2) {
            return;
          }
          (0, import_react_dom6.flushSync)(() => setValue(value2));
          focusInput((_i = collection.at(value2.length - 1)) == null ? void 0 : _i.element);
          return;
        }
      }
    });
    const validationTypeRef = React66.useRef(validation);
    React66.useEffect(() => {
      var _a7;
      if (!validation) {
        return;
      }
      if (((_a7 = validationTypeRef.current) == null ? void 0 : _a7.type) !== validation.type) {
        validationTypeRef.current = validation;
        setValue(sanitizeValue(value.join("")));
      }
    }, [sanitizeValue, setValue, validation, value]);
    const hiddenInputRef = React66.useRef(null);
    const userActionRef = React66.useRef(null);
    const rootRef = React66.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, rootRef);
    const firstInput = (_a6 = collection.at(0)) == null ? void 0 : _a6.element;
    const locateForm = React66.useCallback(() => {
      var _a7;
      let formElement;
      if (form) {
        const associatedElement = (((_a7 = rootRef.current) == null ? void 0 : _a7.ownerDocument) ?? document).getElementById(form);
        if (isFormElement(associatedElement)) {
          formElement = associatedElement;
        }
      } else if (hiddenInputRef.current) {
        formElement = hiddenInputRef.current.form;
      } else if (firstInput) {
        formElement = firstInput.form;
      }
      return formElement ?? null;
    }, [form, firstInput]);
    const attemptSubmit = React66.useCallback(() => {
      const formElement = locateForm();
      formElement == null ? void 0 : formElement.requestSubmit();
    }, [locateForm]);
    React66.useEffect(() => {
      const form2 = locateForm();
      if (form2) {
        const reset2 = () => dispatch2({ type: "CLEAR", reason: "Reset" });
        form2.addEventListener("reset", reset2);
        return () => form2.removeEventListener("reset", reset2);
      }
    }, [dispatch2, locateForm]);
    const currentValue = value.join("");
    const valueRef = React66.useRef(currentValue);
    const length = collection.size;
    React66.useEffect(() => {
      const previousValue = valueRef.current;
      valueRef.current = currentValue;
      if (previousValue === currentValue) {
        return;
      }
      if (autoSubmit && value.every((char) => char !== "") && value.length === length) {
        onAutoSubmit == null ? void 0 : onAutoSubmit(value.join(""));
        attemptSubmit();
      }
    }, [attemptSubmit, autoSubmit, currentValue, length, onAutoSubmit, value]);
    const isHydrated = useIsHydrated();
    return (0, import_jsx_runtime75.jsx)(
      OneTimePasswordFieldContext,
      {
        scope: __scopeOneTimePasswordField,
        value,
        attemptSubmit,
        disabled,
        readOnly,
        autoComplete,
        autoFocus,
        form,
        name,
        placeholder,
        type,
        hiddenInputRef,
        userActionRef,
        dispatch: dispatch2,
        validationType,
        orientation,
        isHydrated,
        sanitizeValue,
        children: (0, import_jsx_runtime75.jsx)(Collection6.Provider, { scope: __scopeOneTimePasswordField, state: collectionState, children: (0, import_jsx_runtime75.jsx)(Collection6.Slot, { scope: __scopeOneTimePasswordField, children: (0, import_jsx_runtime75.jsx)(
          Root7,
          {
            asChild: true,
            ...rovingFocusGroupScope,
            orientation,
            dir: direction,
            children: (0, import_jsx_runtime75.jsx)(
              Root.div,
              {
                ...domProps,
                role: "group",
                ref: composedRefs,
                onPaste: composeEventHandlers(
                  onPaste,
                  (event) => {
                    event.preventDefault();
                    const pastedValue = event.clipboardData.getData("Text");
                    dispatch2({ type: "PASTE", value: pastedValue });
                  }
                ),
                children
              }
            )
          }
        ) }) })
      }
    );
  }
);
var OneTimePasswordFieldHiddenInput = React66.forwardRef(function OneTimePasswordFieldHiddenInput2({ __scopeOneTimePasswordField, ...props }, forwardedRef) {
  const { value, hiddenInputRef, name } = useOneTimePasswordFieldContext(
    "OneTimePasswordFieldHiddenInput",
    __scopeOneTimePasswordField
  );
  const ref = useComposedRefs(hiddenInputRef, forwardedRef);
  return (0, import_jsx_runtime75.jsx)(
    "input",
    {
      ref,
      name,
      value: value.join("").trim(),
      autoComplete: "off",
      autoFocus: false,
      autoCapitalize: "off",
      autoCorrect: "off",
      autoSave: "off",
      spellCheck: false,
      ...props,
      type: "hidden",
      readOnly: true
    }
  );
});
var OneTimePasswordFieldInput = React66.forwardRef(function OneTimePasswordFieldInput2({
  __scopeOneTimePasswordField,
  onInvalidChange,
  index: indexProp,
  ...props
}, forwardedRef) {
  const {
    value: _value,
    defaultValue: _defaultValue,
    disabled: _disabled,
    readOnly: _readOnly,
    autoComplete: _autoComplete,
    autoFocus: _autoFocus,
    form: _form,
    name: _name,
    placeholder: _placeholder,
    type: _type,
    ...domProps
  } = props;
  const context = useOneTimePasswordFieldContext(
    "OneTimePasswordFieldInput",
    __scopeOneTimePasswordField
  );
  const { dispatch: dispatch2, userActionRef, validationType, isHydrated, disabled } = context;
  const collection = useCollection6(__scopeOneTimePasswordField);
  const rovingFocusGroupScope = useRovingFocusGroupScope3(__scopeOneTimePasswordField);
  const inputRef = React66.useRef(null);
  const [element, setElement] = React66.useState(null);
  const index2 = indexProp ?? (element ? collection.indexOf(element) : -1);
  const canSetPlaceholder = indexProp != null || isHydrated;
  let placeholder;
  if (canSetPlaceholder && context.placeholder && context.value.length === 0) {
    placeholder = context.placeholder[index2];
  }
  const composedInputRef = useComposedRefs(forwardedRef, inputRef, setElement);
  const char = context.value[index2] ?? "";
  const keyboardActionTimeoutRef = React66.useRef(null);
  React66.useEffect(() => {
    return () => {
      window.clearTimeout(keyboardActionTimeoutRef.current);
    };
  }, []);
  const totalValue = context.value.join("").trim();
  const lastSelectableIndex = clamp4(totalValue.length, [0, collection.size - 1]);
  const isFocusable = index2 <= lastSelectableIndex;
  const validation = validationType in INPUT_VALIDATION_MAP ? INPUT_VALIDATION_MAP[validationType] : void 0;
  return (0, import_jsx_runtime75.jsx)(Collection6.ItemSlot, { scope: __scopeOneTimePasswordField, children: (0, import_jsx_runtime75.jsx)(
    Item,
    {
      ...rovingFocusGroupScope,
      asChild: true,
      focusable: !context.disabled && isFocusable,
      active: index2 === lastSelectableIndex,
      children: ({ hasTabStop, isCurrentTabStop }) => {
        const supportsAutoComplete = hasTabStop ? isCurrentTabStop : index2 === 0;
        return (0, import_jsx_runtime75.jsx)(
          Root.input,
          {
            ref: composedInputRef,
            type: context.type,
            disabled,
            "aria-label": `Character ${index2 + 1} of ${collection.size}`,
            autoComplete: supportsAutoComplete ? context.autoComplete : "off",
            "data-1p-ignore": supportsAutoComplete ? void 0 : "true",
            "data-lpignore": supportsAutoComplete ? void 0 : "true",
            "data-protonpass-ignore": supportsAutoComplete ? void 0 : "true",
            "data-bwignore": supportsAutoComplete ? void 0 : "true",
            inputMode: validation == null ? void 0 : validation.inputMode,
            maxLength: 1,
            pattern: validation == null ? void 0 : validation.pattern,
            readOnly: context.readOnly,
            value: char,
            placeholder,
            "data-radix-otp-input": "",
            "data-radix-index": index2,
            ...domProps,
            onFocus: composeEventHandlers(props.onFocus, (event) => {
              event.currentTarget.select();
            }),
            onCut: composeEventHandlers(props.onCut, (event) => {
              const currentValue = event.currentTarget.value;
              if (currentValue !== "") {
                userActionRef.current = {
                  type: "cut"
                };
                keyboardActionTimeoutRef.current = window.setTimeout(() => {
                  userActionRef.current = null;
                }, 10);
              }
            }),
            onInput: composeEventHandlers(props.onInput, (event) => {
              const value = event.currentTarget.value;
              if (value.length > 1) {
                event.preventDefault();
                dispatch2({ type: "PASTE", value });
              }
            }),
            onChange: composeEventHandlers(props.onChange, (event) => {
              const value = event.target.value;
              event.preventDefault();
              const action = userActionRef.current;
              userActionRef.current = null;
              if (action) {
                switch (action.type) {
                  case "cut":
                    dispatch2({ type: "CLEAR_CHAR", index: index2, reason: "Cut" });
                    return;
                  case "keydown": {
                    if (action.key === "Char") {
                      return;
                    }
                    const isClearing = action.key === "Backspace" && (action.metaKey || action.ctrlKey);
                    if (action.key === "Clear" || isClearing) {
                      dispatch2({ type: "CLEAR", reason: "Backspace" });
                    } else {
                      dispatch2({ type: "CLEAR_CHAR", index: index2, reason: action.key });
                    }
                    return;
                  }
                  default:
                    return;
                }
              }
              if (event.target.validity.valid) {
                if (value === "") {
                  let reason = "Backspace";
                  if (isInputEvent(event.nativeEvent)) {
                    const inputType = event.nativeEvent.inputType;
                    if (inputType === "deleteContentBackward") {
                      reason = "Backspace";
                    } else if (inputType === "deleteByCut") {
                      reason = "Cut";
                    }
                  }
                  dispatch2({ type: "CLEAR_CHAR", index: index2, reason });
                } else {
                  dispatch2({ type: "SET_CHAR", char: value, index: index2, event });
                }
              } else {
                const element2 = event.target;
                onInvalidChange == null ? void 0 : onInvalidChange(element2.value);
                requestAnimationFrame(() => {
                  if (element2.ownerDocument.activeElement === element2) {
                    element2.select();
                  }
                });
              }
            }),
            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
              var _a6, _b3, _c;
              switch (event.key) {
                case "Clear":
                case "Delete":
                case "Backspace": {
                  const currentValue = event.currentTarget.value;
                  if (currentValue === "") {
                    if (event.key === "Delete") return;
                    const isClearing = event.key === "Clear" || event.metaKey || event.ctrlKey;
                    if (isClearing) {
                      dispatch2({ type: "CLEAR", reason: "Backspace" });
                    } else {
                      const element2 = event.currentTarget;
                      requestAnimationFrame(() => {
                        var _a7;
                        focusInput((_a7 = collection.from(element2, -1)) == null ? void 0 : _a7.element);
                      });
                    }
                  } else {
                    userActionRef.current = {
                      type: "keydown",
                      key: event.key,
                      metaKey: event.metaKey,
                      ctrlKey: event.ctrlKey
                    };
                    keyboardActionTimeoutRef.current = window.setTimeout(() => {
                      userActionRef.current = null;
                    }, 10);
                  }
                  return;
                }
                case "Enter": {
                  event.preventDefault();
                  context.attemptSubmit();
                  return;
                }
                case "ArrowDown":
                case "ArrowUp": {
                  if (context.orientation === "horizontal") {
                    event.preventDefault();
                  }
                  return;
                }
                // TODO: Handle left/right arrow keys in vertical writing mode
                default: {
                  if (event.currentTarget.value === event.key) {
                    const element2 = event.currentTarget;
                    event.preventDefault();
                    focusInput((_a6 = collection.from(element2, 1)) == null ? void 0 : _a6.element);
                    return;
                  } else if (
                    // input already has a value, but...
                    event.currentTarget.value && // the value is not selected
                    !(event.currentTarget.selectionStart === 0 && event.currentTarget.selectionEnd != null && event.currentTarget.selectionEnd > 0)
                  ) {
                    const attemptedValue = event.key;
                    if (event.key.length > 1 || event.key === " ") {
                      return;
                    } else {
                      const nextInput = (_b3 = collection.from(event.currentTarget, 1)) == null ? void 0 : _b3.element;
                      const lastInput = (_c = collection.at(-1)) == null ? void 0 : _c.element;
                      if (nextInput !== lastInput && event.currentTarget !== lastInput) {
                        if (event.currentTarget.selectionStart === 0) {
                          dispatch2({ type: "SET_CHAR", char: attemptedValue, index: index2, event });
                        } else {
                          dispatch2({
                            type: "SET_CHAR",
                            char: attemptedValue,
                            index: index2 + 1,
                            event
                          });
                        }
                        userActionRef.current = {
                          type: "keydown",
                          key: "Char",
                          metaKey: event.metaKey,
                          ctrlKey: event.ctrlKey
                        };
                        keyboardActionTimeoutRef.current = window.setTimeout(() => {
                          userActionRef.current = null;
                        }, 10);
                      }
                    }
                  }
                }
              }
            }),
            onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
              var _a6;
              event.preventDefault();
              const indexToFocus = Math.min(index2, lastSelectableIndex);
              const element2 = (_a6 = collection.at(indexToFocus)) == null ? void 0 : _a6.element;
              focusInput(element2);
            })
          }
        );
      }
    }
  ) });
});
function isFormElement(element) {
  return (element == null ? void 0 : element.tagName) === "FORM";
}
function removeWhitespace(value) {
  return value.replace(/\s/g, "");
}
function focusInput(element) {
  if (!element) return;
  if (element.ownerDocument.activeElement === element) {
    window.requestAnimationFrame(() => {
      var _a6;
      (_a6 = element.select) == null ? void 0 : _a6.call(element);
    });
  } else {
    element.focus();
  }
}
function isInputEvent(event) {
  return event.type === "input";
}

// ../node_modules/@radix-ui/react-password-toggle-field/dist/index.mjs
var React67 = __toESM(require_react(), 1);
var import_react_dom7 = __toESM(require_react_dom(), 1);
var import_jsx_runtime76 = __toESM(require_jsx_runtime(), 1);
var PASSWORD_TOGGLE_FIELD_NAME = "PasswordToggleField";
var [createPasswordToggleFieldContext] = createContextScope(PASSWORD_TOGGLE_FIELD_NAME);
var [PasswordToggleFieldProvider, usePasswordToggleFieldContext] = createPasswordToggleFieldContext(PASSWORD_TOGGLE_FIELD_NAME);
var INITIAL_FOCUS_STATE = {
  clickTriggered: false,
  selectionStart: null,
  selectionEnd: null
};
var PasswordToggleField = ({
  __scopePasswordToggleField,
  ...props
}) => {
  const baseId = useId2(props.id);
  const defaultInputId = `${baseId}-input`;
  const [inputIdState, setInputIdState] = React67.useState(defaultInputId);
  const inputId = inputIdState ?? defaultInputId;
  const syncInputId = React67.useCallback(
    (providedId) => setInputIdState(providedId != null ? String(providedId) : null),
    []
  );
  const { visible: visibleProp, defaultVisible, onVisiblityChange, children } = props;
  const [visible = false, setVisible] = useControllableState({
    caller: PASSWORD_TOGGLE_FIELD_NAME,
    prop: visibleProp,
    defaultProp: defaultVisible ?? false,
    onChange: onVisiblityChange
  });
  const inputRef = React67.useRef(null);
  const focusState = React67.useRef(INITIAL_FOCUS_STATE);
  return (0, import_jsx_runtime76.jsx)(
    PasswordToggleFieldProvider,
    {
      scope: __scopePasswordToggleField,
      inputId,
      inputRef,
      setVisible,
      syncInputId,
      visible,
      focusState,
      children
    }
  );
};
PasswordToggleField.displayName = PASSWORD_TOGGLE_FIELD_NAME;
var PASSWORD_TOGGLE_FIELD_INPUT_NAME = PASSWORD_TOGGLE_FIELD_NAME + "Input";
var PasswordToggleFieldInput = React67.forwardRef(
  ({
    __scopePasswordToggleField,
    autoComplete = "current-password",
    autoCapitalize = "off",
    spellCheck = false,
    id: idProp,
    ...props
  }, forwardedRef) => {
    const { visible, inputRef, inputId, syncInputId, setVisible, focusState } = usePasswordToggleFieldContext(PASSWORD_TOGGLE_FIELD_INPUT_NAME, __scopePasswordToggleField);
    React67.useEffect(() => {
      syncInputId(idProp);
    }, [idProp, syncInputId]);
    const _setVisible = useEffectEvent(setVisible);
    React67.useEffect(() => {
      const inputElement = inputRef.current;
      const form = inputElement == null ? void 0 : inputElement.form;
      if (!form) {
        return;
      }
      const controller = new AbortController();
      form.addEventListener(
        "reset",
        (event) => {
          if (!event.defaultPrevented) {
            _setVisible(false);
          }
        },
        { signal: controller.signal }
      );
      form.addEventListener(
        "submit",
        () => {
          _setVisible(false);
        },
        { signal: controller.signal }
      );
      return () => {
        controller.abort();
      };
    }, [inputRef, _setVisible]);
    return (0, import_jsx_runtime76.jsx)(
      Primitive.input,
      {
        ...props,
        id: idProp ?? inputId,
        autoCapitalize,
        autoComplete,
        ref: useComposedRefs(forwardedRef, inputRef),
        spellCheck,
        type: visible ? "text" : "password",
        onBlur: composeEventHandlers(props.onBlur, (event) => {
          const { selectionStart, selectionEnd } = event.currentTarget;
          focusState.current.selectionStart = selectionStart;
          focusState.current.selectionEnd = selectionEnd;
        })
      }
    );
  }
);
PasswordToggleFieldInput.displayName = PASSWORD_TOGGLE_FIELD_INPUT_NAME;
var PASSWORD_TOGGLE_FIELD_TOGGLE_NAME = PASSWORD_TOGGLE_FIELD_NAME + "Toggle";
var PasswordToggleFieldToggle = React67.forwardRef(
  ({
    __scopePasswordToggleField,
    onClick,
    onPointerDown,
    onPointerCancel,
    onPointerUp,
    onFocus,
    children,
    "aria-label": ariaLabelProp,
    "aria-controls": ariaControls,
    "aria-hidden": ariaHidden,
    tabIndex,
    ...props
  }, forwardedRef) => {
    const { setVisible, visible, inputRef, inputId, focusState } = usePasswordToggleFieldContext(
      PASSWORD_TOGGLE_FIELD_TOGGLE_NAME,
      __scopePasswordToggleField
    );
    const [internalAriaLabel, setInternalAriaLabel] = React67.useState(void 0);
    const elementRef = React67.useRef(null);
    const ref = useComposedRefs(forwardedRef, elementRef);
    const isHydrated = useIsHydrated();
    React67.useEffect(() => {
      const element = elementRef.current;
      if (!element || ariaLabelProp) {
        setInternalAriaLabel(void 0);
        return;
      }
      const DEFAULT_ARIA_LABEL = visible ? "Hide password" : "Show password";
      function checkForInnerTextLabel(textContent) {
        const text = textContent ? textContent : void 0;
        setInternalAriaLabel(text ? void 0 : DEFAULT_ARIA_LABEL);
      }
      checkForInnerTextLabel(element.textContent);
      const observer = new MutationObserver((entries) => {
        let textContent;
        for (const entry of entries) {
          if (entry.type === "characterData") {
            if (element.textContent) {
              textContent = element.textContent;
            }
          }
        }
        checkForInnerTextLabel(textContent);
      });
      observer.observe(element, { characterData: true, subtree: true });
      return () => {
        observer.disconnect();
      };
    }, [visible, ariaLabelProp]);
    const ariaLabel = ariaLabelProp || internalAriaLabel;
    if (!isHydrated) {
      ariaHidden ?? (ariaHidden = true);
      tabIndex ?? (tabIndex = -1);
    } else {
      ariaControls ?? (ariaControls = inputId);
    }
    React67.useEffect(() => {
      var _a6, _b3;
      let cleanup = () => {
      };
      const ownerWindow = ((_b3 = (_a6 = elementRef.current) == null ? void 0 : _a6.ownerDocument) == null ? void 0 : _b3.defaultView) || window;
      const reset2 = () => focusState.current.clickTriggered = false;
      const handlePointerUp = () => cleanup = requestIdleCallback(ownerWindow, reset2);
      ownerWindow.addEventListener("pointerup", handlePointerUp);
      return () => {
        cleanup();
        ownerWindow.removeEventListener("pointerup", handlePointerUp);
      };
    }, [focusState]);
    return (0, import_jsx_runtime76.jsx)(
      Primitive.button,
      {
        "aria-controls": ariaControls,
        "aria-hidden": ariaHidden,
        "aria-label": ariaLabel,
        ref,
        id: inputId,
        ...props,
        onPointerDown: composeEventHandlers(onPointerDown, () => {
          focusState.current.clickTriggered = true;
        }),
        onPointerCancel: (event) => {
          onPointerCancel == null ? void 0 : onPointerCancel(event);
          focusState.current = INITIAL_FOCUS_STATE;
        },
        onClick: (event) => {
          onClick == null ? void 0 : onClick(event);
          if (event.defaultPrevented) {
            focusState.current = INITIAL_FOCUS_STATE;
            return;
          }
          (0, import_react_dom7.flushSync)(() => {
            setVisible((s) => !s);
          });
          if (focusState.current.clickTriggered) {
            const input = inputRef.current;
            if (input) {
              const { selectionStart, selectionEnd } = focusState.current;
              input.focus();
              if (selectionStart !== null || selectionEnd !== null) {
                requestAnimationFrame(() => {
                  if (input.ownerDocument.activeElement === input) {
                    input.selectionStart = selectionStart;
                    input.selectionEnd = selectionEnd;
                  }
                });
              }
            }
          }
          focusState.current = INITIAL_FOCUS_STATE;
        },
        onPointerUp: (event) => {
          onPointerUp == null ? void 0 : onPointerUp(event);
          setTimeout(() => {
            focusState.current = INITIAL_FOCUS_STATE;
          }, 50);
        },
        type: "button",
        children
      }
    );
  }
);
PasswordToggleFieldToggle.displayName = PASSWORD_TOGGLE_FIELD_TOGGLE_NAME;
var PASSWORD_TOGGLE_FIELD_SLOT_NAME = PASSWORD_TOGGLE_FIELD_NAME + "Slot";
var PasswordToggleFieldSlot = ({
  __scopePasswordToggleField,
  ...props
}) => {
  const { visible } = usePasswordToggleFieldContext(
    PASSWORD_TOGGLE_FIELD_SLOT_NAME,
    __scopePasswordToggleField
  );
  return "render" in props ? (
    //
    props.render({ visible })
  ) : visible ? props.visible : props.hidden;
};
PasswordToggleFieldSlot.displayName = PASSWORD_TOGGLE_FIELD_SLOT_NAME;
var PASSWORD_TOGGLE_FIELD_ICON_NAME = PASSWORD_TOGGLE_FIELD_NAME + "Icon";
var PasswordToggleFieldIcon = React67.forwardRef(
  ({
    __scopePasswordToggleField,
    // @ts-expect-error
    children,
    ...props
  }, forwardedRef) => {
    const { visible } = usePasswordToggleFieldContext(
      PASSWORD_TOGGLE_FIELD_ICON_NAME,
      __scopePasswordToggleField
    );
    const { visible: visibleIcon, hidden: hiddenIcon, ...domProps } = props;
    return (0, import_jsx_runtime76.jsx)(Primitive.svg, { ...domProps, ref: forwardedRef, "aria-hidden": true, asChild: true, children: visible ? visibleIcon : hiddenIcon });
  }
);
PasswordToggleFieldIcon.displayName = PASSWORD_TOGGLE_FIELD_ICON_NAME;
function requestIdleCallback(window22, callback, options2) {
  if (window22.requestIdleCallback) {
    const id2 = window22.requestIdleCallback(callback, options2);
    return () => {
      window22.cancelIdleCallback(id2);
    };
  }
  const start = Date.now();
  const id = window22.setTimeout(() => {
    const timeRemaining = () => Math.max(0, 50 - (Date.now() - start));
    callback({ didTimeout: false, timeRemaining });
  }, 1);
  return () => {
    window22.clearTimeout(id);
  };
}

// ../node_modules/@radix-ui/react-popover/dist/index.mjs
var dist_exports12 = {};
__export(dist_exports12, {
  Anchor: () => Anchor22,
  Arrow: () => Arrow25,
  Close: () => Close2,
  Content: () => Content25,
  Popover: () => Popover,
  PopoverAnchor: () => PopoverAnchor,
  PopoverArrow: () => PopoverArrow,
  PopoverClose: () => PopoverClose,
  PopoverContent: () => PopoverContent,
  PopoverPortal: () => PopoverPortal,
  PopoverTrigger: () => PopoverTrigger,
  Portal: () => Portal4,
  Root: () => Root25,
  Trigger: () => Trigger5,
  createPopoverScope: () => createPopoverScope
});
var React68 = __toESM(require_react(), 1);
var import_jsx_runtime77 = __toESM(require_jsx_runtime(), 1);
var POPOVER_NAME = "Popover";
var [createPopoverContext, createPopoverScope] = createContextScope(POPOVER_NAME, [
  createPopperScope
]);
var usePopperScope3 = createPopperScope();
var [PopoverProvider, usePopoverContext] = createPopoverContext(POPOVER_NAME);
var Popover = (props) => {
  const {
    __scopePopover,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = false
  } = props;
  const popperScope = usePopperScope3(__scopePopover);
  const triggerRef = React68.useRef(null);
  const [hasCustomAnchor, setHasCustomAnchor] = React68.useState(false);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: POPOVER_NAME
  });
  return (0, import_jsx_runtime77.jsx)(Root22, { ...popperScope, children: (0, import_jsx_runtime77.jsx)(
    PopoverProvider,
    {
      scope: __scopePopover,
      contentId: useId2(),
      triggerRef,
      open,
      onOpenChange: setOpen,
      onOpenToggle: React68.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      hasCustomAnchor,
      onCustomAnchorAdd: React68.useCallback(() => setHasCustomAnchor(true), []),
      onCustomAnchorRemove: React68.useCallback(() => setHasCustomAnchor(false), []),
      modal,
      children
    }
  ) });
};
Popover.displayName = POPOVER_NAME;
var ANCHOR_NAME3 = "PopoverAnchor";
var PopoverAnchor = React68.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...anchorProps } = props;
    const context = usePopoverContext(ANCHOR_NAME3, __scopePopover);
    const popperScope = usePopperScope3(__scopePopover);
    const { onCustomAnchorAdd, onCustomAnchorRemove } = context;
    React68.useEffect(() => {
      onCustomAnchorAdd();
      return () => onCustomAnchorRemove();
    }, [onCustomAnchorAdd, onCustomAnchorRemove]);
    return (0, import_jsx_runtime77.jsx)(Anchor, { ...popperScope, ...anchorProps, ref: forwardedRef });
  }
);
PopoverAnchor.displayName = ANCHOR_NAME3;
var TRIGGER_NAME11 = "PopoverTrigger";
var PopoverTrigger = React68.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...triggerProps } = props;
    const context = usePopoverContext(TRIGGER_NAME11, __scopePopover);
    const popperScope = usePopperScope3(__scopePopover);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    const trigger2 = (0, import_jsx_runtime77.jsx)(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState5(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
    return context.hasCustomAnchor ? trigger2 : (0, import_jsx_runtime77.jsx)(Anchor, { asChild: true, ...popperScope, children: trigger2 });
  }
);
PopoverTrigger.displayName = TRIGGER_NAME11;
var PORTAL_NAME9 = "PopoverPortal";
var [PortalProvider4, usePortalContext4] = createPopoverContext(PORTAL_NAME9, {
  forceMount: void 0
});
var PopoverPortal = (props) => {
  const { __scopePopover, forceMount, children, container } = props;
  const context = usePopoverContext(PORTAL_NAME9, __scopePopover);
  return (0, import_jsx_runtime77.jsx)(PortalProvider4, { scope: __scopePopover, forceMount, children: (0, import_jsx_runtime77.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime77.jsx)(Portal, { asChild: true, container, children }) }) });
};
PopoverPortal.displayName = PORTAL_NAME9;
var CONTENT_NAME12 = "PopoverContent";
var PopoverContent = React68.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext4(CONTENT_NAME12, props.__scopePopover);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = usePopoverContext(CONTENT_NAME12, props.__scopePopover);
    return (0, import_jsx_runtime77.jsx)(Presence, { present: forceMount || context.open, children: context.modal ? (0, import_jsx_runtime77.jsx)(PopoverContentModal, { ...contentProps, ref: forwardedRef }) : (0, import_jsx_runtime77.jsx)(PopoverContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
PopoverContent.displayName = CONTENT_NAME12;
var Slot4 = createSlot("PopoverContent.RemoveScroll");
var PopoverContentModal = React68.forwardRef(
  (props, forwardedRef) => {
    const context = usePopoverContext(CONTENT_NAME12, props.__scopePopover);
    const contentRef = React68.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    const isRightClickOutsideRef = React68.useRef(false);
    React68.useEffect(() => {
      const content = contentRef.current;
      if (content) return hideOthers(content);
    }, []);
    return (0, import_jsx_runtime77.jsx)(Combination_default, { as: Slot4, allowPinchZoom: true, children: (0, import_jsx_runtime77.jsx)(
      PopoverContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          var _a6;
          event.preventDefault();
          if (!isRightClickOutsideRef.current) (_a6 = context.triggerRef.current) == null ? void 0 : _a6.focus();
        }),
        onPointerDownOutside: composeEventHandlers(
          props.onPointerDownOutside,
          (event) => {
            const originalEvent = event.detail.originalEvent;
            const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
            const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
            isRightClickOutsideRef.current = isRightClick;
          },
          { checkForDefaultPrevented: false }
        ),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault(),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
var PopoverContentNonModal = React68.forwardRef(
  (props, forwardedRef) => {
    const context = usePopoverContext(CONTENT_NAME12, props.__scopePopover);
    const hasInteractedOutsideRef = React68.useRef(false);
    const hasPointerDownOutsideRef = React68.useRef(false);
    return (0, import_jsx_runtime77.jsx)(
      PopoverContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          var _a6, _b3;
          (_a6 = props.onCloseAutoFocus) == null ? void 0 : _a6.call(props, event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) (_b3 = context.triggerRef.current) == null ? void 0 : _b3.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          var _a6, _b3;
          (_a6 = props.onInteractOutside) == null ? void 0 : _a6.call(props, event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = (_b3 = context.triggerRef.current) == null ? void 0 : _b3.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var PopoverContentImpl = React68.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopePopover,
      trapFocus,
      onOpenAutoFocus,
      onCloseAutoFocus,
      disableOutsidePointerEvents,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      ...contentProps
    } = props;
    const context = usePopoverContext(CONTENT_NAME12, __scopePopover);
    const popperScope = usePopperScope3(__scopePopover);
    useFocusGuards();
    return (0, import_jsx_runtime77.jsx)(
      FocusScope,
      {
        asChild: true,
        loop: true,
        trapped: trapFocus,
        onMountAutoFocus: onOpenAutoFocus,
        onUnmountAutoFocus: onCloseAutoFocus,
        children: (0, import_jsx_runtime77.jsx)(
          DismissableLayer,
          {
            asChild: true,
            disableOutsidePointerEvents,
            onInteractOutside,
            onEscapeKeyDown,
            onPointerDownOutside,
            onFocusOutside,
            onDismiss: () => context.onOpenChange(false),
            children: (0, import_jsx_runtime77.jsx)(
              Content3,
              {
                "data-state": getState5(context.open),
                role: "dialog",
                id: context.contentId,
                ...popperScope,
                ...contentProps,
                ref: forwardedRef,
                style: {
                  ...contentProps.style,
                  // re-namespace exposed content custom properties
                  ...{
                    "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                    "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                    "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                    "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                    "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                  }
                }
              }
            )
          }
        )
      }
    );
  }
);
var CLOSE_NAME2 = "PopoverClose";
var PopoverClose = React68.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...closeProps } = props;
    const context = usePopoverContext(CLOSE_NAME2, __scopePopover);
    return (0, import_jsx_runtime77.jsx)(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
PopoverClose.displayName = CLOSE_NAME2;
var ARROW_NAME7 = "PopoverArrow";
var PopoverArrow = React68.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...arrowProps } = props;
    const popperScope = usePopperScope3(__scopePopover);
    return (0, import_jsx_runtime77.jsx)(Arrow2, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
PopoverArrow.displayName = ARROW_NAME7;
function getState5(open) {
  return open ? "open" : "closed";
}
var Root25 = Popover;
var Anchor22 = PopoverAnchor;
var Trigger5 = PopoverTrigger;
var Portal4 = PopoverPortal;
var Content25 = PopoverContent;
var Close2 = PopoverClose;
var Arrow25 = PopoverArrow;

// ../node_modules/@radix-ui/react-progress/dist/index.mjs
var React69 = __toESM(require_react(), 1);
var import_jsx_runtime78 = __toESM(require_jsx_runtime(), 1);
var PROGRESS_NAME = "Progress";
var DEFAULT_MAX = 100;
var [createProgressContext, createProgressScope] = createContextScope(PROGRESS_NAME);
var [ProgressProvider, useProgressContext] = createProgressContext(PROGRESS_NAME);
var Progress = React69.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeProgress,
      value: valueProp = null,
      max: maxProp,
      getValueLabel = defaultGetValueLabel,
      ...progressProps
    } = props;
    if ((maxProp || maxProp === 0) && !isValidMaxNumber(maxProp)) {
      console.error(getInvalidMaxError(`${maxProp}`, "Progress"));
    }
    const max2 = isValidMaxNumber(maxProp) ? maxProp : DEFAULT_MAX;
    if (valueProp !== null && !isValidValueNumber(valueProp, max2)) {
      console.error(getInvalidValueError(`${valueProp}`, "Progress"));
    }
    const value = isValidValueNumber(valueProp, max2) ? valueProp : null;
    const valueLabel = isNumber2(value) ? getValueLabel(value, max2) : void 0;
    return (0, import_jsx_runtime78.jsx)(ProgressProvider, { scope: __scopeProgress, value, max: max2, children: (0, import_jsx_runtime78.jsx)(
      Primitive.div,
      {
        "aria-valuemax": max2,
        "aria-valuemin": 0,
        "aria-valuenow": isNumber2(value) ? value : void 0,
        "aria-valuetext": valueLabel,
        role: "progressbar",
        "data-state": getProgressState(value, max2),
        "data-value": value ?? void 0,
        "data-max": max2,
        ...progressProps,
        ref: forwardedRef
      }
    ) });
  }
);
Progress.displayName = PROGRESS_NAME;
var INDICATOR_NAME6 = "ProgressIndicator";
var ProgressIndicator = React69.forwardRef(
  (props, forwardedRef) => {
    const { __scopeProgress, ...indicatorProps } = props;
    const context = useProgressContext(INDICATOR_NAME6, __scopeProgress);
    return (0, import_jsx_runtime78.jsx)(
      Primitive.div,
      {
        "data-state": getProgressState(context.value, context.max),
        "data-value": context.value ?? void 0,
        "data-max": context.max,
        ...indicatorProps,
        ref: forwardedRef
      }
    );
  }
);
ProgressIndicator.displayName = INDICATOR_NAME6;
function defaultGetValueLabel(value, max2) {
  return `${Math.round(value / max2 * 100)}%`;
}
function getProgressState(value, maxValue) {
  return value == null ? "indeterminate" : value === maxValue ? "complete" : "loading";
}
function isNumber2(value) {
  return typeof value === "number";
}
function isValidMaxNumber(max2) {
  return isNumber2(max2) && !isNaN(max2) && max2 > 0;
}
function isValidValueNumber(value, max2) {
  return isNumber2(value) && !isNaN(value) && value <= max2 && value >= 0;
}
function getInvalidMaxError(propValue, componentName) {
  return `Invalid prop \`max\` of value \`${propValue}\` supplied to \`${componentName}\`. Only numbers greater than 0 are valid max values. Defaulting to \`${DEFAULT_MAX}\`.`;
}
function getInvalidValueError(propValue, componentName) {
  return `Invalid prop \`value\` of value \`${propValue}\` supplied to \`${componentName}\`. The \`value\` prop must be:
  - a positive number
  - less than the value passed to \`max\` (or ${DEFAULT_MAX} if no \`max\` prop is set)
  - \`null\` or \`undefined\` if the progress is indeterminate.

Defaulting to \`null\`.`;
}

// ../node_modules/@radix-ui/react-radio-group/dist/index.mjs
var React210 = __toESM(require_react(), 1);
var React70 = __toESM(require_react(), 1);
var import_jsx_runtime79 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime80 = __toESM(require_jsx_runtime(), 1);
var RADIO_NAME = "Radio";
var [createRadioContext, createRadioScope] = createContextScope(RADIO_NAME);
var [RadioProvider, useRadioContext] = createRadioContext(RADIO_NAME);
var Radio = React70.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeRadio,
      name,
      checked = false,
      required,
      disabled,
      value = "on",
      onCheck,
      form,
      ...radioProps
    } = props;
    const [button, setButton] = React70.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));
    const hasConsumerStoppedPropagationRef = React70.useRef(false);
    const isFormControl2 = button ? form || !!button.closest("form") : true;
    return (0, import_jsx_runtime79.jsxs)(RadioProvider, { scope: __scopeRadio, checked, disabled, children: [
      (0, import_jsx_runtime79.jsx)(
        Primitive.button,
        {
          type: "button",
          role: "radio",
          "aria-checked": checked,
          "data-state": getState6(checked),
          "data-disabled": disabled ? "" : void 0,
          disabled,
          value,
          ...radioProps,
          ref: composedRefs,
          onClick: composeEventHandlers(props.onClick, (event) => {
            if (!checked) onCheck == null ? void 0 : onCheck();
            if (isFormControl2) {
              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
              if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();
            }
          })
        }
      ),
      isFormControl2 && (0, import_jsx_runtime79.jsx)(
        RadioBubbleInput,
        {
          control: button,
          bubbles: !hasConsumerStoppedPropagationRef.current,
          name,
          value,
          checked,
          required,
          disabled,
          form,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
Radio.displayName = RADIO_NAME;
var INDICATOR_NAME7 = "RadioIndicator";
var RadioIndicator = React70.forwardRef(
  (props, forwardedRef) => {
    const { __scopeRadio, forceMount, ...indicatorProps } = props;
    const context = useRadioContext(INDICATOR_NAME7, __scopeRadio);
    return (0, import_jsx_runtime79.jsx)(Presence, { present: forceMount || context.checked, children: (0, import_jsx_runtime79.jsx)(
      Primitive.span,
      {
        "data-state": getState6(context.checked),
        "data-disabled": context.disabled ? "" : void 0,
        ...indicatorProps,
        ref: forwardedRef
      }
    ) });
  }
);
RadioIndicator.displayName = INDICATOR_NAME7;
var BUBBLE_INPUT_NAME2 = "RadioBubbleInput";
var RadioBubbleInput = React70.forwardRef(
  ({
    __scopeRadio,
    control,
    checked,
    bubbles = true,
    ...props
  }, forwardedRef) => {
    const ref = React70.useRef(null);
    const composedRefs = useComposedRefs(ref, forwardedRef);
    const prevChecked = usePrevious(checked);
    const controlSize = useSize(control);
    React70.useEffect(() => {
      const input = ref.current;
      if (!input) return;
      const inputProto = window.HTMLInputElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        inputProto,
        "checked"
      );
      const setChecked = descriptor.set;
      if (prevChecked !== checked && setChecked) {
        const event = new Event("click", { bubbles });
        setChecked.call(input, checked);
        input.dispatchEvent(event);
      }
    }, [prevChecked, checked, bubbles]);
    return (0, import_jsx_runtime79.jsx)(
      Primitive.input,
      {
        type: "radio",
        "aria-hidden": true,
        defaultChecked: checked,
        ...props,
        tabIndex: -1,
        ref: composedRefs,
        style: {
          ...props.style,
          ...controlSize,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        }
      }
    );
  }
);
RadioBubbleInput.displayName = BUBBLE_INPUT_NAME2;
function getState6(checked) {
  return checked ? "checked" : "unchecked";
}
var ARROW_KEYS2 = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
var RADIO_GROUP_NAME5 = "RadioGroup";
var [createRadioGroupContext, createRadioGroupScope] = createContextScope(RADIO_GROUP_NAME5, [
  createRovingFocusGroupScope,
  createRadioScope
]);
var useRovingFocusGroupScope4 = createRovingFocusGroupScope();
var useRadioScope = createRadioScope();
var [RadioGroupProvider2, useRadioGroupContext2] = createRadioGroupContext(RADIO_GROUP_NAME5);
var RadioGroup3 = React210.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeRadioGroup,
      name,
      defaultValue,
      value: valueProp,
      required = false,
      disabled = false,
      orientation,
      dir,
      loop = true,
      onValueChange,
      ...groupProps
    } = props;
    const rovingFocusGroupScope = useRovingFocusGroupScope4(__scopeRadioGroup);
    const direction = useDirection(dir);
    const [value, setValue] = useControllableState({
      prop: valueProp,
      defaultProp: defaultValue ?? null,
      onChange: onValueChange,
      caller: RADIO_GROUP_NAME5
    });
    return (0, import_jsx_runtime80.jsx)(
      RadioGroupProvider2,
      {
        scope: __scopeRadioGroup,
        name,
        required,
        disabled,
        value,
        onValueChange: setValue,
        children: (0, import_jsx_runtime80.jsx)(
          Root7,
          {
            asChild: true,
            ...rovingFocusGroupScope,
            orientation,
            dir: direction,
            loop,
            children: (0, import_jsx_runtime80.jsx)(
              Primitive.div,
              {
                role: "radiogroup",
                "aria-required": required,
                "aria-orientation": orientation,
                "data-disabled": disabled ? "" : void 0,
                dir: direction,
                ...groupProps,
                ref: forwardedRef
              }
            )
          }
        )
      }
    );
  }
);
RadioGroup3.displayName = RADIO_GROUP_NAME5;
var ITEM_NAME8 = "RadioGroupItem";
var RadioGroupItem = React210.forwardRef(
  (props, forwardedRef) => {
    const { __scopeRadioGroup, disabled, ...itemProps } = props;
    const context = useRadioGroupContext2(ITEM_NAME8, __scopeRadioGroup);
    const isDisabled = context.disabled || disabled;
    const rovingFocusGroupScope = useRovingFocusGroupScope4(__scopeRadioGroup);
    const radioScope = useRadioScope(__scopeRadioGroup);
    const ref = React210.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const checked = context.value === itemProps.value;
    const isArrowKeyPressedRef = React210.useRef(false);
    React210.useEffect(() => {
      const handleKeyDown2 = (event) => {
        if (ARROW_KEYS2.includes(event.key)) {
          isArrowKeyPressedRef.current = true;
        }
      };
      const handleKeyUp = () => isArrowKeyPressedRef.current = false;
      document.addEventListener("keydown", handleKeyDown2);
      document.addEventListener("keyup", handleKeyUp);
      return () => {
        document.removeEventListener("keydown", handleKeyDown2);
        document.removeEventListener("keyup", handleKeyUp);
      };
    }, []);
    return (0, import_jsx_runtime80.jsx)(
      Item,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        focusable: !isDisabled,
        active: checked,
        children: (0, import_jsx_runtime80.jsx)(
          Radio,
          {
            disabled: isDisabled,
            required: context.required,
            checked,
            ...radioScope,
            ...itemProps,
            name: context.name,
            ref: composedRefs,
            onCheck: () => context.onValueChange(itemProps.value),
            onKeyDown: composeEventHandlers((event) => {
              if (event.key === "Enter") event.preventDefault();
            }),
            onFocus: composeEventHandlers(itemProps.onFocus, () => {
              var _a6;
              if (isArrowKeyPressedRef.current) (_a6 = ref.current) == null ? void 0 : _a6.click();
            })
          }
        )
      }
    );
  }
);
RadioGroupItem.displayName = ITEM_NAME8;
var INDICATOR_NAME22 = "RadioGroupIndicator";
var RadioGroupIndicator = React210.forwardRef(
  (props, forwardedRef) => {
    const { __scopeRadioGroup, ...indicatorProps } = props;
    const radioScope = useRadioScope(__scopeRadioGroup);
    return (0, import_jsx_runtime80.jsx)(RadioIndicator, { ...radioScope, ...indicatorProps, ref: forwardedRef });
  }
);
RadioGroupIndicator.displayName = INDICATOR_NAME22;

// ../node_modules/@radix-ui/react-scroll-area/dist/index.mjs
var React211 = __toESM(require_react(), 1);
var React71 = __toESM(require_react(), 1);
var import_jsx_runtime81 = __toESM(require_jsx_runtime(), 1);
function useStateMachine2(initialState2, machine) {
  return React71.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState2);
}
var SCROLL_AREA_NAME = "ScrollArea";
var [createScrollAreaContext, createScrollAreaScope] = createContextScope(SCROLL_AREA_NAME);
var [ScrollAreaProvider, useScrollAreaContext] = createScrollAreaContext(SCROLL_AREA_NAME);
var ScrollArea = React211.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeScrollArea,
      type = "hover",
      dir,
      scrollHideDelay = 600,
      ...scrollAreaProps
    } = props;
    const [scrollArea, setScrollArea] = React211.useState(null);
    const [viewport, setViewport] = React211.useState(null);
    const [content, setContent2] = React211.useState(null);
    const [scrollbarX, setScrollbarX] = React211.useState(null);
    const [scrollbarY, setScrollbarY] = React211.useState(null);
    const [cornerWidth, setCornerWidth] = React211.useState(0);
    const [cornerHeight, setCornerHeight] = React211.useState(0);
    const [scrollbarXEnabled, setScrollbarXEnabled] = React211.useState(false);
    const [scrollbarYEnabled, setScrollbarYEnabled] = React211.useState(false);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setScrollArea(node));
    const direction = useDirection(dir);
    return (0, import_jsx_runtime81.jsx)(
      ScrollAreaProvider,
      {
        scope: __scopeScrollArea,
        type,
        dir: direction,
        scrollHideDelay,
        scrollArea,
        viewport,
        onViewportChange: setViewport,
        content,
        onContentChange: setContent2,
        scrollbarX,
        onScrollbarXChange: setScrollbarX,
        scrollbarXEnabled,
        onScrollbarXEnabledChange: setScrollbarXEnabled,
        scrollbarY,
        onScrollbarYChange: setScrollbarY,
        scrollbarYEnabled,
        onScrollbarYEnabledChange: setScrollbarYEnabled,
        onCornerWidthChange: setCornerWidth,
        onCornerHeightChange: setCornerHeight,
        children: (0, import_jsx_runtime81.jsx)(
          Primitive.div,
          {
            dir: direction,
            ...scrollAreaProps,
            ref: composedRefs,
            style: {
              position: "relative",
              // Pass corner sizes as CSS vars to reduce re-renders of context consumers
              ["--radix-scroll-area-corner-width"]: cornerWidth + "px",
              ["--radix-scroll-area-corner-height"]: cornerHeight + "px",
              ...props.style
            }
          }
        )
      }
    );
  }
);
ScrollArea.displayName = SCROLL_AREA_NAME;
var VIEWPORT_NAME2 = "ScrollAreaViewport";
var ScrollAreaViewport = React211.forwardRef(
  (props, forwardedRef) => {
    const { __scopeScrollArea, children, nonce, ...viewportProps } = props;
    const context = useScrollAreaContext(VIEWPORT_NAME2, __scopeScrollArea);
    const ref = React211.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);
    return (0, import_jsx_runtime81.jsxs)(import_jsx_runtime81.Fragment, { children: [
      (0, import_jsx_runtime81.jsx)(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: `[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}`
          },
          nonce
        }
      ),
      (0, import_jsx_runtime81.jsx)(
        Primitive.div,
        {
          "data-radix-scroll-area-viewport": "",
          ...viewportProps,
          ref: composedRefs,
          style: {
            /**
             * We don't support `visible` because the intention is to have at least one scrollbar
             * if this component is used and `visible` will behave like `auto` in that case
             * https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#description
             *
             * We don't handle `auto` because the intention is for the native implementation
             * to be hidden if using this component. We just want to ensure the node is scrollable
             * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
             * the browser from having to work out whether to render native scrollbars or not,
             * we tell it to with the intention of hiding them in CSS.
             */
            overflowX: context.scrollbarXEnabled ? "scroll" : "hidden",
            overflowY: context.scrollbarYEnabled ? "scroll" : "hidden",
            ...props.style
          },
          children: (0, import_jsx_runtime81.jsx)("div", { ref: context.onContentChange, style: { minWidth: "100%", display: "table" }, children })
        }
      )
    ] });
  }
);
ScrollAreaViewport.displayName = VIEWPORT_NAME2;
var SCROLLBAR_NAME = "ScrollAreaScrollbar";
var ScrollAreaScrollbar = React211.forwardRef(
  (props, forwardedRef) => {
    const { forceMount, ...scrollbarProps } = props;
    const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
    const { onScrollbarXEnabledChange, onScrollbarYEnabledChange } = context;
    const isHorizontal = props.orientation === "horizontal";
    React211.useEffect(() => {
      isHorizontal ? onScrollbarXEnabledChange(true) : onScrollbarYEnabledChange(true);
      return () => {
        isHorizontal ? onScrollbarXEnabledChange(false) : onScrollbarYEnabledChange(false);
      };
    }, [isHorizontal, onScrollbarXEnabledChange, onScrollbarYEnabledChange]);
    return context.type === "hover" ? (0, import_jsx_runtime81.jsx)(ScrollAreaScrollbarHover, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "scroll" ? (0, import_jsx_runtime81.jsx)(ScrollAreaScrollbarScroll, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "auto" ? (0, import_jsx_runtime81.jsx)(ScrollAreaScrollbarAuto, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "always" ? (0, import_jsx_runtime81.jsx)(ScrollAreaScrollbarVisible, { ...scrollbarProps, ref: forwardedRef }) : null;
  }
);
ScrollAreaScrollbar.displayName = SCROLLBAR_NAME;
var ScrollAreaScrollbarHover = React211.forwardRef((props, forwardedRef) => {
  const { forceMount, ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const [visible, setVisible] = React211.useState(false);
  React211.useEffect(() => {
    const scrollArea = context.scrollArea;
    let hideTimer = 0;
    if (scrollArea) {
      const handlePointerEnter = () => {
        window.clearTimeout(hideTimer);
        setVisible(true);
      };
      const handlePointerLeave = () => {
        hideTimer = window.setTimeout(() => setVisible(false), context.scrollHideDelay);
      };
      scrollArea.addEventListener("pointerenter", handlePointerEnter);
      scrollArea.addEventListener("pointerleave", handlePointerLeave);
      return () => {
        window.clearTimeout(hideTimer);
        scrollArea.removeEventListener("pointerenter", handlePointerEnter);
        scrollArea.removeEventListener("pointerleave", handlePointerLeave);
      };
    }
  }, [context.scrollArea, context.scrollHideDelay]);
  return (0, import_jsx_runtime81.jsx)(Presence, { present: forceMount || visible, children: (0, import_jsx_runtime81.jsx)(
    ScrollAreaScrollbarAuto,
    {
      "data-state": visible ? "visible" : "hidden",
      ...scrollbarProps,
      ref: forwardedRef
    }
  ) });
});
var ScrollAreaScrollbarScroll = React211.forwardRef((props, forwardedRef) => {
  const { forceMount, ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const isHorizontal = props.orientation === "horizontal";
  const debounceScrollEnd = useDebounceCallback(() => send("SCROLL_END"), 100);
  const [state, send] = useStateMachine2("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  React211.useEffect(() => {
    if (state === "idle") {
      const hideTimer = window.setTimeout(() => send("HIDE"), context.scrollHideDelay);
      return () => window.clearTimeout(hideTimer);
    }
  }, [state, context.scrollHideDelay, send]);
  React211.useEffect(() => {
    const viewport = context.viewport;
    const scrollDirection = isHorizontal ? "scrollLeft" : "scrollTop";
    if (viewport) {
      let prevScrollPos = viewport[scrollDirection];
      const handleScroll2 = () => {
        const scrollPos = viewport[scrollDirection];
        const hasScrollInDirectionChanged = prevScrollPos !== scrollPos;
        if (hasScrollInDirectionChanged) {
          send("SCROLL");
          debounceScrollEnd();
        }
        prevScrollPos = scrollPos;
      };
      viewport.addEventListener("scroll", handleScroll2);
      return () => viewport.removeEventListener("scroll", handleScroll2);
    }
  }, [context.viewport, isHorizontal, send, debounceScrollEnd]);
  return (0, import_jsx_runtime81.jsx)(Presence, { present: forceMount || state !== "hidden", children: (0, import_jsx_runtime81.jsx)(
    ScrollAreaScrollbarVisible,
    {
      "data-state": state === "hidden" ? "hidden" : "visible",
      ...scrollbarProps,
      ref: forwardedRef,
      onPointerEnter: composeEventHandlers(props.onPointerEnter, () => send("POINTER_ENTER")),
      onPointerLeave: composeEventHandlers(props.onPointerLeave, () => send("POINTER_LEAVE"))
    }
  ) });
});
var ScrollAreaScrollbarAuto = React211.forwardRef((props, forwardedRef) => {
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const { forceMount, ...scrollbarProps } = props;
  const [visible, setVisible] = React211.useState(false);
  const isHorizontal = props.orientation === "horizontal";
  const handleResize = useDebounceCallback(() => {
    if (context.viewport) {
      const isOverflowX = context.viewport.offsetWidth < context.viewport.scrollWidth;
      const isOverflowY = context.viewport.offsetHeight < context.viewport.scrollHeight;
      setVisible(isHorizontal ? isOverflowX : isOverflowY);
    }
  }, 10);
  useResizeObserver2(context.viewport, handleResize);
  useResizeObserver2(context.content, handleResize);
  return (0, import_jsx_runtime81.jsx)(Presence, { present: forceMount || visible, children: (0, import_jsx_runtime81.jsx)(
    ScrollAreaScrollbarVisible,
    {
      "data-state": visible ? "visible" : "hidden",
      ...scrollbarProps,
      ref: forwardedRef
    }
  ) });
});
var ScrollAreaScrollbarVisible = React211.forwardRef((props, forwardedRef) => {
  const { orientation = "vertical", ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const thumbRef = React211.useRef(null);
  const pointerOffsetRef = React211.useRef(0);
  const [sizes, setSizes] = React211.useState({
    content: 0,
    viewport: 0,
    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
  });
  const thumbRatio = getThumbRatio(sizes.viewport, sizes.content);
  const commonProps = {
    ...scrollbarProps,
    sizes,
    onSizesChange: setSizes,
    hasThumb: Boolean(thumbRatio > 0 && thumbRatio < 1),
    onThumbChange: (thumb) => thumbRef.current = thumb,
    onThumbPointerUp: () => pointerOffsetRef.current = 0,
    onThumbPointerDown: (pointerPos) => pointerOffsetRef.current = pointerPos
  };
  function getScrollPosition(pointerPos, dir) {
    return getScrollPositionFromPointer(pointerPos, pointerOffsetRef.current, sizes, dir);
  }
  if (orientation === "horizontal") {
    return (0, import_jsx_runtime81.jsx)(
      ScrollAreaScrollbarX,
      {
        ...commonProps,
        ref: forwardedRef,
        onThumbPositionChange: () => {
          if (context.viewport && thumbRef.current) {
            const scrollPos = context.viewport.scrollLeft;
            const offset4 = getThumbOffsetFromScroll(scrollPos, sizes, context.dir);
            thumbRef.current.style.transform = `translate3d(${offset4}px, 0, 0)`;
          }
        },
        onWheelScroll: (scrollPos) => {
          if (context.viewport) context.viewport.scrollLeft = scrollPos;
        },
        onDragScroll: (pointerPos) => {
          if (context.viewport) {
            context.viewport.scrollLeft = getScrollPosition(pointerPos, context.dir);
          }
        }
      }
    );
  }
  if (orientation === "vertical") {
    return (0, import_jsx_runtime81.jsx)(
      ScrollAreaScrollbarY,
      {
        ...commonProps,
        ref: forwardedRef,
        onThumbPositionChange: () => {
          if (context.viewport && thumbRef.current) {
            const scrollPos = context.viewport.scrollTop;
            const offset4 = getThumbOffsetFromScroll(scrollPos, sizes);
            thumbRef.current.style.transform = `translate3d(0, ${offset4}px, 0)`;
          }
        },
        onWheelScroll: (scrollPos) => {
          if (context.viewport) context.viewport.scrollTop = scrollPos;
        },
        onDragScroll: (pointerPos) => {
          if (context.viewport) context.viewport.scrollTop = getScrollPosition(pointerPos);
        }
      }
    );
  }
  return null;
});
var ScrollAreaScrollbarX = React211.forwardRef((props, forwardedRef) => {
  const { sizes, onSizesChange, ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const [computedStyle, setComputedStyle] = React211.useState();
  const ref = React211.useRef(null);
  const composeRefs2 = useComposedRefs(forwardedRef, ref, context.onScrollbarXChange);
  React211.useEffect(() => {
    if (ref.current) setComputedStyle(getComputedStyle(ref.current));
  }, [ref]);
  return (0, import_jsx_runtime81.jsx)(
    ScrollAreaScrollbarImpl,
    {
      "data-orientation": "horizontal",
      ...scrollbarProps,
      ref: composeRefs2,
      sizes,
      style: {
        bottom: 0,
        left: context.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
        right: context.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
        ["--radix-scroll-area-thumb-width"]: getThumbSize(sizes) + "px",
        ...props.style
      },
      onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.x),
      onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.x),
      onWheelScroll: (event, maxScrollPos) => {
        if (context.viewport) {
          const scrollPos = context.viewport.scrollLeft + event.deltaX;
          props.onWheelScroll(scrollPos);
          if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {
            event.preventDefault();
          }
        }
      },
      onResize: () => {
        if (ref.current && context.viewport && computedStyle) {
          onSizesChange({
            content: context.viewport.scrollWidth,
            viewport: context.viewport.offsetWidth,
            scrollbar: {
              size: ref.current.clientWidth,
              paddingStart: toInt(computedStyle.paddingLeft),
              paddingEnd: toInt(computedStyle.paddingRight)
            }
          });
        }
      }
    }
  );
});
var ScrollAreaScrollbarY = React211.forwardRef((props, forwardedRef) => {
  const { sizes, onSizesChange, ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const [computedStyle, setComputedStyle] = React211.useState();
  const ref = React211.useRef(null);
  const composeRefs2 = useComposedRefs(forwardedRef, ref, context.onScrollbarYChange);
  React211.useEffect(() => {
    if (ref.current) setComputedStyle(getComputedStyle(ref.current));
  }, [ref]);
  return (0, import_jsx_runtime81.jsx)(
    ScrollAreaScrollbarImpl,
    {
      "data-orientation": "vertical",
      ...scrollbarProps,
      ref: composeRefs2,
      sizes,
      style: {
        top: 0,
        right: context.dir === "ltr" ? 0 : void 0,
        left: context.dir === "rtl" ? 0 : void 0,
        bottom: "var(--radix-scroll-area-corner-height)",
        ["--radix-scroll-area-thumb-height"]: getThumbSize(sizes) + "px",
        ...props.style
      },
      onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.y),
      onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.y),
      onWheelScroll: (event, maxScrollPos) => {
        if (context.viewport) {
          const scrollPos = context.viewport.scrollTop + event.deltaY;
          props.onWheelScroll(scrollPos);
          if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {
            event.preventDefault();
          }
        }
      },
      onResize: () => {
        if (ref.current && context.viewport && computedStyle) {
          onSizesChange({
            content: context.viewport.scrollHeight,
            viewport: context.viewport.offsetHeight,
            scrollbar: {
              size: ref.current.clientHeight,
              paddingStart: toInt(computedStyle.paddingTop),
              paddingEnd: toInt(computedStyle.paddingBottom)
            }
          });
        }
      }
    }
  );
});
var [ScrollbarProvider, useScrollbarContext] = createScrollAreaContext(SCROLLBAR_NAME);
var ScrollAreaScrollbarImpl = React211.forwardRef((props, forwardedRef) => {
  const {
    __scopeScrollArea,
    sizes,
    hasThumb,
    onThumbChange,
    onThumbPointerUp,
    onThumbPointerDown,
    onThumbPositionChange,
    onDragScroll,
    onWheelScroll,
    onResize,
    ...scrollbarProps
  } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, __scopeScrollArea);
  const [scrollbar, setScrollbar] = React211.useState(null);
  const composeRefs2 = useComposedRefs(forwardedRef, (node) => setScrollbar(node));
  const rectRef = React211.useRef(null);
  const prevWebkitUserSelectRef = React211.useRef("");
  const viewport = context.viewport;
  const maxScrollPos = sizes.content - sizes.viewport;
  const handleWheelScroll = useCallbackRef(onWheelScroll);
  const handleThumbPositionChange = useCallbackRef(onThumbPositionChange);
  const handleResize = useDebounceCallback(onResize, 10);
  function handleDragScroll(event) {
    if (rectRef.current) {
      const x = event.clientX - rectRef.current.left;
      const y = event.clientY - rectRef.current.top;
      onDragScroll({ x, y });
    }
  }
  React211.useEffect(() => {
    const handleWheel = (event) => {
      const element = event.target;
      const isScrollbarWheel = scrollbar == null ? void 0 : scrollbar.contains(element);
      if (isScrollbarWheel) handleWheelScroll(event, maxScrollPos);
    };
    document.addEventListener("wheel", handleWheel, { passive: false });
    return () => document.removeEventListener("wheel", handleWheel, { passive: false });
  }, [viewport, scrollbar, maxScrollPos, handleWheelScroll]);
  React211.useEffect(handleThumbPositionChange, [sizes, handleThumbPositionChange]);
  useResizeObserver2(scrollbar, handleResize);
  useResizeObserver2(context.content, handleResize);
  return (0, import_jsx_runtime81.jsx)(
    ScrollbarProvider,
    {
      scope: __scopeScrollArea,
      scrollbar,
      hasThumb,
      onThumbChange: useCallbackRef(onThumbChange),
      onThumbPointerUp: useCallbackRef(onThumbPointerUp),
      onThumbPositionChange: handleThumbPositionChange,
      onThumbPointerDown: useCallbackRef(onThumbPointerDown),
      children: (0, import_jsx_runtime81.jsx)(
        Primitive.div,
        {
          ...scrollbarProps,
          ref: composeRefs2,
          style: { position: "absolute", ...scrollbarProps.style },
          onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
            const mainPointer = 0;
            if (event.button === mainPointer) {
              const element = event.target;
              element.setPointerCapture(event.pointerId);
              rectRef.current = scrollbar.getBoundingClientRect();
              prevWebkitUserSelectRef.current = document.body.style.webkitUserSelect;
              document.body.style.webkitUserSelect = "none";
              if (context.viewport) context.viewport.style.scrollBehavior = "auto";
              handleDragScroll(event);
            }
          }),
          onPointerMove: composeEventHandlers(props.onPointerMove, handleDragScroll),
          onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
            const element = event.target;
            if (element.hasPointerCapture(event.pointerId)) {
              element.releasePointerCapture(event.pointerId);
            }
            document.body.style.webkitUserSelect = prevWebkitUserSelectRef.current;
            if (context.viewport) context.viewport.style.scrollBehavior = "";
            rectRef.current = null;
          })
        }
      )
    }
  );
});
var THUMB_NAME = "ScrollAreaThumb";
var ScrollAreaThumb = React211.forwardRef(
  (props, forwardedRef) => {
    const { forceMount, ...thumbProps } = props;
    const scrollbarContext = useScrollbarContext(THUMB_NAME, props.__scopeScrollArea);
    return (0, import_jsx_runtime81.jsx)(Presence, { present: forceMount || scrollbarContext.hasThumb, children: (0, import_jsx_runtime81.jsx)(ScrollAreaThumbImpl, { ref: forwardedRef, ...thumbProps }) });
  }
);
var ScrollAreaThumbImpl = React211.forwardRef(
  (props, forwardedRef) => {
    const { __scopeScrollArea, style: style2, ...thumbProps } = props;
    const scrollAreaContext = useScrollAreaContext(THUMB_NAME, __scopeScrollArea);
    const scrollbarContext = useScrollbarContext(THUMB_NAME, __scopeScrollArea);
    const { onThumbPositionChange } = scrollbarContext;
    const composedRef = useComposedRefs(
      forwardedRef,
      (node) => scrollbarContext.onThumbChange(node)
    );
    const removeUnlinkedScrollListenerRef = React211.useRef(void 0);
    const debounceScrollEnd = useDebounceCallback(() => {
      if (removeUnlinkedScrollListenerRef.current) {
        removeUnlinkedScrollListenerRef.current();
        removeUnlinkedScrollListenerRef.current = void 0;
      }
    }, 100);
    React211.useEffect(() => {
      const viewport = scrollAreaContext.viewport;
      if (viewport) {
        const handleScroll2 = () => {
          debounceScrollEnd();
          if (!removeUnlinkedScrollListenerRef.current) {
            const listener = addUnlinkedScrollListener(viewport, onThumbPositionChange);
            removeUnlinkedScrollListenerRef.current = listener;
            onThumbPositionChange();
          }
        };
        onThumbPositionChange();
        viewport.addEventListener("scroll", handleScroll2);
        return () => viewport.removeEventListener("scroll", handleScroll2);
      }
    }, [scrollAreaContext.viewport, debounceScrollEnd, onThumbPositionChange]);
    return (0, import_jsx_runtime81.jsx)(
      Primitive.div,
      {
        "data-state": scrollbarContext.hasThumb ? "visible" : "hidden",
        ...thumbProps,
        ref: composedRef,
        style: {
          width: "var(--radix-scroll-area-thumb-width)",
          height: "var(--radix-scroll-area-thumb-height)",
          ...style2
        },
        onPointerDownCapture: composeEventHandlers(props.onPointerDownCapture, (event) => {
          const thumb = event.target;
          const thumbRect = thumb.getBoundingClientRect();
          const x = event.clientX - thumbRect.left;
          const y = event.clientY - thumbRect.top;
          scrollbarContext.onThumbPointerDown({ x, y });
        }),
        onPointerUp: composeEventHandlers(props.onPointerUp, scrollbarContext.onThumbPointerUp)
      }
    );
  }
);
ScrollAreaThumb.displayName = THUMB_NAME;
var CORNER_NAME = "ScrollAreaCorner";
var ScrollAreaCorner = React211.forwardRef(
  (props, forwardedRef) => {
    const context = useScrollAreaContext(CORNER_NAME, props.__scopeScrollArea);
    const hasBothScrollbarsVisible = Boolean(context.scrollbarX && context.scrollbarY);
    const hasCorner = context.type !== "scroll" && hasBothScrollbarsVisible;
    return hasCorner ? (0, import_jsx_runtime81.jsx)(ScrollAreaCornerImpl, { ...props, ref: forwardedRef }) : null;
  }
);
ScrollAreaCorner.displayName = CORNER_NAME;
var ScrollAreaCornerImpl = React211.forwardRef((props, forwardedRef) => {
  const { __scopeScrollArea, ...cornerProps } = props;
  const context = useScrollAreaContext(CORNER_NAME, __scopeScrollArea);
  const [width, setWidth] = React211.useState(0);
  const [height, setHeight] = React211.useState(0);
  const hasSize = Boolean(width && height);
  useResizeObserver2(context.scrollbarX, () => {
    var _a6;
    const height2 = ((_a6 = context.scrollbarX) == null ? void 0 : _a6.offsetHeight) || 0;
    context.onCornerHeightChange(height2);
    setHeight(height2);
  });
  useResizeObserver2(context.scrollbarY, () => {
    var _a6;
    const width2 = ((_a6 = context.scrollbarY) == null ? void 0 : _a6.offsetWidth) || 0;
    context.onCornerWidthChange(width2);
    setWidth(width2);
  });
  return hasSize ? (0, import_jsx_runtime81.jsx)(
    Primitive.div,
    {
      ...cornerProps,
      ref: forwardedRef,
      style: {
        width,
        height,
        position: "absolute",
        right: context.dir === "ltr" ? 0 : void 0,
        left: context.dir === "rtl" ? 0 : void 0,
        bottom: 0,
        ...props.style
      }
    }
  ) : null;
});
function toInt(value) {
  return value ? parseInt(value, 10) : 0;
}
function getThumbRatio(viewportSize, contentSize) {
  const ratio = viewportSize / contentSize;
  return isNaN(ratio) ? 0 : ratio;
}
function getThumbSize(sizes) {
  const ratio = getThumbRatio(sizes.viewport, sizes.content);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const thumbSize = (sizes.scrollbar.size - scrollbarPadding) * ratio;
  return Math.max(thumbSize, 18);
}
function getScrollPositionFromPointer(pointerPos, pointerOffset, sizes, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes);
  const thumbCenter = thumbSizePx / 2;
  const offset4 = pointerOffset || thumbCenter;
  const thumbOffsetFromEnd = thumbSizePx - offset4;
  const minPointerPos = sizes.scrollbar.paddingStart + offset4;
  const maxPointerPos = sizes.scrollbar.size - sizes.scrollbar.paddingEnd - thumbOffsetFromEnd;
  const maxScrollPos = sizes.content - sizes.viewport;
  const scrollRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const interpolate = linearScale([minPointerPos, maxPointerPos], scrollRange);
  return interpolate(pointerPos);
}
function getThumbOffsetFromScroll(scrollPos, sizes, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const scrollbar = sizes.scrollbar.size - scrollbarPadding;
  const maxScrollPos = sizes.content - sizes.viewport;
  const maxThumbPos = scrollbar - thumbSizePx;
  const scrollClampRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const scrollWithoutMomentum = clamp4(scrollPos, scrollClampRange);
  const interpolate = linearScale([0, maxScrollPos], [0, maxThumbPos]);
  return interpolate(scrollWithoutMomentum);
}
function linearScale(input, output) {
  return (value) => {
    if (input[0] === input[1] || output[0] === output[1]) return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) {
  return scrollPos > 0 && scrollPos < maxScrollPos;
}
var addUnlinkedScrollListener = (node, handler = () => {
}) => {
  let prevPosition = { left: node.scrollLeft, top: node.scrollTop };
  let rAF = 0;
  (function loop() {
    const position = { left: node.scrollLeft, top: node.scrollTop };
    const isHorizontalScroll = prevPosition.left !== position.left;
    const isVerticalScroll = prevPosition.top !== position.top;
    if (isHorizontalScroll || isVerticalScroll) handler();
    prevPosition = position;
    rAF = window.requestAnimationFrame(loop);
  })();
  return () => window.cancelAnimationFrame(rAF);
};
function useDebounceCallback(callback, delay) {
  const handleCallback = useCallbackRef(callback);
  const debounceTimerRef = React211.useRef(0);
  React211.useEffect(() => () => window.clearTimeout(debounceTimerRef.current), []);
  return React211.useCallback(() => {
    window.clearTimeout(debounceTimerRef.current);
    debounceTimerRef.current = window.setTimeout(handleCallback, delay);
  }, [handleCallback, delay]);
}
function useResizeObserver2(element, onResize) {
  const handleResize = useCallbackRef(onResize);
  useLayoutEffect22(() => {
    let rAF = 0;
    if (element) {
      const resizeObserver = new ResizeObserver(() => {
        cancelAnimationFrame(rAF);
        rAF = window.requestAnimationFrame(handleResize);
      });
      resizeObserver.observe(element);
      return () => {
        window.cancelAnimationFrame(rAF);
        resizeObserver.unobserve(element);
      };
    }
  }, [element, handleResize]);
}

// ../node_modules/@radix-ui/react-select/dist/index.mjs
var React72 = __toESM(require_react(), 1);
var ReactDOM5 = __toESM(require_react_dom(), 1);
var import_jsx_runtime82 = __toESM(require_jsx_runtime(), 1);
var OPEN_KEYS = [" ", "Enter", "ArrowUp", "ArrowDown"];
var SELECTION_KEYS2 = [" ", "Enter"];
var SELECT_NAME = "Select";
var [Collection7, useCollection7, createCollectionScope7] = createCollection(SELECT_NAME);
var [createSelectContext, createSelectScope] = createContextScope(SELECT_NAME, [
  createCollectionScope7,
  createPopperScope
]);
var usePopperScope4 = createPopperScope();
var [SelectProvider, useSelectContext] = createSelectContext(SELECT_NAME);
var [SelectNativeOptionsProvider, useSelectNativeOptionsContext] = createSelectContext(SELECT_NAME);
var Select = (props) => {
  const {
    __scopeSelect,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    value: valueProp,
    defaultValue,
    onValueChange,
    dir,
    name,
    autoComplete,
    disabled,
    required,
    form
  } = props;
  const popperScope = usePopperScope4(__scopeSelect);
  const [trigger2, setTrigger] = React72.useState(null);
  const [valueNode, setValueNode] = React72.useState(null);
  const [valueNodeHasChildren, setValueNodeHasChildren] = React72.useState(false);
  const direction = useDirection(dir);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: SELECT_NAME
  });
  const [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue,
    onChange: onValueChange,
    caller: SELECT_NAME
  });
  const triggerPointerDownPosRef = React72.useRef(null);
  const isFormControl2 = trigger2 ? form || !!trigger2.closest("form") : true;
  const [nativeOptionsSet, setNativeOptionsSet] = React72.useState(/* @__PURE__ */ new Set());
  const nativeSelectKey = Array.from(nativeOptionsSet).map((option) => option.props.value).join(";");
  return (0, import_jsx_runtime82.jsx)(Root22, { ...popperScope, children: (0, import_jsx_runtime82.jsxs)(
    SelectProvider,
    {
      required,
      scope: __scopeSelect,
      trigger: trigger2,
      onTriggerChange: setTrigger,
      valueNode,
      onValueNodeChange: setValueNode,
      valueNodeHasChildren,
      onValueNodeHasChildrenChange: setValueNodeHasChildren,
      contentId: useId2(),
      value,
      onValueChange: setValue,
      open,
      onOpenChange: setOpen,
      dir: direction,
      triggerPointerDownPosRef,
      disabled,
      children: [
        (0, import_jsx_runtime82.jsx)(Collection7.Provider, { scope: __scopeSelect, children: (0, import_jsx_runtime82.jsx)(
          SelectNativeOptionsProvider,
          {
            scope: props.__scopeSelect,
            onNativeOptionAdd: React72.useCallback((option) => {
              setNativeOptionsSet((prev) => new Set(prev).add(option));
            }, []),
            onNativeOptionRemove: React72.useCallback((option) => {
              setNativeOptionsSet((prev) => {
                const optionsSet = new Set(prev);
                optionsSet.delete(option);
                return optionsSet;
              });
            }, []),
            children
          }
        ) }),
        isFormControl2 ? (0, import_jsx_runtime82.jsxs)(
          SelectBubbleInput,
          {
            "aria-hidden": true,
            required,
            tabIndex: -1,
            name,
            autoComplete,
            value,
            onChange: (event) => setValue(event.target.value),
            disabled,
            form,
            children: [
              value === void 0 ? (0, import_jsx_runtime82.jsx)("option", { value: "" }) : null,
              Array.from(nativeOptionsSet)
            ]
          },
          nativeSelectKey
        ) : null
      ]
    }
  ) });
};
Select.displayName = SELECT_NAME;
var TRIGGER_NAME12 = "SelectTrigger";
var SelectTrigger = React72.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, disabled = false, ...triggerProps } = props;
    const popperScope = usePopperScope4(__scopeSelect);
    const context = useSelectContext(TRIGGER_NAME12, __scopeSelect);
    const isDisabled = context.disabled || disabled;
    const composedRefs = useComposedRefs(forwardedRef, context.onTriggerChange);
    const getItems = useCollection7(__scopeSelect);
    const pointerTypeRef = React72.useRef("touch");
    const [searchRef, handleTypeaheadSearch, resetTypeahead] = useTypeaheadSearch((search) => {
      const enabledItems = getItems().filter((item) => !item.disabled);
      const currentItem = enabledItems.find((item) => item.value === context.value);
      const nextItem = findNextItem(enabledItems, search, currentItem);
      if (nextItem !== void 0) {
        context.onValueChange(nextItem.value);
      }
    });
    const handleOpen = (pointerEvent) => {
      if (!isDisabled) {
        context.onOpenChange(true);
        resetTypeahead();
      }
      if (pointerEvent) {
        context.triggerPointerDownPosRef.current = {
          x: Math.round(pointerEvent.pageX),
          y: Math.round(pointerEvent.pageY)
        };
      }
    };
    return (0, import_jsx_runtime82.jsx)(Anchor, { asChild: true, ...popperScope, children: (0, import_jsx_runtime82.jsx)(
      Primitive.button,
      {
        type: "button",
        role: "combobox",
        "aria-controls": context.contentId,
        "aria-expanded": context.open,
        "aria-required": context.required,
        "aria-autocomplete": "none",
        dir: context.dir,
        "data-state": context.open ? "open" : "closed",
        disabled: isDisabled,
        "data-disabled": isDisabled ? "" : void 0,
        "data-placeholder": shouldShowPlaceholder(context.value) ? "" : void 0,
        ...triggerProps,
        ref: composedRefs,
        onClick: composeEventHandlers(triggerProps.onClick, (event) => {
          event.currentTarget.focus();
          if (pointerTypeRef.current !== "mouse") {
            handleOpen(event);
          }
        }),
        onPointerDown: composeEventHandlers(triggerProps.onPointerDown, (event) => {
          pointerTypeRef.current = event.pointerType;
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) {
            target.releasePointerCapture(event.pointerId);
          }
          if (event.button === 0 && event.ctrlKey === false && event.pointerType === "mouse") {
            handleOpen(event);
            event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers(triggerProps.onKeyDown, (event) => {
          const isTypingAhead = searchRef.current !== "";
          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
          if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
          if (isTypingAhead && event.key === " ") return;
          if (OPEN_KEYS.includes(event.key)) {
            handleOpen();
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
SelectTrigger.displayName = TRIGGER_NAME12;
var VALUE_NAME = "SelectValue";
var SelectValue = React72.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, className, style: style2, children, placeholder = "", ...valueProps } = props;
    const context = useSelectContext(VALUE_NAME, __scopeSelect);
    const { onValueNodeHasChildrenChange } = context;
    const hasChildren = children !== void 0;
    const composedRefs = useComposedRefs(forwardedRef, context.onValueNodeChange);
    useLayoutEffect22(() => {
      onValueNodeHasChildrenChange(hasChildren);
    }, [onValueNodeHasChildrenChange, hasChildren]);
    return (0, import_jsx_runtime82.jsx)(
      Primitive.span,
      {
        ...valueProps,
        ref: composedRefs,
        style: { pointerEvents: "none" },
        children: shouldShowPlaceholder(context.value) ? (0, import_jsx_runtime82.jsx)(import_jsx_runtime82.Fragment, { children: placeholder }) : children
      }
    );
  }
);
SelectValue.displayName = VALUE_NAME;
var ICON_NAME = "SelectIcon";
var SelectIcon = React72.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, children, ...iconProps } = props;
    return (0, import_jsx_runtime82.jsx)(Primitive.span, { "aria-hidden": true, ...iconProps, ref: forwardedRef, children: children || "▼" });
  }
);
SelectIcon.displayName = ICON_NAME;
var PORTAL_NAME10 = "SelectPortal";
var SelectPortal = (props) => {
  return (0, import_jsx_runtime82.jsx)(Portal, { asChild: true, ...props });
};
SelectPortal.displayName = PORTAL_NAME10;
var CONTENT_NAME13 = "SelectContent";
var SelectContent = React72.forwardRef(
  (props, forwardedRef) => {
    const context = useSelectContext(CONTENT_NAME13, props.__scopeSelect);
    const [fragment, setFragment] = React72.useState();
    useLayoutEffect22(() => {
      setFragment(new DocumentFragment());
    }, []);
    if (!context.open) {
      const frag = fragment;
      return frag ? ReactDOM5.createPortal(
        (0, import_jsx_runtime82.jsx)(SelectContentProvider, { scope: props.__scopeSelect, children: (0, import_jsx_runtime82.jsx)(Collection7.Slot, { scope: props.__scopeSelect, children: (0, import_jsx_runtime82.jsx)("div", { children: props.children }) }) }),
        frag
      ) : null;
    }
    return (0, import_jsx_runtime82.jsx)(SelectContentImpl, { ...props, ref: forwardedRef });
  }
);
SelectContent.displayName = CONTENT_NAME13;
var CONTENT_MARGIN = 10;
var [SelectContentProvider, useSelectContentContext] = createSelectContext(CONTENT_NAME13);
var CONTENT_IMPL_NAME = "SelectContentImpl";
var Slot5 = createSlot("SelectContent.RemoveScroll");
var SelectContentImpl = React72.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSelect,
      position = "item-aligned",
      onCloseAutoFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      //
      // PopperContent props
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions,
      //
      ...contentProps
    } = props;
    const context = useSelectContext(CONTENT_NAME13, __scopeSelect);
    const [content, setContent2] = React72.useState(null);
    const [viewport, setViewport] = React72.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent2(node));
    const [selectedItem, setSelectedItem] = React72.useState(null);
    const [selectedItemText, setSelectedItemText] = React72.useState(
      null
    );
    const getItems = useCollection7(__scopeSelect);
    const [isPositioned, setIsPositioned] = React72.useState(false);
    const firstValidItemFoundRef = React72.useRef(false);
    React72.useEffect(() => {
      if (content) return hideOthers(content);
    }, [content]);
    useFocusGuards();
    const focusFirst6 = React72.useCallback(
      (candidates) => {
        const [firstItem, ...restItems] = getItems().map((item) => item.ref.current);
        const [lastItem] = restItems.slice(-1);
        const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
        for (const candidate of candidates) {
          if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
          candidate == null ? void 0 : candidate.scrollIntoView({ block: "nearest" });
          if (candidate === firstItem && viewport) viewport.scrollTop = 0;
          if (candidate === lastItem && viewport) viewport.scrollTop = viewport.scrollHeight;
          candidate == null ? void 0 : candidate.focus();
          if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
        }
      },
      [getItems, viewport]
    );
    const focusSelectedItem = React72.useCallback(
      () => focusFirst6([selectedItem, content]),
      [focusFirst6, selectedItem, content]
    );
    React72.useEffect(() => {
      if (isPositioned) {
        focusSelectedItem();
      }
    }, [isPositioned, focusSelectedItem]);
    const { onOpenChange, triggerPointerDownPosRef } = context;
    React72.useEffect(() => {
      if (content) {
        let pointerMoveDelta = { x: 0, y: 0 };
        const handlePointerMove = (event) => {
          var _a6, _b3;
          pointerMoveDelta = {
            x: Math.abs(Math.round(event.pageX) - (((_a6 = triggerPointerDownPosRef.current) == null ? void 0 : _a6.x) ?? 0)),
            y: Math.abs(Math.round(event.pageY) - (((_b3 = triggerPointerDownPosRef.current) == null ? void 0 : _b3.y) ?? 0))
          };
        };
        const handlePointerUp = (event) => {
          if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10) {
            event.preventDefault();
          } else {
            if (!content.contains(event.target)) {
              onOpenChange(false);
            }
          }
          document.removeEventListener("pointermove", handlePointerMove);
          triggerPointerDownPosRef.current = null;
        };
        if (triggerPointerDownPosRef.current !== null) {
          document.addEventListener("pointermove", handlePointerMove);
          document.addEventListener("pointerup", handlePointerUp, { capture: true, once: true });
        }
        return () => {
          document.removeEventListener("pointermove", handlePointerMove);
          document.removeEventListener("pointerup", handlePointerUp, { capture: true });
        };
      }
    }, [content, onOpenChange, triggerPointerDownPosRef]);
    React72.useEffect(() => {
      const close2 = () => onOpenChange(false);
      window.addEventListener("blur", close2);
      window.addEventListener("resize", close2);
      return () => {
        window.removeEventListener("blur", close2);
        window.removeEventListener("resize", close2);
      };
    }, [onOpenChange]);
    const [searchRef, handleTypeaheadSearch] = useTypeaheadSearch((search) => {
      const enabledItems = getItems().filter((item) => !item.disabled);
      const currentItem = enabledItems.find((item) => item.ref.current === document.activeElement);
      const nextItem = findNextItem(enabledItems, search, currentItem);
      if (nextItem) {
        setTimeout(() => nextItem.ref.current.focus());
      }
    });
    const itemRefCallback = React72.useCallback(
      (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItem(node);
          if (isFirstValidItem) firstValidItemFoundRef.current = true;
        }
      },
      [context.value]
    );
    const handleItemLeave = React72.useCallback(() => content == null ? void 0 : content.focus(), [content]);
    const itemTextRefCallback = React72.useCallback(
      (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItemText(node);
        }
      },
      [context.value]
    );
    const SelectPosition = position === "popper" ? SelectPopperPosition : SelectItemAlignedPosition;
    const popperContentProps = SelectPosition === SelectPopperPosition ? {
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions
    } : {};
    return (0, import_jsx_runtime82.jsx)(
      SelectContentProvider,
      {
        scope: __scopeSelect,
        content,
        viewport,
        onViewportChange: setViewport,
        itemRefCallback,
        selectedItem,
        onItemLeave: handleItemLeave,
        itemTextRefCallback,
        focusSelectedItem,
        selectedItemText,
        position,
        isPositioned,
        searchRef,
        children: (0, import_jsx_runtime82.jsx)(Combination_default, { as: Slot5, allowPinchZoom: true, children: (0, import_jsx_runtime82.jsx)(
          FocusScope,
          {
            asChild: true,
            trapped: context.open,
            onMountAutoFocus: (event) => {
              event.preventDefault();
            },
            onUnmountAutoFocus: composeEventHandlers(onCloseAutoFocus, (event) => {
              var _a6;
              (_a6 = context.trigger) == null ? void 0 : _a6.focus({ preventScroll: true });
              event.preventDefault();
            }),
            children: (0, import_jsx_runtime82.jsx)(
              DismissableLayer,
              {
                asChild: true,
                disableOutsidePointerEvents: true,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside: (event) => event.preventDefault(),
                onDismiss: () => context.onOpenChange(false),
                children: (0, import_jsx_runtime82.jsx)(
                  SelectPosition,
                  {
                    role: "listbox",
                    id: context.contentId,
                    "data-state": context.open ? "open" : "closed",
                    dir: context.dir,
                    onContextMenu: (event) => event.preventDefault(),
                    ...contentProps,
                    ...popperContentProps,
                    onPlaced: () => setIsPositioned(true),
                    ref: composedRefs,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...contentProps.style
                    },
                    onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                      if (event.key === "Tab") event.preventDefault();
                      if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
                      if (["ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
                        const items = getItems().filter((item) => !item.disabled);
                        let candidateNodes = items.map((item) => item.ref.current);
                        if (["ArrowUp", "End"].includes(event.key)) {
                          candidateNodes = candidateNodes.slice().reverse();
                        }
                        if (["ArrowUp", "ArrowDown"].includes(event.key)) {
                          const currentElement = event.target;
                          const currentIndex = candidateNodes.indexOf(currentElement);
                          candidateNodes = candidateNodes.slice(currentIndex + 1);
                        }
                        setTimeout(() => focusFirst6(candidateNodes));
                        event.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
SelectContentImpl.displayName = CONTENT_IMPL_NAME;
var ITEM_ALIGNED_POSITION_NAME = "SelectItemAlignedPosition";
var SelectItemAlignedPosition = React72.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, onPlaced, ...popperProps } = props;
  const context = useSelectContext(CONTENT_NAME13, __scopeSelect);
  const contentContext = useSelectContentContext(CONTENT_NAME13, __scopeSelect);
  const [contentWrapper, setContentWrapper] = React72.useState(null);
  const [content, setContent2] = React72.useState(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContent2(node));
  const getItems = useCollection7(__scopeSelect);
  const shouldExpandOnScrollRef = React72.useRef(false);
  const shouldRepositionRef = React72.useRef(true);
  const { viewport, selectedItem, selectedItemText, focusSelectedItem } = contentContext;
  const position = React72.useCallback(() => {
    if (context.trigger && context.valueNode && contentWrapper && content && viewport && selectedItem && selectedItemText) {
      const triggerRect = context.trigger.getBoundingClientRect();
      const contentRect = content.getBoundingClientRect();
      const valueNodeRect = context.valueNode.getBoundingClientRect();
      const itemTextRect = selectedItemText.getBoundingClientRect();
      if (context.dir !== "rtl") {
        const itemTextOffset = itemTextRect.left - contentRect.left;
        const left = valueNodeRect.left - itemTextOffset;
        const leftDelta = triggerRect.left - left;
        const minContentWidth = triggerRect.width + leftDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const rightEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedLeft = clamp4(left, [
          CONTENT_MARGIN,
          // Prevents the content from going off the starting edge of the
          // viewport. It may still go off the ending edge, but this can be
          // controlled by the user since they may want to manage overflow in a
          // specific way.
          // https://github.com/radix-ui/primitives/issues/2049
          Math.max(CONTENT_MARGIN, rightEdge - contentWidth)
        ]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.left = clampedLeft + "px";
      } else {
        const itemTextOffset = contentRect.right - itemTextRect.right;
        const right = window.innerWidth - valueNodeRect.right - itemTextOffset;
        const rightDelta = window.innerWidth - triggerRect.right - right;
        const minContentWidth = triggerRect.width + rightDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const leftEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedRight = clamp4(right, [
          CONTENT_MARGIN,
          Math.max(CONTENT_MARGIN, leftEdge - contentWidth)
        ]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.right = clampedRight + "px";
      }
      const items = getItems();
      const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
      const itemsHeight = viewport.scrollHeight;
      const contentStyles = window.getComputedStyle(content);
      const contentBorderTopWidth = parseInt(contentStyles.borderTopWidth, 10);
      const contentPaddingTop = parseInt(contentStyles.paddingTop, 10);
      const contentBorderBottomWidth = parseInt(contentStyles.borderBottomWidth, 10);
      const contentPaddingBottom = parseInt(contentStyles.paddingBottom, 10);
      const fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom + contentBorderBottomWidth;
      const minContentHeight = Math.min(selectedItem.offsetHeight * 5, fullContentHeight);
      const viewportStyles = window.getComputedStyle(viewport);
      const viewportPaddingTop = parseInt(viewportStyles.paddingTop, 10);
      const viewportPaddingBottom = parseInt(viewportStyles.paddingBottom, 10);
      const topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - CONTENT_MARGIN;
      const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle;
      const selectedItemHalfHeight = selectedItem.offsetHeight / 2;
      const itemOffsetMiddle = selectedItem.offsetTop + selectedItemHalfHeight;
      const contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle;
      const itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle;
      const willAlignWithoutTopOverflow = contentTopToItemMiddle <= topEdgeToTriggerMiddle;
      if (willAlignWithoutTopOverflow) {
        const isLastItem = items.length > 0 && selectedItem === items[items.length - 1].ref.current;
        contentWrapper.style.bottom = "0px";
        const viewportOffsetBottom = content.clientHeight - viewport.offsetTop - viewport.offsetHeight;
        const clampedTriggerMiddleToBottomEdge = Math.max(
          triggerMiddleToBottomEdge,
          selectedItemHalfHeight + // viewport might have padding bottom, include it to avoid a scrollable viewport
          (isLastItem ? viewportPaddingBottom : 0) + viewportOffsetBottom + contentBorderBottomWidth
        );
        const height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge;
        contentWrapper.style.height = height + "px";
      } else {
        const isFirstItem = items.length > 0 && selectedItem === items[0].ref.current;
        contentWrapper.style.top = "0px";
        const clampedTopEdgeToTriggerMiddle = Math.max(
          topEdgeToTriggerMiddle,
          contentBorderTopWidth + viewport.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
          (isFirstItem ? viewportPaddingTop : 0) + selectedItemHalfHeight
        );
        const height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom;
        contentWrapper.style.height = height + "px";
        viewport.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport.offsetTop;
      }
      contentWrapper.style.margin = `${CONTENT_MARGIN}px 0`;
      contentWrapper.style.minHeight = minContentHeight + "px";
      contentWrapper.style.maxHeight = availableHeight + "px";
      onPlaced == null ? void 0 : onPlaced();
      requestAnimationFrame(() => shouldExpandOnScrollRef.current = true);
    }
  }, [
    getItems,
    context.trigger,
    context.valueNode,
    contentWrapper,
    content,
    viewport,
    selectedItem,
    selectedItemText,
    context.dir,
    onPlaced
  ]);
  useLayoutEffect22(() => position(), [position]);
  const [contentZIndex, setContentZIndex] = React72.useState();
  useLayoutEffect22(() => {
    if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
  }, [content]);
  const handleScrollButtonChange = React72.useCallback(
    (node) => {
      if (node && shouldRepositionRef.current === true) {
        position();
        focusSelectedItem == null ? void 0 : focusSelectedItem();
        shouldRepositionRef.current = false;
      }
    },
    [position, focusSelectedItem]
  );
  return (0, import_jsx_runtime82.jsx)(
    SelectViewportProvider,
    {
      scope: __scopeSelect,
      contentWrapper,
      shouldExpandOnScrollRef,
      onScrollButtonChange: handleScrollButtonChange,
      children: (0, import_jsx_runtime82.jsx)(
        "div",
        {
          ref: setContentWrapper,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: contentZIndex
          },
          children: (0, import_jsx_runtime82.jsx)(
            Primitive.div,
            {
              ...popperProps,
              ref: composedRefs,
              style: {
                // When we get the height of the content, it includes borders. If we were to set
                // the height without having `boxSizing: 'border-box'` it would be too big.
                boxSizing: "border-box",
                // We need to ensure the content doesn't get taller than the wrapper
                maxHeight: "100%",
                ...popperProps.style
              }
            }
          )
        }
      )
    }
  );
});
SelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME;
var POPPER_POSITION_NAME = "SelectPopperPosition";
var SelectPopperPosition = React72.forwardRef((props, forwardedRef) => {
  const {
    __scopeSelect,
    align = "start",
    collisionPadding = CONTENT_MARGIN,
    ...popperProps
  } = props;
  const popperScope = usePopperScope4(__scopeSelect);
  return (0, import_jsx_runtime82.jsx)(
    Content3,
    {
      ...popperScope,
      ...popperProps,
      ref: forwardedRef,
      align,
      collisionPadding,
      style: {
        // Ensure border-box for floating-ui calculations
        boxSizing: "border-box",
        ...popperProps.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-select-content-available-width": "var(--radix-popper-available-width)",
          "--radix-select-content-available-height": "var(--radix-popper-available-height)",
          "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
SelectPopperPosition.displayName = POPPER_POSITION_NAME;
var [SelectViewportProvider, useSelectViewportContext] = createSelectContext(CONTENT_NAME13, {});
var VIEWPORT_NAME3 = "SelectViewport";
var SelectViewport = React72.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, nonce, ...viewportProps } = props;
    const contentContext = useSelectContentContext(VIEWPORT_NAME3, __scopeSelect);
    const viewportContext = useSelectViewportContext(VIEWPORT_NAME3, __scopeSelect);
    const composedRefs = useComposedRefs(forwardedRef, contentContext.onViewportChange);
    const prevScrollTopRef = React72.useRef(0);
    return (0, import_jsx_runtime82.jsxs)(import_jsx_runtime82.Fragment, { children: [
      (0, import_jsx_runtime82.jsx)(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: `[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}`
          },
          nonce
        }
      ),
      (0, import_jsx_runtime82.jsx)(Collection7.Slot, { scope: __scopeSelect, children: (0, import_jsx_runtime82.jsx)(
        Primitive.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...viewportProps,
          ref: composedRefs,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            // Viewport should only be scrollable in the vertical direction.
            // This won't work in vertical writing modes, so we'll need to
            // revisit this if/when that is supported
            // https://developer.chrome.com/blog/vertical-form-controls
            overflow: "hidden auto",
            ...viewportProps.style
          },
          onScroll: composeEventHandlers(viewportProps.onScroll, (event) => {
            const viewport = event.currentTarget;
            const { contentWrapper, shouldExpandOnScrollRef } = viewportContext;
            if ((shouldExpandOnScrollRef == null ? void 0 : shouldExpandOnScrollRef.current) && contentWrapper) {
              const scrolledBy = Math.abs(prevScrollTopRef.current - viewport.scrollTop);
              if (scrolledBy > 0) {
                const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
                const cssMinHeight = parseFloat(contentWrapper.style.minHeight);
                const cssHeight = parseFloat(contentWrapper.style.height);
                const prevHeight = Math.max(cssMinHeight, cssHeight);
                if (prevHeight < availableHeight) {
                  const nextHeight = prevHeight + scrolledBy;
                  const clampedNextHeight = Math.min(availableHeight, nextHeight);
                  const heightDiff = nextHeight - clampedNextHeight;
                  contentWrapper.style.height = clampedNextHeight + "px";
                  if (contentWrapper.style.bottom === "0px") {
                    viewport.scrollTop = heightDiff > 0 ? heightDiff : 0;
                    contentWrapper.style.justifyContent = "flex-end";
                  }
                }
              }
            }
            prevScrollTopRef.current = viewport.scrollTop;
          })
        }
      ) })
    ] });
  }
);
SelectViewport.displayName = VIEWPORT_NAME3;
var GROUP_NAME6 = "SelectGroup";
var [SelectGroupContextProvider, useSelectGroupContext] = createSelectContext(GROUP_NAME6);
var SelectGroup = React72.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...groupProps } = props;
    const groupId = useId2();
    return (0, import_jsx_runtime82.jsx)(SelectGroupContextProvider, { scope: __scopeSelect, id: groupId, children: (0, import_jsx_runtime82.jsx)(Primitive.div, { role: "group", "aria-labelledby": groupId, ...groupProps, ref: forwardedRef }) });
  }
);
SelectGroup.displayName = GROUP_NAME6;
var LABEL_NAME6 = "SelectLabel";
var SelectLabel = React72.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...labelProps } = props;
    const groupContext = useSelectGroupContext(LABEL_NAME6, __scopeSelect);
    return (0, import_jsx_runtime82.jsx)(Primitive.div, { id: groupContext.id, ...labelProps, ref: forwardedRef });
  }
);
SelectLabel.displayName = LABEL_NAME6;
var ITEM_NAME9 = "SelectItem";
var [SelectItemContextProvider, useSelectItemContext] = createSelectContext(ITEM_NAME9);
var SelectItem = React72.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSelect,
      value,
      disabled = false,
      textValue: textValueProp,
      ...itemProps
    } = props;
    const context = useSelectContext(ITEM_NAME9, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_NAME9, __scopeSelect);
    const isSelected = context.value === value;
    const [textValue, setTextValue] = React72.useState(textValueProp ?? "");
    const [isFocused, setIsFocused] = React72.useState(false);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node) => {
        var _a6;
        return (_a6 = contentContext.itemRefCallback) == null ? void 0 : _a6.call(contentContext, node, value, disabled);
      }
    );
    const textId = useId2();
    const pointerTypeRef = React72.useRef("touch");
    const handleSelect = () => {
      if (!disabled) {
        context.onValueChange(value);
        context.onOpenChange(false);
      }
    };
    if (value === "") {
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    }
    return (0, import_jsx_runtime82.jsx)(
      SelectItemContextProvider,
      {
        scope: __scopeSelect,
        value,
        disabled,
        textId,
        isSelected,
        onItemTextChange: React72.useCallback((node) => {
          setTextValue((prevTextValue) => prevTextValue || ((node == null ? void 0 : node.textContent) ?? "").trim());
        }, []),
        children: (0, import_jsx_runtime82.jsx)(
          Collection7.ItemSlot,
          {
            scope: __scopeSelect,
            value,
            disabled,
            textValue,
            children: (0, import_jsx_runtime82.jsx)(
              Primitive.div,
              {
                role: "option",
                "aria-labelledby": textId,
                "data-highlighted": isFocused ? "" : void 0,
                "aria-selected": isSelected && isFocused,
                "data-state": isSelected ? "checked" : "unchecked",
                "aria-disabled": disabled || void 0,
                "data-disabled": disabled ? "" : void 0,
                tabIndex: disabled ? void 0 : -1,
                ...itemProps,
                ref: composedRefs,
                onFocus: composeEventHandlers(itemProps.onFocus, () => setIsFocused(true)),
                onBlur: composeEventHandlers(itemProps.onBlur, () => setIsFocused(false)),
                onClick: composeEventHandlers(itemProps.onClick, () => {
                  if (pointerTypeRef.current !== "mouse") handleSelect();
                }),
                onPointerUp: composeEventHandlers(itemProps.onPointerUp, () => {
                  if (pointerTypeRef.current === "mouse") handleSelect();
                }),
                onPointerDown: composeEventHandlers(itemProps.onPointerDown, (event) => {
                  pointerTypeRef.current = event.pointerType;
                }),
                onPointerMove: composeEventHandlers(itemProps.onPointerMove, (event) => {
                  var _a6;
                  pointerTypeRef.current = event.pointerType;
                  if (disabled) {
                    (_a6 = contentContext.onItemLeave) == null ? void 0 : _a6.call(contentContext);
                  } else if (pointerTypeRef.current === "mouse") {
                    event.currentTarget.focus({ preventScroll: true });
                  }
                }),
                onPointerLeave: composeEventHandlers(itemProps.onPointerLeave, (event) => {
                  var _a6;
                  if (event.currentTarget === document.activeElement) {
                    (_a6 = contentContext.onItemLeave) == null ? void 0 : _a6.call(contentContext);
                  }
                }),
                onKeyDown: composeEventHandlers(itemProps.onKeyDown, (event) => {
                  var _a6;
                  const isTypingAhead = ((_a6 = contentContext.searchRef) == null ? void 0 : _a6.current) !== "";
                  if (isTypingAhead && event.key === " ") return;
                  if (SELECTION_KEYS2.includes(event.key)) handleSelect();
                  if (event.key === " ") event.preventDefault();
                })
              }
            )
          }
        )
      }
    );
  }
);
SelectItem.displayName = ITEM_NAME9;
var ITEM_TEXT_NAME = "SelectItemText";
var SelectItemText = React72.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, className, style: style2, ...itemTextProps } = props;
    const context = useSelectContext(ITEM_TEXT_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_TEXT_NAME, __scopeSelect);
    const itemContext = useSelectItemContext(ITEM_TEXT_NAME, __scopeSelect);
    const nativeOptionsContext = useSelectNativeOptionsContext(ITEM_TEXT_NAME, __scopeSelect);
    const [itemTextNode, setItemTextNode] = React72.useState(null);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node) => setItemTextNode(node),
      itemContext.onItemTextChange,
      (node) => {
        var _a6;
        return (_a6 = contentContext.itemTextRefCallback) == null ? void 0 : _a6.call(contentContext, node, itemContext.value, itemContext.disabled);
      }
    );
    const textContent = itemTextNode == null ? void 0 : itemTextNode.textContent;
    const nativeOption = React72.useMemo(
      () => (0, import_jsx_runtime82.jsx)("option", { value: itemContext.value, disabled: itemContext.disabled, children: textContent }, itemContext.value),
      [itemContext.disabled, itemContext.value, textContent]
    );
    const { onNativeOptionAdd, onNativeOptionRemove } = nativeOptionsContext;
    useLayoutEffect22(() => {
      onNativeOptionAdd(nativeOption);
      return () => onNativeOptionRemove(nativeOption);
    }, [onNativeOptionAdd, onNativeOptionRemove, nativeOption]);
    return (0, import_jsx_runtime82.jsxs)(import_jsx_runtime82.Fragment, { children: [
      (0, import_jsx_runtime82.jsx)(Primitive.span, { id: itemContext.textId, ...itemTextProps, ref: composedRefs }),
      itemContext.isSelected && context.valueNode && !context.valueNodeHasChildren ? ReactDOM5.createPortal(itemTextProps.children, context.valueNode) : null
    ] });
  }
);
SelectItemText.displayName = ITEM_TEXT_NAME;
var ITEM_INDICATOR_NAME2 = "SelectItemIndicator";
var SelectItemIndicator = React72.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...itemIndicatorProps } = props;
    const itemContext = useSelectItemContext(ITEM_INDICATOR_NAME2, __scopeSelect);
    return itemContext.isSelected ? (0, import_jsx_runtime82.jsx)(Primitive.span, { "aria-hidden": true, ...itemIndicatorProps, ref: forwardedRef }) : null;
  }
);
SelectItemIndicator.displayName = ITEM_INDICATOR_NAME2;
var SCROLL_UP_BUTTON_NAME = "SelectScrollUpButton";
var SelectScrollUpButton = React72.forwardRef((props, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
  const [canScrollUp, setCanScrollUp] = React72.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect22(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll22 = function() {
        const canScrollUp2 = viewport.scrollTop > 0;
        setCanScrollUp(canScrollUp2);
      };
      var handleScroll2 = handleScroll22;
      const viewport = contentContext.viewport;
      handleScroll22();
      viewport.addEventListener("scroll", handleScroll22);
      return () => viewport.removeEventListener("scroll", handleScroll22);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollUp ? (0, import_jsx_runtime82.jsx)(
    SelectScrollButtonImpl,
    {
      ...props,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport, selectedItem } = contentContext;
        if (viewport && selectedItem) {
          viewport.scrollTop = viewport.scrollTop - selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollUpButton.displayName = SCROLL_UP_BUTTON_NAME;
var SCROLL_DOWN_BUTTON_NAME = "SelectScrollDownButton";
var SelectScrollDownButton = React72.forwardRef((props, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
  const [canScrollDown, setCanScrollDown] = React72.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect22(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll22 = function() {
        const maxScroll = viewport.scrollHeight - viewport.clientHeight;
        const canScrollDown2 = Math.ceil(viewport.scrollTop) < maxScroll;
        setCanScrollDown(canScrollDown2);
      };
      var handleScroll2 = handleScroll22;
      const viewport = contentContext.viewport;
      handleScroll22();
      viewport.addEventListener("scroll", handleScroll22);
      return () => viewport.removeEventListener("scroll", handleScroll22);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollDown ? (0, import_jsx_runtime82.jsx)(
    SelectScrollButtonImpl,
    {
      ...props,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport, selectedItem } = contentContext;
        if (viewport && selectedItem) {
          viewport.scrollTop = viewport.scrollTop + selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollDownButton.displayName = SCROLL_DOWN_BUTTON_NAME;
var SelectScrollButtonImpl = React72.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, onAutoScroll, ...scrollIndicatorProps } = props;
  const contentContext = useSelectContentContext("SelectScrollButton", __scopeSelect);
  const autoScrollTimerRef = React72.useRef(null);
  const getItems = useCollection7(__scopeSelect);
  const clearAutoScrollTimer = React72.useCallback(() => {
    if (autoScrollTimerRef.current !== null) {
      window.clearInterval(autoScrollTimerRef.current);
      autoScrollTimerRef.current = null;
    }
  }, []);
  React72.useEffect(() => {
    return () => clearAutoScrollTimer();
  }, [clearAutoScrollTimer]);
  useLayoutEffect22(() => {
    var _a6;
    const activeItem = getItems().find((item) => item.ref.current === document.activeElement);
    (_a6 = activeItem == null ? void 0 : activeItem.ref.current) == null ? void 0 : _a6.scrollIntoView({ block: "nearest" });
  }, [getItems]);
  return (0, import_jsx_runtime82.jsx)(
    Primitive.div,
    {
      "aria-hidden": true,
      ...scrollIndicatorProps,
      ref: forwardedRef,
      style: { flexShrink: 0, ...scrollIndicatorProps.style },
      onPointerDown: composeEventHandlers(scrollIndicatorProps.onPointerDown, () => {
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerMove: composeEventHandlers(scrollIndicatorProps.onPointerMove, () => {
        var _a6;
        (_a6 = contentContext.onItemLeave) == null ? void 0 : _a6.call(contentContext);
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerLeave: composeEventHandlers(scrollIndicatorProps.onPointerLeave, () => {
        clearAutoScrollTimer();
      })
    }
  );
});
var SEPARATOR_NAME5 = "SelectSeparator";
var SelectSeparator = React72.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...separatorProps } = props;
    return (0, import_jsx_runtime82.jsx)(Primitive.div, { "aria-hidden": true, ...separatorProps, ref: forwardedRef });
  }
);
SelectSeparator.displayName = SEPARATOR_NAME5;
var ARROW_NAME8 = "SelectArrow";
var SelectArrow = React72.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...arrowProps } = props;
    const popperScope = usePopperScope4(__scopeSelect);
    const context = useSelectContext(ARROW_NAME8, __scopeSelect);
    const contentContext = useSelectContentContext(ARROW_NAME8, __scopeSelect);
    return context.open && contentContext.position === "popper" ? (0, import_jsx_runtime82.jsx)(Arrow2, { ...popperScope, ...arrowProps, ref: forwardedRef }) : null;
  }
);
SelectArrow.displayName = ARROW_NAME8;
var BUBBLE_INPUT_NAME3 = "SelectBubbleInput";
var SelectBubbleInput = React72.forwardRef(
  ({ __scopeSelect, value, ...props }, forwardedRef) => {
    const ref = React72.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const prevValue = usePrevious(value);
    React72.useEffect(() => {
      const select = ref.current;
      if (!select) return;
      const selectProto = window.HTMLSelectElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        selectProto,
        "value"
      );
      const setValue = descriptor.set;
      if (prevValue !== value && setValue) {
        const event = new Event("change", { bubbles: true });
        setValue.call(select, value);
        select.dispatchEvent(event);
      }
    }, [prevValue, value]);
    return (0, import_jsx_runtime82.jsx)(
      Primitive.select,
      {
        ...props,
        style: { ...VISUALLY_HIDDEN_STYLES, ...props.style },
        ref: composedRefs,
        defaultValue: value
      }
    );
  }
);
SelectBubbleInput.displayName = BUBBLE_INPUT_NAME3;
function shouldShowPlaceholder(value) {
  return value === "" || value === void 0;
}
function useTypeaheadSearch(onSearchChange) {
  const handleSearchChange = useCallbackRef(onSearchChange);
  const searchRef = React72.useRef("");
  const timerRef = React72.useRef(0);
  const handleTypeaheadSearch = React72.useCallback(
    (key) => {
      const search = searchRef.current + key;
      handleSearchChange(search);
      (function updateSearch(value) {
        searchRef.current = value;
        window.clearTimeout(timerRef.current);
        if (value !== "") timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search);
    },
    [handleSearchChange]
  );
  const resetTypeahead = React72.useCallback(() => {
    searchRef.current = "";
    window.clearTimeout(timerRef.current);
  }, []);
  React72.useEffect(() => {
    return () => window.clearTimeout(timerRef.current);
  }, []);
  return [searchRef, handleTypeaheadSearch, resetTypeahead];
}
function findNextItem(items, search, currentItem) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentItemIndex = currentItem ? items.indexOf(currentItem) : -1;
  let wrappedItems = wrapArray4(items, Math.max(currentItemIndex, 0));
  const excludeCurrentItem = normalizedSearch.length === 1;
  if (excludeCurrentItem) wrappedItems = wrappedItems.filter((v) => v !== currentItem);
  const nextItem = wrappedItems.find(
    (item) => item.textValue.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextItem !== currentItem ? nextItem : void 0;
}
function wrapArray4(array, startIndex) {
  return array.map((_, index2) => array[(startIndex + index2) % array.length]);
}

// ../node_modules/@radix-ui/react-separator/dist/index.mjs
var React73 = __toESM(require_react(), 1);
var import_jsx_runtime83 = __toESM(require_jsx_runtime(), 1);
var NAME6 = "Separator";
var DEFAULT_ORIENTATION = "horizontal";
var ORIENTATIONS = ["horizontal", "vertical"];
var Separator3 = React73.forwardRef((props, forwardedRef) => {
  const { decorative, orientation: orientationProp = DEFAULT_ORIENTATION, ...domProps } = props;
  const orientation = isValidOrientation(orientationProp) ? orientationProp : DEFAULT_ORIENTATION;
  const ariaOrientation = orientation === "vertical" ? orientation : void 0;
  const semanticProps = decorative ? { role: "none" } : { "aria-orientation": ariaOrientation, role: "separator" };
  return (0, import_jsx_runtime83.jsx)(
    Primitive.div,
    {
      "data-orientation": orientation,
      ...semanticProps,
      ...domProps,
      ref: forwardedRef
    }
  );
});
Separator3.displayName = NAME6;
function isValidOrientation(orientation) {
  return ORIENTATIONS.includes(orientation);
}
var Root8 = Separator3;

// ../node_modules/@radix-ui/react-slider/dist/index.mjs
var dist_exports13 = {};
__export(dist_exports13, {
  Range: () => Range2,
  Root: () => Root9,
  Slider: () => Slider,
  SliderRange: () => SliderRange,
  SliderThumb: () => SliderThumb,
  SliderTrack: () => SliderTrack,
  Thumb: () => Thumb,
  Track: () => Track,
  createSliderScope: () => createSliderScope
});
var React74 = __toESM(require_react(), 1);
var import_jsx_runtime84 = __toESM(require_jsx_runtime(), 1);
var PAGE_KEYS = ["PageUp", "PageDown"];
var ARROW_KEYS3 = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
var BACK_KEYS = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
};
var SLIDER_NAME = "Slider";
var [Collection8, useCollection8, createCollectionScope8] = createCollection(SLIDER_NAME);
var [createSliderContext, createSliderScope] = createContextScope(SLIDER_NAME, [
  createCollectionScope8
]);
var [SliderProvider, useSliderContext] = createSliderContext(SLIDER_NAME);
var Slider = React74.forwardRef(
  (props, forwardedRef) => {
    const {
      name,
      min: min3 = 0,
      max: max2 = 100,
      step = 1,
      orientation = "horizontal",
      disabled = false,
      minStepsBetweenThumbs = 0,
      defaultValue = [min3],
      value,
      onValueChange = () => {
      },
      onValueCommit = () => {
      },
      inverted = false,
      form,
      ...sliderProps
    } = props;
    const thumbRefs = React74.useRef(/* @__PURE__ */ new Set());
    const valueIndexToChangeRef = React74.useRef(0);
    const isHorizontal = orientation === "horizontal";
    const SliderOrientation = isHorizontal ? SliderHorizontal : SliderVertical;
    const [values = [], setValues] = useControllableState({
      prop: value,
      defaultProp: defaultValue,
      onChange: (value2) => {
        var _a6;
        const thumbs = [...thumbRefs.current];
        (_a6 = thumbs[valueIndexToChangeRef.current]) == null ? void 0 : _a6.focus();
        onValueChange(value2);
      }
    });
    const valuesBeforeSlideStartRef = React74.useRef(values);
    function handleSlideStart(value2) {
      const closestIndex = getClosestValueIndex(values, value2);
      updateValues(value2, closestIndex);
    }
    function handleSlideMove(value2) {
      updateValues(value2, valueIndexToChangeRef.current);
    }
    function handleSlideEnd() {
      const prevValue = valuesBeforeSlideStartRef.current[valueIndexToChangeRef.current];
      const nextValue = values[valueIndexToChangeRef.current];
      const hasChanged = nextValue !== prevValue;
      if (hasChanged) onValueCommit(values);
    }
    function updateValues(value2, atIndex, { commit } = { commit: false }) {
      const decimalCount = getDecimalCount(step);
      const snapToStep = roundValue(Math.round((value2 - min3) / step) * step + min3, decimalCount);
      const nextValue = clamp4(snapToStep, [min3, max2]);
      setValues((prevValues = []) => {
        const nextValues = getNextSortedValues(prevValues, nextValue, atIndex);
        if (hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs * step)) {
          valueIndexToChangeRef.current = nextValues.indexOf(nextValue);
          const hasChanged = String(nextValues) !== String(prevValues);
          if (hasChanged && commit) onValueCommit(nextValues);
          return hasChanged ? nextValues : prevValues;
        } else {
          return prevValues;
        }
      });
    }
    return (0, import_jsx_runtime84.jsx)(
      SliderProvider,
      {
        scope: props.__scopeSlider,
        name,
        disabled,
        min: min3,
        max: max2,
        valueIndexToChangeRef,
        thumbs: thumbRefs.current,
        values,
        orientation,
        form,
        children: (0, import_jsx_runtime84.jsx)(Collection8.Provider, { scope: props.__scopeSlider, children: (0, import_jsx_runtime84.jsx)(Collection8.Slot, { scope: props.__scopeSlider, children: (0, import_jsx_runtime84.jsx)(
          SliderOrientation,
          {
            "aria-disabled": disabled,
            "data-disabled": disabled ? "" : void 0,
            ...sliderProps,
            ref: forwardedRef,
            onPointerDown: composeEventHandlers(sliderProps.onPointerDown, () => {
              if (!disabled) valuesBeforeSlideStartRef.current = values;
            }),
            min: min3,
            max: max2,
            inverted,
            onSlideStart: disabled ? void 0 : handleSlideStart,
            onSlideMove: disabled ? void 0 : handleSlideMove,
            onSlideEnd: disabled ? void 0 : handleSlideEnd,
            onHomeKeyDown: () => !disabled && updateValues(min3, 0, { commit: true }),
            onEndKeyDown: () => !disabled && updateValues(max2, values.length - 1, { commit: true }),
            onStepKeyDown: ({ event, direction: stepDirection }) => {
              if (!disabled) {
                const isPageKey = PAGE_KEYS.includes(event.key);
                const isSkipKey = isPageKey || event.shiftKey && ARROW_KEYS3.includes(event.key);
                const multiplier = isSkipKey ? 10 : 1;
                const atIndex = valueIndexToChangeRef.current;
                const value2 = values[atIndex];
                const stepInDirection = step * multiplier * stepDirection;
                updateValues(value2 + stepInDirection, atIndex, { commit: true });
              }
            }
          }
        ) }) })
      }
    );
  }
);
Slider.displayName = SLIDER_NAME;
var [SliderOrientationProvider, useSliderOrientationContext] = createSliderContext(SLIDER_NAME, {
  startEdge: "left",
  endEdge: "right",
  size: "width",
  direction: 1
});
var SliderHorizontal = React74.forwardRef(
  (props, forwardedRef) => {
    const {
      min: min3,
      max: max2,
      dir,
      inverted,
      onSlideStart,
      onSlideMove,
      onSlideEnd,
      onStepKeyDown,
      ...sliderProps
    } = props;
    const [slider, setSlider] = React74.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setSlider(node));
    const rectRef = React74.useRef(void 0);
    const direction = useDirection(dir);
    const isDirectionLTR = direction === "ltr";
    const isSlidingFromLeft = isDirectionLTR && !inverted || !isDirectionLTR && inverted;
    function getValueFromPointer(pointerPosition) {
      const rect = rectRef.current || slider.getBoundingClientRect();
      const input = [0, rect.width];
      const output = isSlidingFromLeft ? [min3, max2] : [max2, min3];
      const value = linearScale2(input, output);
      rectRef.current = rect;
      return value(pointerPosition - rect.left);
    }
    return (0, import_jsx_runtime84.jsx)(
      SliderOrientationProvider,
      {
        scope: props.__scopeSlider,
        startEdge: isSlidingFromLeft ? "left" : "right",
        endEdge: isSlidingFromLeft ? "right" : "left",
        direction: isSlidingFromLeft ? 1 : -1,
        size: "width",
        children: (0, import_jsx_runtime84.jsx)(
          SliderImpl,
          {
            dir: direction,
            "data-orientation": "horizontal",
            ...sliderProps,
            ref: composedRefs,
            style: {
              ...sliderProps.style,
              ["--radix-slider-thumb-transform"]: "translateX(-50%)"
            },
            onSlideStart: (event) => {
              const value = getValueFromPointer(event.clientX);
              onSlideStart == null ? void 0 : onSlideStart(value);
            },
            onSlideMove: (event) => {
              const value = getValueFromPointer(event.clientX);
              onSlideMove == null ? void 0 : onSlideMove(value);
            },
            onSlideEnd: () => {
              rectRef.current = void 0;
              onSlideEnd == null ? void 0 : onSlideEnd();
            },
            onStepKeyDown: (event) => {
              const slideDirection = isSlidingFromLeft ? "from-left" : "from-right";
              const isBackKey = BACK_KEYS[slideDirection].includes(event.key);
              onStepKeyDown == null ? void 0 : onStepKeyDown({ event, direction: isBackKey ? -1 : 1 });
            }
          }
        )
      }
    );
  }
);
var SliderVertical = React74.forwardRef(
  (props, forwardedRef) => {
    const {
      min: min3,
      max: max2,
      inverted,
      onSlideStart,
      onSlideMove,
      onSlideEnd,
      onStepKeyDown,
      ...sliderProps
    } = props;
    const sliderRef = React74.useRef(null);
    const ref = useComposedRefs(forwardedRef, sliderRef);
    const rectRef = React74.useRef(void 0);
    const isSlidingFromBottom = !inverted;
    function getValueFromPointer(pointerPosition) {
      const rect = rectRef.current || sliderRef.current.getBoundingClientRect();
      const input = [0, rect.height];
      const output = isSlidingFromBottom ? [max2, min3] : [min3, max2];
      const value = linearScale2(input, output);
      rectRef.current = rect;
      return value(pointerPosition - rect.top);
    }
    return (0, import_jsx_runtime84.jsx)(
      SliderOrientationProvider,
      {
        scope: props.__scopeSlider,
        startEdge: isSlidingFromBottom ? "bottom" : "top",
        endEdge: isSlidingFromBottom ? "top" : "bottom",
        size: "height",
        direction: isSlidingFromBottom ? 1 : -1,
        children: (0, import_jsx_runtime84.jsx)(
          SliderImpl,
          {
            "data-orientation": "vertical",
            ...sliderProps,
            ref,
            style: {
              ...sliderProps.style,
              ["--radix-slider-thumb-transform"]: "translateY(50%)"
            },
            onSlideStart: (event) => {
              const value = getValueFromPointer(event.clientY);
              onSlideStart == null ? void 0 : onSlideStart(value);
            },
            onSlideMove: (event) => {
              const value = getValueFromPointer(event.clientY);
              onSlideMove == null ? void 0 : onSlideMove(value);
            },
            onSlideEnd: () => {
              rectRef.current = void 0;
              onSlideEnd == null ? void 0 : onSlideEnd();
            },
            onStepKeyDown: (event) => {
              const slideDirection = isSlidingFromBottom ? "from-bottom" : "from-top";
              const isBackKey = BACK_KEYS[slideDirection].includes(event.key);
              onStepKeyDown == null ? void 0 : onStepKeyDown({ event, direction: isBackKey ? -1 : 1 });
            }
          }
        )
      }
    );
  }
);
var SliderImpl = React74.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSlider,
      onSlideStart,
      onSlideMove,
      onSlideEnd,
      onHomeKeyDown,
      onEndKeyDown,
      onStepKeyDown,
      ...sliderProps
    } = props;
    const context = useSliderContext(SLIDER_NAME, __scopeSlider);
    return (0, import_jsx_runtime84.jsx)(
      Primitive.span,
      {
        ...sliderProps,
        ref: forwardedRef,
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          if (event.key === "Home") {
            onHomeKeyDown(event);
            event.preventDefault();
          } else if (event.key === "End") {
            onEndKeyDown(event);
            event.preventDefault();
          } else if (PAGE_KEYS.concat(ARROW_KEYS3).includes(event.key)) {
            onStepKeyDown(event);
            event.preventDefault();
          }
        }),
        onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
          const target = event.target;
          target.setPointerCapture(event.pointerId);
          event.preventDefault();
          if (context.thumbs.has(target)) {
            target.focus();
          } else {
            onSlideStart(event);
          }
        }),
        onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) onSlideMove(event);
        }),
        onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) {
            target.releasePointerCapture(event.pointerId);
            onSlideEnd(event);
          }
        })
      }
    );
  }
);
var TRACK_NAME = "SliderTrack";
var SliderTrack = React74.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSlider, ...trackProps } = props;
    const context = useSliderContext(TRACK_NAME, __scopeSlider);
    return (0, import_jsx_runtime84.jsx)(
      Primitive.span,
      {
        "data-disabled": context.disabled ? "" : void 0,
        "data-orientation": context.orientation,
        ...trackProps,
        ref: forwardedRef
      }
    );
  }
);
SliderTrack.displayName = TRACK_NAME;
var RANGE_NAME = "SliderRange";
var SliderRange = React74.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSlider, ...rangeProps } = props;
    const context = useSliderContext(RANGE_NAME, __scopeSlider);
    const orientation = useSliderOrientationContext(RANGE_NAME, __scopeSlider);
    const ref = React74.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const valuesCount = context.values.length;
    const percentages = context.values.map(
      (value) => convertValueToPercentage(value, context.min, context.max)
    );
    const offsetStart = valuesCount > 1 ? Math.min(...percentages) : 0;
    const offsetEnd = 100 - Math.max(...percentages);
    return (0, import_jsx_runtime84.jsx)(
      Primitive.span,
      {
        "data-orientation": context.orientation,
        "data-disabled": context.disabled ? "" : void 0,
        ...rangeProps,
        ref: composedRefs,
        style: {
          ...props.style,
          [orientation.startEdge]: offsetStart + "%",
          [orientation.endEdge]: offsetEnd + "%"
        }
      }
    );
  }
);
SliderRange.displayName = RANGE_NAME;
var THUMB_NAME2 = "SliderThumb";
var SliderThumb = React74.forwardRef(
  (props, forwardedRef) => {
    const getItems = useCollection8(props.__scopeSlider);
    const [thumb, setThumb] = React74.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setThumb(node));
    const index2 = React74.useMemo(
      () => thumb ? getItems().findIndex((item) => item.ref.current === thumb) : -1,
      [getItems, thumb]
    );
    return (0, import_jsx_runtime84.jsx)(SliderThumbImpl, { ...props, ref: composedRefs, index: index2 });
  }
);
var SliderThumbImpl = React74.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSlider, index: index2, name, ...thumbProps } = props;
    const context = useSliderContext(THUMB_NAME2, __scopeSlider);
    const orientation = useSliderOrientationContext(THUMB_NAME2, __scopeSlider);
    const [thumb, setThumb] = React74.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setThumb(node));
    const isFormControl2 = thumb ? context.form || !!thumb.closest("form") : true;
    const size4 = useSize(thumb);
    const value = context.values[index2];
    const percent = value === void 0 ? 0 : convertValueToPercentage(value, context.min, context.max);
    const label = getLabel(index2, context.values.length);
    const orientationSize = size4 == null ? void 0 : size4[orientation.size];
    const thumbInBoundsOffset = orientationSize ? getThumbInBoundsOffset(orientationSize, percent, orientation.direction) : 0;
    React74.useEffect(() => {
      if (thumb) {
        context.thumbs.add(thumb);
        return () => {
          context.thumbs.delete(thumb);
        };
      }
    }, [thumb, context.thumbs]);
    return (0, import_jsx_runtime84.jsxs)(
      "span",
      {
        style: {
          transform: "var(--radix-slider-thumb-transform)",
          position: "absolute",
          [orientation.startEdge]: `calc(${percent}% + ${thumbInBoundsOffset}px)`
        },
        children: [
          (0, import_jsx_runtime84.jsx)(Collection8.ItemSlot, { scope: props.__scopeSlider, children: (0, import_jsx_runtime84.jsx)(
            Primitive.span,
            {
              role: "slider",
              "aria-label": props["aria-label"] || label,
              "aria-valuemin": context.min,
              "aria-valuenow": value,
              "aria-valuemax": context.max,
              "aria-orientation": context.orientation,
              "data-orientation": context.orientation,
              "data-disabled": context.disabled ? "" : void 0,
              tabIndex: context.disabled ? void 0 : 0,
              ...thumbProps,
              ref: composedRefs,
              style: value === void 0 ? { display: "none" } : props.style,
              onFocus: composeEventHandlers(props.onFocus, () => {
                context.valueIndexToChangeRef.current = index2;
              })
            }
          ) }),
          isFormControl2 && (0, import_jsx_runtime84.jsx)(
            SliderBubbleInput,
            {
              name: name ?? (context.name ? context.name + (context.values.length > 1 ? "[]" : "") : void 0),
              form: context.form,
              value
            },
            index2
          )
        ]
      }
    );
  }
);
SliderThumb.displayName = THUMB_NAME2;
var BUBBLE_INPUT_NAME4 = "RadioBubbleInput";
var SliderBubbleInput = React74.forwardRef(
  ({ __scopeSlider, value, ...props }, forwardedRef) => {
    const ref = React74.useRef(null);
    const composedRefs = useComposedRefs(ref, forwardedRef);
    const prevValue = usePrevious(value);
    React74.useEffect(() => {
      const input = ref.current;
      if (!input) return;
      const inputProto = window.HTMLInputElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(inputProto, "value");
      const setValue = descriptor.set;
      if (prevValue !== value && setValue) {
        const event = new Event("input", { bubbles: true });
        setValue.call(input, value);
        input.dispatchEvent(event);
      }
    }, [prevValue, value]);
    return (0, import_jsx_runtime84.jsx)(
      Primitive.input,
      {
        style: { display: "none" },
        ...props,
        ref: composedRefs,
        defaultValue: value
      }
    );
  }
);
SliderBubbleInput.displayName = BUBBLE_INPUT_NAME4;
function getNextSortedValues(prevValues = [], nextValue, atIndex) {
  const nextValues = [...prevValues];
  nextValues[atIndex] = nextValue;
  return nextValues.sort((a, b) => a - b);
}
function convertValueToPercentage(value, min3, max2) {
  const maxSteps = max2 - min3;
  const percentPerStep = 100 / maxSteps;
  const percentage = percentPerStep * (value - min3);
  return clamp4(percentage, [0, 100]);
}
function getLabel(index2, totalValues) {
  if (totalValues > 2) {
    return `Value ${index2 + 1} of ${totalValues}`;
  } else if (totalValues === 2) {
    return ["Minimum", "Maximum"][index2];
  } else {
    return void 0;
  }
}
function getClosestValueIndex(values, nextValue) {
  if (values.length === 1) return 0;
  const distances = values.map((value) => Math.abs(value - nextValue));
  const closestDistance = Math.min(...distances);
  return distances.indexOf(closestDistance);
}
function getThumbInBoundsOffset(width, left, direction) {
  const halfWidth = width / 2;
  const halfPercent = 50;
  const offset4 = linearScale2([0, halfPercent], [0, halfWidth]);
  return (halfWidth - offset4(left) * direction) * direction;
}
function getStepsBetweenValues(values) {
  return values.slice(0, -1).map((value, index2) => values[index2 + 1] - value);
}
function hasMinStepsBetweenValues(values, minStepsBetweenValues) {
  if (minStepsBetweenValues > 0) {
    const stepsBetweenValues = getStepsBetweenValues(values);
    const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);
    return actualMinStepsBetweenValues >= minStepsBetweenValues;
  }
  return true;
}
function linearScale2(input, output) {
  return (value) => {
    if (input[0] === input[1] || output[0] === output[1]) return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function getDecimalCount(value) {
  return (String(value).split(".")[1] || "").length;
}
function roundValue(value, decimalCount) {
  const rounder = Math.pow(10, decimalCount);
  return Math.round(value * rounder) / rounder;
}
var Root9 = Slider;
var Track = SliderTrack;
var Range2 = SliderRange;
var Thumb = SliderThumb;

// ../node_modules/@radix-ui/react-switch/dist/index.mjs
var React75 = __toESM(require_react(), 1);
var import_jsx_runtime85 = __toESM(require_jsx_runtime(), 1);
var SWITCH_NAME = "Switch";
var [createSwitchContext, createSwitchScope] = createContextScope(SWITCH_NAME);
var [SwitchProvider, useSwitchContext] = createSwitchContext(SWITCH_NAME);
var Switch = React75.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSwitch,
      name,
      checked: checkedProp,
      defaultChecked,
      required,
      disabled,
      value = "on",
      onCheckedChange,
      form,
      ...switchProps
    } = props;
    const [button, setButton] = React75.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));
    const hasConsumerStoppedPropagationRef = React75.useRef(false);
    const isFormControl2 = button ? form || !!button.closest("form") : true;
    const [checked, setChecked] = useControllableState({
      prop: checkedProp,
      defaultProp: defaultChecked ?? false,
      onChange: onCheckedChange,
      caller: SWITCH_NAME
    });
    return (0, import_jsx_runtime85.jsxs)(SwitchProvider, { scope: __scopeSwitch, checked, disabled, children: [
      (0, import_jsx_runtime85.jsx)(
        Primitive.button,
        {
          type: "button",
          role: "switch",
          "aria-checked": checked,
          "aria-required": required,
          "data-state": getState7(checked),
          "data-disabled": disabled ? "" : void 0,
          disabled,
          value,
          ...switchProps,
          ref: composedRefs,
          onClick: composeEventHandlers(props.onClick, (event) => {
            setChecked((prevChecked) => !prevChecked);
            if (isFormControl2) {
              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
              if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();
            }
          })
        }
      ),
      isFormControl2 && (0, import_jsx_runtime85.jsx)(
        SwitchBubbleInput,
        {
          control: button,
          bubbles: !hasConsumerStoppedPropagationRef.current,
          name,
          value,
          checked,
          required,
          disabled,
          form,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
Switch.displayName = SWITCH_NAME;
var THUMB_NAME3 = "SwitchThumb";
var SwitchThumb = React75.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSwitch, ...thumbProps } = props;
    const context = useSwitchContext(THUMB_NAME3, __scopeSwitch);
    return (0, import_jsx_runtime85.jsx)(
      Primitive.span,
      {
        "data-state": getState7(context.checked),
        "data-disabled": context.disabled ? "" : void 0,
        ...thumbProps,
        ref: forwardedRef
      }
    );
  }
);
SwitchThumb.displayName = THUMB_NAME3;
var BUBBLE_INPUT_NAME5 = "SwitchBubbleInput";
var SwitchBubbleInput = React75.forwardRef(
  ({
    __scopeSwitch,
    control,
    checked,
    bubbles = true,
    ...props
  }, forwardedRef) => {
    const ref = React75.useRef(null);
    const composedRefs = useComposedRefs(ref, forwardedRef);
    const prevChecked = usePrevious(checked);
    const controlSize = useSize(control);
    React75.useEffect(() => {
      const input = ref.current;
      if (!input) return;
      const inputProto = window.HTMLInputElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        inputProto,
        "checked"
      );
      const setChecked = descriptor.set;
      if (prevChecked !== checked && setChecked) {
        const event = new Event("click", { bubbles });
        setChecked.call(input, checked);
        input.dispatchEvent(event);
      }
    }, [prevChecked, checked, bubbles]);
    return (0, import_jsx_runtime85.jsx)(
      "input",
      {
        type: "checkbox",
        "aria-hidden": true,
        defaultChecked: checked,
        ...props,
        tabIndex: -1,
        ref: composedRefs,
        style: {
          ...props.style,
          ...controlSize,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        }
      }
    );
  }
);
SwitchBubbleInput.displayName = BUBBLE_INPUT_NAME5;
function getState7(checked) {
  return checked ? "checked" : "unchecked";
}

// ../node_modules/@radix-ui/react-tabs/dist/index.mjs
var React76 = __toESM(require_react(), 1);
var import_jsx_runtime86 = __toESM(require_jsx_runtime(), 1);
var TABS_NAME = "Tabs";
var [createTabsContext, createTabsScope] = createContextScope(TABS_NAME, [
  createRovingFocusGroupScope
]);
var useRovingFocusGroupScope5 = createRovingFocusGroupScope();
var [TabsProvider, useTabsContext] = createTabsContext(TABS_NAME);
var Tabs = React76.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeTabs,
      value: valueProp,
      onValueChange,
      defaultValue,
      orientation = "horizontal",
      dir,
      activationMode = "automatic",
      ...tabsProps
    } = props;
    const direction = useDirection(dir);
    const [value, setValue] = useControllableState({
      prop: valueProp,
      onChange: onValueChange,
      defaultProp: defaultValue ?? "",
      caller: TABS_NAME
    });
    return (0, import_jsx_runtime86.jsx)(
      TabsProvider,
      {
        scope: __scopeTabs,
        baseId: useId2(),
        value,
        onValueChange: setValue,
        orientation,
        dir: direction,
        activationMode,
        children: (0, import_jsx_runtime86.jsx)(
          Primitive.div,
          {
            dir: direction,
            "data-orientation": orientation,
            ...tabsProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
Tabs.displayName = TABS_NAME;
var TAB_LIST_NAME = "TabsList";
var TabsList = React76.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, loop = true, ...listProps } = props;
    const context = useTabsContext(TAB_LIST_NAME, __scopeTabs);
    const rovingFocusGroupScope = useRovingFocusGroupScope5(__scopeTabs);
    return (0, import_jsx_runtime86.jsx)(
      Root7,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        orientation: context.orientation,
        dir: context.dir,
        loop,
        children: (0, import_jsx_runtime86.jsx)(
          Primitive.div,
          {
            role: "tablist",
            "aria-orientation": context.orientation,
            ...listProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
TabsList.displayName = TAB_LIST_NAME;
var TRIGGER_NAME13 = "TabsTrigger";
var TabsTrigger = React76.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, value, disabled = false, ...triggerProps } = props;
    const context = useTabsContext(TRIGGER_NAME13, __scopeTabs);
    const rovingFocusGroupScope = useRovingFocusGroupScope5(__scopeTabs);
    const triggerId = makeTriggerId2(context.baseId, value);
    const contentId = makeContentId2(context.baseId, value);
    const isSelected = value === context.value;
    return (0, import_jsx_runtime86.jsx)(
      Item,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        focusable: !disabled,
        active: isSelected,
        children: (0, import_jsx_runtime86.jsx)(
          Primitive.button,
          {
            type: "button",
            role: "tab",
            "aria-selected": isSelected,
            "aria-controls": contentId,
            "data-state": isSelected ? "active" : "inactive",
            "data-disabled": disabled ? "" : void 0,
            disabled,
            id: triggerId,
            ...triggerProps,
            ref: forwardedRef,
            onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {
              if (!disabled && event.button === 0 && event.ctrlKey === false) {
                context.onValueChange(value);
              } else {
                event.preventDefault();
              }
            }),
            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
              if ([" ", "Enter"].includes(event.key)) context.onValueChange(value);
            }),
            onFocus: composeEventHandlers(props.onFocus, () => {
              const isAutomaticActivation = context.activationMode !== "manual";
              if (!isSelected && !disabled && isAutomaticActivation) {
                context.onValueChange(value);
              }
            })
          }
        )
      }
    );
  }
);
TabsTrigger.displayName = TRIGGER_NAME13;
var CONTENT_NAME14 = "TabsContent";
var TabsContent = React76.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, value, forceMount, children, ...contentProps } = props;
    const context = useTabsContext(CONTENT_NAME14, __scopeTabs);
    const triggerId = makeTriggerId2(context.baseId, value);
    const contentId = makeContentId2(context.baseId, value);
    const isSelected = value === context.value;
    const isMountAnimationPreventedRef = React76.useRef(isSelected);
    React76.useEffect(() => {
      const rAF = requestAnimationFrame(() => isMountAnimationPreventedRef.current = false);
      return () => cancelAnimationFrame(rAF);
    }, []);
    return (0, import_jsx_runtime86.jsx)(Presence, { present: forceMount || isSelected, children: ({ present }) => (0, import_jsx_runtime86.jsx)(
      Primitive.div,
      {
        "data-state": isSelected ? "active" : "inactive",
        "data-orientation": context.orientation,
        role: "tabpanel",
        "aria-labelledby": triggerId,
        hidden: !present,
        id: contentId,
        tabIndex: 0,
        ...contentProps,
        ref: forwardedRef,
        style: {
          ...props.style,
          animationDuration: isMountAnimationPreventedRef.current ? "0s" : void 0
        },
        children: present && children
      }
    ) });
  }
);
TabsContent.displayName = CONTENT_NAME14;
function makeTriggerId2(baseId, value) {
  return `${baseId}-trigger-${value}`;
}
function makeContentId2(baseId, value) {
  return `${baseId}-content-${value}`;
}

// ../node_modules/@radix-ui/react-toast/dist/index.mjs
var dist_exports14 = {};
__export(dist_exports14, {
  Action: () => Action,
  Close: () => Close3,
  Description: () => Description2,
  Provider: () => Provider,
  Root: () => Root26,
  Title: () => Title2,
  Toast: () => Toast,
  ToastAction: () => ToastAction,
  ToastClose: () => ToastClose,
  ToastDescription: () => ToastDescription,
  ToastProvider: () => ToastProvider,
  ToastTitle: () => ToastTitle,
  ToastViewport: () => ToastViewport,
  Viewport: () => Viewport,
  createToastScope: () => createToastScope
});
var React77 = __toESM(require_react(), 1);
var ReactDOM6 = __toESM(require_react_dom(), 1);
var import_jsx_runtime87 = __toESM(require_jsx_runtime(), 1);
var PROVIDER_NAME = "ToastProvider";
var [Collection9, useCollection9, createCollectionScope9] = createCollection("Toast");
var [createToastContext, createToastScope] = createContextScope("Toast", [createCollectionScope9]);
var [ToastProviderProvider, useToastProviderContext] = createToastContext(PROVIDER_NAME);
var ToastProvider = (props) => {
  const {
    __scopeToast,
    label = "Notification",
    duration = 5e3,
    swipeDirection = "right",
    swipeThreshold = 50,
    children
  } = props;
  const [viewport, setViewport] = React77.useState(null);
  const [toastCount, setToastCount] = React77.useState(0);
  const isFocusedToastEscapeKeyDownRef = React77.useRef(false);
  const isClosePausedRef = React77.useRef(false);
  if (!label.trim()) {
    console.error(
      `Invalid prop \`label\` supplied to \`${PROVIDER_NAME}\`. Expected non-empty \`string\`.`
    );
  }
  return (0, import_jsx_runtime87.jsx)(Collection9.Provider, { scope: __scopeToast, children: (0, import_jsx_runtime87.jsx)(
    ToastProviderProvider,
    {
      scope: __scopeToast,
      label,
      duration,
      swipeDirection,
      swipeThreshold,
      toastCount,
      viewport,
      onViewportChange: setViewport,
      onToastAdd: React77.useCallback(() => setToastCount((prevCount) => prevCount + 1), []),
      onToastRemove: React77.useCallback(() => setToastCount((prevCount) => prevCount - 1), []),
      isFocusedToastEscapeKeyDownRef,
      isClosePausedRef,
      children
    }
  ) });
};
ToastProvider.displayName = PROVIDER_NAME;
var VIEWPORT_NAME4 = "ToastViewport";
var VIEWPORT_DEFAULT_HOTKEY = ["F8"];
var VIEWPORT_PAUSE = "toast.viewportPause";
var VIEWPORT_RESUME = "toast.viewportResume";
var ToastViewport = React77.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeToast,
      hotkey = VIEWPORT_DEFAULT_HOTKEY,
      label = "Notifications ({hotkey})",
      ...viewportProps
    } = props;
    const context = useToastProviderContext(VIEWPORT_NAME4, __scopeToast);
    const getItems = useCollection9(__scopeToast);
    const wrapperRef = React77.useRef(null);
    const headFocusProxyRef = React77.useRef(null);
    const tailFocusProxyRef = React77.useRef(null);
    const ref = React77.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);
    const hotkeyLabel = hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
    const hasToasts = context.toastCount > 0;
    React77.useEffect(() => {
      const handleKeyDown2 = (event) => {
        var _a6;
        const isHotkeyPressed = hotkey.length !== 0 && hotkey.every((key) => event[key] || event.code === key);
        if (isHotkeyPressed) (_a6 = ref.current) == null ? void 0 : _a6.focus();
      };
      document.addEventListener("keydown", handleKeyDown2);
      return () => document.removeEventListener("keydown", handleKeyDown2);
    }, [hotkey]);
    React77.useEffect(() => {
      const wrapper = wrapperRef.current;
      const viewport = ref.current;
      if (hasToasts && wrapper && viewport) {
        const handlePause = () => {
          if (!context.isClosePausedRef.current) {
            const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);
            viewport.dispatchEvent(pauseEvent);
            context.isClosePausedRef.current = true;
          }
        };
        const handleResume = () => {
          if (context.isClosePausedRef.current) {
            const resumeEvent = new CustomEvent(VIEWPORT_RESUME);
            viewport.dispatchEvent(resumeEvent);
            context.isClosePausedRef.current = false;
          }
        };
        const handleFocusOutResume = (event) => {
          const isFocusMovingOutside = !wrapper.contains(event.relatedTarget);
          if (isFocusMovingOutside) handleResume();
        };
        const handlePointerLeaveResume = () => {
          const isFocusInside = wrapper.contains(document.activeElement);
          if (!isFocusInside) handleResume();
        };
        wrapper.addEventListener("focusin", handlePause);
        wrapper.addEventListener("focusout", handleFocusOutResume);
        wrapper.addEventListener("pointermove", handlePause);
        wrapper.addEventListener("pointerleave", handlePointerLeaveResume);
        window.addEventListener("blur", handlePause);
        window.addEventListener("focus", handleResume);
        return () => {
          wrapper.removeEventListener("focusin", handlePause);
          wrapper.removeEventListener("focusout", handleFocusOutResume);
          wrapper.removeEventListener("pointermove", handlePause);
          wrapper.removeEventListener("pointerleave", handlePointerLeaveResume);
          window.removeEventListener("blur", handlePause);
          window.removeEventListener("focus", handleResume);
        };
      }
    }, [hasToasts, context.isClosePausedRef]);
    const getSortedTabbableCandidates = React77.useCallback(
      ({ tabbingDirection }) => {
        const toastItems = getItems();
        const tabbableCandidates = toastItems.map((toastItem) => {
          const toastNode = toastItem.ref.current;
          const toastTabbableCandidates = [toastNode, ...getTabbableCandidates3(toastNode)];
          return tabbingDirection === "forwards" ? toastTabbableCandidates : toastTabbableCandidates.reverse();
        });
        return (tabbingDirection === "forwards" ? tabbableCandidates.reverse() : tabbableCandidates).flat();
      },
      [getItems]
    );
    React77.useEffect(() => {
      const viewport = ref.current;
      if (viewport) {
        const handleKeyDown2 = (event) => {
          var _a6, _b3, _c;
          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
          const isTabKey = event.key === "Tab" && !isMetaKey;
          if (isTabKey) {
            const focusedElement = document.activeElement;
            const isTabbingBackwards = event.shiftKey;
            const targetIsViewport = event.target === viewport;
            if (targetIsViewport && isTabbingBackwards) {
              (_a6 = headFocusProxyRef.current) == null ? void 0 : _a6.focus();
              return;
            }
            const tabbingDirection = isTabbingBackwards ? "backwards" : "forwards";
            const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection });
            const index2 = sortedCandidates.findIndex((candidate) => candidate === focusedElement);
            if (focusFirst5(sortedCandidates.slice(index2 + 1))) {
              event.preventDefault();
            } else {
              isTabbingBackwards ? (_b3 = headFocusProxyRef.current) == null ? void 0 : _b3.focus() : (_c = tailFocusProxyRef.current) == null ? void 0 : _c.focus();
            }
          }
        };
        viewport.addEventListener("keydown", handleKeyDown2);
        return () => viewport.removeEventListener("keydown", handleKeyDown2);
      }
    }, [getItems, getSortedTabbableCandidates]);
    return (0, import_jsx_runtime87.jsxs)(
      Branch,
      {
        ref: wrapperRef,
        role: "region",
        "aria-label": label.replace("{hotkey}", hotkeyLabel),
        tabIndex: -1,
        style: { pointerEvents: hasToasts ? void 0 : "none" },
        children: [
          hasToasts && (0, import_jsx_runtime87.jsx)(
            FocusProxy,
            {
              ref: headFocusProxyRef,
              onFocusFromOutsideViewport: () => {
                const tabbableCandidates = getSortedTabbableCandidates({
                  tabbingDirection: "forwards"
                });
                focusFirst5(tabbableCandidates);
              }
            }
          ),
          (0, import_jsx_runtime87.jsx)(Collection9.Slot, { scope: __scopeToast, children: (0, import_jsx_runtime87.jsx)(Primitive.ol, { tabIndex: -1, ...viewportProps, ref: composedRefs }) }),
          hasToasts && (0, import_jsx_runtime87.jsx)(
            FocusProxy,
            {
              ref: tailFocusProxyRef,
              onFocusFromOutsideViewport: () => {
                const tabbableCandidates = getSortedTabbableCandidates({
                  tabbingDirection: "backwards"
                });
                focusFirst5(tabbableCandidates);
              }
            }
          )
        ]
      }
    );
  }
);
ToastViewport.displayName = VIEWPORT_NAME4;
var FOCUS_PROXY_NAME = "ToastFocusProxy";
var FocusProxy = React77.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, onFocusFromOutsideViewport, ...proxyProps } = props;
    const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);
    return (0, import_jsx_runtime87.jsx)(
      VisuallyHidden,
      {
        tabIndex: 0,
        ...proxyProps,
        ref: forwardedRef,
        style: { position: "fixed" },
        onFocus: (event) => {
          var _a6;
          const prevFocusedElement = event.relatedTarget;
          const isFocusFromOutsideViewport = !((_a6 = context.viewport) == null ? void 0 : _a6.contains(prevFocusedElement));
          if (isFocusFromOutsideViewport) onFocusFromOutsideViewport();
        }
      }
    );
  }
);
FocusProxy.displayName = FOCUS_PROXY_NAME;
var TOAST_NAME = "Toast";
var TOAST_SWIPE_START = "toast.swipeStart";
var TOAST_SWIPE_MOVE = "toast.swipeMove";
var TOAST_SWIPE_CANCEL = "toast.swipeCancel";
var TOAST_SWIPE_END = "toast.swipeEnd";
var Toast = React77.forwardRef(
  (props, forwardedRef) => {
    const { forceMount, open: openProp, defaultOpen, onOpenChange, ...toastProps } = props;
    const [open, setOpen] = useControllableState({
      prop: openProp,
      defaultProp: defaultOpen ?? true,
      onChange: onOpenChange,
      caller: TOAST_NAME
    });
    return (0, import_jsx_runtime87.jsx)(Presence, { present: forceMount || open, children: (0, import_jsx_runtime87.jsx)(
      ToastImpl,
      {
        open,
        ...toastProps,
        ref: forwardedRef,
        onClose: () => setOpen(false),
        onPause: useCallbackRef(props.onPause),
        onResume: useCallbackRef(props.onResume),
        onSwipeStart: composeEventHandlers(props.onSwipeStart, (event) => {
          event.currentTarget.setAttribute("data-swipe", "start");
        }),
        onSwipeMove: composeEventHandlers(props.onSwipeMove, (event) => {
          const { x, y } = event.detail.delta;
          event.currentTarget.setAttribute("data-swipe", "move");
          event.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${x}px`);
          event.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${y}px`);
        }),
        onSwipeCancel: composeEventHandlers(props.onSwipeCancel, (event) => {
          event.currentTarget.setAttribute("data-swipe", "cancel");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-end-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
        }),
        onSwipeEnd: composeEventHandlers(props.onSwipeEnd, (event) => {
          const { x, y } = event.detail.delta;
          event.currentTarget.setAttribute("data-swipe", "end");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
          event.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${x}px`);
          event.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${y}px`);
          setOpen(false);
        })
      }
    ) });
  }
);
Toast.displayName = TOAST_NAME;
var [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {
  onClose() {
  }
});
var ToastImpl = React77.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeToast,
      type = "foreground",
      duration: durationProp,
      open,
      onClose,
      onEscapeKeyDown,
      onPause,
      onResume,
      onSwipeStart,
      onSwipeMove,
      onSwipeCancel,
      onSwipeEnd,
      ...toastProps
    } = props;
    const context = useToastProviderContext(TOAST_NAME, __scopeToast);
    const [node, setNode2] = React77.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode2(node2));
    const pointerStartRef = React77.useRef(null);
    const swipeDeltaRef = React77.useRef(null);
    const duration = durationProp || context.duration;
    const closeTimerStartTimeRef = React77.useRef(0);
    const closeTimerRemainingTimeRef = React77.useRef(duration);
    const closeTimerRef = React77.useRef(0);
    const { onToastAdd, onToastRemove } = context;
    const handleClose = useCallbackRef(() => {
      var _a6;
      const isFocusInToast = node == null ? void 0 : node.contains(document.activeElement);
      if (isFocusInToast) (_a6 = context.viewport) == null ? void 0 : _a6.focus();
      onClose();
    });
    const startTimer = React77.useCallback(
      (duration2) => {
        if (!duration2 || duration2 === Infinity) return;
        window.clearTimeout(closeTimerRef.current);
        closeTimerStartTimeRef.current = (/* @__PURE__ */ new Date()).getTime();
        closeTimerRef.current = window.setTimeout(handleClose, duration2);
      },
      [handleClose]
    );
    React77.useEffect(() => {
      const viewport = context.viewport;
      if (viewport) {
        const handleResume = () => {
          startTimer(closeTimerRemainingTimeRef.current);
          onResume == null ? void 0 : onResume();
        };
        const handlePause = () => {
          const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef.current;
          closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;
          window.clearTimeout(closeTimerRef.current);
          onPause == null ? void 0 : onPause();
        };
        viewport.addEventListener(VIEWPORT_PAUSE, handlePause);
        viewport.addEventListener(VIEWPORT_RESUME, handleResume);
        return () => {
          viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);
          viewport.removeEventListener(VIEWPORT_RESUME, handleResume);
        };
      }
    }, [context.viewport, duration, onPause, onResume, startTimer]);
    React77.useEffect(() => {
      if (open && !context.isClosePausedRef.current) startTimer(duration);
    }, [open, duration, context.isClosePausedRef, startTimer]);
    React77.useEffect(() => {
      onToastAdd();
      return () => onToastRemove();
    }, [onToastAdd, onToastRemove]);
    const announceTextContent = React77.useMemo(() => {
      return node ? getAnnounceTextContent(node) : null;
    }, [node]);
    if (!context.viewport) return null;
    return (0, import_jsx_runtime87.jsxs)(import_jsx_runtime87.Fragment, { children: [
      announceTextContent && (0, import_jsx_runtime87.jsx)(
        ToastAnnounce,
        {
          __scopeToast,
          role: "status",
          "aria-live": type === "foreground" ? "assertive" : "polite",
          children: announceTextContent
        }
      ),
      (0, import_jsx_runtime87.jsx)(ToastInteractiveProvider, { scope: __scopeToast, onClose: handleClose, children: ReactDOM6.createPortal(
        (0, import_jsx_runtime87.jsx)(Collection9.ItemSlot, { scope: __scopeToast, children: (0, import_jsx_runtime87.jsx)(
          Root4,
          {
            asChild: true,
            onEscapeKeyDown: composeEventHandlers(onEscapeKeyDown, () => {
              if (!context.isFocusedToastEscapeKeyDownRef.current) handleClose();
              context.isFocusedToastEscapeKeyDownRef.current = false;
            }),
            children: (0, import_jsx_runtime87.jsx)(
              Primitive.li,
              {
                tabIndex: 0,
                "data-state": open ? "open" : "closed",
                "data-swipe-direction": context.swipeDirection,
                ...toastProps,
                ref: composedRefs,
                style: { userSelect: "none", touchAction: "none", ...props.style },
                onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
                  if (event.key !== "Escape") return;
                  onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event.nativeEvent);
                  if (!event.nativeEvent.defaultPrevented) {
                    context.isFocusedToastEscapeKeyDownRef.current = true;
                    handleClose();
                  }
                }),
                onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
                  if (event.button !== 0) return;
                  pointerStartRef.current = { x: event.clientX, y: event.clientY };
                }),
                onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
                  if (!pointerStartRef.current) return;
                  const x = event.clientX - pointerStartRef.current.x;
                  const y = event.clientY - pointerStartRef.current.y;
                  const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);
                  const isHorizontalSwipe = ["left", "right"].includes(context.swipeDirection);
                  const clamp5 = ["left", "up"].includes(context.swipeDirection) ? Math.min : Math.max;
                  const clampedX = isHorizontalSwipe ? clamp5(0, x) : 0;
                  const clampedY = !isHorizontalSwipe ? clamp5(0, y) : 0;
                  const moveStartBuffer = event.pointerType === "touch" ? 10 : 2;
                  const delta = { x: clampedX, y: clampedY };
                  const eventDetail = { originalEvent: event, delta };
                  if (hasSwipeMoveStarted) {
                    swipeDeltaRef.current = delta;
                    handleAndDispatchCustomEvent2(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {
                      discrete: false
                    });
                  } else if (isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {
                    swipeDeltaRef.current = delta;
                    handleAndDispatchCustomEvent2(TOAST_SWIPE_START, onSwipeStart, eventDetail, {
                      discrete: false
                    });
                    event.target.setPointerCapture(event.pointerId);
                  } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) {
                    pointerStartRef.current = null;
                  }
                }),
                onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
                  const delta = swipeDeltaRef.current;
                  const target = event.target;
                  if (target.hasPointerCapture(event.pointerId)) {
                    target.releasePointerCapture(event.pointerId);
                  }
                  swipeDeltaRef.current = null;
                  pointerStartRef.current = null;
                  if (delta) {
                    const toast = event.currentTarget;
                    const eventDetail = { originalEvent: event, delta };
                    if (isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)) {
                      handleAndDispatchCustomEvent2(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {
                        discrete: true
                      });
                    } else {
                      handleAndDispatchCustomEvent2(
                        TOAST_SWIPE_CANCEL,
                        onSwipeCancel,
                        eventDetail,
                        {
                          discrete: true
                        }
                      );
                    }
                    toast.addEventListener("click", (event2) => event2.preventDefault(), {
                      once: true
                    });
                  }
                })
              }
            )
          }
        ) }),
        context.viewport
      ) })
    ] });
  }
);
var ToastAnnounce = (props) => {
  const { __scopeToast, children, ...announceProps } = props;
  const context = useToastProviderContext(TOAST_NAME, __scopeToast);
  const [renderAnnounceText, setRenderAnnounceText] = React77.useState(false);
  const [isAnnounced, setIsAnnounced] = React77.useState(false);
  useNextFrame(() => setRenderAnnounceText(true));
  React77.useEffect(() => {
    const timer = window.setTimeout(() => setIsAnnounced(true), 1e3);
    return () => window.clearTimeout(timer);
  }, []);
  return isAnnounced ? null : (0, import_jsx_runtime87.jsx)(Portal, { asChild: true, children: (0, import_jsx_runtime87.jsx)(VisuallyHidden, { ...announceProps, children: renderAnnounceText && (0, import_jsx_runtime87.jsxs)(import_jsx_runtime87.Fragment, { children: [
    context.label,
    " ",
    children
  ] }) }) });
};
var TITLE_NAME3 = "ToastTitle";
var ToastTitle = React77.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...titleProps } = props;
    return (0, import_jsx_runtime87.jsx)(Primitive.div, { ...titleProps, ref: forwardedRef });
  }
);
ToastTitle.displayName = TITLE_NAME3;
var DESCRIPTION_NAME3 = "ToastDescription";
var ToastDescription = React77.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...descriptionProps } = props;
    return (0, import_jsx_runtime87.jsx)(Primitive.div, { ...descriptionProps, ref: forwardedRef });
  }
);
ToastDescription.displayName = DESCRIPTION_NAME3;
var ACTION_NAME2 = "ToastAction";
var ToastAction = React77.forwardRef(
  (props, forwardedRef) => {
    const { altText, ...actionProps } = props;
    if (!altText.trim()) {
      console.error(
        `Invalid prop \`altText\` supplied to \`${ACTION_NAME2}\`. Expected non-empty \`string\`.`
      );
      return null;
    }
    return (0, import_jsx_runtime87.jsx)(ToastAnnounceExclude, { altText, asChild: true, children: (0, import_jsx_runtime87.jsx)(ToastClose, { ...actionProps, ref: forwardedRef }) });
  }
);
ToastAction.displayName = ACTION_NAME2;
var CLOSE_NAME3 = "ToastClose";
var ToastClose = React77.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...closeProps } = props;
    const interactiveContext = useToastInteractiveContext(CLOSE_NAME3, __scopeToast);
    return (0, import_jsx_runtime87.jsx)(ToastAnnounceExclude, { asChild: true, children: (0, import_jsx_runtime87.jsx)(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, interactiveContext.onClose)
      }
    ) });
  }
);
ToastClose.displayName = CLOSE_NAME3;
var ToastAnnounceExclude = React77.forwardRef((props, forwardedRef) => {
  const { __scopeToast, altText, ...announceExcludeProps } = props;
  return (0, import_jsx_runtime87.jsx)(
    Primitive.div,
    {
      "data-radix-toast-announce-exclude": "",
      "data-radix-toast-announce-alt": altText || void 0,
      ...announceExcludeProps,
      ref: forwardedRef
    }
  );
});
function getAnnounceTextContent(container) {
  const textContent = [];
  const childNodes = Array.from(container.childNodes);
  childNodes.forEach((node) => {
    if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);
    if (isHTMLElement3(node)) {
      const isHidden2 = node.ariaHidden || node.hidden || node.style.display === "none";
      const isExcluded = node.dataset.radixToastAnnounceExclude === "";
      if (!isHidden2) {
        if (isExcluded) {
          const altText = node.dataset.radixToastAnnounceAlt;
          if (altText) textContent.push(altText);
        } else {
          textContent.push(...getAnnounceTextContent(node));
        }
      }
    }
  });
  return textContent;
}
function handleAndDispatchCustomEvent2(name, handler, detail, { discrete }) {
  const currentTarget = detail.originalEvent.currentTarget;
  const event = new CustomEvent(name, { bubbles: true, cancelable: true, detail });
  if (handler) currentTarget.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(currentTarget, event);
  } else {
    currentTarget.dispatchEvent(event);
  }
}
var isDeltaInDirection = (delta, direction, threshold = 0) => {
  const deltaX = Math.abs(delta.x);
  const deltaY = Math.abs(delta.y);
  const isDeltaX = deltaX > deltaY;
  if (direction === "left" || direction === "right") {
    return isDeltaX && deltaX > threshold;
  } else {
    return !isDeltaX && deltaY > threshold;
  }
};
function useNextFrame(callback = () => {
}) {
  const fn = useCallbackRef(callback);
  useLayoutEffect22(() => {
    let raf1 = 0;
    let raf2 = 0;
    raf1 = window.requestAnimationFrame(() => raf2 = window.requestAnimationFrame(fn));
    return () => {
      window.cancelAnimationFrame(raf1);
      window.cancelAnimationFrame(raf2);
    };
  }, [fn]);
}
function isHTMLElement3(node) {
  return node.nodeType === node.ELEMENT_NODE;
}
function getTabbableCandidates3(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function focusFirst5(candidates) {
  const previouslyFocusedElement = document.activeElement;
  return candidates.some((candidate) => {
    if (candidate === previouslyFocusedElement) return true;
    candidate.focus();
    return document.activeElement !== previouslyFocusedElement;
  });
}
var Provider = ToastProvider;
var Viewport = ToastViewport;
var Root26 = Toast;
var Title2 = ToastTitle;
var Description2 = ToastDescription;
var Action = ToastAction;
var Close3 = ToastClose;

// ../node_modules/@radix-ui/react-toggle/dist/index.mjs
var React78 = __toESM(require_react(), 1);
var import_jsx_runtime88 = __toESM(require_jsx_runtime(), 1);
var NAME7 = "Toggle";
var Toggle = React78.forwardRef((props, forwardedRef) => {
  const { pressed: pressedProp, defaultPressed, onPressedChange, ...buttonProps } = props;
  const [pressed, setPressed] = useControllableState({
    prop: pressedProp,
    onChange: onPressedChange,
    defaultProp: defaultPressed ?? false,
    caller: NAME7
  });
  return (0, import_jsx_runtime88.jsx)(
    Primitive.button,
    {
      type: "button",
      "aria-pressed": pressed,
      "data-state": pressed ? "on" : "off",
      "data-disabled": props.disabled ? "" : void 0,
      ...buttonProps,
      ref: forwardedRef,
      onClick: composeEventHandlers(props.onClick, () => {
        if (!props.disabled) {
          setPressed(!pressed);
        }
      })
    }
  );
});
Toggle.displayName = NAME7;

// ../node_modules/@radix-ui/react-toggle-group/dist/index.mjs
var import_react62 = __toESM(require_react(), 1);
var import_jsx_runtime89 = __toESM(require_jsx_runtime(), 1);
var TOGGLE_GROUP_NAME = "ToggleGroup";
var [createToggleGroupContext, createToggleGroupScope] = createContextScope(TOGGLE_GROUP_NAME, [
  createRovingFocusGroupScope
]);
var useRovingFocusGroupScope6 = createRovingFocusGroupScope();
var ToggleGroup = import_react62.default.forwardRef((props, forwardedRef) => {
  const { type, ...toggleGroupProps } = props;
  if (type === "single") {
    const singleProps = toggleGroupProps;
    return (0, import_jsx_runtime89.jsx)(ToggleGroupImplSingle, { ...singleProps, ref: forwardedRef });
  }
  if (type === "multiple") {
    const multipleProps = toggleGroupProps;
    return (0, import_jsx_runtime89.jsx)(ToggleGroupImplMultiple, { ...multipleProps, ref: forwardedRef });
  }
  throw new Error(`Missing prop \`type\` expected on \`${TOGGLE_GROUP_NAME}\``);
});
ToggleGroup.displayName = TOGGLE_GROUP_NAME;
var [ToggleGroupValueProvider, useToggleGroupValueContext] = createToggleGroupContext(TOGGLE_GROUP_NAME);
var ToggleGroupImplSingle = import_react62.default.forwardRef((props, forwardedRef) => {
  const {
    value: valueProp,
    defaultValue,
    onValueChange = () => {
    },
    ...toggleGroupSingleProps
  } = props;
  const [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue ?? "",
    onChange: onValueChange,
    caller: TOGGLE_GROUP_NAME
  });
  return (0, import_jsx_runtime89.jsx)(
    ToggleGroupValueProvider,
    {
      scope: props.__scopeToggleGroup,
      type: "single",
      value: import_react62.default.useMemo(() => value ? [value] : [], [value]),
      onItemActivate: setValue,
      onItemDeactivate: import_react62.default.useCallback(() => setValue(""), [setValue]),
      children: (0, import_jsx_runtime89.jsx)(ToggleGroupImpl, { ...toggleGroupSingleProps, ref: forwardedRef })
    }
  );
});
var ToggleGroupImplMultiple = import_react62.default.forwardRef((props, forwardedRef) => {
  const {
    value: valueProp,
    defaultValue,
    onValueChange = () => {
    },
    ...toggleGroupMultipleProps
  } = props;
  const [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue ?? [],
    onChange: onValueChange,
    caller: TOGGLE_GROUP_NAME
  });
  const handleButtonActivate = import_react62.default.useCallback(
    (itemValue) => setValue((prevValue = []) => [...prevValue, itemValue]),
    [setValue]
  );
  const handleButtonDeactivate = import_react62.default.useCallback(
    (itemValue) => setValue((prevValue = []) => prevValue.filter((value2) => value2 !== itemValue)),
    [setValue]
  );
  return (0, import_jsx_runtime89.jsx)(
    ToggleGroupValueProvider,
    {
      scope: props.__scopeToggleGroup,
      type: "multiple",
      value,
      onItemActivate: handleButtonActivate,
      onItemDeactivate: handleButtonDeactivate,
      children: (0, import_jsx_runtime89.jsx)(ToggleGroupImpl, { ...toggleGroupMultipleProps, ref: forwardedRef })
    }
  );
});
ToggleGroup.displayName = TOGGLE_GROUP_NAME;
var [ToggleGroupContext, useToggleGroupContext] = createToggleGroupContext(TOGGLE_GROUP_NAME);
var ToggleGroupImpl = import_react62.default.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeToggleGroup,
      disabled = false,
      rovingFocus = true,
      orientation,
      dir,
      loop = true,
      ...toggleGroupProps
    } = props;
    const rovingFocusGroupScope = useRovingFocusGroupScope6(__scopeToggleGroup);
    const direction = useDirection(dir);
    const commonProps = { role: "group", dir: direction, ...toggleGroupProps };
    return (0, import_jsx_runtime89.jsx)(ToggleGroupContext, { scope: __scopeToggleGroup, rovingFocus, disabled, children: rovingFocus ? (0, import_jsx_runtime89.jsx)(
      Root7,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        orientation,
        dir: direction,
        loop,
        children: (0, import_jsx_runtime89.jsx)(Primitive.div, { ...commonProps, ref: forwardedRef })
      }
    ) : (0, import_jsx_runtime89.jsx)(Primitive.div, { ...commonProps, ref: forwardedRef }) });
  }
);
var ITEM_NAME10 = "ToggleGroupItem";
var ToggleGroupItem = import_react62.default.forwardRef(
  (props, forwardedRef) => {
    const valueContext = useToggleGroupValueContext(ITEM_NAME10, props.__scopeToggleGroup);
    const context = useToggleGroupContext(ITEM_NAME10, props.__scopeToggleGroup);
    const rovingFocusGroupScope = useRovingFocusGroupScope6(props.__scopeToggleGroup);
    const pressed = valueContext.value.includes(props.value);
    const disabled = context.disabled || props.disabled;
    const commonProps = { ...props, pressed, disabled };
    const ref = import_react62.default.useRef(null);
    return context.rovingFocus ? (0, import_jsx_runtime89.jsx)(
      Item,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        focusable: !disabled,
        active: pressed,
        ref,
        children: (0, import_jsx_runtime89.jsx)(ToggleGroupItemImpl, { ...commonProps, ref: forwardedRef })
      }
    ) : (0, import_jsx_runtime89.jsx)(ToggleGroupItemImpl, { ...commonProps, ref: forwardedRef });
  }
);
ToggleGroupItem.displayName = ITEM_NAME10;
var ToggleGroupItemImpl = import_react62.default.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToggleGroup, value, ...itemProps } = props;
    const valueContext = useToggleGroupValueContext(ITEM_NAME10, __scopeToggleGroup);
    const singleProps = { role: "radio", "aria-checked": props.pressed, "aria-pressed": void 0 };
    const typeProps = valueContext.type === "single" ? singleProps : void 0;
    return (0, import_jsx_runtime89.jsx)(
      Toggle,
      {
        ...typeProps,
        ...itemProps,
        ref: forwardedRef,
        onPressedChange: (pressed) => {
          if (pressed) {
            valueContext.onItemActivate(value);
          } else {
            valueContext.onItemDeactivate(value);
          }
        }
      }
    );
  }
);
var Root27 = ToggleGroup;
var Item24 = ToggleGroupItem;

// ../node_modules/@radix-ui/react-toolbar/dist/index.mjs
var dist_exports16 = {};
__export(dist_exports16, {
  Button: () => Button,
  Link: () => Link,
  Root: () => Root42,
  Separator: () => Separator4,
  ToggleGroup: () => ToggleGroup2,
  ToggleItem: () => ToggleItem,
  Toolbar: () => Toolbar,
  ToolbarButton: () => ToolbarButton,
  ToolbarLink: () => ToolbarLink,
  ToolbarSeparator: () => ToolbarSeparator,
  ToolbarToggleGroup: () => ToolbarToggleGroup,
  ToolbarToggleItem: () => ToolbarToggleItem,
  createToolbarScope: () => createToolbarScope
});
var React80 = __toESM(require_react(), 1);
var import_jsx_runtime90 = __toESM(require_jsx_runtime(), 1);
var TOOLBAR_NAME = "Toolbar";
var [createToolbarContext, createToolbarScope] = createContextScope(TOOLBAR_NAME, [
  createRovingFocusGroupScope,
  createToggleGroupScope
]);
var useRovingFocusGroupScope7 = createRovingFocusGroupScope();
var useToggleGroupScope = createToggleGroupScope();
var [ToolbarProvider, useToolbarContext] = createToolbarContext(TOOLBAR_NAME);
var Toolbar = React80.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToolbar, orientation = "horizontal", dir, loop = true, ...toolbarProps } = props;
    const rovingFocusGroupScope = useRovingFocusGroupScope7(__scopeToolbar);
    const direction = useDirection(dir);
    return (0, import_jsx_runtime90.jsx)(ToolbarProvider, { scope: __scopeToolbar, orientation, dir: direction, children: (0, import_jsx_runtime90.jsx)(
      Root7,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        orientation,
        dir: direction,
        loop,
        children: (0, import_jsx_runtime90.jsx)(
          Primitive.div,
          {
            role: "toolbar",
            "aria-orientation": orientation,
            dir: direction,
            ...toolbarProps,
            ref: forwardedRef
          }
        )
      }
    ) });
  }
);
Toolbar.displayName = TOOLBAR_NAME;
var SEPARATOR_NAME6 = "ToolbarSeparator";
var ToolbarSeparator = React80.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToolbar, ...separatorProps } = props;
    const context = useToolbarContext(SEPARATOR_NAME6, __scopeToolbar);
    return (0, import_jsx_runtime90.jsx)(
      Root8,
      {
        orientation: context.orientation === "horizontal" ? "vertical" : "horizontal",
        ...separatorProps,
        ref: forwardedRef
      }
    );
  }
);
ToolbarSeparator.displayName = SEPARATOR_NAME6;
var BUTTON_NAME = "ToolbarButton";
var ToolbarButton = React80.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToolbar, ...buttonProps } = props;
    const rovingFocusGroupScope = useRovingFocusGroupScope7(__scopeToolbar);
    return (0, import_jsx_runtime90.jsx)(Item, { asChild: true, ...rovingFocusGroupScope, focusable: !props.disabled, children: (0, import_jsx_runtime90.jsx)(Primitive.button, { type: "button", ...buttonProps, ref: forwardedRef }) });
  }
);
ToolbarButton.displayName = BUTTON_NAME;
var LINK_NAME2 = "ToolbarLink";
var ToolbarLink = React80.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToolbar, ...linkProps } = props;
    const rovingFocusGroupScope = useRovingFocusGroupScope7(__scopeToolbar);
    return (0, import_jsx_runtime90.jsx)(Item, { asChild: true, ...rovingFocusGroupScope, focusable: true, children: (0, import_jsx_runtime90.jsx)(
      Primitive.a,
      {
        ...linkProps,
        ref: forwardedRef,
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          if (event.key === " ") event.currentTarget.click();
        })
      }
    ) });
  }
);
ToolbarLink.displayName = LINK_NAME2;
var TOGGLE_GROUP_NAME2 = "ToolbarToggleGroup";
var ToolbarToggleGroup = React80.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToolbar, ...toggleGroupProps } = props;
    const context = useToolbarContext(TOGGLE_GROUP_NAME2, __scopeToolbar);
    const toggleGroupScope = useToggleGroupScope(__scopeToolbar);
    return (0, import_jsx_runtime90.jsx)(
      Root27,
      {
        "data-orientation": context.orientation,
        dir: context.dir,
        ...toggleGroupScope,
        ...toggleGroupProps,
        ref: forwardedRef,
        rovingFocus: false
      }
    );
  }
);
ToolbarToggleGroup.displayName = TOGGLE_GROUP_NAME2;
var TOGGLE_ITEM_NAME = "ToolbarToggleItem";
var ToolbarToggleItem = React80.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToolbar, ...toggleItemProps } = props;
    const toggleGroupScope = useToggleGroupScope(__scopeToolbar);
    const scope = { __scopeToolbar: props.__scopeToolbar };
    return (0, import_jsx_runtime90.jsx)(ToolbarButton, { asChild: true, ...scope, children: (0, import_jsx_runtime90.jsx)(Item24, { ...toggleGroupScope, ...toggleItemProps, ref: forwardedRef }) });
  }
);
ToolbarToggleItem.displayName = TOGGLE_ITEM_NAME;
var Root42 = Toolbar;
var Separator4 = ToolbarSeparator;
var Button = ToolbarButton;
var Link = ToolbarLink;
var ToggleGroup2 = ToolbarToggleGroup;
var ToggleItem = ToolbarToggleItem;

// ../node_modules/@radix-ui/react-tooltip/dist/index.mjs
var dist_exports19 = {};
__export(dist_exports19, {
  Arrow: () => Arrow26,
  Content: () => Content26,
  Portal: () => Portal5,
  Provider: () => Provider2,
  Root: () => Root33,
  Tooltip: () => Tooltip,
  TooltipArrow: () => TooltipArrow,
  TooltipContent: () => TooltipContent,
  TooltipPortal: () => TooltipPortal,
  TooltipProvider: () => TooltipProvider,
  TooltipTrigger: () => TooltipTrigger,
  Trigger: () => Trigger6,
  createTooltipScope: () => createTooltipScope
});
var React81 = __toESM(require_react(), 1);
var import_jsx_runtime91 = __toESM(require_jsx_runtime(), 1);
var [createTooltipContext, createTooltipScope] = createContextScope("Tooltip", [
  createPopperScope
]);
var usePopperScope5 = createPopperScope();
var PROVIDER_NAME2 = "TooltipProvider";
var DEFAULT_DELAY_DURATION = 700;
var TOOLTIP_OPEN = "tooltip.open";
var [TooltipProviderContextProvider, useTooltipProviderContext] = createTooltipContext(PROVIDER_NAME2);
var TooltipProvider = (props) => {
  const {
    __scopeTooltip,
    delayDuration = DEFAULT_DELAY_DURATION,
    skipDelayDuration = 300,
    disableHoverableContent = false,
    children
  } = props;
  const isOpenDelayedRef = React81.useRef(true);
  const isPointerInTransitRef = React81.useRef(false);
  const skipDelayTimerRef = React81.useRef(0);
  React81.useEffect(() => {
    const skipDelayTimer = skipDelayTimerRef.current;
    return () => window.clearTimeout(skipDelayTimer);
  }, []);
  return (0, import_jsx_runtime91.jsx)(
    TooltipProviderContextProvider,
    {
      scope: __scopeTooltip,
      isOpenDelayedRef,
      delayDuration,
      onOpen: React81.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        isOpenDelayedRef.current = false;
      }, []),
      onClose: React81.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        skipDelayTimerRef.current = window.setTimeout(
          () => isOpenDelayedRef.current = true,
          skipDelayDuration
        );
      }, [skipDelayDuration]),
      isPointerInTransitRef,
      onPointerInTransitChange: React81.useCallback((inTransit) => {
        isPointerInTransitRef.current = inTransit;
      }, []),
      disableHoverableContent,
      children
    }
  );
};
TooltipProvider.displayName = PROVIDER_NAME2;
var TOOLTIP_NAME = "Tooltip";
var [TooltipContextProvider, useTooltipContext] = createTooltipContext(TOOLTIP_NAME);
var Tooltip = (props) => {
  const {
    __scopeTooltip,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    disableHoverableContent: disableHoverableContentProp,
    delayDuration: delayDurationProp
  } = props;
  const providerContext = useTooltipProviderContext(TOOLTIP_NAME, props.__scopeTooltip);
  const popperScope = usePopperScope5(__scopeTooltip);
  const [trigger2, setTrigger] = React81.useState(null);
  const contentId = useId2();
  const openTimerRef = React81.useRef(0);
  const disableHoverableContent = disableHoverableContentProp ?? providerContext.disableHoverableContent;
  const delayDuration = delayDurationProp ?? providerContext.delayDuration;
  const wasOpenDelayedRef = React81.useRef(false);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: (open2) => {
      if (open2) {
        providerContext.onOpen();
        document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));
      } else {
        providerContext.onClose();
      }
      onOpenChange == null ? void 0 : onOpenChange(open2);
    },
    caller: TOOLTIP_NAME
  });
  const stateAttribute = React81.useMemo(() => {
    return open ? wasOpenDelayedRef.current ? "delayed-open" : "instant-open" : "closed";
  }, [open]);
  const handleOpen = React81.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    wasOpenDelayedRef.current = false;
    setOpen(true);
  }, [setOpen]);
  const handleClose = React81.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    setOpen(false);
  }, [setOpen]);
  const handleDelayedOpen = React81.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = window.setTimeout(() => {
      wasOpenDelayedRef.current = true;
      setOpen(true);
      openTimerRef.current = 0;
    }, delayDuration);
  }, [delayDuration, setOpen]);
  React81.useEffect(() => {
    return () => {
      if (openTimerRef.current) {
        window.clearTimeout(openTimerRef.current);
        openTimerRef.current = 0;
      }
    };
  }, []);
  return (0, import_jsx_runtime91.jsx)(Root22, { ...popperScope, children: (0, import_jsx_runtime91.jsx)(
    TooltipContextProvider,
    {
      scope: __scopeTooltip,
      contentId,
      open,
      stateAttribute,
      trigger: trigger2,
      onTriggerChange: setTrigger,
      onTriggerEnter: React81.useCallback(() => {
        if (providerContext.isOpenDelayedRef.current) handleDelayedOpen();
        else handleOpen();
      }, [providerContext.isOpenDelayedRef, handleDelayedOpen, handleOpen]),
      onTriggerLeave: React81.useCallback(() => {
        if (disableHoverableContent) {
          handleClose();
        } else {
          window.clearTimeout(openTimerRef.current);
          openTimerRef.current = 0;
        }
      }, [handleClose, disableHoverableContent]),
      onOpen: handleOpen,
      onClose: handleClose,
      disableHoverableContent,
      children
    }
  ) });
};
Tooltip.displayName = TOOLTIP_NAME;
var TRIGGER_NAME14 = "TooltipTrigger";
var TooltipTrigger = React81.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...triggerProps } = props;
    const context = useTooltipContext(TRIGGER_NAME14, __scopeTooltip);
    const providerContext = useTooltipProviderContext(TRIGGER_NAME14, __scopeTooltip);
    const popperScope = usePopperScope5(__scopeTooltip);
    const ref = React81.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context.onTriggerChange);
    const isPointerDownRef = React81.useRef(false);
    const hasPointerMoveOpenedRef = React81.useRef(false);
    const handlePointerUp = React81.useCallback(() => isPointerDownRef.current = false, []);
    React81.useEffect(() => {
      return () => document.removeEventListener("pointerup", handlePointerUp);
    }, [handlePointerUp]);
    return (0, import_jsx_runtime91.jsx)(Anchor, { asChild: true, ...popperScope, children: (0, import_jsx_runtime91.jsx)(
      Primitive.button,
      {
        "aria-describedby": context.open ? context.contentId : void 0,
        "data-state": context.stateAttribute,
        ...triggerProps,
        ref: composedRefs,
        onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
          if (event.pointerType === "touch") return;
          if (!hasPointerMoveOpenedRef.current && !providerContext.isPointerInTransitRef.current) {
            context.onTriggerEnter();
            hasPointerMoveOpenedRef.current = true;
          }
        }),
        onPointerLeave: composeEventHandlers(props.onPointerLeave, () => {
          context.onTriggerLeave();
          hasPointerMoveOpenedRef.current = false;
        }),
        onPointerDown: composeEventHandlers(props.onPointerDown, () => {
          if (context.open) {
            context.onClose();
          }
          isPointerDownRef.current = true;
          document.addEventListener("pointerup", handlePointerUp, { once: true });
        }),
        onFocus: composeEventHandlers(props.onFocus, () => {
          if (!isPointerDownRef.current) context.onOpen();
        }),
        onBlur: composeEventHandlers(props.onBlur, context.onClose),
        onClick: composeEventHandlers(props.onClick, context.onClose)
      }
    ) });
  }
);
TooltipTrigger.displayName = TRIGGER_NAME14;
var PORTAL_NAME11 = "TooltipPortal";
var [PortalProvider5, usePortalContext5] = createTooltipContext(PORTAL_NAME11, {
  forceMount: void 0
});
var TooltipPortal = (props) => {
  const { __scopeTooltip, forceMount, children, container } = props;
  const context = useTooltipContext(PORTAL_NAME11, __scopeTooltip);
  return (0, import_jsx_runtime91.jsx)(PortalProvider5, { scope: __scopeTooltip, forceMount, children: (0, import_jsx_runtime91.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime91.jsx)(Portal, { asChild: true, container, children }) }) });
};
TooltipPortal.displayName = PORTAL_NAME11;
var CONTENT_NAME15 = "TooltipContent";
var TooltipContent = React81.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext5(CONTENT_NAME15, props.__scopeTooltip);
    const { forceMount = portalContext.forceMount, side = "top", ...contentProps } = props;
    const context = useTooltipContext(CONTENT_NAME15, props.__scopeTooltip);
    return (0, import_jsx_runtime91.jsx)(Presence, { present: forceMount || context.open, children: context.disableHoverableContent ? (0, import_jsx_runtime91.jsx)(TooltipContentImpl, { side, ...contentProps, ref: forwardedRef }) : (0, import_jsx_runtime91.jsx)(TooltipContentHoverable, { side, ...contentProps, ref: forwardedRef }) });
  }
);
var TooltipContentHoverable = React81.forwardRef((props, forwardedRef) => {
  const context = useTooltipContext(CONTENT_NAME15, props.__scopeTooltip);
  const providerContext = useTooltipProviderContext(CONTENT_NAME15, props.__scopeTooltip);
  const ref = React81.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const [pointerGraceArea, setPointerGraceArea] = React81.useState(null);
  const { trigger: trigger2, onClose } = context;
  const content = ref.current;
  const { onPointerInTransitChange } = providerContext;
  const handleRemoveGraceArea = React81.useCallback(() => {
    setPointerGraceArea(null);
    onPointerInTransitChange(false);
  }, [onPointerInTransitChange]);
  const handleCreateGraceArea = React81.useCallback(
    (event, hoverTarget) => {
      const currentTarget = event.currentTarget;
      const exitPoint = { x: event.clientX, y: event.clientY };
      const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
      const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
      const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
      const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);
      setPointerGraceArea(graceArea);
      onPointerInTransitChange(true);
    },
    [onPointerInTransitChange]
  );
  React81.useEffect(() => {
    return () => handleRemoveGraceArea();
  }, [handleRemoveGraceArea]);
  React81.useEffect(() => {
    if (trigger2 && content) {
      const handleTriggerLeave = (event) => handleCreateGraceArea(event, content);
      const handleContentLeave = (event) => handleCreateGraceArea(event, trigger2);
      trigger2.addEventListener("pointerleave", handleTriggerLeave);
      content.addEventListener("pointerleave", handleContentLeave);
      return () => {
        trigger2.removeEventListener("pointerleave", handleTriggerLeave);
        content.removeEventListener("pointerleave", handleContentLeave);
      };
    }
  }, [trigger2, content, handleCreateGraceArea, handleRemoveGraceArea]);
  React81.useEffect(() => {
    if (pointerGraceArea) {
      const handleTrackPointerGrace = (event) => {
        const target = event.target;
        const pointerPosition = { x: event.clientX, y: event.clientY };
        const hasEnteredTarget = (trigger2 == null ? void 0 : trigger2.contains(target)) || (content == null ? void 0 : content.contains(target));
        const isPointerOutsideGraceArea = !isPointInPolygon2(pointerPosition, pointerGraceArea);
        if (hasEnteredTarget) {
          handleRemoveGraceArea();
        } else if (isPointerOutsideGraceArea) {
          handleRemoveGraceArea();
          onClose();
        }
      };
      document.addEventListener("pointermove", handleTrackPointerGrace);
      return () => document.removeEventListener("pointermove", handleTrackPointerGrace);
    }
  }, [trigger2, content, pointerGraceArea, onClose, handleRemoveGraceArea]);
  return (0, import_jsx_runtime91.jsx)(TooltipContentImpl, { ...props, ref: composedRefs });
});
var [VisuallyHiddenContentContextProvider, useVisuallyHiddenContentContext] = createTooltipContext(TOOLTIP_NAME, { isInside: false });
var Slottable3 = createSlottable("TooltipContent");
var TooltipContentImpl = React81.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeTooltip,
      children,
      "aria-label": ariaLabel,
      onEscapeKeyDown,
      onPointerDownOutside,
      ...contentProps
    } = props;
    const context = useTooltipContext(CONTENT_NAME15, __scopeTooltip);
    const popperScope = usePopperScope5(__scopeTooltip);
    const { onClose } = context;
    React81.useEffect(() => {
      document.addEventListener(TOOLTIP_OPEN, onClose);
      return () => document.removeEventListener(TOOLTIP_OPEN, onClose);
    }, [onClose]);
    React81.useEffect(() => {
      if (context.trigger) {
        const handleScroll2 = (event) => {
          const target = event.target;
          if (target == null ? void 0 : target.contains(context.trigger)) onClose();
        };
        window.addEventListener("scroll", handleScroll2, { capture: true });
        return () => window.removeEventListener("scroll", handleScroll2, { capture: true });
      }
    }, [context.trigger, onClose]);
    return (0, import_jsx_runtime91.jsx)(
      DismissableLayer,
      {
        asChild: true,
        disableOutsidePointerEvents: false,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside: (event) => event.preventDefault(),
        onDismiss: onClose,
        children: (0, import_jsx_runtime91.jsxs)(
          Content3,
          {
            "data-state": context.stateAttribute,
            ...popperScope,
            ...contentProps,
            ref: forwardedRef,
            style: {
              ...contentProps.style,
              // re-namespace exposed content custom properties
              ...{
                "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
                "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
                "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
                "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
                "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
              }
            },
            children: [
              (0, import_jsx_runtime91.jsx)(Slottable3, { children }),
              (0, import_jsx_runtime91.jsx)(VisuallyHiddenContentContextProvider, { scope: __scopeTooltip, isInside: true, children: (0, import_jsx_runtime91.jsx)(Root2, { id: context.contentId, role: "tooltip", children: ariaLabel || children }) })
            ]
          }
        )
      }
    );
  }
);
TooltipContent.displayName = CONTENT_NAME15;
var ARROW_NAME9 = "TooltipArrow";
var TooltipArrow = React81.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...arrowProps } = props;
    const popperScope = usePopperScope5(__scopeTooltip);
    const visuallyHiddenContentContext = useVisuallyHiddenContentContext(
      ARROW_NAME9,
      __scopeTooltip
    );
    return visuallyHiddenContentContext.isInside ? null : (0, import_jsx_runtime91.jsx)(Arrow2, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
TooltipArrow.displayName = ARROW_NAME9;
function getExitSideFromRect(point, rect) {
  const top = Math.abs(rect.top - point.y);
  const bottom = Math.abs(rect.bottom - point.y);
  const right = Math.abs(rect.right - point.x);
  const left = Math.abs(rect.left - point.x);
  switch (Math.min(top, bottom, right, left)) {
    case left:
      return "left";
    case right:
      return "right";
    case top:
      return "top";
    case bottom:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
  const paddedExitPoints = [];
  switch (exitSide) {
    case "top":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y + padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "bottom":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y - padding }
      );
      break;
    case "left":
      paddedExitPoints.push(
        { x: exitPoint.x + padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "right":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x - padding, y: exitPoint.y + padding }
      );
      break;
  }
  return paddedExitPoints;
}
function getPointsFromRect(rect) {
  const { top, right, bottom, left } = rect;
  return [
    { x: left, y: top },
    { x: right, y: top },
    { x: right, y: bottom },
    { x: left, y: bottom }
  ];
}
function isPointInPolygon2(point, polygon) {
  const { x, y } = point;
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const ii = polygon[i];
    const jj = polygon[j];
    const xi = ii.x;
    const yi = ii.y;
    const xj = jj.x;
    const yj = jj.y;
    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect) inside = !inside;
  }
  return inside;
}
function getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a, b) => {
    if (a.x < b.x) return -1;
    else if (a.x > b.x) return 1;
    else if (a.y < b.y) return -1;
    else if (a.y > b.y) return 1;
    else return 0;
  });
  return getHullPresorted(newPoints);
}
function getHullPresorted(points) {
  if (points.length <= 1) return points.slice();
  const upperHull = [];
  for (let i = 0; i < points.length; i++) {
    const p = points[i];
    while (upperHull.length >= 2) {
      const q = upperHull[upperHull.length - 1];
      const r = upperHull[upperHull.length - 2];
      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) upperHull.pop();
      else break;
    }
    upperHull.push(p);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i = points.length - 1; i >= 0; i--) {
    const p = points[i];
    while (lowerHull.length >= 2) {
      const q = lowerHull[lowerHull.length - 1];
      const r = lowerHull[lowerHull.length - 2];
      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) lowerHull.pop();
      else break;
    }
    lowerHull.push(p);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) {
    return upperHull;
  } else {
    return upperHull.concat(lowerHull);
  }
}
var Provider2 = TooltipProvider;
var Root33 = Tooltip;
var Trigger6 = TooltipTrigger;
var Portal5 = TooltipPortal;
var Content26 = TooltipContent;
var Arrow26 = TooltipArrow;

// ../node_modules/tldraw/dist-esm/lib/ui/components/primitives/Button/TldrawUiButtonIcon.mjs
var import_jsx_runtime93 = __toESM(require_jsx_runtime(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/components/primitives/TldrawUiIcon.mjs
var import_jsx_runtime92 = __toESM(require_jsx_runtime(), 1);
var import_classnames16 = __toESM(require_classnames(), 1);
var import_react63 = __toESM(require_react(), 1);
var TldrawUiIcon = (0, import_react63.memo)(function TldrawUiIcon2({
  label,
  small,
  invertIcon,
  icon,
  color,
  className,
  ...props
}) {
  if (typeof icon === "string") {
    return (0, import_jsx_runtime92.jsx)(
      TldrawUIIconInner,
      {
        label,
        small,
        invertIcon,
        icon,
        color,
        className,
        ...props
      }
    );
  }
  return (0, import_react63.cloneElement)(icon, {
    ...props,
    className: (0, import_classnames16.default)({ "tlui-icon__small": small }, className, icon.props.className),
    "aria-label": label,
    style: {
      color,
      transform: invertIcon ? "scale(-1, 1)" : void 0,
      ...icon.props.style
    }
  });
});
function TldrawUIIconInner({
  label,
  small,
  invertIcon,
  icon,
  color,
  className,
  ...props
}) {
  const assetUrls = useAssetUrls();
  const asset = assetUrls.icons[icon] ?? assetUrls.icons["question-mark-circle"];
  const ref = (0, import_react63.useRef)(null);
  (0, import_react63.useLayoutEffect)(() => {
    if (!asset) {
      console.error(`Icon not found: ${icon}. Add it to the assetUrls.icons object.`);
    }
    if (ref == null ? void 0 : ref.current) {
      ref.current.style.webkitMask = `url(${asset}) center 100% / 100% no-repeat`;
    }
  }, [ref, asset, icon]);
  if (icon === "none") {
    return (0, import_jsx_runtime92.jsx)(
      "div",
      {
        className: (0, import_classnames16.default)(
          "tlui-icon tlui-icon__placeholder",
          { "tlui-icon__small": small },
          className
        ),
        ...props
      }
    );
  }
  return (0, import_jsx_runtime92.jsx)(
    "div",
    {
      ...props,
      ref,
      "aria-label": label,
      role: "img",
      className: (0, import_classnames16.default)("tlui-icon", { "tlui-icon__small": small }, className),
      style: {
        color,
        mask: `url(${asset}) center 100% / 100% no-repeat`,
        transform: invertIcon ? "scale(-1, 1)" : void 0
      }
    }
  );
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/primitives/Button/TldrawUiButtonIcon.mjs
function TldrawUiButtonIcon({ icon, small, invertIcon }) {
  return (0, import_jsx_runtime93.jsx)(
    TldrawUiIcon,
    {
      "aria-hidden": "true",
      label: "",
      className: "tlui-button__icon",
      icon,
      small,
      invertIcon
    }
  );
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/primitives/TldrawUiDialog.mjs
function TldrawUiDialogHeader({ className, children }) {
  return (0, import_jsx_runtime94.jsx)("div", { className: (0, import_classnames17.default)("tlui-dialog__header", className), children });
}
function TldrawUiDialogTitle({ className, children, style: style2 }) {
  return (0, import_jsx_runtime94.jsx)(
    dist_exports4.Title,
    {
      dir: "ltr",
      className: (0, import_classnames17.default)("tlui-dialog__header__title", className),
      style: style2,
      children
    }
  );
}
function TldrawUiDialogCloseButton() {
  const msg2 = useTranslation();
  return (0, import_jsx_runtime94.jsx)("div", { className: "tlui-dialog__header__close", children: (0, import_jsx_runtime94.jsx)(dist_exports4.DialogClose, { "data-testid": "dialog.close", dir: "ltr", asChild: true, children: (0, import_jsx_runtime94.jsx)(
    TldrawUiButton,
    {
      type: "icon",
      "aria-label": msg2("ui.close"),
      onTouchEnd: (e) => e.target.click(),
      children: (0, import_jsx_runtime94.jsx)(TldrawUiButtonIcon, { small: true, icon: "cross-2" })
    }
  ) }) });
}
function TldrawUiDialogBody({ className, children, style: style2 }) {
  return (0, import_jsx_runtime94.jsx)("div", { className: (0, import_classnames17.default)("tlui-dialog__body", className), style: style2, tabIndex: 0, children });
}
function TldrawUiDialogFooter({ className, children }) {
  return (0, import_jsx_runtime94.jsx)("div", { className: (0, import_classnames17.default)("tlui-dialog__footer", className), children });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/primitives/TldrawUiInput.mjs
var import_jsx_runtime95 = __toESM(require_jsx_runtime(), 1);
var import_classnames18 = __toESM(require_classnames(), 1);
var React82 = __toESM(require_react(), 1);
var TldrawUiInput = React82.forwardRef(
  function TldrawUiInput2({
    className,
    label,
    icon,
    iconLeft,
    iconLabel,
    autoSelect = false,
    autoFocus = false,
    defaultValue,
    placeholder,
    onComplete,
    onValueChange,
    onCancel,
    onFocus,
    onBlur,
    shouldManuallyMaintainScrollPositionWhenFocused = false,
    children,
    value,
    "data-testid": dataTestId,
    disabled,
    "aria-label": ariaLabel
  }, ref) {
    const editor = useMaybeEditor();
    const rInputRef = React82.useRef(null);
    React82.useImperativeHandle(ref, () => rInputRef.current);
    const msg2 = useTranslation();
    const rInitialValue = React82.useRef(defaultValue ?? "");
    const rCurrentValue = React82.useRef(defaultValue ?? "");
    const isComposing = React82.useRef(false);
    const [isFocused, setIsFocused] = React82.useState(false);
    const handleFocus = React82.useCallback(
      (e) => {
        setIsFocused(true);
        const elm = e.currentTarget;
        rCurrentValue.current = elm.value;
        if (editor) {
          editor.timers.requestAnimationFrame(() => {
            if (autoSelect) {
              elm.select();
            }
          });
        } else {
          tltime.requestAnimationFrame("anon", () => {
            if (autoSelect) {
              elm.select();
            }
          });
        }
        onFocus == null ? void 0 : onFocus();
      },
      [autoSelect, editor, onFocus]
    );
    const handleChange = React82.useCallback(
      (e) => {
        const value2 = e.currentTarget.value;
        rCurrentValue.current = value2;
        onValueChange == null ? void 0 : onValueChange(value2);
      },
      [onValueChange]
    );
    const handleKeyDownCapture = React82.useCallback(
      (e) => {
        switch (e.key) {
          case "Enter": {
            if (isComposing.current) return;
            e.currentTarget.blur();
            e.stopPropagation();
            onComplete == null ? void 0 : onComplete(e.currentTarget.value);
            break;
          }
          case "Escape": {
            e.currentTarget.value = rInitialValue.current;
            onCancel == null ? void 0 : onCancel(e.currentTarget.value);
            e.currentTarget.blur();
            e.stopPropagation();
            break;
          }
        }
      },
      [onComplete, onCancel]
    );
    const handleBlur = React82.useCallback(
      (e) => {
        setIsFocused(false);
        const value2 = e.currentTarget.value;
        onBlur == null ? void 0 : onBlur(value2);
      },
      [onBlur]
    );
    const handleCompositionStart = React82.useCallback(() => isComposing.current = true, []);
    const handleCompositionEnd = React82.useCallback(() => isComposing.current = false, []);
    React82.useEffect(() => {
      if (!tlenv.isIos) return;
      const visualViewport = window.visualViewport;
      if (isFocused && shouldManuallyMaintainScrollPositionWhenFocused && visualViewport) {
        const onViewportChange = () => {
          var _a6;
          (_a6 = rInputRef.current) == null ? void 0 : _a6.scrollIntoView({ block: "center" });
        };
        visualViewport.addEventListener("resize", onViewportChange);
        visualViewport.addEventListener("scroll", onViewportChange);
        if (editor) {
          editor.timers.requestAnimationFrame(() => {
            var _a6;
            (_a6 = rInputRef.current) == null ? void 0 : _a6.scrollIntoView({ block: "center" });
          });
        } else {
          tltime.requestAnimationFrame("anon", () => {
            var _a6;
            (_a6 = rInputRef.current) == null ? void 0 : _a6.scrollIntoView({ block: "center" });
          });
        }
        return () => {
          visualViewport.removeEventListener("resize", onViewportChange);
          visualViewport.removeEventListener("scroll", onViewportChange);
        };
      }
    }, [isFocused, editor, shouldManuallyMaintainScrollPositionWhenFocused]);
    return (0, import_jsx_runtime95.jsxs)("div", { draggable: false, className: "tlui-input__wrapper", children: [
      children,
      label && (0, import_jsx_runtime95.jsx)("label", { children: msg2(label) }),
      iconLeft && (0, import_jsx_runtime95.jsx)(
        TldrawUiIcon,
        {
          label: iconLabel ? msg2(iconLabel) : "",
          icon: iconLeft,
          className: "tlui-icon-left",
          small: true
        }
      ),
      (0, import_jsx_runtime95.jsx)(
        "input",
        {
          ref: rInputRef,
          className: (0, import_classnames18.default)("tlui-input", className),
          type: "text",
          defaultValue,
          onKeyDownCapture: handleKeyDownCapture,
          onChange: handleChange,
          onFocus: handleFocus,
          onBlur: handleBlur,
          onCompositionStart: handleCompositionStart,
          onCompositionEnd: handleCompositionEnd,
          autoFocus,
          "aria-label": ariaLabel,
          placeholder,
          value,
          "data-testid": dataTestId,
          disabled
        }
      ),
      icon && (0, import_jsx_runtime95.jsx)(TldrawUiIcon, { label: iconLabel ? msg2(iconLabel) : "", icon, small: !!label })
    ] });
  }
);

// ../node_modules/tldraw/dist-esm/lib/ui/components/EditLinkDialog.mjs
function validateUrl(url) {
  if (validation_exports.linkUrl.isValid(url)) {
    return { isValid: true, hasProtocol: true };
  }
  if (validation_exports.linkUrl.isValid("https://" + url)) {
    return { isValid: true, hasProtocol: false };
  }
  return { isValid: false, hasProtocol: false };
}
function isShapeWithUrl(shape) {
  return !!(shape && "url" in shape.props && typeof shape.props.url === "string");
}
function assertShapeWithUrl(shape) {
  if (!isShapeWithUrl(shape)) {
    throw new Error("Shape is not a valid ShapeWithUrl");
  }
}
var EditLinkDialog = track(function EditLinkDialog2({ onClose }) {
  const editor = useEditor();
  const selectedShape = editor.getOnlySelectedShape();
  if (!isShapeWithUrl(selectedShape)) {
    return null;
  }
  return (0, import_jsx_runtime96.jsx)(EditLinkDialogInner, { onClose, selectedShape });
});
var EditLinkDialogInner = track(function EditLinkDialogInner2({
  onClose,
  selectedShape
}) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const rInput = (0, import_react64.useRef)(null);
  (0, import_react64.useEffect)(() => {
    editor.timers.requestAnimationFrame(() => {
      var _a6;
      return (_a6 = rInput.current) == null ? void 0 : _a6.focus();
    });
  }, [editor]);
  const rInitialValue = (0, import_react64.useRef)(selectedShape.props.url);
  const [urlInputState, setUrlInputState] = (0, import_react64.useState)(() => {
    const urlValidResult = validateUrl(selectedShape.props.url);
    const initialValue = urlValidResult.isValid === true ? urlValidResult.hasProtocol ? selectedShape.props.url : "https://" + selectedShape.props.url : "https://";
    return {
      actual: initialValue,
      safe: initialValue,
      valid: true
    };
  });
  const handleChange = (0, import_react64.useCallback)((rawValue) => {
    const fixedRawValue = rawValue.replace(/https?:\/\/(https?:\/\/)/, (_match, arg1) => {
      return arg1;
    });
    const urlValidResult = validateUrl(fixedRawValue);
    const safeValue = urlValidResult.isValid === true ? urlValidResult.hasProtocol ? fixedRawValue : "https://" + fixedRawValue : "https://";
    setUrlInputState({
      actual: fixedRawValue,
      safe: safeValue,
      valid: urlValidResult.isValid
    });
  }, []);
  const handleClear = (0, import_react64.useCallback)(() => {
    const onlySelectedShape = editor.getOnlySelectedShape();
    if (!onlySelectedShape) return;
    assertShapeWithUrl(onlySelectedShape);
    editor.updateShapes([
      { id: onlySelectedShape.id, type: onlySelectedShape.type, props: { url: "" } }
    ]);
    onClose();
  }, [editor, onClose]);
  const handleComplete = (0, import_react64.useCallback)(() => {
    const onlySelectedShape = editor.getOnlySelectedShape();
    if (!onlySelectedShape) return;
    assertShapeWithUrl(onlySelectedShape);
    if (onlySelectedShape && "url" in onlySelectedShape.props) {
      if (onlySelectedShape.props.url !== urlInputState.safe) {
        editor.updateShapes([
          {
            id: onlySelectedShape.id,
            type: onlySelectedShape.type,
            props: { url: urlInputState.safe }
          }
        ]);
      }
    }
    onClose();
  }, [editor, onClose, urlInputState]);
  const handleCancel = (0, import_react64.useCallback)(() => {
    onClose();
  }, [onClose]);
  if (!selectedShape) {
    onClose();
    return null;
  }
  const isRemoving = rInitialValue.current && !urlInputState.valid;
  return (0, import_jsx_runtime96.jsxs)(import_jsx_runtime96.Fragment, { children: [
    (0, import_jsx_runtime96.jsxs)(TldrawUiDialogHeader, { children: [
      (0, import_jsx_runtime96.jsx)(TldrawUiDialogTitle, { children: msg2("edit-link-dialog.title") }),
      (0, import_jsx_runtime96.jsx)(TldrawUiDialogCloseButton, {})
    ] }),
    (0, import_jsx_runtime96.jsx)(TldrawUiDialogBody, { children: (0, import_jsx_runtime96.jsxs)("div", { className: "tlui-edit-link-dialog", children: [
      (0, import_jsx_runtime96.jsx)(
        TldrawUiInput,
        {
          ref: rInput,
          className: "tlui-edit-link-dialog__input",
          label: "edit-link-dialog.url",
          autoFocus: true,
          autoSelect: true,
          placeholder: "https://example.com",
          value: urlInputState.actual,
          onValueChange: handleChange,
          onComplete: handleComplete,
          onCancel: handleCancel
        }
      ),
      (0, import_jsx_runtime96.jsx)("div", { children: urlInputState.valid ? msg2("edit-link-dialog.detail") : msg2("edit-link-dialog.invalid-url") })
    ] }) }),
    (0, import_jsx_runtime96.jsxs)(TldrawUiDialogFooter, { className: "tlui-dialog__footer__actions", children: [
      (0, import_jsx_runtime96.jsx)(TldrawUiButton, { type: "normal", onClick: handleCancel, onTouchEnd: handleCancel, children: (0, import_jsx_runtime96.jsx)(TldrawUiButtonLabel, { children: msg2("edit-link-dialog.cancel") }) }),
      isRemoving ? (0, import_jsx_runtime96.jsx)(TldrawUiButton, { type: "danger", onTouchEnd: handleClear, onClick: handleClear, children: (0, import_jsx_runtime96.jsx)(TldrawUiButtonLabel, { children: msg2("edit-link-dialog.clear") }) }) : (0, import_jsx_runtime96.jsx)(
        TldrawUiButton,
        {
          type: "primary",
          disabled: !urlInputState.valid,
          onTouchEnd: handleComplete,
          onClick: handleComplete,
          children: (0, import_jsx_runtime96.jsx)(TldrawUiButtonLabel, { children: msg2("edit-link-dialog.save") })
        }
      )
    ] })
  ] });
});

// ../node_modules/tldraw/dist-esm/lib/ui/components/EmbedDialog.mjs
var import_jsx_runtime97 = __toESM(require_jsx_runtime(), 1);
var import_react65 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/defaultEmbedDefinitions.mjs
var TLDRAW_APP_RE2 = /(^\/[f|p|r|ro|s|v]\/[^/]+\/?$)/;
var DEFAULT_EMBED_DEFINITIONS = [
  {
    type: "tldraw",
    title: "tldraw",
    hostnames: ["beta.tldraw.com", "tldraw.com", "localhost:3000"],
    minWidth: 300,
    minHeight: 300,
    width: 720,
    height: 500,
    doesResize: true,
    overridePermissions: {
      "allow-top-navigation": true
    },
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(TLDRAW_APP_RE2)) {
        urlObj.searchParams.append("embed", "true");
        return url;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(TLDRAW_APP_RE2)) {
        urlObj.searchParams.delete("embed");
        return url;
      }
      return;
    },
    embedOnPaste: false
  },
  {
    type: "figma",
    title: "Figma",
    hostnames: ["figma.com"],
    width: 720,
    height: 500,
    doesResize: true,
    toEmbedUrl: (url) => {
      if (!!url.match(
        // eslint-disable-next-line no-useless-escape
        /https:\/\/([\w\.-]+\.)?figma.com\/(file|proto|design)\/([0-9a-zA-Z]{22,128})(?:\/.*)?$/
      ) && !url.includes("figma.com/embed")) {
        return `https://www.figma.com/embed?embed_host=share&url=${url}`;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/embed\/?$/)) {
        const outUrl = urlObj.searchParams.get("url");
        if (outUrl) {
          return outUrl;
        }
      }
      return;
    },
    embedOnPaste: true
  },
  {
    type: "google_maps",
    title: "Google Maps",
    hostnames: ["google.*"],
    width: 720,
    height: 500,
    doesResize: true,
    overridePermissions: {
      "allow-presentation": true
    },
    toEmbedUrl: (url) => {
      if (url.includes("/maps/embed?")) {
        return url;
      } else if (url.includes("/maps/")) {
        const match = url.match(/@(.*?),(.*?),(.*?)(z|m)/);
        let result;
        if (match) {
          const [, lat, lng, zoomOrMeters, mapTypeSymbol] = match;
          const mapType = mapTypeSymbol === "z" ? "roadmap" : "satellite";
          const z = mapType === "roadmap" ? zoomOrMeters : -Math.log2(parseInt(zoomOrMeters) / 14772321) / 0.8;
          const host = new URL(url).host.replace("www.", "");
          result = `https://${host}/maps/embed/v1/view?key=${process.env.NEXT_PUBLIC_GC_API_KEY}&center=${lat},${lng}&zoom=${z}&maptype=${mapType}`;
        } else {
          result = "";
        }
        return result;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (!urlObj) return;
      const matches2 = urlObj.pathname.match(/^\/maps\/embed\/v1\/view\/?$/);
      if (matches2 && urlObj.searchParams.has("center") && urlObj.searchParams.get("zoom")) {
        const zoom = urlObj.searchParams.get("zoom") ?? "12";
        const mapType = urlObj.searchParams.get("maptype") ?? "roadmap";
        const zoomOrMeters = mapType === "roadmap" ? zoom : 14772321 * Math.pow(2, parseInt(zoom) * -0.8);
        const [lat, lon] = urlObj.searchParams.get("center").split(",");
        return `https://www.google.com/maps/@${lat},${lon},${zoomOrMeters}${mapType === "roadmap" ? "z" : "m"}`;
      }
      return;
    },
    embedOnPaste: true
  },
  {
    type: "val_town",
    title: "Val Town",
    hostnames: ["val.town"],
    minWidth: 260,
    minHeight: 100,
    width: 720,
    height: 500,
    doesResize: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const matches2 = urlObj && urlObj.pathname.match(/\/v\/(.+)\/?/);
      if (matches2) {
        return `https://www.val.town/embed/${matches2[1]}`;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const matches2 = urlObj && urlObj.pathname.match(/\/embed\/(.+)\/?/);
      if (matches2) {
        return `https://www.val.town/v/${matches2[1]}`;
      }
      return;
    },
    embedOnPaste: true
  },
  {
    type: "codesandbox",
    title: "CodeSandbox",
    hostnames: ["codesandbox.io"],
    minWidth: 300,
    minHeight: 300,
    width: 720,
    height: 500,
    doesResize: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const matches2 = urlObj && urlObj.pathname.match(/\/s\/([^/]+)\/?/);
      if (matches2) {
        return `https://codesandbox.io/embed/${matches2[1]}`;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const matches2 = urlObj && urlObj.pathname.match(/\/embed\/([^/]+)\/?/);
      if (matches2) {
        return `https://codesandbox.io/s/${matches2[1]}`;
      }
      return;
    },
    embedOnPaste: true
  },
  {
    type: "codepen",
    title: "Codepen",
    hostnames: ["codepen.io"],
    minWidth: 300,
    minHeight: 300,
    width: 520,
    height: 400,
    doesResize: true,
    toEmbedUrl: (url) => {
      const CODEPEN_URL_REGEXP = /https:\/\/codepen.io\/([^/]+)\/pen\/([^/]+)/;
      const matches2 = url.match(CODEPEN_URL_REGEXP);
      if (matches2) {
        const [_, user, id] = matches2;
        return `https://codepen.io/${user}/embed/${id}`;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const CODEPEN_EMBED_REGEXP = /https:\/\/codepen.io\/([^/]+)\/embed\/([^/]+)/;
      const matches2 = url.match(CODEPEN_EMBED_REGEXP);
      if (matches2) {
        const [_, user, id] = matches2;
        return `https://codepen.io/${user}/pen/${id}`;
      }
      return;
    },
    embedOnPaste: true
  },
  {
    type: "scratch",
    title: "Scratch",
    hostnames: ["scratch.mit.edu"],
    width: 520,
    height: 400,
    doesResize: false,
    embedOnPaste: true,
    toEmbedUrl: (url) => {
      const SCRATCH_URL_REGEXP = /https?:\/\/scratch.mit.edu\/projects\/([^/]+)/;
      const matches2 = url.match(SCRATCH_URL_REGEXP);
      if (matches2) {
        const [_, id] = matches2;
        return `https://scratch.mit.edu/projects/embed/${id}`;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const SCRATCH_EMBED_REGEXP = /https:\/\/scratch.mit.edu\/projects\/embed\/([^/]+)/;
      const matches2 = url.match(SCRATCH_EMBED_REGEXP);
      if (matches2) {
        const [_, id] = matches2;
        return `https://scratch.mit.edu/projects/${id}`;
      }
      return;
    }
  },
  {
    type: "youtube",
    title: "YouTube",
    hostnames: ["*.youtube.com", "youtube.com", "youtu.be"],
    width: 800,
    height: 450,
    doesResize: true,
    overridePermissions: {
      "allow-presentation": true,
      "allow-popups-to-escape-sandbox": true
    },
    isAspectRatioLocked: true,
    embedOnPaste: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (!urlObj) return;
      const hostname = urlObj.hostname.replace(/^www./, "");
      if (hostname === "youtu.be") {
        const videoId = urlObj.pathname.split("/").filter(Boolean)[0];
        const searchParams = new URLSearchParams(urlObj.search);
        const timeStart = searchParams.get("t");
        if (timeStart) {
          searchParams.set("start", timeStart);
          searchParams.delete("t");
        }
        const search = searchParams.toString() ? "?" + searchParams.toString() : "";
        return `https://www.youtube.com/embed/${videoId}${search}`;
      } else if ((hostname === "youtube.com" || hostname === "m.youtube.com") && urlObj.pathname.match(/^\/watch/)) {
        const videoId = urlObj.searchParams.get("v");
        const searchParams = new URLSearchParams(urlObj.search);
        searchParams.delete("v");
        const timeStart = searchParams.get("t");
        if (timeStart) {
          searchParams.set("start", timeStart);
          searchParams.delete("t");
        }
        const search = searchParams.toString() ? "?" + searchParams.toString() : "";
        return `https://www.youtube.com/embed/${videoId}${search}`;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (!urlObj) return;
      const hostname = urlObj.hostname.replace(/^www./, "");
      if (hostname === "youtube.com") {
        const matches2 = urlObj.pathname.match(/^\/embed\/([^/]+)\/?/);
        if (matches2) {
          const params = new URLSearchParams(urlObj.search);
          params.set("v", (matches2 == null ? void 0 : matches2[1]) ?? "");
          const timeStart = params.get("start");
          if (timeStart) {
            params.set("t", timeStart);
            params.delete("start");
          }
          return `https://www.youtube.com/watch?${params.toString()}`;
        }
      }
      return;
    }
  },
  {
    type: "google_calendar",
    title: "Google Calendar",
    hostnames: ["calendar.google.*"],
    width: 720,
    height: 500,
    minWidth: 460,
    minHeight: 360,
    doesResize: true,
    instructionLink: "https://support.google.com/calendar/answer/41207?hl=en",
    overridePermissions: {
      "allow-popups-to-escape-sandbox": true
    },
    embedOnPaste: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const cidQs = urlObj == null ? void 0 : urlObj.searchParams.get("cid");
      if ((urlObj == null ? void 0 : urlObj.pathname.match(/\/calendar\/u\/0/)) && cidQs) {
        urlObj.pathname = "/calendar/embed";
        const keys3 = Array.from(urlObj.searchParams.keys());
        for (const key of keys3) {
          urlObj.searchParams.delete(key);
        }
        urlObj.searchParams.set("src", cidQs);
        return urlObj.href;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const srcQs = urlObj == null ? void 0 : urlObj.searchParams.get("src");
      if ((urlObj == null ? void 0 : urlObj.pathname.match(/\/calendar\/embed/)) && srcQs) {
        urlObj.pathname = "/calendar/u/0";
        const keys3 = Array.from(urlObj.searchParams.keys());
        for (const key of keys3) {
          urlObj.searchParams.delete(key);
        }
        urlObj.searchParams.set("cid", srcQs);
        return urlObj.href;
      }
      return;
    }
  },
  {
    type: "google_slides",
    title: "Google Slides",
    hostnames: ["docs.google.*"],
    width: 720,
    height: 500,
    minWidth: 460,
    minHeight: 360,
    doesResize: true,
    overridePermissions: {
      "allow-popups-to-escape-sandbox": true
    },
    embedOnPaste: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if ((urlObj == null ? void 0 : urlObj.pathname.match(/^\/presentation/)) && (urlObj == null ? void 0 : urlObj.pathname.match(/\/pub\/?$/))) {
        urlObj.pathname = urlObj.pathname.replace(/\/pub$/, "/embed");
        const keys3 = Array.from(urlObj.searchParams.keys());
        for (const key of keys3) {
          urlObj.searchParams.delete(key);
        }
        return urlObj.href;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if ((urlObj == null ? void 0 : urlObj.pathname.match(/^\/presentation/)) && (urlObj == null ? void 0 : urlObj.pathname.match(/\/embed\/?$/))) {
        urlObj.pathname = urlObj.pathname.replace(/\/embed$/, "/pub");
        const keys3 = Array.from(urlObj.searchParams.keys());
        for (const key of keys3) {
          urlObj.searchParams.delete(key);
        }
        return urlObj.href;
      }
      return;
    }
  },
  {
    type: "github_gist",
    title: "GitHub Gist",
    hostnames: ["gist.github.com"],
    width: 720,
    height: 500,
    doesResize: true,
    embedOnPaste: true,
    // Security warning:
    // Gists allow adding .json extensions to the URL which return JSONP.
    // Furthermore, the JSONP can include callbacks that execute arbitrary JavaScript.
    // It _is_ sandboxed by the iframe but we still want to disable it nonetheless.
    // We restrict the id to only allow hexdecimal characters to prevent this.
    // Read more:
    //   https://github.com/bhaveshk90/Content-Security-Policy-CSP-Bypass-Techniques
    //   https://github.com/renniepak/CSPBypass
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/\/([^/]+)\/([0-9a-f]+)$/)) {
        if (!url.split("/").pop()) return;
        return url;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/\/([^/]+)\/([0-9a-f]+)$/)) {
        if (!url.split("/").pop()) return;
        return url;
      }
      return;
    }
  },
  {
    type: "replit",
    title: "Replit",
    hostnames: ["replit.com"],
    width: 720,
    height: 500,
    doesResize: true,
    embedOnPaste: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/\/@([^/]+)\/([^/]+)/)) {
        urlObj.searchParams.append("embed", "true");
        return urlObj.href;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/\/@([^/]+)\/([^/]+)/) && urlObj.searchParams.has("embed")) {
        urlObj.searchParams.delete("embed");
        return urlObj.href;
      }
      return;
    }
  },
  {
    type: "felt",
    title: "Felt",
    hostnames: ["felt.com"],
    width: 720,
    height: 500,
    doesResize: true,
    embedOnPaste: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/map\//)) {
        return urlObj.origin + "/embed" + urlObj.pathname;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/embed\/map\//)) {
        urlObj.pathname = urlObj.pathname.replace(/^\/embed/, "");
        return urlObj.href;
      }
      return;
    }
  },
  {
    type: "spotify",
    title: "Spotify",
    hostnames: ["open.spotify.com"],
    width: 720,
    height: 500,
    minHeight: 500,
    overrideOutlineRadius: 12,
    doesResize: true,
    embedOnPaste: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/(artist|album)\//)) {
        return urlObj.origin + "/embed" + urlObj.pathname;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/embed\/(artist|album)\//)) {
        return urlObj.origin + urlObj.pathname.replace(/^\/embed/, "");
      }
      return;
    }
  },
  {
    type: "vimeo",
    title: "Vimeo",
    hostnames: ["vimeo.com", "player.vimeo.com"],
    width: 640,
    height: 360,
    doesResize: true,
    isAspectRatioLocked: true,
    embedOnPaste: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.hostname === "vimeo.com") {
        if (urlObj.pathname.match(/^\/[0-9]+/)) {
          return "https://player.vimeo.com/video/" + urlObj.pathname.split("/")[1] + "?title=0&byline=0";
        }
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.hostname === "player.vimeo.com") {
        const matches2 = urlObj.pathname.match(/^\/video\/([^/]+)\/?$/);
        if (matches2) {
          return "https://vimeo.com/" + matches2[1];
        }
      }
      return;
    }
  },
  {
    type: "observable",
    title: "Observable",
    hostnames: ["observablehq.com"],
    width: 720,
    height: 500,
    doesResize: true,
    isAspectRatioLocked: false,
    backgroundColor: "#fff",
    embedOnPaste: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/@([^/]+)\/([^/]+)\/?$/)) {
        return `${urlObj.origin}/embed${urlObj.pathname}?cell=*`;
      }
      if (urlObj && urlObj.pathname.match(/^\/d\/([^/]+)\/?$/)) {
        const pathName = urlObj.pathname.replace(/^\/d/, "");
        return `${urlObj.origin}/embed${pathName}?cell=*`;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/embed\/@([^/]+)\/([^/]+)\/?$/)) {
        return `${urlObj.origin}${urlObj.pathname.replace("/embed", "")}#cell-*`;
      }
      if (urlObj && urlObj.pathname.match(/^\/embed\/([^/]+)\/?$/)) {
        return `${urlObj.origin}${urlObj.pathname.replace("/embed", "/d")}#cell-*`;
      }
      return;
    }
  },
  {
    type: "desmos",
    title: "Desmos",
    hostnames: ["desmos.com"],
    width: 700,
    height: 450,
    doesResize: true,
    embedOnPaste: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.hostname === "www.desmos.com" && urlObj.pathname.match(/^\/calculator\/([^/]+)\/?$/) && urlObj.search === "" && urlObj.hash === "") {
        return `${url}?embed`;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.hostname === "www.desmos.com" && urlObj.pathname.match(/^\/calculator\/([^/]+)\/?$/) && urlObj.search === "?embed" && urlObj.hash === "") {
        return url.replace("?embed", "");
      }
      return;
    }
  }
];
var embedShapePermissionDefaults = {
  // ========================================================================================
  // Disabled permissions
  // ========================================================================================
  // [MDN] Experimental: Allows for downloads to occur without a gesture from the user.
  // [REASON] Disabled because otherwise the <iframe/> can trick the user on behalf of us to perform an action.
  "allow-downloads-without-user-activation": false,
  // [MDN] Allows for downloads to occur with a gesture from the user.
  // [REASON] Disabled because otherwise the <iframe/> can trick the user on behalf of us to perform an action.
  "allow-downloads": false,
  // [MDN] Lets the resource open modal windows.
  // [REASON] The <iframe/> could 'window.prompt("Enter your tldraw password")'.
  "allow-modals": false,
  // [MDN] Lets the resource lock the screen orientation.
  // [REASON] Would interfere with the tldraw interface.
  "allow-orientation-lock": false,
  // [MDN] Lets the resource use the Pointer Lock API.
  // [REASON] Maybe we should allow this for games embeds (scratch/codepen/codesandbox).
  "allow-pointer-lock": false,
  // [MDN] Allows popups (such as window.open(), target="_blank", or showModalDialog()). If this keyword is not used, the popup will silently fail to open.
  // [REASON] We want to allow embeds to link back to their original sites (e.g. YouTube).
  "allow-popups": true,
  // [MDN] Lets the sandboxed document open new windows without those windows inheriting the sandboxing. For example, this can safely sandbox an advertisement without forcing the same restrictions upon the page the ad links to.
  // [REASON] We shouldn't allow popups as an embed could pretend to be us by opening a mocked version of tldraw. This is very unobvious when it is performed as an action within our app.
  "allow-popups-to-escape-sandbox": false,
  // [MDN] Lets the resource start a presentation session.
  // [REASON] Prevents embed from navigating away from tldraw and pretending to be us.
  "allow-presentation": false,
  // [MDN] Experimental: Lets the resource request access to the parent's storage capabilities with the Storage Access API.
  // [REASON] We don't want anyone else to access our storage.
  "allow-storage-access-by-user-activation": false,
  // [MDN] Lets the resource navigate the top-level browsing context (the one named _top).
  // [REASON] Prevents embed from navigating away from tldraw and pretending to be us.
  "allow-top-navigation": false,
  // [MDN] Lets the resource navigate the top-level browsing context, but only if initiated by a user gesture.
  // [REASON] Prevents embed from navigating away from tldraw and pretending to be us.
  "allow-top-navigation-by-user-activation": false,
  // ========================================================================================
  // Enabled permissions
  // ========================================================================================
  // [MDN] Lets the resource run scripts (but not create popup windows).
  "allow-scripts": true,
  // [MDN] If this token is not used, the resource is treated as being from a special origin that always fails the same-origin policy (potentially preventing access to data storage/cookies and some JavaScript APIs).
  "allow-same-origin": true,
  // [MDN] Allows the resource to submit forms. If this keyword is not used, form submission is blocked.
  "allow-forms": true
};
var DEFAULT_EMBED_DEFINITION_TYPES = DEFAULT_EMBED_DEFINITIONS.map(
  (def) => def.type
);
function isDefaultEmbedDefinitionType(type) {
  return DEFAULT_EMBED_DEFINITION_TYPES.includes(type);
}
function isCustomEmbedDefinition(def) {
  return "icon" in def;
}

// ../node_modules/tldraw/dist-esm/lib/ui/hooks/useGetEmbedDefinition.mjs
function useGetEmbedShapeUtil() {
  const editor = useMaybeEditor();
  if (!editor) return void 0;
  if (editor.hasShapeUtil("embed")) {
    return editor.getShapeUtil("embed");
  }
  return void 0;
}
function useGetEmbedDefinition() {
  const embedUtil = useGetEmbedShapeUtil();
  return (url) => {
    return embedUtil ? embedUtil.getEmbedDefinition(url) : void 0;
  };
}

// ../node_modules/tldraw/dist-esm/lib/ui/hooks/useGetEmbedDefinitions.mjs
function useGetEmbedDefinitions() {
  const embedUtil = useGetEmbedShapeUtil();
  return embedUtil ? embedUtil.getEmbedDefinitions() : [];
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/EmbedDialog.mjs
var EmbedDialog = track(function EmbedDialog2({ onClose }) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const assetUrls = useAssetUrls();
  const [embedDefinition, setEmbedDefinition] = (0, import_react65.useState)(null);
  const [url, setUrl] = (0, import_react65.useState)("");
  const [embedInfoForUrl, setEmbedInfoForUrl] = (0, import_react65.useState)(null);
  const [showError, setShowError] = (0, import_react65.useState)(false);
  const rShowErrorTimeout = (0, import_react65.useRef)(-1);
  const definitions = useGetEmbedDefinitions();
  const getEmbedDefinition = useGetEmbedDefinition();
  return (0, import_jsx_runtime97.jsxs)(import_jsx_runtime97.Fragment, { children: [
    (0, import_jsx_runtime97.jsxs)(TldrawUiDialogHeader, { children: [
      (0, import_jsx_runtime97.jsx)(TldrawUiDialogTitle, { children: embedDefinition ? `${msg2("embed-dialog.title")} — ${embedDefinition.title}` : msg2("embed-dialog.title") }),
      (0, import_jsx_runtime97.jsx)(TldrawUiDialogCloseButton, {})
    ] }),
    embedDefinition ? (0, import_jsx_runtime97.jsxs)(import_jsx_runtime97.Fragment, { children: [
      (0, import_jsx_runtime97.jsxs)(TldrawUiDialogBody, { className: "tlui-embed-dialog__enter", children: [
        (0, import_jsx_runtime97.jsx)(
          TldrawUiInput,
          {
            className: "tlui-embed-dialog__input",
            label: "embed-dialog.url",
            placeholder: "https://example.com",
            autoFocus: true,
            onValueChange: (value) => {
              setUrl(value);
              const embedInfo = getEmbedDefinition(value);
              setEmbedInfoForUrl(
                embedInfo && embedInfo.definition.type === embedDefinition.type ? embedInfo : null
              );
              setShowError(false);
              clearTimeout(rShowErrorTimeout.current);
              rShowErrorTimeout.current = editor.timers.setTimeout(
                () => setShowError(!embedInfo),
                320
              );
            }
          }
        ),
        url === "" ? (0, import_jsx_runtime97.jsxs)("div", { className: "tlui-embed-dialog__instruction", children: [
          (0, import_jsx_runtime97.jsx)("span", { children: msg2("embed-dialog.instruction") }),
          " ",
          embedDefinition.instructionLink && (0, import_jsx_runtime97.jsxs)(import_jsx_runtime97.Fragment, { children: [
            (0, import_jsx_runtime97.jsx)(
              "a",
              {
                target: "_blank",
                rel: "noopener noreferrer",
                href: embedDefinition.instructionLink,
                className: "tlui-embed-dialog__instruction__link",
                children: "Learn more"
              }
            ),
            "."
          ] })
        ] }) : (0, import_jsx_runtime97.jsx)("div", { className: "tlui-embed-dialog__warning", children: showError ? msg2("embed-dialog.invalid-url") : " " })
      ] }),
      (0, import_jsx_runtime97.jsxs)(TldrawUiDialogFooter, { className: "tlui-dialog__footer__actions", children: [
        (0, import_jsx_runtime97.jsx)(
          TldrawUiButton,
          {
            type: "normal",
            onClick: () => {
              setEmbedDefinition(null);
              setEmbedInfoForUrl(null);
              setUrl("");
            },
            children: (0, import_jsx_runtime97.jsx)(TldrawUiButtonLabel, { children: msg2("embed-dialog.back") })
          }
        ),
        (0, import_jsx_runtime97.jsx)("div", { className: "tlui-embed__spacer" }),
        (0, import_jsx_runtime97.jsx)(TldrawUiButton, { type: "normal", onClick: onClose, children: (0, import_jsx_runtime97.jsx)(TldrawUiButtonLabel, { children: msg2("embed-dialog.cancel") }) }),
        (0, import_jsx_runtime97.jsx)(
          TldrawUiButton,
          {
            type: "primary",
            disabled: !embedInfoForUrl,
            onClick: () => {
              if (!embedInfoForUrl) return;
              editor.putExternalContent({
                type: "embed",
                url,
                point: editor.getViewportPageBounds().center,
                embed: embedInfoForUrl.definition
              });
              onClose();
            },
            children: (0, import_jsx_runtime97.jsx)(TldrawUiButtonLabel, { children: msg2("embed-dialog.create") })
          }
        )
      ] })
    ] }) : (0, import_jsx_runtime97.jsx)(import_jsx_runtime97.Fragment, { children: (0, import_jsx_runtime97.jsx)(TldrawUiDialogBody, { className: "tlui-embed-dialog__list", children: definitions.map((def) => {
      const url2 = isDefaultEmbedDefinitionType(def.type) ? assetUrls.embedIcons[def.type] : isCustomEmbedDefinition(def) ? def.icon : void 0;
      return (0, import_jsx_runtime97.jsxs)(TldrawUiButton, { type: "menu", onClick: () => setEmbedDefinition(def), children: [
        (0, import_jsx_runtime97.jsx)(TldrawUiButtonLabel, { children: untranslated(def.title) }),
        url2 && (0, import_jsx_runtime97.jsx)(
          "div",
          {
            className: "tlui-embed-dialog__item__image",
            style: { backgroundImage: `url(${url2})` }
          }
        )
      ] }, def.type);
    }) }) })
  ] });
});

// ../node_modules/tldraw/dist-esm/lib/ui/components/KeyboardShortcutsDialog/DefaultKeyboardShortcutsDialog.mjs
var import_jsx_runtime115 = __toESM(require_jsx_runtime(), 1);
var import_classnames23 = __toESM(require_classnames(), 1);
var import_react80 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/constants.mjs
var PORTRAIT_BREAKPOINTS = [0, 389, 436, 476, 580, 640, 840, 1023];
var PORTRAIT_BREAKPOINT = ((PORTRAIT_BREAKPOINT2) => {
  PORTRAIT_BREAKPOINT2[PORTRAIT_BREAKPOINT2["ZERO"] = 0] = "ZERO";
  PORTRAIT_BREAKPOINT2[PORTRAIT_BREAKPOINT2["MOBILE_XXS"] = 1] = "MOBILE_XXS";
  PORTRAIT_BREAKPOINT2[PORTRAIT_BREAKPOINT2["MOBILE_XS"] = 2] = "MOBILE_XS";
  PORTRAIT_BREAKPOINT2[PORTRAIT_BREAKPOINT2["MOBILE_SM"] = 3] = "MOBILE_SM";
  PORTRAIT_BREAKPOINT2[PORTRAIT_BREAKPOINT2["MOBILE"] = 4] = "MOBILE";
  PORTRAIT_BREAKPOINT2[PORTRAIT_BREAKPOINT2["TABLET_SM"] = 5] = "TABLET_SM";
  PORTRAIT_BREAKPOINT2[PORTRAIT_BREAKPOINT2["TABLET"] = 6] = "TABLET";
  PORTRAIT_BREAKPOINT2[PORTRAIT_BREAKPOINT2["DESKTOP"] = 7] = "DESKTOP";
  return PORTRAIT_BREAKPOINT2;
})(PORTRAIT_BREAKPOINT || {});

// ../node_modules/tldraw/dist-esm/lib/ui/context/breakpoints.mjs
var import_jsx_runtime98 = __toESM(require_jsx_runtime(), 1);
var import_react66 = __toESM(require_react(), 1);
var BreakpointContext = import_react66.default.createContext(null);
function BreakPointProvider({ forceMobile = false, children }) {
  const editor = useMaybeEditor();
  const breakpoint = useValue(
    "breakpoint",
    () => {
      const { width } = (editor == null ? void 0 : editor.getViewportScreenBounds()) ?? { width: window.innerWidth };
      const maxBreakpoint = forceMobile ? PORTRAIT_BREAKPOINT.MOBILE_SM : PORTRAIT_BREAKPOINTS.length - 1;
      for (let i = 0; i < maxBreakpoint; i++) {
        if (width > PORTRAIT_BREAKPOINTS[i] && width <= PORTRAIT_BREAKPOINTS[i + 1]) {
          return i;
        }
      }
      return maxBreakpoint;
    },
    [editor]
  );
  return (0, import_jsx_runtime98.jsx)(BreakpointContext.Provider, { value: breakpoint, children });
}
function useBreakpoint() {
  const breakpoint = (0, import_react66.useContext)(BreakpointContext);
  if (breakpoint === null) {
    throw new Error("useBreakpoint must be used inside of the <BreakpointProvider /> component");
  }
  return breakpoint;
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/primitives/menus/TldrawUiMenuContext.mjs
var import_jsx_runtime99 = __toESM(require_jsx_runtime(), 1);
var import_react67 = __toESM(require_react(), 1);
var menuContext = (0, import_react67.createContext)(null);
function useTldrawUiMenuContext() {
  const context = (0, import_react67.useContext)(menuContext);
  if (!context) {
    throw new Error("useTldrawUiMenuContext must be used within a TldrawUiMenuContextProvider");
  }
  return context;
}
function TldrawUiMenuContextProvider({
  type,
  sourceId,
  children
}) {
  return (0, import_jsx_runtime99.jsx)(menuContext.Provider, { value: { type, sourceId }, children });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/KeyboardShortcutsDialog/DefaultKeyboardShortcutsDialogContent.mjs
var import_jsx_runtime114 = __toESM(require_jsx_runtime(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/hooks/useCollaborationStatus.mjs
function useShowCollaborationUi() {
  const editor = useMaybeEditor();
  return (editor == null ? void 0 : editor.store.props.collaboration) !== void 0;
}
function useCollaborationStatus() {
  const editor = useMaybeEditor();
  return useValue(
    "sync status",
    () => {
      var _a6;
      if (!((_a6 = editor == null ? void 0 : editor.store.props.collaboration) == null ? void 0 : _a6.status)) {
        return null;
      }
      return editor.store.props.collaboration.status.get();
    },
    [editor]
  );
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/primitives/menus/TldrawUiMenuActionItem.mjs
var import_jsx_runtime108 = __toESM(require_jsx_runtime(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/components/primitives/menus/TldrawUiMenuItem.mjs
var import_jsx_runtime107 = __toESM(require_jsx_runtime(), 1);
var import_react72 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/hooks/useReadonly.mjs
function useReadonly() {
  const editor = useMaybeEditor();
  return useValue("isReadonlyMode", () => !!(editor == null ? void 0 : editor.getIsReadonly()), [editor]);
}

// ../node_modules/tldraw/dist-esm/lib/ui/kbd-utils.mjs
var cmdKey = tlenv.isDarwin ? "⌘" : "__CTRL__";
var ctrlKey = tlenv.isDarwin ? "⌃" : "__CTRL__";
var altKey = tlenv.isDarwin ? "⌥" : "__ALT__";
function kbd(str) {
  if (str === ",") return [","];
  return str.split(",")[0].split(/(\[\[[^\]]+\]\])/g).map(
    (s) => s.startsWith("[[") ? s.replace(/[[\]]/g, "") : s.replace(/cmd\+/g, cmdKey).replace(/ctrl\+/g, ctrlKey).replace(/alt\+/g, altKey).replace(/shift\+/g, "⇧").replace(/\$/g, cmdKey).replace(/\?/g, altKey).replace(/!/g, "⇧").match(/__CTRL__|__ALT__|./g) || []
  ).flat().map((sub, index2) => {
    if (sub[0] === "+") return [];
    let modifiedKey;
    if (sub === "__CTRL__") {
      modifiedKey = "Ctrl";
    } else if (sub === "__ALT__") {
      modifiedKey = "Alt";
    } else {
      modifiedKey = sub[0].toUpperCase() + sub.slice(1);
    }
    return tlenv.isDarwin || !index2 ? modifiedKey : ["+", modifiedKey];
  }).flat();
}
function kbdStr(str) {
  return "— " + kbd(str).join(" ");
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/Spinner.mjs
var import_jsx_runtime100 = __toESM(require_jsx_runtime(), 1);
function Spinner(props) {
  const msg2 = useTranslation();
  return (0, import_jsx_runtime100.jsx)(DefaultSpinner, { "aria-label": msg2("app.loading"), ...props });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/primitives/TldrawUiDropdownMenu.mjs
var import_jsx_runtime102 = __toESM(require_jsx_runtime(), 1);
var import_classnames19 = __toESM(require_classnames(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/hooks/useMenuIsOpen.mjs
var import_react68 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/context/events.mjs
var import_jsx_runtime101 = __toESM(require_jsx_runtime(), 1);
var React84 = __toESM(require_react(), 1);
var defaultEventHandler = () => void 0;
var EventsContext = React84.createContext(null);
function TldrawUiEventsProvider({ onEvent, children }) {
  return (0, import_jsx_runtime101.jsx)(EventsContext.Provider, { value: onEvent ?? defaultEventHandler, children });
}
function useUiEvents() {
  const eventHandler2 = React84.useContext(EventsContext);
  return eventHandler2 ?? defaultEventHandler;
}

// ../node_modules/tldraw/dist-esm/lib/ui/hooks/useMenuIsOpen.mjs
function useMenuIsOpen(id, cb) {
  const editor = useMaybeEditor();
  const onChange = (0, import_react68.useCallback)(
    (isOpen) => {
      if (isOpen) {
        editor == null ? void 0 : editor.complete();
      }
      cb == null ? void 0 : cb(isOpen);
    },
    [editor, cb]
  );
  const trackEvent = useUiEvents();
  const onEvent = (0, import_react68.useCallback)(
    (eventName) => {
      trackEvent(eventName, { source: "unknown", id });
    },
    [id, trackEvent]
  );
  return useGlobalMenuIsOpen(editor ? `${id}-${editor.contextId}` : id, onChange, onEvent);
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/primitives/TldrawUiDropdownMenu.mjs
function TldrawUiDropdownMenuRoot({
  id,
  children,
  modal = false,
  debugOpen = false
}) {
  const [open, onOpenChange] = useMenuIsOpen(id);
  return (0, import_jsx_runtime102.jsx)(
    dist_exports10.Root,
    {
      open: debugOpen || open,
      dir: "ltr",
      modal,
      onOpenChange,
      children
    }
  );
}
function TldrawUiDropdownMenuTrigger({ children, ...rest }) {
  return (0, import_jsx_runtime102.jsx)(
    dist_exports10.Trigger,
    {
      dir: "ltr",
      asChild: true,
      onTouchEnd: (e) => preventDefault(e),
      ...rest,
      children
    }
  );
}
function TldrawUiDropdownMenuContent({
  className,
  side = "bottom",
  align = "start",
  sideOffset = 8,
  alignOffset = 8,
  children
}) {
  const container = useContainer();
  return (0, import_jsx_runtime102.jsx)(dist_exports10.Portal, { container, children: (0, import_jsx_runtime102.jsx)(
    dist_exports10.Content,
    {
      className: (0, import_classnames19.default)("tlui-menu", className),
      side,
      sideOffset,
      align,
      alignOffset,
      collisionPadding: 4,
      children
    }
  ) });
}
function TldrawUiDropdownMenuSub({ id, children }) {
  const [open, onOpenChange] = useMenuIsOpen(id);
  return (0, import_jsx_runtime102.jsx)(dist_exports10.Sub, { open, onOpenChange, children });
}
function TldrawUiDropdownMenuSubTrigger({
  id,
  label,
  title,
  disabled
}) {
  return (0, import_jsx_runtime102.jsx)(dist_exports10.SubTrigger, { dir: "ltr", asChild: true, disabled, children: (0, import_jsx_runtime102.jsxs)(
    TldrawUiButton,
    {
      "data-testid": id,
      type: "menu",
      className: "tlui-menu__submenu__trigger",
      disabled,
      title,
      children: [
        (0, import_jsx_runtime102.jsx)(TldrawUiButtonLabel, { children: label }),
        (0, import_jsx_runtime102.jsx)(TldrawUiButtonIcon, { icon: "chevron-right", small: true })
      ]
    }
  ) });
}
function TldrawUiDropdownMenuSubContent({
  id,
  alignOffset = -1,
  sideOffset = -6,
  size: size4 = "small",
  children
}) {
  const container = useContainer();
  return (0, import_jsx_runtime102.jsx)(dist_exports10.Portal, { container, children: (0, import_jsx_runtime102.jsx)(
    dist_exports10.SubContent,
    {
      "data-testid": id,
      className: "tlui-menu tlui-menu__submenu__content",
      alignOffset,
      sideOffset,
      collisionPadding: 4,
      "data-size": size4,
      children
    }
  ) });
}
function TldrawUiDropdownMenuGroup({ className, children }) {
  return (0, import_jsx_runtime102.jsx)("div", { dir: "ltr", className: (0, import_classnames19.default)("tlui-menu__group", className), children });
}
function TldrawUiDropdownMenuIndicator() {
  const msg2 = useTranslation();
  return (0, import_jsx_runtime102.jsx)(dist_exports10.ItemIndicator, { dir: "ltr", asChild: true, children: (0, import_jsx_runtime102.jsx)(TldrawUiIcon, { label: msg2("ui.checked"), icon: "check" }) });
}
function TldrawUiDropdownMenuItem({ noClose, children }) {
  return (0, import_jsx_runtime102.jsx)(dist_exports10.Item, { dir: "ltr", asChild: true, onClick: noClose ? preventDefault : void 0, children });
}
function TldrawUiDropdownMenuCheckboxItem({
  children,
  onSelect,
  ...rest
}) {
  const msg2 = useTranslation();
  return (0, import_jsx_runtime102.jsxs)(
    dist_exports10.CheckboxItem,
    {
      dir: "ltr",
      className: "tlui-button tlui-button__menu tlui-button__checkbox",
      onSelect: (e) => {
        onSelect == null ? void 0 : onSelect(e);
        preventDefault(e);
      },
      ...rest,
      children: [
        (0, import_jsx_runtime102.jsx)("div", { className: "tlui-button__checkbox__indicator", children: (0, import_jsx_runtime102.jsx)(dist_exports10.ItemIndicator, { dir: "ltr", children: (0, import_jsx_runtime102.jsx)(TldrawUiIcon, { label: msg2("ui.checked"), icon: "check", small: true }) }) }),
        children
      ]
    }
  );
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/primitives/TldrawUiKbd.mjs
var import_jsx_runtime103 = __toESM(require_jsx_runtime(), 1);
function TldrawUiKbd({ children, visibleOnMobileLayout = false }) {
  const breakpoint = useBreakpoint();
  if (!visibleOnMobileLayout && breakpoint < PORTRAIT_BREAKPOINT.MOBILE) return null;
  return (0, import_jsx_runtime103.jsx)("kbd", { className: "tlui-kbd", children: kbd(children).map((k, i) => (0, import_jsx_runtime103.jsx)("span", { children: k }, i)) });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/primitives/TldrawUiToolbar.mjs
var import_jsx_runtime106 = __toESM(require_jsx_runtime(), 1);
var import_classnames21 = __toESM(require_classnames(), 1);
var import_react71 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/components/primitives/layout.mjs
var import_jsx_runtime104 = __toESM(require_jsx_runtime(), 1);
var import_classnames20 = __toESM(require_classnames(), 1);
var import_react69 = __toESM(require_react(), 1);
var TldrawUiOrientationContext = (0, import_react69.createContext)({
  orientation: "horizontal",
  tooltipSide: "bottom"
});
function TldrawUiOrientationProvider({
  children,
  orientation,
  tooltipSide
}) {
  const prevContext = useTldrawUiOrientation();
  const tooltipSideToUse = tooltipSide ?? (orientation === prevContext.orientation ? prevContext.tooltipSide : orientation === "horizontal" ? "bottom" : "right");
  return (0, import_jsx_runtime104.jsx)(TldrawUiOrientationContext.Provider, { value: { orientation, tooltipSide: tooltipSideToUse }, children });
}
function useTldrawUiOrientation() {
  return (0, import_react69.useContext)(TldrawUiOrientationContext);
}
var TldrawUiRow = (0, import_react69.forwardRef)(
  ({ asChild, className, tooltipSide, ...props }, ref) => {
    const Component2 = asChild ? dist_exports.Root : "div";
    return (0, import_jsx_runtime104.jsx)(TldrawUiOrientationProvider, { orientation: "horizontal", tooltipSide, children: (0, import_jsx_runtime104.jsx)(Component2, { ref, className: (0, import_classnames20.default)("tlui-row", className), ...props }) });
  }
);
var TldrawUiColumn = (0, import_react69.forwardRef)(
  ({ asChild, className, tooltipSide, ...props }, ref) => {
    const Component2 = asChild ? dist_exports.Root : "div";
    return (0, import_jsx_runtime104.jsx)(TldrawUiOrientationProvider, { orientation: "vertical", tooltipSide, children: (0, import_jsx_runtime104.jsx)(Component2, { ref, className: (0, import_classnames20.default)("tlui-column", className), ...props }) });
  }
);
var TldrawUiGrid = (0, import_react69.forwardRef)(
  ({ asChild, className, tooltipSide, ...props }, ref) => {
    const Component2 = asChild ? dist_exports.Root : "div";
    return (0, import_jsx_runtime104.jsx)(TldrawUiOrientationProvider, { orientation: "horizontal", tooltipSide, children: (0, import_jsx_runtime104.jsx)(Component2, { ref, className: (0, import_classnames20.default)("tlui-grid", className), ...props }) });
  }
);

// ../node_modules/tldraw/dist-esm/lib/ui/components/primitives/TldrawUiTooltip.mjs
var import_jsx_runtime105 = __toESM(require_jsx_runtime(), 1);
var import_react70 = __toESM(require_react(), 1);
var DEFAULT_TOOLTIP_DELAY_MS = 700;
var _TooltipManager = class _TooltipManager {
  constructor() {
    __publicField(this, "state", atom("tooltip state", { name: "idle" }));
  }
  static getInstance() {
    if (!_TooltipManager.instance) {
      _TooltipManager.instance = new _TooltipManager();
    }
    return _TooltipManager.instance;
  }
  hideAllTooltips() {
    this.handleEvent({ type: "hide_all" });
  }
  handleEvent(event) {
    const currentState = this.state.get();
    switch (event.type) {
      case "pointer_down": {
        if (currentState.name === "waiting_to_hide") {
          clearTimeout(currentState.timeoutId);
        }
        this.state.set({ name: "pointer_down" });
        break;
      }
      case "pointer_up": {
        if (currentState.name === "pointer_down") {
          this.state.set({ name: "idle" });
        }
        break;
      }
      case "show": {
        if (currentState.name === "pointer_down") {
          return;
        }
        if (currentState.name === "waiting_to_hide") {
          clearTimeout(currentState.timeoutId);
        }
        this.state.set({ name: "showing", tooltip: event.tooltip });
        break;
      }
      case "hide": {
        const { tooltipId, editor, instant } = event;
        if (currentState.name === "showing" && currentState.tooltip.id === tooltipId) {
          if (editor && !instant) {
            const timeoutId = editor.timers.setTimeout(() => {
              const state = this.state.get();
              if (state.name === "waiting_to_hide" && state.tooltip.id === tooltipId) {
                this.state.set({ name: "idle" });
              }
            }, 300);
            this.state.set({
              name: "waiting_to_hide",
              tooltip: currentState.tooltip,
              timeoutId
            });
          } else {
            this.state.set({ name: "idle" });
          }
        } else if (currentState.name === "waiting_to_hide" && currentState.tooltip.id === tooltipId) {
          if (instant) {
            clearTimeout(currentState.timeoutId);
            this.state.set({ name: "idle" });
          }
        }
        break;
      }
      case "hide_all": {
        if (currentState.name === "waiting_to_hide") {
          clearTimeout(currentState.timeoutId);
        }
        if (currentState.name === "pointer_down") {
          return;
        }
        this.state.set({ name: "idle" });
        break;
      }
    }
  }
  getCurrentTooltipData() {
    const currentState = this.state.get();
    let tooltip = null;
    if (currentState.name === "showing") {
      tooltip = currentState.tooltip;
    } else if (currentState.name === "waiting_to_hide") {
      tooltip = currentState.tooltip;
    }
    if (!tooltip) return null;
    if (tlenvReactive.get().isCoarsePointer && !tooltip.showOnMobile) return null;
    return tooltip;
  }
};
__publicField(_TooltipManager, "instance", null);
var TooltipManager = _TooltipManager;
var tooltipManager = TooltipManager.getInstance();
function hideAllTooltips() {
  tooltipManager.hideAllTooltips();
}
var TooltipSingletonContext = (0, import_react70.createContext)(false);
function TldrawUiTooltipProvider({ children }) {
  return (0, import_jsx_runtime105.jsx)(dist_exports19.Provider, { skipDelayDuration: 700, children: (0, import_jsx_runtime105.jsxs)(TooltipSingletonContext.Provider, { value: true, children: [
    children,
    (0, import_jsx_runtime105.jsx)(TooltipSingleton, {})
  ] }) });
}
function TooltipSingleton() {
  const [isOpen, setIsOpen] = (0, import_react70.useState)(false);
  const triggerRef = (0, import_react70.useRef)(null);
  const isFirstShowRef = (0, import_react70.useRef)(true);
  const editor = useMaybeEditor();
  const currentTooltip = useValue(
    "current tooltip",
    () => tooltipManager.getCurrentTooltipData(),
    []
  );
  const cameraState = useValue("camera state", () => editor == null ? void 0 : editor.getCameraState(), [editor]);
  (0, import_react70.useEffect)(() => {
    if (cameraState === "moving" && isOpen && currentTooltip) {
      tooltipManager.handleEvent({
        type: "hide",
        tooltipId: currentTooltip.id,
        editor,
        instant: true
      });
    }
  }, [cameraState, isOpen, currentTooltip, editor]);
  (0, import_react70.useEffect)(() => {
    function handleKeyDown2(event) {
      if (event.key === "Escape" && currentTooltip && isOpen) {
        hideAllTooltips();
        event.stopPropagation();
      }
    }
    document.addEventListener("keydown", handleKeyDown2, { capture: true });
    return () => {
      document.removeEventListener("keydown", handleKeyDown2, { capture: true });
    };
  }, [currentTooltip, isOpen]);
  (0, import_react70.useEffect)(() => {
    function handlePointerDown() {
      tooltipManager.handleEvent({ type: "pointer_down" });
    }
    function handlePointerUp() {
      tooltipManager.handleEvent({ type: "pointer_up" });
    }
    document.addEventListener("pointerdown", handlePointerDown, { capture: true });
    document.addEventListener("pointerup", handlePointerUp, { capture: true });
    document.addEventListener("pointercancel", handlePointerUp, { capture: true });
    return () => {
      document.removeEventListener("pointerdown", handlePointerDown, { capture: true });
      document.removeEventListener("pointerup", handlePointerUp, { capture: true });
      document.removeEventListener("pointercancel", handlePointerUp, { capture: true });
      tooltipManager.handleEvent({ type: "pointer_up" });
    };
  }, []);
  (0, import_react70.useEffect)(() => {
    let timer = null;
    if (currentTooltip && triggerRef.current) {
      const activeRect = currentTooltip.targetElement.getBoundingClientRect();
      const trigger2 = triggerRef.current;
      trigger2.style.position = "fixed";
      trigger2.style.left = `${activeRect.left}px`;
      trigger2.style.top = `${activeRect.top}px`;
      trigger2.style.width = `${activeRect.width}px`;
      trigger2.style.height = `${activeRect.height}px`;
      trigger2.style.pointerEvents = "none";
      trigger2.style.zIndex = "9999";
      if (isFirstShowRef.current) {
        timer = setTimeout(() => {
          setIsOpen(true);
          isFirstShowRef.current = false;
        }, currentTooltip.delayDuration);
      } else {
        setIsOpen(true);
      }
    } else {
      setIsOpen(false);
      isFirstShowRef.current = true;
    }
    return () => {
      if (timer !== null) {
        clearTimeout(timer);
      }
    };
  }, [currentTooltip]);
  if (!currentTooltip) {
    return null;
  }
  return (0, import_jsx_runtime105.jsxs)(dist_exports19.Root, { open: isOpen, delayDuration: 0, children: [
    (0, import_jsx_runtime105.jsx)(dist_exports19.Trigger, { asChild: true, children: (0, import_jsx_runtime105.jsx)("div", { ref: triggerRef }) }),
    (0, import_jsx_runtime105.jsxs)(
      dist_exports19.Content,
      {
        className: "tlui-tooltip",
        side: currentTooltip.side,
        sideOffset: currentTooltip.sideOffset,
        avoidCollisions: true,
        collisionPadding: 8,
        dir: "ltr",
        children: [
          currentTooltip.content,
          (0, import_jsx_runtime105.jsx)(dist_exports19.Arrow, { className: "tlui-tooltip__arrow" })
        ]
      }
    )
  ] });
}
var TldrawUiTooltip = (0, import_react70.forwardRef)(
  ({
    children,
    content,
    side,
    sideOffset = 5,
    disabled = false,
    showOnMobile = false,
    delayDuration
  }, ref) => {
    const editor = useMaybeEditor();
    const tooltipId = (0, import_react70.useRef)(uniqueId());
    const hasProvider = (0, import_react70.useContext)(TooltipSingletonContext);
    const enhancedA11yMode = useValue(
      "enhancedA11yMode",
      () => editor == null ? void 0 : editor.user.getEnhancedA11yMode(),
      [editor]
    );
    const orientationCtx = useTldrawUiOrientation();
    const sideToUse = side ?? orientationCtx.tooltipSide;
    (0, import_react70.useEffect)(() => {
      const currentTooltipId = tooltipId.current;
      return () => {
        if (hasProvider) {
          tooltipManager.handleEvent({
            type: "hide",
            tooltipId: currentTooltipId,
            editor,
            instant: true
          });
        }
      };
    }, [editor, hasProvider]);
    if (disabled || !content) {
      return (0, import_jsx_runtime105.jsx)(import_jsx_runtime105.Fragment, { children });
    }
    let delayDurationToUse;
    if (enhancedA11yMode) {
      delayDurationToUse = 0;
    } else {
      delayDurationToUse = delayDuration ?? ((editor == null ? void 0 : editor.options.tooltipDelayMs) || DEFAULT_TOOLTIP_DELAY_MS);
    }
    if (!hasProvider || enhancedA11yMode) {
      return (0, import_jsx_runtime105.jsxs)(
        dist_exports19.Root,
        {
          delayDuration: delayDurationToUse,
          disableHoverableContent: !enhancedA11yMode,
          children: [
            (0, import_jsx_runtime105.jsx)(dist_exports19.Trigger, { asChild: true, ref, children }),
            (0, import_jsx_runtime105.jsxs)(
              dist_exports19.Content,
              {
                className: "tlui-tooltip",
                side: sideToUse,
                sideOffset,
                avoidCollisions: true,
                collisionPadding: 8,
                dir: "ltr",
                children: [
                  content,
                  (0, import_jsx_runtime105.jsx)(dist_exports19.Arrow, { className: "tlui-tooltip__arrow" })
                ]
              }
            )
          ]
        }
      );
    }
    const child = import_react70.default.Children.only(children);
    assert(import_react70.default.isValidElement(child), "TldrawUiTooltip children must be a single element");
    const childElement = child;
    const handleMouseEnter = (event) => {
      var _a6, _b3;
      (_b3 = (_a6 = childElement.props).onMouseEnter) == null ? void 0 : _b3.call(_a6, event);
      tooltipManager.handleEvent({
        type: "show",
        tooltip: {
          id: tooltipId.current,
          content,
          targetElement: event.currentTarget,
          side: sideToUse,
          sideOffset,
          showOnMobile,
          delayDuration: delayDurationToUse
        }
      });
    };
    const handleMouseLeave = (event) => {
      var _a6, _b3;
      (_b3 = (_a6 = childElement.props).onMouseLeave) == null ? void 0 : _b3.call(_a6, event);
      tooltipManager.handleEvent({
        type: "hide",
        tooltipId: tooltipId.current,
        editor,
        instant: false
      });
    };
    const handleFocus = (event) => {
      var _a6, _b3;
      (_b3 = (_a6 = childElement.props).onFocus) == null ? void 0 : _b3.call(_a6, event);
      tooltipManager.handleEvent({
        type: "show",
        tooltip: {
          id: tooltipId.current,
          content,
          targetElement: event.currentTarget,
          side: sideToUse,
          sideOffset,
          showOnMobile,
          delayDuration: delayDurationToUse
        }
      });
    };
    const handleBlur = (event) => {
      var _a6, _b3;
      (_b3 = (_a6 = childElement.props).onBlur) == null ? void 0 : _b3.call(_a6, event);
      tooltipManager.handleEvent({
        type: "hide",
        tooltipId: tooltipId.current,
        editor,
        instant: false
      });
    };
    const childrenWithHandlers = import_react70.default.cloneElement(childElement, {
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      onFocus: handleFocus,
      onBlur: handleBlur
    });
    return childrenWithHandlers;
  }
);

// ../node_modules/tldraw/dist-esm/lib/ui/components/primitives/TldrawUiToolbar.mjs
var LayoutByOrientation = {
  horizontal: TldrawUiRow,
  vertical: TldrawUiColumn,
  grid: TldrawUiGrid
};
var TldrawUiToolbar = import_react71.default.forwardRef(
  ({
    children,
    className,
    label,
    orientation = "horizontal",
    tooltipSide,
    ...props
  }, ref) => {
    const Layout2 = LayoutByOrientation[orientation];
    return (0, import_jsx_runtime106.jsx)(Layout2, { asChild: true, tooltipSide, children: (0, import_jsx_runtime106.jsx)(
      dist_exports16.Root,
      {
        ref,
        ...props,
        className: (0, import_classnames21.default)("tlui-toolbar", className),
        "aria-label": label,
        orientation: orientation === "grid" ? "horizontal" : orientation,
        children
      }
    ) });
  }
);
var TldrawUiToolbarButton = import_react71.default.forwardRef(
  ({ asChild, children, type, isActive: isActive2, tooltip, ...props }, ref) => {
    const button = (0, import_jsx_runtime106.jsx)(
      dist_exports16.Button,
      {
        ref,
        asChild,
        draggable: false,
        "data-isactive": isActive2,
        ...props,
        "aria-label": props.title,
        title: void 0,
        className: (0, import_classnames21.default)("tlui-button", `tlui-button__${type}`, props.className),
        children
      }
    );
    const tooltipContent = tooltip || props.title;
    return (0, import_jsx_runtime106.jsx)(TldrawUiTooltip, { content: tooltipContent, children: button });
  }
);
var TldrawUiToolbarToggleGroup = ({
  children,
  className,
  type,
  asChild,
  ...props
}) => {
  return (0, import_jsx_runtime106.jsx)(
    dist_exports16.ToggleGroup,
    {
      asChild,
      type,
      ...props,
      role: "radiogroup",
      className: (0, import_classnames21.default)("tlui-toolbar-toggle-group", className),
      children
    }
  );
};
var TldrawUiToolbarToggleItem = ({
  children,
  className,
  type,
  value,
  tooltip,
  ...props
}) => {
  const toggleItem = (0, import_jsx_runtime106.jsx)(
    dist_exports16.ToggleItem,
    {
      ...props,
      title: void 0,
      className: (0, import_classnames21.default)(
        "tlui-button",
        `tlui-button__${type}`,
        "tlui-toolbar-toggle-group-item",
        className
      ),
      value,
      children
    }
  );
  const tooltipContent = tooltip || props.title;
  return (0, import_jsx_runtime106.jsx)(TldrawUiTooltip, { content: tooltipContent, children: toggleItem });
};

// ../node_modules/tldraw/dist-esm/lib/ui/components/primitives/menus/TldrawUiMenuItem.mjs
function TldrawUiMenuItem({
  disabled = false,
  spinner = false,
  readonlyOk = false,
  id,
  kbd: kbd2,
  label,
  icon,
  iconLeft,
  onSelect,
  noClose,
  isSelected,
  onDragStart
}) {
  const { type: menuType, sourceId } = useTldrawUiMenuContext();
  const msg2 = useTranslation();
  const [disableClicks, setDisableClicks] = (0, import_react72.useState)(false);
  const isReadonlyMode = useReadonly();
  if (isReadonlyMode && !readonlyOk) return null;
  const labelToUse = unwrapLabel(label, menuType);
  const kbdToUse = kbd2 ? kbdStr(kbd2) : void 0;
  const labelStr = labelToUse ? msg2(labelToUse) : void 0;
  const titleStr = labelStr && kbdToUse ? `${labelStr} ${kbdToUse}` : labelStr;
  switch (menuType) {
    case "menu": {
      return (0, import_jsx_runtime107.jsx)(TldrawUiDropdownMenuItem, { children: (0, import_jsx_runtime107.jsxs)(
        TldrawUiButton,
        {
          type: "menu",
          "data-testid": `${sourceId}.${id}`,
          disabled,
          onClick: (e) => {
            if (noClose) {
              preventDefault(e);
            }
            if (disableClicks) {
              setDisableClicks(false);
            } else {
              onSelect(sourceId);
            }
          },
          children: [
            iconLeft && (0, import_jsx_runtime107.jsx)(TldrawUiButtonIcon, { icon: iconLeft, small: true }),
            (0, import_jsx_runtime107.jsx)(TldrawUiButtonLabel, { children: labelStr }),
            kbd2 && (0, import_jsx_runtime107.jsx)(TldrawUiKbd, { children: kbd2 })
          ]
        }
      ) });
    }
    case "context-menu": {
      if (disabled) return null;
      return (0, import_jsx_runtime107.jsxs)(
        dist_exports8.Item,
        {
          dir: "ltr",
          draggable: false,
          className: "tlui-button tlui-button__menu",
          "data-testid": `${sourceId}.${id}`,
          onSelect: (e) => {
            if (noClose) preventDefault(e);
            if (disableClicks) {
              setDisableClicks(false);
            } else {
              onSelect(sourceId);
            }
          },
          children: [
            (0, import_jsx_runtime107.jsx)("span", { className: "tlui-button__label", draggable: false, children: labelStr }),
            iconLeft && (0, import_jsx_runtime107.jsx)(TldrawUiButtonIcon, { icon: iconLeft, small: true }),
            kbd2 && (0, import_jsx_runtime107.jsx)(TldrawUiKbd, { children: kbd2 }),
            spinner && (0, import_jsx_runtime107.jsx)(Spinner, {})
          ]
        }
      );
    }
    case "small-icons":
    case "icons": {
      return (0, import_jsx_runtime107.jsx)(
        TldrawUiToolbarButton,
        {
          "data-testid": `${sourceId}.${id}`,
          type: "icon",
          title: titleStr,
          disabled,
          onClick: () => onSelect(sourceId),
          children: (0, import_jsx_runtime107.jsx)(TldrawUiButtonIcon, { icon, small: true })
        }
      );
    }
    case "keyboard-shortcuts": {
      if (!kbd2) {
        console.warn(
          `Menu item '${label}' isn't shown in the keyboard shortcuts dialog because it doesn't have a keyboard shortcut.`
        );
        return null;
      }
      return (0, import_jsx_runtime107.jsxs)("div", { className: "tlui-shortcuts-dialog__key-pair", "data-testid": `${sourceId}.${id}`, children: [
        (0, import_jsx_runtime107.jsx)("div", { className: "tlui-shortcuts-dialog__key-pair__key", children: labelStr }),
        (0, import_jsx_runtime107.jsx)("div", { className: "tlui-shortcuts-dialog__key-pair__value", children: (0, import_jsx_runtime107.jsx)(TldrawUiKbd, { visibleOnMobileLayout: true, children: kbd2 }) })
      ] });
    }
    case "helper-buttons": {
      return (0, import_jsx_runtime107.jsxs)(
        TldrawUiButton,
        {
          type: "low",
          "data-testid": `${sourceId}.${id}`,
          onClick: () => onSelect(sourceId),
          children: [
            (0, import_jsx_runtime107.jsx)(TldrawUiButtonIcon, { icon }),
            (0, import_jsx_runtime107.jsx)(TldrawUiButtonLabel, { children: labelStr })
          ]
        }
      );
    }
    case "toolbar": {
      if (onDragStart) {
        return (0, import_jsx_runtime107.jsx)(
          DraggableToolbarButton,
          {
            id,
            icon,
            onSelect,
            onDragStart,
            labelStr,
            titleStr,
            disabled,
            isSelected
          }
        );
      }
      return (0, import_jsx_runtime107.jsx)(
        TldrawUiToolbarButton,
        {
          "aria-label": labelStr,
          "aria-pressed": isSelected ? "true" : "false",
          "data-testid": `tools.${id}`,
          "data-value": id,
          disabled,
          onClick: () => onSelect("toolbar"),
          onTouchStart: (e) => {
            preventDefault(e);
            onSelect("toolbar");
          },
          title: titleStr,
          type: "tool",
          children: (0, import_jsx_runtime107.jsx)(TldrawUiButtonIcon, { icon })
        }
      );
    }
    case "toolbar-overflow": {
      if (onDragStart) {
        return (0, import_jsx_runtime107.jsx)(
          DraggableToolbarButton,
          {
            id,
            icon,
            onSelect,
            onDragStart,
            labelStr,
            titleStr,
            disabled,
            isSelected,
            overflow: true
          }
        );
      }
      return (0, import_jsx_runtime107.jsx)(
        TldrawUiToolbarButton,
        {
          "aria-label": labelStr,
          "aria-pressed": isSelected ? "true" : "false",
          isActive: isSelected,
          "data-testid": `tools.more.${id}`,
          "data-value": id,
          disabled,
          onClick: () => onSelect("toolbar"),
          title: titleStr,
          type: "icon",
          children: (0, import_jsx_runtime107.jsx)(TldrawUiButtonIcon, { icon })
        }
      );
    }
    default: {
      throw exhaustiveSwitchError(menuType);
    }
  }
}
function useDraggableEvents(onDragStart, onSelect) {
  const editor = useEditor();
  const events = (0, import_react72.useMemo)(() => {
    let state = { name: "idle" };
    function handlePointerDown(e) {
      state = {
        name: "pointing",
        screenSpaceStart: { x: e.clientX, y: e.clientY }
      };
      e.currentTarget.setPointerCapture(e.pointerId);
    }
    function handlePointerMove(e) {
      if (e.isSpecialRedispatchedEvent) return;
      if (state.name === "pointing") {
        const distanceSq = Vec.Dist2(state.screenSpaceStart, { x: e.clientX, y: e.clientY });
        if (distanceSq > (editor.getInstanceState().isCoarsePointer ? editor.options.uiCoarseDragDistanceSquared : editor.options.uiDragDistanceSquared)) {
          const screenSpaceStart = state.screenSpaceStart;
          state = {
            name: "dragging",
            screenSpaceStart
          };
          editor.run(() => {
            editor.setCurrentTool("select");
            editor.dispatch({
              type: "pointer",
              target: "canvas",
              name: "pointer_down",
              ...getPointerInfo(editor, e),
              point: screenSpaceStart
            });
            editor.selectNone();
            onDragStart == null ? void 0 : onDragStart("toolbar", {
              type: "pointer",
              target: "canvas",
              name: "pointer_move",
              ...getPointerInfo(editor, e),
              point: screenSpaceStart
            });
            hideAllTooltips();
            editor.getContainer().focus();
          });
        }
      }
    }
    function handlePointerUp(e) {
      if (e.isSpecialRedispatchedEvent) return;
      e.currentTarget.releasePointerCapture(e.pointerId);
      editor.dispatch({
        type: "pointer",
        target: "canvas",
        name: "pointer_up",
        ...getPointerInfo(editor, e)
      });
    }
    function handleClick2() {
      if (state.name === "dragging" || state.name === "dragged") {
        state = { name: "idle" };
        return true;
      }
      state = { name: "idle" };
      onSelect == null ? void 0 : onSelect("toolbar");
    }
    return {
      onPointerDown: handlePointerDown,
      onPointerMove: handlePointerMove,
      onPointerUp: handlePointerUp,
      onClick: handleClick2
    };
  }, [onDragStart, editor, onSelect]);
  return events;
}
function DraggableToolbarButton({
  id,
  labelStr,
  titleStr,
  disabled,
  isSelected,
  icon,
  onSelect,
  onDragStart,
  overflow
}) {
  const events = useDraggableEvents(onDragStart, onSelect);
  if (overflow) {
    return (0, import_jsx_runtime107.jsx)(
      TldrawUiToolbarButton,
      {
        "aria-label": labelStr,
        "aria-pressed": isSelected ? "true" : "false",
        isActive: isSelected,
        className: "tlui-button-grid__button",
        "data-testid": `tools.more.${id}`,
        "data-value": id,
        disabled,
        title: titleStr,
        type: "icon",
        ...events,
        children: (0, import_jsx_runtime107.jsx)(TldrawUiButtonIcon, { icon })
      }
    );
  }
  return (0, import_jsx_runtime107.jsx)(
    TldrawUiToolbarButton,
    {
      "aria-label": labelStr,
      "aria-pressed": isSelected ? "true" : "false",
      "data-testid": `tools.${id}`,
      "data-value": id,
      disabled,
      onTouchStart: (e) => {
        preventDefault(e);
        onSelect("toolbar");
      },
      title: titleStr,
      type: "tool",
      ...events,
      children: (0, import_jsx_runtime107.jsx)(TldrawUiButtonIcon, { icon })
    }
  );
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/primitives/menus/TldrawUiMenuActionItem.mjs
function TldrawUiMenuActionItem({ actionId = "", ...rest }) {
  const actions = useActions();
  const action = actions[actionId];
  if (!action) return null;
  return (0, import_jsx_runtime108.jsx)(TldrawUiMenuItem, { ...action, ...rest });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/primitives/menus/TldrawUiMenuGroup.mjs
var import_jsx_runtime109 = __toESM(require_jsx_runtime(), 1);
var import_classnames22 = __toESM(require_classnames(), 1);
function TldrawUiMenuGroup({ id, label, className, children }) {
  const menu = useTldrawUiMenuContext();
  const { orientation } = useTldrawUiOrientation();
  const msg2 = useTranslation();
  const labelToUse = unwrapLabel(label, menu.type);
  const labelStr = labelToUse ? msg2(labelToUse) : void 0;
  switch (menu.type) {
    case "menu": {
      return (0, import_jsx_runtime109.jsx)(
        TldrawUiDropdownMenuGroup,
        {
          className,
          "data-testid": `${menu.sourceId}-group.${id}`,
          children
        }
      );
    }
    case "context-menu": {
      return (0, import_jsx_runtime109.jsx)(
        "div",
        {
          dir: "ltr",
          className: (0, import_classnames22.default)("tlui-menu__group", className),
          "data-testid": `${menu.sourceId}-group.${id}`,
          children
        }
      );
    }
    case "keyboard-shortcuts": {
      return (0, import_jsx_runtime109.jsxs)("div", { className: "tlui-shortcuts-dialog__group", "data-testid": `${menu.sourceId}-group.${id}`, children: [
        (0, import_jsx_runtime109.jsx)("h2", { className: "tlui-shortcuts-dialog__group__title", children: labelStr }),
        (0, import_jsx_runtime109.jsx)("div", { className: "tlui-shortcuts-dialog__group__content", children })
      ] });
    }
    case "toolbar": {
      const Layout2 = orientation === "horizontal" ? TldrawUiRow : TldrawUiColumn;
      return (0, import_jsx_runtime109.jsx)(Layout2, { className: "tlui-main-toolbar__group", "data-testid": `${menu.sourceId}-group.${id}`, children });
    }
    case "toolbar-overflow": {
      return (0, import_jsx_runtime109.jsx)(
        TldrawUiGrid,
        {
          className: "tlui-main-toolbar__group",
          "data-testid": `${menu.sourceId}-group.${id}`,
          children
        }
      );
    }
    default: {
      return children;
    }
  }
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/primitives/menus/TldrawUiMenuToolItem.mjs
var import_jsx_runtime113 = __toESM(require_jsx_runtime(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/hooks/useTools.mjs
var import_jsx_runtime112 = __toESM(require_jsx_runtime(), 1);
var React87 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/overrides.mjs
var import_react79 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/context/dialogs.mjs
var import_jsx_runtime110 = __toESM(require_jsx_runtime(), 1);
var import_react73 = __toESM(require_react(), 1);
var DialogsContext = (0, import_react73.createContext)(null);
function TldrawUiDialogsProvider({ context, children }) {
  const ctx = (0, import_react73.useContext)(DialogsContext);
  const trackEvent = useUiEvents();
  const dialogs = useAtom("dialogs", []);
  const content = (0, import_react73.useMemo)(() => {
    return {
      dialogs,
      addDialog(dialog) {
        const id = dialog.id ?? uniqueId();
        dialogs.update((d) => {
          return [...d.filter((m) => m.id !== dialog.id), { ...dialog, id }];
        });
        trackEvent("open-menu", { source: "dialog", id });
        tlmenus.addOpenMenu(id, context);
        return id;
      },
      removeDialog(id) {
        var _a6;
        const dialog = dialogs.get().find((d) => d.id === id);
        if (dialog) {
          (_a6 = dialog.onClose) == null ? void 0 : _a6.call(dialog);
          trackEvent("close-menu", { source: "dialog", id });
          tlmenus.deleteOpenMenu(id, context);
          dialogs.update((d) => d.filter((m) => m !== dialog));
        }
        return id;
      },
      clearDialogs() {
        const current = dialogs.get();
        if (current.length === 0) return;
        current.forEach((d) => {
          var _a6;
          (_a6 = d.onClose) == null ? void 0 : _a6.call(d);
          trackEvent("close-menu", { source: "dialog", id: d.id });
          tlmenus.deleteOpenMenu(d.id, context);
        });
        dialogs.set([]);
      }
    };
  }, [trackEvent, dialogs, context]);
  if (ctx) return (0, import_jsx_runtime110.jsx)(import_jsx_runtime110.Fragment, { children });
  return (0, import_jsx_runtime110.jsx)(DialogsContext.Provider, { value: content, children });
}
function useDialogs() {
  const ctx = (0, import_react73.useContext)(DialogsContext);
  if (!ctx) {
    throw new Error("useDialogs must be used within a DialogsProvider");
  }
  return ctx;
}

// ../node_modules/tldraw/dist-esm/lib/ui/context/toasts.mjs
var import_jsx_runtime111 = __toESM(require_jsx_runtime(), 1);
var import_react74 = __toESM(require_react(), 1);
var ToastsContext = (0, import_react74.createContext)(null);
function TldrawUiToastsProvider({ children }) {
  const toasts = useAtom("toasts", []);
  const ctx = (0, import_react74.useContext)(ToastsContext);
  const current = (0, import_react74.useMemo)(() => {
    return {
      toasts,
      addToast(toast) {
        const id = toast.id ?? uniqueId();
        toasts.update((d) => [...d.filter((m) => m.id !== toast.id), { ...toast, id }]);
        return id;
      },
      removeToast(id) {
        toasts.update((d) => d.filter((m) => m.id !== id));
        return id;
      },
      clearToasts() {
        toasts.set([]);
      }
    };
  }, [toasts]);
  if (ctx) {
    return (0, import_jsx_runtime111.jsx)(import_jsx_runtime111.Fragment, { children });
  }
  return (0, import_jsx_runtime111.jsx)(dist_exports14.Provider, { children: (0, import_jsx_runtime111.jsx)(ToastsContext.Provider, { value: current, children }) });
}
function useToasts() {
  const ctx = (0, import_react74.useContext)(ToastsContext);
  if (!ctx) {
    throw new Error("useToasts must be used within a ToastsProvider");
  }
  return ctx;
}

// ../node_modules/tldraw/dist-esm/lib/ui/getLocalFiles.mjs
function getLocalFiles(options2) {
  return new Promise((resolve) => {
    const { allowMultiple = true, mimeTypes = [] } = options2 || {};
    const input = document.createElement("input");
    input.type = "file";
    input.accept = mimeTypes == null ? void 0 : mimeTypes.join(",");
    input.multiple = allowMultiple;
    input.style.display = "none";
    function dispose() {
      input.removeEventListener("change", onchange);
      input.removeEventListener("cancel", oncancel);
      input.remove();
    }
    async function onchange(e) {
      const fileList = e.target.files;
      if (!fileList || fileList.length === 0) {
        resolve([]);
        dispose();
        return;
      }
      const files = Array.from(fileList);
      input.value = "";
      resolve(files);
      dispose();
    }
    function oncancel() {
      resolve([]);
      dispose();
    }
    document.body.appendChild(input);
    input.addEventListener("cancel", oncancel);
    input.addEventListener("change", onchange);
    input == null ? void 0 : input.click();
  });
}

// ../node_modules/tldraw/dist-esm/lib/ui/hooks/useClipboardEvents.mjs
var import_lz_string = __toESM(require_lz_string(), 1);
var import_react75 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/utils/clipboard.mjs
var TLDRAW_CUSTOM_PNG_MIME_TYPE = "web image/vnd.tldraw+png";
var additionalClipboardWriteTypes = {
  png: TLDRAW_CUSTOM_PNG_MIME_TYPE
};
var canonicalClipboardReadTypes = {
  [TLDRAW_CUSTOM_PNG_MIME_TYPE]: "image/png"
};
function getAdditionalClipboardWriteType(format) {
  return getOwnProperty(additionalClipboardWriteTypes, format) ?? null;
}
function getCanonicalClipboardReadType(mimeType) {
  return getOwnProperty(canonicalClipboardReadTypes, mimeType) ?? mimeType;
}
function doesClipboardSupportType(mimeType) {
  return typeof ClipboardItem !== "undefined" && "supports" in ClipboardItem && ClipboardItem.supports(mimeType);
}
function clipboardWrite(types) {
  const entries = Object.entries(types);
  for (const [_, promise] of entries) promise.catch((err) => console.error(err));
  return navigator.clipboard.write([new ClipboardItem(types)]).catch((err) => {
    console.error(err);
    return Promise.all(
      entries.map(async ([type, promise]) => {
        return [type, await promise];
      })
    ).then((entries2) => {
      const resolvedTypes = objectMapFromEntries(entries2);
      return navigator.clipboard.write([new ClipboardItem(resolvedTypes)]);
    });
  });
}

// ../node_modules/tldraw/dist-esm/lib/ui/hooks/clipboard/pasteFiles.mjs
async function pasteFiles(editor, blobs, point, sources) {
  const files = blobs.map(
    (blob) => blob instanceof File ? blob : new File([blob], "tldrawFile", { type: blob.type })
  );
  editor.markHistoryStoppingPoint("paste");
  await editor.putExternalContent({
    type: "files",
    files,
    point,
    sources
  });
}

// ../node_modules/tldraw/dist-esm/lib/ui/hooks/clipboard/pasteUrl.mjs
async function pasteUrl(editor, url, point, sources) {
  editor.markHistoryStoppingPoint("paste");
  return await editor.putExternalContent({
    type: "url",
    point,
    url,
    sources
  });
}

// ../node_modules/tldraw/dist-esm/lib/ui/hooks/useClipboardEvents.mjs
var expectedPasteFileMimeTypes = [
  TLDRAW_CUSTOM_PNG_MIME_TYPE,
  "image/png",
  "image/jpeg",
  "image/webp",
  "image/svg+xml"
];
function stripHtml(html) {
  const doc3 = document.implementation.createHTMLDocument("");
  doc3.documentElement.innerHTML = html.trim();
  return doc3.body.textContent || doc3.body.innerText || "";
}
var isValidHttpURL = (url) => {
  try {
    const u = new URL(url);
    return u.protocol === "http:" || u.protocol === "https:";
  } catch {
    return false;
  }
};
var getValidHttpURLList = (url) => {
  const urls = url.split(/[\n\s]/);
  for (const url2 of urls) {
    try {
      const u = new URL(url2);
      if (!(u.protocol === "http:" || u.protocol === "https:")) {
        return;
      }
    } catch {
      return;
    }
  }
  return uniq(urls);
};
var isSvgText = (text) => {
  return /^<svg/.test(text);
};
var INPUTS = ["input", "select", "textarea"];
function areShortcutsDisabled2(editor) {
  const { activeElement } = document;
  return editor.menus.hasAnyOpenMenus() || activeElement && (activeElement.isContentEditable || INPUTS.indexOf(activeElement.tagName.toLowerCase()) > -1);
}
var handleText = (editor, data, point, sources) => {
  const validUrlList = getValidHttpURLList(data);
  if (validUrlList) {
    for (const url of validUrlList) {
      pasteUrl(editor, url, point);
    }
  } else if (isValidHttpURL(data)) {
    pasteUrl(editor, data, point);
  } else if (isSvgText(data)) {
    editor.markHistoryStoppingPoint("paste");
    editor.putExternalContent({
      type: "svg-text",
      text: data,
      point,
      sources
    });
  } else {
    editor.markHistoryStoppingPoint("paste");
    editor.putExternalContent({
      type: "text",
      text: data,
      point,
      sources
    });
  }
};
var handlePasteFromEventClipboardData = async (editor, clipboardData, point) => {
  if (editor.getEditingShapeId() !== null) return;
  if (!clipboardData) {
    throw Error("No clipboard data");
  }
  const things = [];
  for (const item of Object.values(clipboardData.items)) {
    switch (item.kind) {
      case "file": {
        things.push({
          type: "file",
          source: new Promise((r) => r(item.getAsFile()))
        });
        break;
      }
      case "string": {
        if (item.type === "text/html") {
          things.push({
            type: "html",
            source: new Promise((r) => item.getAsString(r))
          });
        } else if (item.type === "text/plain") {
          things.push({
            type: "text",
            source: new Promise((r) => item.getAsString(r))
          });
        } else {
          things.push({ type: item.type, source: new Promise((r) => item.getAsString(r)) });
        }
        break;
      }
    }
  }
  handleClipboardThings(editor, things, point);
};
var handlePasteFromClipboardApi = async ({
  editor,
  clipboardItems,
  point,
  fallbackFiles
}) => {
  const things = [];
  for (const item of clipboardItems) {
    for (const type of expectedPasteFileMimeTypes) {
      if (item.types.includes(type)) {
        const blobPromise = item.getType(type).then((blob) => FileHelpers.rewriteMimeType(blob, getCanonicalClipboardReadType(type)));
        things.push({
          type: "blob",
          source: blobPromise
        });
        break;
      }
    }
    if (item.types.includes("text/html")) {
      things.push({
        type: "html",
        source: (async () => {
          const blob = await item.getType("text/html");
          return await FileHelpers.blobToText(blob);
        })()
      });
    }
    if (item.types.includes("text/uri-list")) {
      things.push({
        type: "url",
        source: (async () => {
          const blob = await item.getType("text/uri-list");
          return await FileHelpers.blobToText(blob);
        })()
      });
    }
    if (item.types.includes("text/plain")) {
      things.push({
        type: "text",
        source: (async () => {
          const blob = await item.getType("text/plain");
          return await FileHelpers.blobToText(blob);
        })()
      });
    }
  }
  if ((fallbackFiles == null ? void 0 : fallbackFiles.length) && things.length === 1 && things[0].type === "text") {
    things.pop();
    things.push(
      ...fallbackFiles.map((f) => ({ type: "file", source: Promise.resolve(f) }))
    );
  } else if ((fallbackFiles == null ? void 0 : fallbackFiles.length) && things.length === 0) {
    things.push(
      ...fallbackFiles.map((f) => ({ type: "file", source: Promise.resolve(f) }))
    );
  }
  return await handleClipboardThings(editor, things, point);
};
async function handleClipboardThings(editor, things, point) {
  const files = things.filter(
    (t2) => (t2.type === "file" || t2.type === "blob") && t2.source !== null
  );
  if (files.length) {
    if (files.length > editor.options.maxFilesAtOnce) {
      throw Error("Too many files");
    }
    const fileBlobs = compact(await Promise.all(files.map((t2) => t2.source)));
    return await pasteFiles(editor, fileBlobs, point);
  }
  const results = await Promise.all(
    things.filter((t2) => t2.type !== "file").map(
      (t2) => new Promise((r) => {
        const thing = t2;
        if (thing.type === "file") {
          r({ type: "error", data: null, reason: "unexpected file" });
          return;
        }
        thing.source.then((text) => {
          var _a6;
          const tldrawHtmlComment = (_a6 = text.match(/<div data-tldraw[^>]*>(.*)<\/div>/)) == null ? void 0 : _a6[1];
          if (tldrawHtmlComment) {
            try {
              let json;
              try {
                json = JSON.parse(tldrawHtmlComment);
              } catch {
                const jsonComment = import_lz_string.default.decompressFromBase64(tldrawHtmlComment);
                if (jsonComment === null) {
                  r({
                    type: "error",
                    data: null,
                    reason: `found tldraw data comment but could not parse`
                  });
                  return;
                }
                json = JSON.parse(jsonComment);
              }
              if (json.type !== "application/tldraw") {
                r({
                  type: "error",
                  data: json,
                  reason: `found tldraw data comment but JSON was of a different type: ${json.type}`
                });
                return;
              }
              if (json.version === 3) {
                try {
                  const otherData = JSON.parse(
                    import_lz_string.default.decompressFromBase64(json.data.otherCompressed) || "{}"
                  );
                  const reconstructedData = {
                    assets: json.data.assets || [],
                    ...otherData
                  };
                  r({ type: "tldraw", data: reconstructedData });
                  return;
                } catch (error) {
                  r({
                    type: "error",
                    data: json,
                    reason: `failed to decompress version 2 clipboard data: ${error}`
                  });
                  return;
                }
              }
              if (json.version === 2) {
                r({ type: "tldraw", data: json.data });
              } else {
                if (typeof json.data === "string") {
                  r({
                    type: "error",
                    data: json,
                    reason: "found tldraw json but data was a string instead of a TLClipboardModel object"
                  });
                  return;
                }
                r({ type: "tldraw", data: json.data });
                return;
              }
            } catch {
              r({
                type: "error",
                data: tldrawHtmlComment,
                reason: "found tldraw json but data was a string instead of a TLClipboardModel object"
              });
              return;
            }
          } else {
            if (thing.type === "html") {
              r({ type: "text", data: text, subtype: "html" });
              return;
            }
            if (thing.type === "url") {
              r({ type: "text", data: text, subtype: "url" });
              return;
            }
            try {
              const json = JSON.parse(text);
              if (json.type === "excalidraw/clipboard") {
                r({ type: "excalidraw", data: json });
                return;
              } else {
                r({ type: "text", data: text, subtype: "json" });
                return;
              }
            } catch {
              r({ type: "text", data: text, subtype: "text" });
              return;
            }
          }
          r({ type: "error", data: text, reason: "unhandled case" });
        });
      })
    )
  );
  for (const result of results) {
    if (result.type === "tldraw") {
      editor.markHistoryStoppingPoint("paste");
      editor.putExternalContent({ type: "tldraw", content: result.data, point });
      return;
    }
  }
  for (const result of results) {
    if (result.type === "excalidraw") {
      editor.markHistoryStoppingPoint("paste");
      editor.putExternalContent({ type: "excalidraw", content: result.data, point });
      return;
    }
  }
  for (const result of results) {
    if (result.type === "text" && result.subtype === "html") {
      const rootNode = new DOMParser().parseFromString(result.data, "text/html");
      const bodyNode = rootNode.querySelector("body");
      const isHtmlSingleLink = bodyNode && Array.from(bodyNode.children).filter((el) => el.nodeType === 1).length === 1 && bodyNode.firstElementChild && bodyNode.firstElementChild.tagName === "A" && bodyNode.firstElementChild.hasAttribute("href") && bodyNode.firstElementChild.getAttribute("href") !== "";
      if (isHtmlSingleLink) {
        const href = bodyNode.firstElementChild.getAttribute("href");
        handleText(editor, href, point, results);
        return;
      }
      if (!results.some((r) => r.type === "text" && r.subtype !== "html") && result.data.trim()) {
        const html = stripHtml(result.data) ?? "";
        if (html) {
          handleText(editor, stripHtml(result.data), point, results);
          return;
        }
      }
      if (results.some((r) => r.type === "text" && r.subtype !== "html")) {
        const html = stripHtml(result.data) ?? "";
        if (html) {
          editor.markHistoryStoppingPoint("paste");
          editor.putExternalContent({
            type: "text",
            text: html,
            html: result.data,
            point,
            sources: results
          });
          return;
        }
      }
    }
    if (result.type === "text" && result.subtype === "text" && result.data.startsWith("<iframe ")) {
      const rootNode = new DOMParser().parseFromString(result.data, "text/html");
      const bodyNode = rootNode.querySelector("body");
      const isSingleIframe = bodyNode && Array.from(bodyNode.children).filter((el) => el.nodeType === 1).length === 1 && bodyNode.firstElementChild && bodyNode.firstElementChild.tagName === "IFRAME" && bodyNode.firstElementChild.hasAttribute("src") && bodyNode.firstElementChild.getAttribute("src") !== "";
      if (isSingleIframe) {
        const src = bodyNode.firstElementChild.getAttribute("src");
        handleText(editor, src, point, results);
        return;
      }
    }
  }
  for (const result of results) {
    if (result.type === "text" && result.subtype === "url") {
      pasteUrl(editor, result.data, point, results);
      return;
    }
  }
  for (const result of results) {
    if (result.type === "text" && result.subtype === "text" && result.data.trim()) {
      handleText(editor, result.data, point, results);
      return;
    }
  }
}
var handleNativeOrMenuCopy = async (editor) => {
  var _a6, _b3, _c;
  const navigator2 = ((_b3 = (_a6 = editor.getContainer().ownerDocument) == null ? void 0 : _a6.defaultView) == null ? void 0 : _b3.navigator) ?? globalThis.navigator;
  const content = await editor.resolveAssetsInContent(
    editor.getContentFromCurrentPage(editor.getSelectedShapeIds())
  );
  if (!content) {
    if (navigator2 && navigator2.clipboard) {
      navigator2.clipboard.writeText("");
    }
    return;
  }
  const { assets, ...otherData } = content;
  const clipboardData = {
    type: "application/tldraw",
    kind: "content",
    version: 3,
    data: {
      assets: assets || [],
      // Plain JSON, no compression
      otherCompressed: import_lz_string.default.compressToBase64(JSON.stringify(otherData))
      // Only compress non-asset data
    }
  };
  const stringifiedClipboard = JSON.stringify(clipboardData);
  if (typeof navigator2 === "undefined") {
    return;
  } else {
    const textItems = content.shapes.map((shape) => {
      const util = editor.getShapeUtil(shape);
      return util.getText(shape);
    }).filter(isDefined);
    if ((_c = navigator2.clipboard) == null ? void 0 : _c.write) {
      const htmlBlob = new Blob([`<div data-tldraw>${stringifiedClipboard}</div>`], {
        type: "text/html"
      });
      let textContent = textItems.join(" ");
      if (textContent === "") {
        textContent = " ";
      }
      navigator2.clipboard.write([
        new ClipboardItem({
          "text/html": htmlBlob,
          // What is this second blob used for?
          "text/plain": new Blob([textContent], { type: "text/plain" })
        })
      ]);
    } else if (navigator2.clipboard.writeText) {
      navigator2.clipboard.writeText(`<div data-tldraw>${stringifiedClipboard}</div>`);
    }
  }
};
function useMenuClipboardEvents() {
  const editor = useMaybeEditor();
  const trackEvent = useUiEvents();
  const copy2 = (0, import_react75.useCallback)(
    async function onCopy(source) {
      assert(editor, "editor is required for copy");
      if (editor.getSelectedShapeIds().length === 0) return;
      await handleNativeOrMenuCopy(editor);
      trackEvent("copy", { source });
    },
    [editor, trackEvent]
  );
  const cut2 = (0, import_react75.useCallback)(
    async function onCut(source) {
      if (!editor) return;
      if (editor.getSelectedShapeIds().length === 0) return;
      await handleNativeOrMenuCopy(editor);
      editor.deleteShapes(editor.getSelectedShapeIds());
      trackEvent("cut", { source });
    },
    [editor, trackEvent]
  );
  const paste = (0, import_react75.useCallback)(
    async function onPaste(data, source, point) {
      if (!editor) return;
      if (editor.getEditingShapeId() !== null) return;
      if (Array.isArray(data) && data[0] instanceof ClipboardItem) {
        handlePasteFromClipboardApi({ editor, clipboardItems: data, point });
        trackEvent("paste", { source: "menu" });
      } else {
        navigator.clipboard.read().then((clipboardItems) => {
          paste(clipboardItems, source, point);
        });
      }
    },
    [editor, trackEvent]
  );
  return {
    copy: copy2,
    cut: cut2,
    paste
  };
}
function useNativeClipboardEvents() {
  const editor = useEditor();
  const ownerDocument = editor.getContainer().ownerDocument;
  const trackEvent = useUiEvents();
  const appIsFocused = useValue("editor.isFocused", () => editor.getInstanceState().isFocused, [
    editor
  ]);
  (0, import_react75.useEffect)(() => {
    if (!appIsFocused) return;
    const copy2 = async (e) => {
      if (editor.getSelectedShapeIds().length === 0 || editor.getEditingShapeId() !== null || areShortcutsDisabled2(editor)) {
        return;
      }
      preventDefault(e);
      await handleNativeOrMenuCopy(editor);
      trackEvent("copy", { source: "kbd" });
    };
    async function cut2(e) {
      if (editor.getSelectedShapeIds().length === 0 || editor.getEditingShapeId() !== null || areShortcutsDisabled2(editor)) {
        return;
      }
      preventDefault(e);
      await handleNativeOrMenuCopy(editor);
      editor.deleteShapes(editor.getSelectedShapeIds());
      trackEvent("cut", { source: "kbd" });
    }
    let disablingMiddleClickPaste = false;
    const pointerUpHandler = (e) => {
      if (e.button === 1) {
        disablingMiddleClickPaste = true;
        editor.timers.requestAnimationFrame(() => {
          disablingMiddleClickPaste = false;
        });
      }
    };
    const paste = (e) => {
      var _a6, _b3;
      if (disablingMiddleClickPaste) {
        editor.markEventAsHandled(e);
        return;
      }
      if (editor.getEditingShapeId() !== null || areShortcutsDisabled2(editor)) return;
      let point = void 0;
      let pasteAtCursor = false;
      if (editor.inputs.getShiftKey()) pasteAtCursor = true;
      if (editor.user.getIsPasteAtCursorMode()) pasteAtCursor = !pasteAtCursor;
      if (pasteAtCursor) point = editor.inputs.getCurrentPagePoint();
      const pasteFromEvent = () => {
        if (e.clipboardData) {
          handlePasteFromEventClipboardData(editor, e.clipboardData, point);
        }
      };
      if ((_a6 = navigator.clipboard) == null ? void 0 : _a6.read) {
        const fallbackFiles = Array.from(((_b3 = e.clipboardData) == null ? void 0 : _b3.files) || []);
        navigator.clipboard.read().then(
          (clipboardItems) => {
            if (Array.isArray(clipboardItems) && clipboardItems[0] instanceof ClipboardItem) {
              handlePasteFromClipboardApi({ editor, clipboardItems, point, fallbackFiles });
            }
          },
          () => {
            pasteFromEvent();
          }
        );
      } else {
        pasteFromEvent();
      }
      preventDefault(e);
      trackEvent("paste", { source: "kbd" });
    };
    ownerDocument == null ? void 0 : ownerDocument.addEventListener("copy", copy2);
    ownerDocument == null ? void 0 : ownerDocument.addEventListener("cut", cut2);
    ownerDocument == null ? void 0 : ownerDocument.addEventListener("paste", paste);
    ownerDocument == null ? void 0 : ownerDocument.addEventListener("pointerup", pointerUpHandler);
    return () => {
      ownerDocument == null ? void 0 : ownerDocument.removeEventListener("copy", copy2);
      ownerDocument == null ? void 0 : ownerDocument.removeEventListener("cut", cut2);
      ownerDocument == null ? void 0 : ownerDocument.removeEventListener("paste", paste);
      ownerDocument == null ? void 0 : ownerDocument.removeEventListener("pointerup", pointerUpHandler);
    };
  }, [editor, trackEvent, appIsFocused, ownerDocument]);
}

// ../node_modules/tldraw/dist-esm/lib/ui/hooks/useCopyAs.mjs
var import_react76 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/utils/export/export.mjs
var clipboardMimeTypesByFormat = {
  jpeg: "image/jpeg",
  png: "image/png",
  webp: "image/webp",
  svg: "text/plain"
};
function exportToImagePromiseForClipboard(editor, ids, opts = {}) {
  const idsToUse = (ids == null ? void 0 : ids.length) ? ids : [...editor.getCurrentPageShapeIds()];
  const format = opts.format ?? "png";
  return {
    blobPromise: editor.toImage(idsToUse, opts).then(
      (result) => FileHelpers.rewriteMimeType(result.blob, clipboardMimeTypesByFormat[format])
    ),
    mimeType: clipboardMimeTypesByFormat[format]
  };
}

// ../node_modules/tldraw/dist-esm/lib/utils/export/copyAs.mjs
function copyAs(editor, ids, opts) {
  if (!navigator.clipboard) return Promise.reject(new Error("Copy not supported"));
  if (navigator.clipboard.write) {
    const { blobPromise, mimeType } = exportToImagePromiseForClipboard(editor, ids, opts);
    const types = { [mimeType]: blobPromise };
    const additionalMimeType = getAdditionalClipboardWriteType(opts.format);
    if (additionalMimeType && doesClipboardSupportType(additionalMimeType)) {
      types[additionalMimeType] = blobPromise.then(
        (blob) => FileHelpers.rewriteMimeType(blob, additionalMimeType)
      );
    }
    return clipboardWrite(types);
  }
  switch (opts.format) {
    case "svg": {
      return fallbackWriteTextAsync(async () => {
        const result = await editor.getSvgString(ids, opts);
        if (!result) throw new Error("Failed to copy");
        return result.svg;
      });
    }
    case "png":
      throw new Error("Copy not supported");
    default:
      exhaustiveSwitchError(opts.format);
  }
}
async function fallbackWriteTextAsync(getText3) {
  var _a6, _b3;
  await ((_b3 = (_a6 = navigator.clipboard) == null ? void 0 : _a6.writeText) == null ? void 0 : _b3.call(_a6, await getText3()));
}

// ../node_modules/tldraw/dist-esm/lib/ui/hooks/useCopyAs.mjs
function useCopyAs() {
  const editor = useMaybeEditor();
  const { addToast } = useToasts();
  const msg2 = useTranslation();
  return (0, import_react76.useCallback)(
    (ids, format = "svg") => {
      assert(editor, "useCopyAs: editor is required");
      copyAs(editor, ids, { format }).catch(() => {
        addToast({
          id: "copy-fail",
          severity: "warning",
          title: msg2("toast.error.copy-fail.title"),
          description: msg2("toast.error.copy-fail.desc")
        });
      });
    },
    [editor, addToast, msg2]
  );
}

// ../node_modules/tldraw/dist-esm/lib/ui/hooks/useExportAs.mjs
var import_react77 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/utils/export/exportAs.mjs
async function exportAs(editor, ids, opts) {
  let name = opts.name;
  if (!name) {
    name = `shapes at ${getTimestamp()}`;
    if (ids.length === 1) {
      const first2 = editor.getShape(ids[0]);
      if (editor.isShapeOfType(first2, "frame")) {
        name = first2.props.name || "frame";
      } else {
        name = `${sanitizeId(first2.id)} at ${getTimestamp()}`;
      }
    }
  }
  name += `.${opts.format}`;
  const { blob } = await editor.toImage(ids, opts);
  const file = new File([blob], name, { type: blob.type });
  downloadFile(file);
}
function getTimestamp() {
  const now = /* @__PURE__ */ new Date();
  const year = String(now.getFullYear()).slice(2);
  const month = String(now.getMonth() + 1).padStart(2, "0");
  const day = String(now.getDate()).padStart(2, "0");
  const hours = String(now.getHours()).padStart(2, "0");
  const minutes = String(now.getMinutes()).padStart(2, "0");
  const seconds = String(now.getSeconds()).padStart(2, "0");
  return `${year}-${month}-${day} ${hours}.${minutes}.${seconds}`;
}
function downloadFile(file) {
  const link = document.createElement("a");
  const url = URL.createObjectURL(file);
  link.href = url;
  link.download = file.name;
  link.click();
  URL.revokeObjectURL(url);
}

// ../node_modules/tldraw/dist-esm/lib/ui/hooks/useExportAs.mjs
function useExportAs() {
  const editor = useMaybeEditor();
  const { addToast } = useToasts();
  const msg2 = useTranslation();
  return (0, import_react77.useCallback)(
    (ids, opts = {}) => {
      assert(editor, "useExportAs: editor is required");
      const { format = "png", name, scale = 1 } = opts;
      exportAs(editor, ids, {
        format,
        name,
        scale
      }).catch((e) => {
        console.error(e.message);
        addToast({
          id: "export-fail",
          title: msg2("toast.error.export-fail.title"),
          description: msg2("toast.error.export-fail.desc"),
          severity: "error"
        });
      });
    },
    [editor, addToast, msg2]
  );
}

// ../node_modules/tldraw/dist-esm/lib/ui/hooks/usePrint.mjs
var import_react78 = __toESM(require_react(), 1);
function usePrint() {
  const editor = useMaybeEditor();
  const prevPrintEl = (0, import_react78.useRef)(null);
  const prevStyleEl = (0, import_react78.useRef)(null);
  return (0, import_react78.useCallback)(
    async function printSelectionOrPages() {
      assert(editor, "usePrint: editor is required");
      const el = document.createElement("div");
      const style2 = document.createElement("style");
      const clearElements = (printEl, styleEl) => {
        if (printEl) printEl.innerHTML = "";
        if (styleEl && document.head.contains(styleEl)) document.head.removeChild(styleEl);
        if (printEl && document.body.contains(printEl)) {
          document.body.removeChild(printEl);
        }
      };
      clearElements(prevPrintEl.current, prevStyleEl.current);
      prevPrintEl.current = el;
      prevStyleEl.current = style2;
      const className = `tl-print-surface-${uniqueId()}`;
      el.className = className;
      const enableMargins = false;
      const allowAllPages = false;
      style2.innerHTML = `
			.${className} {
				display: none;
			}

			.${className} svg {
				max-width: 100%;
				height: 100%;
				display: block;
			}

			@media print {				  
				html, body {
					min-height: 100%;
					height: 100%;
					margin: 0;
				}

				body {
					position: relative;
				}

				body > * {
					display: none;
				}

				.tldraw__editor {
					display: none;
				}

				.${className} {
					display: block !important;
					background: white;
					min-height: 100%;
					height: 100%;
					max-width: 100%;
				}

				.${className}__item {
					padding: 10mm;
					display: flex;
					min-height: 100%;
					flex-direction: column;
					page-break-after: always;
					position: relative;
					overflow: hidden;
					height: 100%;
				}

				.${className}__item__main {
					flex: 1;
					display: flex;
					align-items: center;
					justify-content: center;
					max-height: 100%;
				}

				.${className}__item__header {
					display: none;
				}

				.${className}__item__footer {
					display: none;
					text-align: right;
				}

				.${className}__item__footer__hide {
					display: none;
				}

				${!enableMargins ? "" : `
					/**
					 * Note: Safari doesn't support removing the page margins to remove them all!
					 */
					@page {
						margin:0;
					}

					.${className} .${className}__item__header {
						display: block;
					}

					.${className} .${className}__item__footer {
						display: block;
					}
				`}
			}

		`;
      const beforePrintHandler = () => {
        document.head.appendChild(style2);
        document.body.appendChild(el);
      };
      const afterPrintHandler = () => {
        editor.once("tick", () => {
          clearElements(el, style2);
        });
      };
      window.addEventListener("beforeprint", beforePrintHandler);
      window.addEventListener("afterprint", afterPrintHandler);
      function addPageToPrint(title, footer, svg) {
        try {
          el.innerHTML += `<div class="${className}__item">
        <div class="${className}__item__header">
          ${title.replace(/</g, "&lt;").replace(/>/g, "&gt;")}
        </div>
        <div class="${className}__item__main">
          ${svg}
        </div>
        <div class="${className}__item__footer ${className}__item__footer__${footer ? "" : "hide"}">
          ${footer ?? ""}
        </div>
      </div>`;
        } catch (e) {
          console.error(e);
        }
      }
      function triggerPrint() {
        if (tlenv.isChromeForIos) {
          beforePrintHandler();
          window.print();
        } else if (tlenv.isSafari) {
          beforePrintHandler();
          document.execCommand("print", false);
        } else {
          window.print();
        }
      }
      const selectedShapeIds = editor.getSelectedShapeIds();
      const currentPageId = editor.getCurrentPageId();
      const pages = editor.getPages();
      const preserveAspectRatio = "xMidYMid meet";
      const svgOpts = {
        scale: 1,
        background: false,
        darkMode: false,
        preserveAspectRatio
      };
      if (editor.getSelectedShapeIds().length > 0) {
        const svgExport = await editor.getSvgString(selectedShapeIds, svgOpts);
        if (svgExport) {
          const page = pages.find((p) => p.id === currentPageId);
          addPageToPrint(`tldraw — ${page == null ? void 0 : page.name}`, null, svgExport.svg);
          triggerPrint();
        }
      } else {
        if (allowAllPages) {
          for (let i = 0; i < pages.length; i++) {
            const page = pages[i];
            const svgExport = await editor.getSvgString(
              editor.getSortedChildIdsForParent(page.id),
              svgOpts
            );
            if (svgExport) {
              addPageToPrint(`tldraw — ${page.name}`, `${i}/${pages.length}`, svgExport.svg);
            }
          }
          triggerPrint();
        } else {
          const page = editor.getCurrentPage();
          const svgExport = await editor.getSvgString(
            editor.getSortedChildIdsForParent(page.id),
            svgOpts
          );
          if (svgExport) {
            addPageToPrint(`tldraw — ${page.name}`, null, svgExport.svg);
            triggerPrint();
          }
        }
      }
      window.removeEventListener("beforeprint", beforePrintHandler);
      window.removeEventListener("afterprint", afterPrintHandler);
    },
    [editor]
  );
}

// ../node_modules/tldraw/dist-esm/lib/ui/overrides.mjs
var MimeTypeContext = (0, import_react79.createContext)([]);
function useDefaultHelpers() {
  const editor = useMaybeEditor();
  const { addToast, removeToast, clearToasts } = useToasts();
  const { addDialog, clearDialogs, removeDialog } = useDialogs();
  const msg2 = useTranslation();
  const printSelectionOrPages = usePrint();
  const { cut: cut2, copy: copy2, paste } = useMenuClipboardEvents();
  const copyAs2 = useCopyAs();
  const exportAs2 = useExportAs();
  const getEmbedDefinition = useGetEmbedDefinition();
  const breakpoint = useBreakpoint();
  const isMobile = breakpoint < PORTRAIT_BREAKPOINT.TABLET_SM;
  const mimeTypes = useShallowArrayIdentity((0, import_react79.useContext)(MimeTypeContext));
  const insertMedia = (0, import_react79.useCallback)(async () => {
    if (!editor) return;
    const files = await getLocalFiles({
      allowMultiple: true,
      mimeTypes
    });
    if (!files.length) return;
    editor.markHistoryStoppingPoint("insert media");
    editor.putExternalContent({
      type: "files",
      files,
      point: editor.getViewportPageBounds().center
    });
  }, [editor, mimeTypes]);
  const replaceMedia = (0, import_react79.useCallback)(
    async (isImage) => {
      if (!editor) return;
      const files = await getLocalFiles({
        allowMultiple: false,
        mimeTypes: mimeTypes == null ? void 0 : mimeTypes.filter(
          (m) => isImage ? m.startsWith("image/") : m.startsWith("video/")
        )
      });
      if (!files.length) return;
      const shape = editor.getOnlySelectedShape();
      if (!shape || isImage && shape.type !== "image" || !isImage && shape.type !== "video")
        return;
      editor.markHistoryStoppingPoint("replace media");
      const file = files[0];
      editor.replaceExternalContent({
        type: "file-replace",
        file,
        shapeId: shape.id,
        isImage
      });
    },
    [editor, mimeTypes]
  );
  const replaceImage = (0, import_react79.useCallback)(() => replaceMedia(
    true
    /* isImage */
  ), [replaceMedia]);
  const replaceVideo = (0, import_react79.useCallback)(() => replaceMedia(
    false
    /* isImage */
  ), [replaceMedia]);
  return (0, import_react79.useMemo)(
    () => ({
      addToast,
      removeToast,
      clearToasts,
      addDialog,
      removeDialog,
      clearDialogs,
      msg: msg2,
      isMobile,
      insertMedia,
      replaceImage,
      replaceVideo,
      printSelectionOrPages,
      cut: cut2,
      copy: copy2,
      paste,
      copyAs: copyAs2,
      exportAs: exportAs2,
      getEmbedDefinition
    }),
    [
      addToast,
      removeToast,
      clearToasts,
      addDialog,
      removeDialog,
      clearDialogs,
      msg2,
      isMobile,
      insertMedia,
      replaceImage,
      replaceVideo,
      printSelectionOrPages,
      cut2,
      copy2,
      paste,
      copyAs2,
      exportAs2,
      getEmbedDefinition
    ]
  );
}
function mergeOverrides(overrides, defaultHelpers) {
  const mergedTranslations = {};
  for (const override of overrides) {
    if (override.translations) {
      for (const [key, value] of objectMapEntries(override.translations)) {
        let strings = mergedTranslations[key];
        if (!strings) {
          strings = mergedTranslations[key] = {};
        }
        Object.assign(strings, value);
      }
    }
  }
  return {
    actions: (editor, schema, helpers) => {
      for (const override of overrides) {
        if (override.actions) {
          schema = override.actions(editor, schema, helpers);
        }
      }
      return schema;
    },
    tools: (editor, schema, helpers) => {
      for (const override of overrides) {
        if (override.tools) {
          schema = override.tools(editor, schema, { ...defaultHelpers, ...helpers });
        }
      }
      return schema;
    },
    translations: mergedTranslations
  };
}
function useShallowArrayEquality(array) {
  return (0, import_react79.useMemo)(() => array, array);
}
function useMergedTranslationOverrides(overrides) {
  const overridesArray = useShallowArrayEquality(
    overrides == null ? [] : Array.isArray(overrides) ? overrides : [overrides]
  );
  return (0, import_react79.useMemo)(() => {
    const mergedTranslations = {};
    for (const override of overridesArray) {
      if (override.translations) {
        for (const [key, value] of objectMapEntries(override.translations)) {
          let strings = mergedTranslations[key];
          if (!strings) {
            strings = mergedTranslations[key] = {};
          }
          Object.assign(strings, value);
        }
      }
    }
    return mergedTranslations;
  }, [overridesArray]);
}
function useMergedOverrides(overrides) {
  const defaultHelpers = useDefaultHelpers();
  const overridesArray = useShallowArrayEquality(
    overrides == null ? [] : Array.isArray(overrides) ? overrides : [overrides]
  );
  return (0, import_react79.useMemo)(
    () => mergeOverrides(overridesArray, defaultHelpers),
    [overridesArray, defaultHelpers]
  );
}

// ../node_modules/tldraw/dist-esm/lib/ui/hooks/useTools.mjs
var ToolsContext = React87.createContext(null);
function ToolsProvider({ overrides, children }) {
  const editor = useMaybeEditor();
  const trackEvent = useUiEvents();
  const a11y = useA11y();
  const msg2 = useTranslation();
  const helpers = useDefaultHelpers();
  const onToolSelect = React87.useCallback(
    (source, tool, id) => {
      a11y.announce({ msg: msg2(tool.label) });
      trackEvent("select-tool", { source, id: id ?? tool.id });
    },
    [a11y, msg2, trackEvent]
  );
  const tools = React87.useMemo(() => {
    if (!editor) return {};
    const toolsArray = [
      {
        id: "select",
        label: "tool.select",
        icon: "tool-pointer",
        kbd: "v",
        readonlyOk: true,
        onSelect(source) {
          if (editor.isIn("select")) {
            const currentNode = editor.root.getCurrent();
            currentNode.exit({}, currentNode.id);
            currentNode.enter({}, currentNode.id);
          }
          editor.setCurrentTool("select");
          onToolSelect(source, this);
        }
      },
      {
        id: "hand",
        label: "tool.hand",
        icon: "tool-hand",
        kbd: "h",
        readonlyOk: true,
        onSelect(source) {
          editor.setCurrentTool("hand");
          onToolSelect(source, this);
        }
      },
      {
        id: "eraser",
        label: "tool.eraser",
        icon: "tool-eraser",
        kbd: "e",
        onSelect(source) {
          editor.setCurrentTool("eraser");
          onToolSelect(source, this);
        }
      },
      {
        id: "draw",
        label: "tool.draw",
        icon: "tool-pencil",
        kbd: "d,b,x",
        onSelect(source) {
          editor.setCurrentTool("draw");
          onToolSelect(source, this);
        }
      },
      ...[...GeoShapeGeoStyle.values].map((geo) => ({
        id: geo,
        label: `tool.${geo}`,
        meta: {
          geo
        },
        kbd: geo === "rectangle" ? "r" : geo === "ellipse" ? "o" : void 0,
        icon: "geo-" + geo,
        onSelect(source) {
          editor.run(() => {
            editor.setStyleForNextShapes(GeoShapeGeoStyle, geo);
            editor.setCurrentTool("geo");
            onToolSelect(source, this, `geo-${geo}`);
          });
        },
        onDragStart(source, info) {
          onDragFromToolbarToCreateShape(editor, info, {
            createShape: (id) => editor.createShape({ id, type: "geo", props: { w: 200, h: 200, geo } })
          });
          trackEvent("drag-tool", { source, id: "geo" });
        }
      })),
      {
        id: "arrow",
        label: "tool.arrow",
        icon: "tool-arrow",
        kbd: "a",
        onSelect(source) {
          editor.setCurrentTool("arrow");
          onToolSelect(source, this);
        },
        onDragStart(source, info) {
          onDragFromToolbarToCreateShape(editor, info, {
            createShape: (id) => editor.createShape({
              id,
              type: "arrow",
              props: { start: { x: 0, y: 200 }, end: { x: 200, y: 0 } }
            })
          });
          trackEvent("drag-tool", { source, id: "arrow" });
        }
      },
      {
        id: "line",
        label: "tool.line",
        icon: "tool-line",
        kbd: "l",
        onSelect(source) {
          editor.setCurrentTool("line");
          onToolSelect(source, this);
        },
        onDragStart(source, info) {
          onDragFromToolbarToCreateShape(editor, info, {
            createShape: (id) => {
              const [start, end] = getIndicesBetween(null, null, 2);
              editor.createShape({
                id,
                type: "line",
                props: {
                  points: {
                    [start]: { id: start, index: start, x: 0, y: 200 },
                    [end]: { id: end, index: end, x: 200, y: 0 }
                  }
                }
              });
            }
          });
          trackEvent("drag-tool", { source, id: "line" });
        }
      },
      {
        id: "frame",
        label: "tool.frame",
        icon: "tool-frame",
        kbd: "f",
        onSelect(source) {
          editor.setCurrentTool("frame");
          onToolSelect(source, this);
        },
        onDragStart(source, info) {
          onDragFromToolbarToCreateShape(editor, info, {
            createShape: (id) => editor.createShape({ id, type: "frame" })
          });
          trackEvent("drag-tool", { source, id: "frame" });
        }
      },
      {
        id: "text",
        label: "tool.text",
        icon: "tool-text",
        kbd: "t",
        onSelect(source) {
          editor.setCurrentTool("text");
          onToolSelect(source, this);
        },
        onDragStart(source, info) {
          onDragFromToolbarToCreateShape(editor, info, {
            createShape: (id) => editor.createShape({ id, type: "text", props: { richText: toRichText("Text") } }),
            onDragEnd: (id) => {
              startEditingShapeWithRichText(editor, id, { selectAll: true });
            }
          });
          trackEvent("drag-tool", { source, id: "text" });
        }
      },
      {
        id: "asset",
        label: "tool.media",
        icon: "tool-media",
        kbd: "cmd+u,ctrl+u",
        onSelect(source) {
          helpers.insertMedia();
          onToolSelect(source, this, "media");
        }
      },
      {
        id: "note",
        label: "tool.note",
        icon: "tool-note",
        kbd: "n",
        onSelect(source) {
          editor.setCurrentTool("note");
          onToolSelect(source, this);
        },
        onDragStart(source, info) {
          onDragFromToolbarToCreateShape(editor, info, {
            createShape: (id) => editor.createShape({ id, type: "note" }),
            onDragEnd: (id) => {
              startEditingShapeWithRichText(editor, id, { selectAll: true });
            }
          });
          trackEvent("drag-tool", { source, id: "note" });
        }
      },
      {
        id: "laser",
        label: "tool.laser",
        readonlyOk: true,
        icon: "tool-laser",
        kbd: "k",
        onSelect(source) {
          editor.setCurrentTool("laser");
          onToolSelect(source, this);
        }
      },
      {
        id: "embed",
        label: "tool.embed",
        icon: "dot",
        onSelect(source) {
          helpers.addDialog({ component: EmbedDialog });
          onToolSelect(source, this);
        }
      },
      {
        id: "highlight",
        label: "tool.highlight",
        icon: "tool-highlight",
        // TODO: pick a better shortcut
        kbd: "shift+d",
        onSelect(source) {
          editor.setCurrentTool("highlight");
          onToolSelect(source, this);
        }
      }
    ];
    toolsArray.forEach((t2) => t2.onSelect = t2.onSelect.bind(t2));
    const tools2 = Object.fromEntries(toolsArray.map((t2) => [t2.id, t2]));
    if (overrides) {
      return overrides(editor, tools2, helpers);
    }
    return tools2;
  }, [overrides, editor, helpers, onToolSelect, trackEvent]);
  return (0, import_jsx_runtime112.jsx)(ToolsContext.Provider, { value: tools, children });
}
function useTools() {
  const ctx = React87.useContext(ToolsContext);
  if (!ctx) {
    throw new Error("useTools must be used within a ToolProvider");
  }
  return ctx;
}
function onDragFromToolbarToCreateShape(editor, info, opts) {
  const { x, y } = editor.inputs.getCurrentPagePoint();
  const stoppingPoint = editor.markHistoryStoppingPoint("drag shape tool");
  editor.setCurrentTool("select.translating");
  const id = createShapeId();
  opts.createShape(id);
  const shape = assertExists(editor.getShape(id), "Shape not found");
  const { w, h: h2 } = editor.getShapePageBounds(id);
  editor.updateShape({ id, type: shape.type, x: x - w / 2, y: y - h2 / 2 });
  editor.select(id);
  editor.setCurrentTool("select.translating", {
    ...info,
    target: "shape",
    shape: editor.getShape(id),
    isCreating: true,
    creatingMarkId: stoppingPoint,
    onCreate() {
      var _a6;
      editor.setCurrentTool("select.idle");
      editor.select(id);
      (_a6 = opts.onDragEnd) == null ? void 0 : _a6.call(opts, id);
    }
  });
  editor.getCurrentTool().setCurrentToolIdMask(shape.type);
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/primitives/menus/TldrawUiMenuToolItem.mjs
function TldrawUiMenuToolItem({ toolId = "", ...rest }) {
  const tools = useTools();
  const tool = tools[toolId];
  if (!tool) return null;
  return (0, import_jsx_runtime113.jsx)(TldrawUiMenuItem, { ...tool, ...rest });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/KeyboardShortcutsDialog/DefaultKeyboardShortcutsDialogContent.mjs
function DefaultKeyboardShortcutsDialogContent() {
  const showCollaborationUi = useShowCollaborationUi();
  return (0, import_jsx_runtime114.jsxs)(import_jsx_runtime114.Fragment, { children: [
    (0, import_jsx_runtime114.jsxs)(TldrawUiMenuGroup, { label: "shortcuts-dialog.tools", id: "tools", children: [
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "toggle-tool-lock" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "insert-media" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuToolItem, { toolId: "select" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuToolItem, { toolId: "draw" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuToolItem, { toolId: "eraser" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuToolItem, { toolId: "hand" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuToolItem, { toolId: "rectangle" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuToolItem, { toolId: "ellipse" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuToolItem, { toolId: "arrow" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuToolItem, { toolId: "line" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuToolItem, { toolId: "text" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuToolItem, { toolId: "frame" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuToolItem, { toolId: "note" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuToolItem, { toolId: "laser" }),
      (0, import_jsx_runtime114.jsx)(
        TldrawUiMenuItem,
        {
          id: "pointer-down",
          label: "tool.pointer-down",
          kbd: ",",
          onSelect: () => {
          }
        }
      )
    ] }),
    (0, import_jsx_runtime114.jsxs)(TldrawUiMenuGroup, { label: "shortcuts-dialog.preferences", id: "preferences", children: [
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "toggle-dark-mode" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "toggle-focus-mode" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "toggle-grid" })
    ] }),
    (0, import_jsx_runtime114.jsxs)(TldrawUiMenuGroup, { label: "shortcuts-dialog.edit", id: "edit", children: [
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "undo" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "redo" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "cut" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "copy" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "paste" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "select-all" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "delete" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "duplicate" })
    ] }),
    (0, import_jsx_runtime114.jsxs)(TldrawUiMenuGroup, { label: "shortcuts-dialog.view", id: "view", children: [
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "zoom-in" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "zoom-out" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "zoom-to-100" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "zoom-to-fit" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "zoom-to-selection" })
    ] }),
    (0, import_jsx_runtime114.jsxs)(TldrawUiMenuGroup, { label: "shortcuts-dialog.transform", id: "transform", children: [
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "bring-to-front" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "bring-forward" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "send-backward" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "send-to-back" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "group" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "ungroup" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "flip-horizontal" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "flip-vertical" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "align-top" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "align-center-vertical" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "align-bottom" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "align-left" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "align-center-horizontal" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "align-right" })
    ] }),
    (0, import_jsx_runtime114.jsxs)(TldrawUiMenuGroup, { label: "shortcuts-dialog.text-formatting", id: "text", children: [
      (0, import_jsx_runtime114.jsx)(
        TldrawUiMenuItem,
        {
          id: "text-bold",
          label: "tool.rich-text-bold",
          kbd: "cmd+b",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime114.jsx)(
        TldrawUiMenuItem,
        {
          id: "text-italic",
          label: "tool.rich-text-italic",
          kbd: "cmd+i",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime114.jsx)(
        TldrawUiMenuItem,
        {
          id: "text-code",
          label: "tool.rich-text-code",
          kbd: "cmd+e",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime114.jsx)(
        TldrawUiMenuItem,
        {
          id: "text-highlight",
          label: "tool.rich-text-highlight",
          kbd: "cmd+shift+h",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime114.jsx)(
        TldrawUiMenuItem,
        {
          id: "text-strikethrough",
          label: "tool.rich-text-strikethrough",
          kbd: "cmd+shift+s",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime114.jsx)(
        TldrawUiMenuItem,
        {
          id: "text-link",
          label: "tool.rich-text-link",
          kbd: "cmd+shift+k",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime114.jsx)(
        TldrawUiMenuItem,
        {
          id: "text-header",
          label: "tool.rich-text-header",
          kbd: "cmd+alt+[[1-6]]",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime114.jsx)(
        TldrawUiMenuItem,
        {
          id: "text-orderedList",
          label: "tool.rich-text-orderedList",
          kbd: "cmd+shift+7",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime114.jsx)(
        TldrawUiMenuItem,
        {
          id: "text-bulletedlist",
          label: "tool.rich-text-bulletList",
          kbd: "cmd+shift+8",
          onSelect: () => {
          }
        }
      )
    ] }),
    (0, import_jsx_runtime114.jsxs)(TldrawUiMenuGroup, { label: "shortcuts-dialog.a11y", id: "a11y", children: [
      (0, import_jsx_runtime114.jsx)(
        TldrawUiMenuItem,
        {
          id: "a11y-select-next-shape",
          label: "a11y.select-shape",
          kbd: "[[Tab]]",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime114.jsx)(
        TldrawUiMenuItem,
        {
          id: "a11y-select-next-shape-direction",
          label: "a11y.select-shape-direction",
          kbd: "cmd+[[↑→↓←]]",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime114.jsx)(
        TldrawUiMenuItem,
        {
          id: "a11y-select-next-shape-container",
          label: "a11y.enter-leave-container",
          kbd: "cmd+shift+[[↑↓]]",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime114.jsx)(
        TldrawUiMenuItem,
        {
          id: "a11y-pan-camera",
          label: "a11y.pan-camera",
          kbd: "[[Space]]+[[↑→↓←]]",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime114.jsx)(
        TldrawUiMenuItem,
        {
          id: "adjust-shape-styles",
          label: "a11y.adjust-shape-styles",
          kbd: "cmd+[[Enter]]",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime114.jsx)(
        TldrawUiMenuItem,
        {
          id: "open-context-menu",
          label: "a11y.open-context-menu",
          kbd: "cmd+shift+[[Enter]]",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime114.jsx)(
        TldrawUiMenuItem,
        {
          id: "a11y-move-shape",
          label: "a11y.move-shape",
          kbd: "[[↑→↓←]]",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime114.jsx)(
        TldrawUiMenuItem,
        {
          id: "a11y-move-shape-faster",
          label: "a11y.move-shape-faster",
          kbd: "shift+[[↑→↓←]]",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime114.jsx)(
        TldrawUiMenuItem,
        {
          id: "a11y-rotate-shape-cw",
          label: "a11y.rotate-shape-cw",
          kbd: "shift+﹥",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime114.jsx)(
        TldrawUiMenuItem,
        {
          id: "a11y-rotate-shape-cw-fine",
          label: "a11y.rotate-shape-cw-fine",
          kbd: "shift+alt+﹥",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime114.jsx)(
        TldrawUiMenuItem,
        {
          id: "a11y-rotate-shape-ccw",
          label: "a11y.rotate-shape-ccw",
          kbd: "shift+﹤",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime114.jsx)(
        TldrawUiMenuItem,
        {
          id: "a11y-rotate-shape-ccw-fine",
          label: "a11y.rotate-shape-ccw-fine",
          kbd: "shift+alt+﹤",
          onSelect: () => {
          }
        }
      ),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "enlarge-shapes" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "shrink-shapes" }),
      (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "a11y-repeat-shape-announce" }),
      (0, import_jsx_runtime114.jsx)(
        TldrawUiMenuItem,
        {
          id: "a11y-open-keyboard-shortcuts",
          label: "a11y.open-keyboard-shortcuts",
          kbd: "cmd+alt+/",
          onSelect: () => {
          }
        }
      )
    ] }),
    showCollaborationUi && (0, import_jsx_runtime114.jsx)(TldrawUiMenuGroup, { label: "shortcuts-dialog.collaboration", id: "collaboration", children: (0, import_jsx_runtime114.jsx)(TldrawUiMenuActionItem, { actionId: "open-cursor-chat" }) })
  ] });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/KeyboardShortcutsDialog/DefaultKeyboardShortcutsDialog.mjs
var DefaultKeyboardShortcutsDialog = (0, import_react80.memo)(function DefaultKeyboardShortcutsDialog2({
  children
}) {
  const msg2 = useTranslation();
  const breakpoint = useBreakpoint();
  const content = children ?? (0, import_jsx_runtime115.jsx)(DefaultKeyboardShortcutsDialogContent, {});
  return (0, import_jsx_runtime115.jsxs)(import_jsx_runtime115.Fragment, { children: [
    (0, import_jsx_runtime115.jsxs)(TldrawUiDialogHeader, { className: "tlui-shortcuts-dialog__header", children: [
      (0, import_jsx_runtime115.jsx)(TldrawUiDialogTitle, { children: msg2("shortcuts-dialog.title") }),
      (0, import_jsx_runtime115.jsx)(TldrawUiDialogCloseButton, {})
    ] }),
    (0, import_jsx_runtime115.jsx)(
      TldrawUiDialogBody,
      {
        className: (0, import_classnames23.default)("tlui-shortcuts-dialog__body", {
          "tlui-shortcuts-dialog__body__mobile": breakpoint <= PORTRAIT_BREAKPOINT.MOBILE_XS,
          "tlui-shortcuts-dialog__body__tablet": breakpoint <= PORTRAIT_BREAKPOINT.TABLET
        }),
        children: (0, import_jsx_runtime115.jsx)(TldrawUiMenuContextProvider, { type: "keyboard-shortcuts", sourceId: "kbd", children: content })
      }
    ),
    (0, import_jsx_runtime115.jsx)("div", { className: "tlui-dialog__scrim" })
  ] });
});

// ../node_modules/tldraw/dist-esm/lib/ui/hooks/useFlatten.mjs
var import_react81 = __toESM(require_react(), 1);
async function flattenShapesToImages(editor, shapeIds, flattenImageBoundsExpand) {
  const shapes = compact(
    shapeIds.map((id) => {
      const shape = editor.getShape(id);
      if (!shape) return;
      const util = editor.getShapeUtil(shape.type);
      if (util.toSvg === void 0) return;
      return shape;
    })
  );
  if (shapes.length === 0) return;
  if (shapes.length === 1) {
    const shape = shapes[0];
    if (!shape) return;
    if (editor.isShapeOfType(shape, "image")) return;
  }
  const groups = [];
  if (flattenImageBoundsExpand !== void 0) {
    const expandedBounds = shapes.map((shape) => {
      return {
        shape,
        bounds: editor.getShapeMaskedPageBounds(shape).clone().expandBy(flattenImageBoundsExpand)
      };
    });
    for (let i = 0; i < expandedBounds.length; i++) {
      const item = expandedBounds[i];
      if (i === 0) {
        groups[0] = {
          shapes: [item.shape],
          bounds: item.bounds
        };
        continue;
      }
      let didLand = false;
      for (const group of groups) {
        if (group.bounds.includes(item.bounds)) {
          group.shapes.push(item.shape);
          group.bounds.expand(item.bounds);
          didLand = true;
          break;
        }
      }
      if (!didLand) {
        groups.push({
          shapes: [item.shape],
          bounds: item.bounds
        });
      }
    }
  } else {
    const bounds = Box.Common(shapes.map((shape) => editor.getShapeMaskedPageBounds(shape)));
    groups.push({
      shapes,
      bounds
    });
  }
  const padding = editor.options.flattenImageBoundsPadding;
  for (const group of groups) {
    if (flattenImageBoundsExpand !== void 0) {
      group.bounds.expandBy(-flattenImageBoundsExpand);
    }
    const svgResult = await editor.getSvgString(group.shapes, {
      padding,
      background: false
    });
    if (!(svgResult == null ? void 0 : svgResult.svg)) continue;
    const asset = await editor.getAssetForExternalContent({
      type: "file",
      file: new File([svgResult.svg], "asset.svg", { type: "image/svg+xml" })
    });
    if (!asset) continue;
    group.asset = asset;
  }
  const createdShapeIds = [];
  transact(() => {
    for (const group of groups) {
      const { asset, bounds, shapes: shapes2 } = group;
      if (!asset) continue;
      const commonAncestorId = editor.findCommonAncestor(shapes2) ?? editor.getCurrentPageId();
      if (!commonAncestorId) continue;
      let index2 = "a1";
      for (const shape of shapes2) {
        if (shape.parentId === commonAncestorId) {
          if (shape.index > index2) {
            index2 = shape.index;
          }
          break;
        }
      }
      let x;
      let y;
      let rotation;
      if (isShapeId(commonAncestorId)) {
        const commonAncestor = editor.getShape(commonAncestorId);
        if (!commonAncestor) continue;
        const point = editor.getPointInShapeSpace(commonAncestor, {
          x: bounds.x,
          y: bounds.y
        });
        rotation = editor.getShapePageTransform(commonAncestorId).rotation();
        point.sub(new Vec(padding, padding).rot(-rotation));
        x = point.x;
        y = point.y;
      } else {
        x = bounds.x - padding;
        y = bounds.y - padding;
        rotation = 0;
      }
      editor.deleteShapes(shapes2);
      editor.createAssets([{ ...asset, id: asset.id }]);
      const shapeId = createShapeId();
      editor.createShape({
        id: shapeId,
        type: "image",
        index: index2,
        parentId: commonAncestorId,
        x,
        y,
        rotation: -rotation,
        props: {
          assetId: asset.id,
          w: bounds.w + padding * 2,
          h: bounds.h + padding * 2
        }
      });
      createdShapeIds.push(shapeId);
    }
  });
  return createdShapeIds;
}

// ../node_modules/tldraw/dist-esm/lib/ui/context/components.mjs
var import_jsx_runtime182 = __toESM(require_jsx_runtime(), 1);
var import_react122 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/components/ActionsMenu/DefaultActionsMenu.mjs
var import_jsx_runtime118 = __toESM(require_jsx_runtime(), 1);
var import_react83 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/components/primitives/TldrawUiPopover.mjs
var import_jsx_runtime116 = __toESM(require_jsx_runtime(), 1);
var import_classnames24 = __toESM(require_classnames(), 1);
var import_react82 = __toESM(require_react(), 1);
function TldrawUiPopover({ id, children, onOpenChange, open, className }) {
  const [isOpen, handleOpenChange] = useMenuIsOpen(id, onOpenChange);
  return (0, import_jsx_runtime116.jsx)(dist_exports12.Root, { onOpenChange: handleOpenChange, open: open || isOpen, children: (0, import_jsx_runtime116.jsx)("div", { className: (0, import_classnames24.default)("tlui-popover", className), children }) });
}
function TldrawUiPopoverTrigger({ children }) {
  return (0, import_jsx_runtime116.jsx)(dist_exports12.Trigger, { asChild: true, dir: "ltr", children });
}
function TldrawUiPopoverContent({
  side,
  children,
  align = "center",
  sideOffset = 8,
  alignOffset = 0,
  disableEscapeKeyDown = false,
  autoFocusFirstButton = true
}) {
  const container = useContainer();
  const ref = import_react82.default.useRef(null);
  const handleOpenAutoFocus = import_react82.default.useCallback(() => {
    var _a6;
    if (!autoFocusFirstButton) return;
    const buttons = ((_a6 = ref.current) == null ? void 0 : _a6.querySelectorAll("button:not([disabled])")) ?? [];
    const visibleButtons = [...buttons].filter(
      (button) => button.offsetWidth || button.offsetHeight
    );
    const firstButton = visibleButtons[0];
    if (firstButton) firstButton.focus();
  }, [autoFocusFirstButton]);
  return (0, import_jsx_runtime116.jsx)(dist_exports12.Portal, { container, children: (0, import_jsx_runtime116.jsx)(
    dist_exports12.Content,
    {
      className: "tlui-popover__content",
      side,
      sideOffset,
      align,
      alignOffset,
      dir: "ltr",
      ref,
      onOpenAutoFocus: handleOpenAutoFocus,
      onEscapeKeyDown: (e) => disableEscapeKeyDown && e.preventDefault(),
      children
    }
  ) });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/ActionsMenu/DefaultActionsMenuContent.mjs
var import_jsx_runtime117 = __toESM(require_jsx_runtime(), 1);

// ../node_modules/tldraw/dist-esm/lib/shapes/arrow/straight-arrow.mjs
function getStraightArrowInfo(editor, shape, bindings) {
  const { arrowheadStart, arrowheadEnd } = shape.props;
  const terminalsInArrowSpace = getArrowTerminalsInArrowSpace(editor, shape, bindings);
  const a = terminalsInArrowSpace.start.clone();
  const b = terminalsInArrowSpace.end.clone();
  const c = Vec.Med(a, b);
  if (Vec.Equals(a, b)) {
    return {
      bindings,
      type: "straight",
      start: {
        handle: a,
        point: a,
        arrowhead: shape.props.arrowheadStart
      },
      end: {
        handle: b,
        point: b,
        arrowhead: shape.props.arrowheadEnd
      },
      middle: c,
      isValid: false,
      length: 0
    };
  }
  const uAB = Vec.Sub(b, a).uni();
  const startShapeInfo = getBoundShapeInfoForTerminal(editor, shape, "start");
  const endShapeInfo = getBoundShapeInfoForTerminal(editor, shape, "end");
  const arrowPageTransform = editor.getShapePageTransform(shape);
  updateArrowheadPointWithBoundShape(
    b,
    // <-- will be mutated
    terminalsInArrowSpace.start,
    arrowPageTransform,
    endShapeInfo
  );
  updateArrowheadPointWithBoundShape(
    a,
    // <-- will be mutated
    terminalsInArrowSpace.end,
    arrowPageTransform,
    startShapeInfo
  );
  let offsetA = 0;
  let offsetB = 0;
  let strokeOffsetA = 0;
  let strokeOffsetB = 0;
  let minLength = MIN_ARROW_LENGTH * shape.props.scale;
  const isSelfIntersection = startShapeInfo && endShapeInfo && startShapeInfo.shape === endShapeInfo.shape;
  const relationship = startShapeInfo && endShapeInfo ? getBoundShapeRelationships(editor, startShapeInfo.shape.id, endShapeInfo.shape.id) : "safe";
  if (relationship === "safe" && startShapeInfo && endShapeInfo && !isSelfIntersection && !startShapeInfo.isExact && !endShapeInfo.isExact) {
    if (endShapeInfo.didIntersect && !startShapeInfo.didIntersect) {
      if (startShapeInfo.isClosed) {
        a.setTo(b.clone().add(uAB.clone().mul(MIN_ARROW_LENGTH * shape.props.scale)));
      }
    } else if (!endShapeInfo.didIntersect) {
      if (endShapeInfo.isClosed) {
        b.setTo(a.clone().sub(uAB.clone().mul(MIN_ARROW_LENGTH * shape.props.scale)));
      }
    }
  }
  const distance = Vec.Sub(b, a);
  const u = Vec.Len(distance) ? distance.uni() : Vec.From(distance);
  const didFlip = !Vec.Equals(u, uAB);
  if (!isSelfIntersection) {
    if (relationship !== "start-contains-end" && startShapeInfo && arrowheadStart !== "none" && !startShapeInfo.isExact) {
      strokeOffsetA = STROKE_SIZES[shape.props.size] / 2 + ("size" in startShapeInfo.shape.props ? STROKE_SIZES[startShapeInfo.shape.props.size] / 2 : 0);
      offsetA = (BOUND_ARROW_OFFSET + strokeOffsetA) * shape.props.scale;
      minLength += strokeOffsetA * shape.props.scale;
    }
    if (relationship !== "end-contains-start" && endShapeInfo && arrowheadEnd !== "none" && !endShapeInfo.isExact) {
      strokeOffsetB = STROKE_SIZES[shape.props.size] / 2 + ("size" in endShapeInfo.shape.props ? STROKE_SIZES[endShapeInfo.shape.props.size] / 2 : 0);
      offsetB = (BOUND_ARROW_OFFSET + strokeOffsetB) * shape.props.scale;
      minLength += strokeOffsetB * shape.props.scale;
    }
  }
  const tA = a.clone().add(u.clone().mul(offsetA * (didFlip ? -1 : 1)));
  const tB = b.clone().sub(u.clone().mul(offsetB * (didFlip ? -1 : 1)));
  if (Vec.DistMin(tA, tB, minLength)) {
    if (offsetA !== 0 && offsetB !== 0) {
      offsetA *= -1.5;
      offsetB *= -1.5;
    } else if (offsetA !== 0) {
      offsetA *= -1;
    } else if (offsetB !== 0) {
      offsetB *= -1;
    } else {
    }
  }
  a.add(u.clone().mul(offsetA * (didFlip ? -1 : 1)));
  b.sub(u.clone().mul(offsetB * (didFlip ? -1 : 1)));
  if (didFlip) {
    if (startShapeInfo && endShapeInfo) {
      b.setTo(Vec.Add(a, u.clone().mul(-MIN_ARROW_LENGTH * shape.props.scale)));
    }
    c.setTo(Vec.Med(terminalsInArrowSpace.start, terminalsInArrowSpace.end));
  } else {
    c.setTo(Vec.Med(a, b));
  }
  const length = Vec.Dist(a, b);
  return {
    bindings,
    type: "straight",
    start: {
      handle: terminalsInArrowSpace.start,
      point: a,
      arrowhead: shape.props.arrowheadStart
    },
    end: {
      handle: terminalsInArrowSpace.end,
      point: b,
      arrowhead: shape.props.arrowheadEnd
    },
    middle: c,
    isValid: length > 0,
    length
  };
}
function updateArrowheadPointWithBoundShape(point, opposite, arrowPageTransform, targetShapeInfo) {
  if (targetShapeInfo === void 0) {
    return;
  }
  if (targetShapeInfo.isExact) {
    return;
  }
  const pageFrom = Mat.applyToPoint(arrowPageTransform, opposite);
  const pageTo = Mat.applyToPoint(arrowPageTransform, point);
  const targetFrom = Mat.applyToPoint(Mat.Inverse(targetShapeInfo.transform), pageFrom);
  const targetTo = Mat.applyToPoint(Mat.Inverse(targetShapeInfo.transform), pageTo);
  const intersection = Array.from(
    targetShapeInfo.geometry.intersectLineSegment(targetFrom, targetTo, {
      includeLabels: false,
      includeInternal: false
    })
  );
  let targetInt;
  if (intersection.length) {
    targetInt = intersection.sort((p1, p2) => Vec.Dist2(p1, targetFrom) - Vec.Dist2(p2, targetFrom))[0] ?? (targetShapeInfo.isClosed ? void 0 : targetTo);
  }
  if (targetInt === void 0) {
    targetInt = targetShapeInfo.geometry.nearestPoint(targetTo, {
      includeLabels: false,
      includeInternal: false
    });
    if (!Vec.DistMin(targetInt, targetTo, 1)) {
      return;
    }
  }
  const pageInt = Mat.applyToPoint(targetShapeInfo.transform, targetInt);
  const arrowInt = Mat.applyToPoint(Mat.Inverse(arrowPageTransform), pageInt);
  point.setTo(arrowInt);
  targetShapeInfo.didIntersect = true;
}

// ../node_modules/tldraw/dist-esm/lib/shapes/arrow/curved-arrow.mjs
function getCurvedArrowInfo(editor, shape, bindings) {
  const { arrowheadEnd, arrowheadStart } = shape.props;
  const bend = shape.props.bend;
  if (Math.abs(bend) > Math.abs(shape.props.bend * (WAY_TOO_BIG_ARROW_BEND_FACTOR * shape.props.scale))) {
    return getStraightArrowInfo(editor, shape, bindings);
  }
  const terminalsInArrowSpace = getArrowTerminalsInArrowSpace(editor, shape, bindings);
  const med = Vec.Med(terminalsInArrowSpace.start, terminalsInArrowSpace.end);
  const distance = Vec.Sub(terminalsInArrowSpace.end, terminalsInArrowSpace.start);
  const u = Vec.Len(distance) ? distance.uni() : Vec.From(distance);
  const middle = Vec.Add(med, u.per().mul(-bend));
  const startShapeInfo = getBoundShapeInfoForTerminal(editor, shape, "start");
  const endShapeInfo = getBoundShapeInfoForTerminal(editor, shape, "end");
  const a = terminalsInArrowSpace.start.clone();
  const b = terminalsInArrowSpace.end.clone();
  const c = middle.clone();
  if (Vec.Equals(a, b)) {
    return {
      bindings,
      type: "straight",
      start: {
        handle: a,
        point: a,
        arrowhead: shape.props.arrowheadStart
      },
      end: {
        handle: b,
        point: b,
        arrowhead: shape.props.arrowheadEnd
      },
      middle: c,
      isValid: false,
      length: 0
    };
  }
  const isClockwise = shape.props.bend < 0;
  const distFn = isClockwise ? clockwiseAngleDist : counterClockwiseAngleDist;
  const handleArc = getArcInfo(a, b, c);
  const handle_aCA = Vec.Angle(handleArc.center, a);
  const handle_aCB = Vec.Angle(handleArc.center, b);
  const handle_dAB = distFn(handle_aCA, handle_aCB);
  if (handleArc.length === 0 || handleArc.size === 0 || !isSafeFloat(handleArc.length) || !isSafeFloat(handleArc.size)) {
    return getStraightArrowInfo(editor, shape, bindings);
  }
  const tempA = a.clone();
  const tempB = b.clone();
  const tempC = c.clone();
  const arrowPageTransform = editor.getShapePageTransform(shape);
  let offsetA = 0;
  let offsetB = 0;
  let minLength = MIN_ARROW_LENGTH * shape.props.scale;
  if (startShapeInfo && !startShapeInfo.isExact) {
    const startInPageSpace = Mat.applyToPoint(arrowPageTransform, tempA);
    const centerInPageSpace = Mat.applyToPoint(arrowPageTransform, handleArc.center);
    const endInPageSpace = Mat.applyToPoint(arrowPageTransform, tempB);
    const inverseTransform = Mat.Inverse(startShapeInfo.transform);
    const startInStartShapeLocalSpace = Mat.applyToPoint(inverseTransform, startInPageSpace);
    const centerInStartShapeLocalSpace = Mat.applyToPoint(inverseTransform, centerInPageSpace);
    const endInStartShapeLocalSpace = Mat.applyToPoint(inverseTransform, endInPageSpace);
    const { isClosed } = startShapeInfo;
    let point;
    let intersections = Array.from(
      startShapeInfo.geometry.intersectCircle(centerInStartShapeLocalSpace, handleArc.radius, {
        includeLabels: false,
        includeInternal: false
      })
    );
    if (intersections.length) {
      const angleToStart = centerInStartShapeLocalSpace.angle(startInStartShapeLocalSpace);
      const angleToEnd = centerInStartShapeLocalSpace.angle(endInStartShapeLocalSpace);
      const dAB2 = distFn(angleToStart, angleToEnd);
      intersections = intersections.filter(
        (pt) => distFn(angleToStart, centerInStartShapeLocalSpace.angle(pt)) <= dAB2
      );
      const targetDist = dAB2 * 0.25;
      intersections.sort(
        isClosed ? (p0, p1) => Math.abs(distFn(angleToStart, centerInStartShapeLocalSpace.angle(p0)) - targetDist) < Math.abs(distFn(angleToStart, centerInStartShapeLocalSpace.angle(p1)) - targetDist) ? -1 : 1 : (p0, p1) => distFn(angleToStart, centerInStartShapeLocalSpace.angle(p0)) < distFn(angleToStart, centerInStartShapeLocalSpace.angle(p1)) ? -1 : 1
      );
      point = intersections[0];
    }
    if (!point) {
      if (isClosed) {
        const nearestPoint = startShapeInfo.geometry.nearestPoint(startInStartShapeLocalSpace, {
          includeInternal: false,
          includeLabels: false
        });
        if (Vec.DistMin(nearestPoint, startInStartShapeLocalSpace, 1)) {
          point = nearestPoint;
        }
      } else {
        point = startInStartShapeLocalSpace;
      }
    }
    if (point) {
      tempA.setTo(
        editor.getPointInShapeSpace(shape, Mat.applyToPoint(startShapeInfo.transform, point))
      );
      startShapeInfo.didIntersect = true;
      if (arrowheadStart !== "none") {
        const strokeOffset = STROKE_SIZES[shape.props.size] / 2 + ("size" in startShapeInfo.shape.props ? STROKE_SIZES[startShapeInfo.shape.props.size] / 2 : 0);
        offsetA = (BOUND_ARROW_OFFSET + strokeOffset) * shape.props.scale;
        minLength += strokeOffset * shape.props.scale;
      }
    }
  }
  if (endShapeInfo && !endShapeInfo.isExact) {
    const startInPageSpace = Mat.applyToPoint(arrowPageTransform, tempA);
    const endInPageSpace = Mat.applyToPoint(arrowPageTransform, tempB);
    const centerInPageSpace = Mat.applyToPoint(arrowPageTransform, handleArc.center);
    const inverseTransform = Mat.Inverse(endShapeInfo.transform);
    const startInEndShapeLocalSpace = Mat.applyToPoint(inverseTransform, startInPageSpace);
    const centerInEndShapeLocalSpace = Mat.applyToPoint(inverseTransform, centerInPageSpace);
    const endInEndShapeLocalSpace = Mat.applyToPoint(inverseTransform, endInPageSpace);
    const isClosed = endShapeInfo.isClosed;
    let point;
    let intersections = Array.from(
      endShapeInfo.geometry.intersectCircle(centerInEndShapeLocalSpace, handleArc.radius, {
        includeLabels: false,
        includeInternal: false
      })
    );
    if (intersections.length) {
      const angleToStart = centerInEndShapeLocalSpace.angle(startInEndShapeLocalSpace);
      const angleToEnd = centerInEndShapeLocalSpace.angle(endInEndShapeLocalSpace);
      const dAB2 = distFn(angleToStart, angleToEnd);
      const targetDist = dAB2 * 0.75;
      intersections = intersections.filter(
        (pt) => distFn(angleToStart, centerInEndShapeLocalSpace.angle(pt)) <= dAB2
      );
      intersections.sort(
        isClosed ? (p0, p1) => Math.abs(distFn(angleToStart, centerInEndShapeLocalSpace.angle(p0)) - targetDist) < Math.abs(distFn(angleToStart, centerInEndShapeLocalSpace.angle(p1)) - targetDist) ? -1 : 1 : (p0, p1) => distFn(angleToStart, centerInEndShapeLocalSpace.angle(p0)) < distFn(angleToStart, centerInEndShapeLocalSpace.angle(p1)) ? -1 : 1
      );
      point = intersections[0];
    }
    if (!point) {
      if (isClosed) {
        const nearestPoint = endShapeInfo.geometry.nearestPoint(endInEndShapeLocalSpace, {
          includeInternal: false,
          includeLabels: false
        });
        if (Vec.DistMin(nearestPoint, endInEndShapeLocalSpace, 1)) {
          point = nearestPoint;
        }
      } else {
        point = endInEndShapeLocalSpace;
      }
    }
    if (point) {
      tempB.setTo(
        editor.getPointInShapeSpace(shape, Mat.applyToPoint(endShapeInfo.transform, point))
      );
      endShapeInfo.didIntersect = true;
      if (arrowheadEnd !== "none") {
        const strokeOffset = STROKE_SIZES[shape.props.size] / 2 + ("size" in endShapeInfo.shape.props ? STROKE_SIZES[endShapeInfo.shape.props.size] / 2 : 0);
        offsetB = (BOUND_ARROW_OFFSET + strokeOffset) * shape.props.scale;
        minLength += strokeOffset * shape.props.scale;
      }
    }
  }
  let aCA = Vec.Angle(handleArc.center, tempA);
  let aCB = Vec.Angle(handleArc.center, tempB);
  let dAB = distFn(aCA, aCB);
  let lAB = dAB * handleArc.radius;
  const tA = tempA.clone();
  const tB = tempB.clone();
  if (offsetA !== 0) {
    tA.setTo(handleArc.center).add(
      Vec.FromAngle(aCA + dAB * (offsetA / lAB * (isClockwise ? 1 : -1))).mul(handleArc.radius)
    );
  }
  if (offsetB !== 0) {
    tB.setTo(handleArc.center).add(
      Vec.FromAngle(aCB + dAB * (offsetB / lAB * (isClockwise ? -1 : 1))).mul(handleArc.radius)
    );
  }
  if (Vec.DistMin(tA, tB, minLength)) {
    if (offsetA !== 0 && offsetB !== 0) {
      offsetA *= -1.5;
      offsetB *= -1.5;
    } else if (offsetA !== 0) {
      offsetA *= -2;
    } else if (offsetB !== 0) {
      offsetB *= -2;
    } else {
    }
    const minOffsetA = 0.1 - distFn(handle_aCA, aCA) * handleArc.radius;
    const minOffsetB = 0.1 - distFn(aCB, handle_aCB) * handleArc.radius;
    offsetA = Math.max(offsetA, minOffsetA);
    offsetB = Math.max(offsetB, minOffsetB);
  }
  if (offsetA !== 0) {
    tempA.setTo(handleArc.center).add(
      Vec.FromAngle(aCA + dAB * (offsetA / lAB * (isClockwise ? 1 : -1))).mul(handleArc.radius)
    );
  }
  if (offsetB !== 0) {
    tempB.setTo(handleArc.center).add(
      Vec.FromAngle(aCB + dAB * (offsetB / lAB * (isClockwise ? -1 : 1))).mul(handleArc.radius)
    );
  }
  if (startShapeInfo && endShapeInfo && !startShapeInfo.isExact && !endShapeInfo.isExact) {
    aCA = Vec.Angle(handleArc.center, tempA);
    aCB = Vec.Angle(handleArc.center, tempB);
    dAB = distFn(aCA, aCB);
    lAB = dAB * handleArc.radius;
    const relationship = getBoundShapeRelationships(
      editor,
      startShapeInfo.shape.id,
      endShapeInfo.shape.id
    );
    if (relationship === "double-bound" && lAB < 30) {
      tempA.setTo(a);
      tempB.setTo(b);
      tempC.setTo(c);
    } else if (relationship === "safe") {
      if (startShapeInfo && !startShapeInfo.didIntersect) {
        tempA.setTo(a);
      }
      if (endShapeInfo && !endShapeInfo.didIntersect || distFn(handle_aCA, aCA) > distFn(handle_aCA, aCB)) {
        tempB.setTo(handleArc.center).add(
          Vec.FromAngle(
            aCA + dAB * (Math.min(0.9, MIN_ARROW_LENGTH * shape.props.scale / lAB) * (isClockwise ? 1 : -1))
          ).mul(handleArc.radius)
        );
      }
    }
  }
  placeCenterHandle(
    handleArc.center,
    handleArc.radius,
    tempA,
    tempB,
    tempC,
    handle_dAB,
    isClockwise
  );
  if (tempA.equals(tempB)) {
    tempA.setTo(tempC.clone().addXY(1, 1));
    tempB.setTo(tempC.clone().subXY(1, 1));
  }
  a.setTo(tempA);
  b.setTo(tempB);
  c.setTo(tempC);
  const bodyArc = getArcInfo(a, b, c);
  return {
    bindings,
    type: "arc",
    start: {
      point: a,
      handle: terminalsInArrowSpace.start,
      arrowhead: shape.props.arrowheadStart
    },
    end: {
      point: b,
      handle: terminalsInArrowSpace.end,
      arrowhead: shape.props.arrowheadEnd
    },
    middle: c,
    handleArc,
    bodyArc,
    isValid: bodyArc.length !== 0 && isFinite(bodyArc.center.x) && isFinite(bodyArc.center.y)
  };
}
function getArcInfo(a, b, c) {
  const center = centerOfCircleFromThreePoints(a, b, c) ?? Vec.Med(a, b);
  const radius = Vec.Dist(center, a);
  const sweepFlag = +Vec.Clockwise(a, c, b);
  const ab = ((a.y - b.y) ** 2 + (a.x - b.x) ** 2) ** 0.5;
  const bc = ((b.y - c.y) ** 2 + (b.x - c.x) ** 2) ** 0.5;
  const ca = ((c.y - a.y) ** 2 + (c.x - a.x) ** 2) ** 0.5;
  const theta = Math.acos((bc * bc + ca * ca - ab * ab) / (2 * bc * ca)) * 2;
  const largeArcFlag = +(PI > theta);
  const size4 = (PI2 - theta) * (sweepFlag ? 1 : -1);
  const length = size4 * radius;
  return {
    center,
    radius,
    size: size4,
    length,
    largeArcFlag,
    sweepFlag
  };
}
function placeCenterHandle(center, radius, tempA, tempB, tempC, originalArcLength, isClockwise) {
  const aCA = Vec.Angle(center, tempA);
  const aCB = Vec.Angle(center, tempB);
  let dAB = clockwiseAngleDist(aCA, aCB);
  if (!isClockwise) dAB = PI2 - dAB;
  tempC.setTo(center).add(Vec.FromAngle(aCA + dAB * (0.5 * (isClockwise ? 1 : -1))).mul(radius));
  if (dAB > originalArcLength) {
    tempC.rotWith(center, PI);
    const t2 = tempB.clone();
    tempB.setTo(tempA);
    tempA.setTo(t2);
  }
}

// ../node_modules/tldraw/dist-esm/lib/shapes/arrow/elbow/definitions.mjs
var ElbowArrowSides = ["right", "bottom", "left", "top"];
var ElbowArrowSideDeltas = {
  top: { x: 0, y: -1 },
  right: { x: 1, y: 0 },
  bottom: { x: 0, y: 1 },
  left: { x: -1, y: 0 }
};
var ElbowArrowSideAxes = {
  left: "x",
  right: "x",
  top: "y",
  bottom: "y"
};
var ElbowArrowSideOpposites = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var ElbowArrowAxes = {
  x: {
    v: (x, y) => new Vec(x, y),
    loEdge: "left",
    hiEdge: "right",
    crossMid: "midY",
    gap: "gapX",
    midRange: "midXRange",
    self: "x",
    cross: "y",
    size: "width"
  },
  y: {
    v: (y, x) => new Vec(x, y),
    loEdge: "top",
    hiEdge: "bottom",
    crossMid: "midX",
    gap: "gapY",
    midRange: "midYRange",
    self: "y",
    cross: "x",
    size: "height"
  }
};

// ../node_modules/tldraw/dist-esm/lib/shapes/arrow/elbow/range.mjs
function expandRange(range, amount) {
  const newRange = {
    min: range.min - amount,
    max: range.max + amount
  };
  if (newRange.min > newRange.max) {
    return null;
  }
  return newRange;
}
function subtractRange(a, b) {
  assert(a.min <= a.max && b.min <= b.max);
  if (a.min <= b.min && b.max <= a.max) {
    return [
      { min: a.min, max: b.min },
      { min: b.max, max: a.max }
    ];
  }
  if (b.max <= a.min || b.min >= a.max) {
    return [a];
  }
  if (b.min <= a.min && a.max <= b.max) {
    return [];
  }
  if (isWithinRange(a.min, b)) {
    return [{ min: b.max, max: a.max }];
  }
  if (isWithinRange(a.max, b)) {
    return [{ min: a.min, max: b.min }];
  }
  return [];
}
function createRange(a, b) {
  return { min: Math.min(a, b), max: Math.max(a, b) };
}
function isWithinRange(value, range) {
  return value >= range.min && value <= range.max;
}
function rangeSize(range) {
  return range.max - range.min;
}

// ../node_modules/tldraw/dist-esm/lib/shapes/arrow/elbow/routes/ElbowArrowWorkingInfo.mjs
function flipEdgeCrossInPlace(edge) {
  if (!edge) return;
  const tmp = edge.cross.min;
  edge.cross.min = -edge.cross.max;
  edge.cross.max = -tmp;
  edge.crossTarget = -edge.crossTarget;
}
function flipEdgeValueInPlace(edge) {
  if (!edge) return;
  edge.value = -edge.value;
  edge.expanded = edge.expanded === null ? null : -edge.expanded;
}
var ElbowArrowTransform = {
  Identity: { x: 1, y: 1, transpose: false },
  Rotate90: { x: -1, y: 1, transpose: true },
  Rotate180: { x: -1, y: -1, transpose: false },
  Rotate270: { x: 1, y: -1, transpose: true },
  FlipX: { x: -1, y: 1, transpose: false },
  FlipY: { x: 1, y: -1, transpose: false }
};
function invertElbowArrowTransform(transform) {
  if (transform.transpose) {
    return {
      x: transform.y,
      y: transform.x,
      transpose: true
    };
  }
  return transform;
}
function transformElbowArrowTransform(a, b) {
  const next = { ...a };
  if (b.transpose) {
    swap(next, "x", "y");
    next.transpose = !next.transpose;
  }
  if (b.x === -1) {
    next.x = -next.x;
  }
  if (b.y === -1) {
    next.y = -next.y;
  }
  return next;
}
function swap(object, a, b) {
  const temp = object[a];
  object[a] = object[b];
  object[b] = temp;
}
function transformVecInPlace(transform, point) {
  point.x = transform.x * point.x;
  point.y = transform.y * point.y;
  if (transform.transpose) {
    swap(point, "x", "y");
  }
}
function transformBoxInPlace(transform, box) {
  if (transform.x === -1) {
    box.x = -(box.x + box.width);
  }
  if (transform.y === -1) {
    box.y = -(box.y + box.height);
  }
  if (transform.transpose) {
    swap(box, "x", "y");
    swap(box, "width", "height");
  }
}
function transformEdgesInPlace(transform, edges) {
  if (transform.x === -1) {
    swap(edges, "left", "right");
    flipEdgeCrossInPlace(edges.top);
    flipEdgeCrossInPlace(edges.bottom);
    flipEdgeValueInPlace(edges.left);
    flipEdgeValueInPlace(edges.right);
  }
  if (transform.y === -1) {
    swap(edges, "top", "bottom");
    flipEdgeCrossInPlace(edges.left);
    flipEdgeCrossInPlace(edges.right);
    flipEdgeValueInPlace(edges.top);
    flipEdgeValueInPlace(edges.bottom);
  }
  if (transform.transpose) {
    swap(edges, "left", "top");
    swap(edges, "right", "bottom");
  }
}
var ElbowArrowWorkingInfo = class {
  constructor(info) {
    __publicField(this, "options");
    __publicField(this, "A");
    __publicField(this, "B");
    __publicField(this, "common");
    __publicField(this, "gapX");
    __publicField(this, "gapY");
    __publicField(this, "midX");
    __publicField(this, "midY");
    __publicField(this, "bias");
    __publicField(this, "transform", ElbowArrowTransform.Identity);
    __publicField(this, "inverse", ElbowArrowTransform.Identity);
    this.options = info.options;
    this.A = info.A;
    this.B = info.B;
    this.common = info.common;
    this.midX = info.midX;
    this.midY = info.midY;
    this.gapX = info.gapX;
    this.gapY = info.gapY;
    this.bias = new Vec(1, 1);
  }
  apply(transform) {
    this.transform = transformElbowArrowTransform(transform, this.transform);
    this.inverse = invertElbowArrowTransform(this.transform);
    transformBoxInPlace(transform, this.A.original);
    transformBoxInPlace(transform, this.B.original);
    transformBoxInPlace(transform, this.common.original);
    transformBoxInPlace(transform, this.A.expanded);
    transformBoxInPlace(transform, this.B.expanded);
    transformBoxInPlace(transform, this.common.expanded);
    transformEdgesInPlace(transform, this.A.edges);
    transformEdgesInPlace(transform, this.B.edges);
    transformVecInPlace(transform, this.bias);
    if (transform.x === -1) {
      this.gapX = -this.gapX;
      this.midX = this.midX === null ? null : -this.midX;
    }
    if (transform.y === -1) {
      this.gapY = -this.gapY;
      this.midY = this.midY === null ? null : -this.midY;
    }
    if (transform.transpose) {
      let temp = this.midX;
      this.midX = this.midY;
      this.midY = temp;
      temp = this.gapX;
      this.gapX = this.gapY;
      this.gapY = temp;
    }
  }
  reset() {
    this.apply(this.inverse);
  }
  vec(x, y) {
    const point = new Vec(x, y);
    transformVecInPlace(this.inverse, point);
    return point;
  }
};

// ../node_modules/tldraw/dist-esm/lib/shapes/arrow/elbow/routes/ElbowArrowRouteBuilder.mjs
var MIN_DISTANCE = 0.01;
var ElbowArrowRouteBuilder = class {
  constructor(info, name) {
    __publicField(this, "points", []);
    __publicField(this, "_midpointHandle", null);
    this.info = info;
    this.name = name;
  }
  add(x, y) {
    this.points.push(this.info.vec(x, y));
    return this;
  }
  midpointHandle(axis) {
    assert(this._midpointHandle === null, "midX/midY called multiple times");
    const point = Vec.Lrp(
      this.points[this.points.length - 2],
      this.points[this.points.length - 1],
      0.5
    );
    this._midpointHandle = {
      axis: this.info.transform.transpose ? axis === "x" ? "y" : "x" : axis,
      point,
      segmentStart: this.points[this.points.length - 2].clone(),
      segmentEnd: this.points[this.points.length - 1].clone()
    };
    return this;
  }
  build() {
    const finalPoints = [];
    for (let i = 0; i < this.points.length; i++) {
      const p0 = this.points[i];
      const p1 = finalPoints[finalPoints.length - 1];
      const p2 = finalPoints[finalPoints.length - 2];
      if (!p1 || !p2) {
        finalPoints.push(p0);
      } else {
        const d1x = Math.abs(p0.x - p1.x);
        const d1y = Math.abs(p0.y - p1.y);
        const d2x = Math.abs(p0.x - p2.x);
        const d2y = Math.abs(p0.y - p2.y);
        if (d1x < MIN_DISTANCE && d1y < MIN_DISTANCE) {
        } else if (d1x < MIN_DISTANCE && d2x < MIN_DISTANCE) {
          p1.y = p0.y;
        } else if (d1y < MIN_DISTANCE && d2y < MIN_DISTANCE) {
          p1.x = p0.x;
        } else {
          finalPoints.push(p0);
        }
      }
    }
    return {
      name: this.name,
      points: finalPoints,
      distance: measureRouteManhattanDistance(finalPoints),
      aEdgePicking: "manual",
      bEdgePicking: "manual",
      skipPointsWhenDrawing: /* @__PURE__ */ new Set(),
      midpointHandle: this._midpointHandle
    };
  }
};
function measureRouteManhattanDistance(path) {
  let distance = 0;
  for (let i = 0; i < path.length - 1; i++) {
    const start = path[i];
    const end = path[i + 1];
    distance += Math.abs(end.x - start.x) + Math.abs(end.y - start.y);
  }
  return distance;
}

// ../node_modules/tldraw/dist-esm/lib/shapes/arrow/elbow/routes/elbowArrowRoutes.mjs
function routeRightToLeft(info) {
  const aEdge = info.A.edges.right;
  const bEdge = info.B.edges.left;
  if (!aEdge || !bEdge) return null;
  if (aEdge.crossTarget > bEdge.crossTarget) {
    info.apply(ElbowArrowTransform.FlipY);
  }
  if (info.gapX > 0 && info.midX !== null) {
    return new ElbowArrowRouteBuilder(info, "to left 1").add(aEdge.value, aEdge.crossTarget).add(info.midX, aEdge.crossTarget).add(info.midX, bEdge.crossTarget).midpointHandle("x").add(bEdge.value, bEdge.crossTarget).build();
  }
  if (aEdge.expanded === null || bEdge.expanded === null) return null;
  if (info.midY !== null) {
    return new ElbowArrowRouteBuilder(info, "to left 2").add(aEdge.value, aEdge.crossTarget).add(aEdge.expanded, aEdge.crossTarget).add(aEdge.expanded, info.midY).add(bEdge.expanded, info.midY).midpointHandle("y").add(bEdge.expanded, bEdge.crossTarget).add(bEdge.value, bEdge.crossTarget).build();
  }
  const arrow3Distance = Math.abs(aEdge.value - info.common.expanded.right) + Math.abs(aEdge.crossTarget - info.common.expanded.bottom) + Math.abs(info.common.expanded.right - bEdge.expanded) + Math.abs(info.common.expanded.bottom - bEdge.crossTarget) + info.options.expandElbowLegLength + 6;
  const arrow4Distance = info.options.expandElbowLegLength + Math.abs(aEdge.crossTarget - info.common.expanded.top) + Math.abs(aEdge.expanded - info.common.expanded.left) + Math.abs(info.common.expanded.top - bEdge.crossTarget) + Math.abs(info.common.expanded.left - bEdge.value) + // 6 points in this arrow, plus bias towards down/right:
  6 + info.bias.y;
  const arrow5Distance = info.gapX < 0 && info.midX !== null ? info.options.expandElbowLegLength + Math.abs(aEdge.crossTarget - info.A.expanded.bottom) + info.common.expanded.width + Math.abs(info.A.expanded.bottom - info.B.expanded.top) + Math.abs(info.B.expanded.top - bEdge.crossTarget) + info.options.expandElbowLegLength + // 8 points in this arrow
  8 : Infinity;
  if (arrow3Distance < arrow4Distance && arrow3Distance < arrow5Distance) {
    return new ElbowArrowRouteBuilder(info, "to left 3").add(aEdge.value, aEdge.crossTarget).add(info.common.expanded.right, aEdge.crossTarget).add(info.common.expanded.right, info.common.expanded.bottom).add(bEdge.expanded, info.common.expanded.bottom).add(bEdge.expanded, bEdge.crossTarget).add(bEdge.value, bEdge.crossTarget).build();
  }
  if (arrow4Distance < arrow5Distance) {
    return new ElbowArrowRouteBuilder(info, "to left 4").add(aEdge.value, aEdge.crossTarget).add(aEdge.expanded, aEdge.crossTarget).add(aEdge.expanded, info.common.expanded.top).add(info.common.expanded.left, info.common.expanded.top).add(info.common.expanded.left, bEdge.crossTarget).add(bEdge.value, bEdge.crossTarget).build();
  }
  if (info.midX !== null) {
    return new ElbowArrowRouteBuilder(info, "to left 5").add(aEdge.value, aEdge.crossTarget).add(aEdge.expanded, aEdge.crossTarget).add(aEdge.expanded, info.A.expanded.bottom).add(info.midX, info.A.expanded.bottom).add(info.midX, info.B.expanded.top).midpointHandle("y").add(bEdge.expanded, info.B.expanded.top).add(bEdge.expanded, bEdge.crossTarget).add(bEdge.value, bEdge.crossTarget).build();
  }
  return null;
}
function routeRightToTop(info) {
  const aEdge = info.A.edges.right;
  const bEdge = info.B.edges.top;
  if (!aEdge || !bEdge) return null;
  if (aEdge.crossTarget < (bEdge.expanded ?? bEdge.value) && bEdge.crossTarget > (aEdge.expanded ?? aEdge.value) || info.A.isPoint && info.B.expanded.containsPoint(info.A.original.center)) {
    return new ElbowArrowRouteBuilder(info, "to top 1").add(aEdge.value, aEdge.crossTarget).add(bEdge.crossTarget, aEdge.crossTarget).add(bEdge.crossTarget, bEdge.value).build();
  }
  if (info.gapX > 0 && info.midX !== null && bEdge.expanded !== null) {
    return new ElbowArrowRouteBuilder(info, "to top 2").add(aEdge.value, aEdge.crossTarget).add(info.midX, aEdge.crossTarget).add(info.midX, bEdge.expanded).midpointHandle("x").add(bEdge.crossTarget, bEdge.expanded).add(bEdge.crossTarget, bEdge.value).build();
  }
  if (info.gapY > 0 && aEdge.expanded !== null && bEdge.crossTarget < aEdge.expanded && info.midY !== null) {
    return new ElbowArrowRouteBuilder(info, "to top 3").add(aEdge.value, aEdge.crossTarget).add(aEdge.expanded, aEdge.crossTarget).add(aEdge.expanded, info.midY).add(bEdge.crossTarget, info.midY).midpointHandle("y").add(bEdge.crossTarget, bEdge.value).build();
  }
  const arrow4Length = Math.abs(aEdge.value - info.common.expanded.right) + Math.abs(aEdge.crossTarget - info.common.expanded.top) + Math.abs(bEdge.crossTarget - info.common.expanded.right) + Math.abs(bEdge.value - info.common.expanded.top);
  const arrow5Length = aEdge.expanded !== null && info.midY !== null && bEdge.expanded !== null ? Math.abs(aEdge.value - aEdge.expanded) + Math.abs(info.B.expanded.left - aEdge.expanded) + Math.abs(info.B.expanded.left - bEdge.crossTarget) + Math.abs(aEdge.crossTarget - info.B.expanded.top) + Math.abs(bEdge.value - bEdge.expanded) : Infinity;
  const arrow6Length = aEdge.expanded !== null && info.midX !== null && bEdge.expanded !== null ? Math.abs(aEdge.value - info.common.expanded.right) + Math.abs(aEdge.crossTarget - info.A.expanded.bottom) + Math.abs(aEdge.expanded - bEdge.crossTarget) + Math.abs(info.A.expanded.bottom - bEdge.expanded) + Math.abs(bEdge.expanded - bEdge.value) : Infinity;
  if (arrow4Length < arrow5Length && arrow4Length < arrow6Length) {
    return new ElbowArrowRouteBuilder(info, "to top 4").add(aEdge.value, aEdge.crossTarget).add(info.common.expanded.right, aEdge.crossTarget).add(info.common.expanded.right, info.common.expanded.top).add(bEdge.crossTarget, info.common.expanded.top).add(bEdge.crossTarget, bEdge.value).build();
  }
  if (bEdge.expanded !== null && aEdge.expanded !== null && info.midY !== null && arrow5Length < arrow6Length) {
    return new ElbowArrowRouteBuilder(info, "to top 5").add(aEdge.value, aEdge.crossTarget).add(aEdge.expanded, aEdge.crossTarget).add(aEdge.expanded, info.midY).add(info.B.expanded.left, info.midY).midpointHandle("y").add(info.B.expanded.left, bEdge.expanded).add(bEdge.crossTarget, bEdge.expanded).add(bEdge.crossTarget, bEdge.value).build();
  }
  if (bEdge.expanded !== null && aEdge.expanded !== null && info.midX !== null) {
    return new ElbowArrowRouteBuilder(info, "to top 6").add(aEdge.value, aEdge.crossTarget).add(aEdge.expanded, aEdge.crossTarget).add(aEdge.expanded, info.A.expanded.bottom).add(info.midX, info.A.expanded.bottom).add(info.midX, bEdge.expanded).midpointHandle("x").add(bEdge.crossTarget, bEdge.expanded).add(bEdge.crossTarget, bEdge.value).build();
  }
  return null;
}
function routeRightToBottom(info) {
  info.apply(ElbowArrowTransform.FlipY);
  return routeRightToTop(info);
}
function routeRightToRight(info) {
  const aEdge = info.A.edges.right;
  const bEdge = info.B.edges.right;
  if (!aEdge || !bEdge) return null;
  if ((info.gapX <= 0 || aEdge.crossTarget > info.B.expanded.bottom || aEdge.crossTarget < info.B.expanded.top) && (bEdge.value > info.A.original.left || bEdge.crossTarget > info.A.expanded.bottom || bEdge.crossTarget < info.A.expanded.top)) {
    return new ElbowArrowRouteBuilder(info, "to right 1").add(aEdge.value, aEdge.crossTarget).add(info.common.expanded.right, aEdge.crossTarget).add(info.common.expanded.right, bEdge.crossTarget).add(bEdge.value, bEdge.crossTarget).build();
  }
  if (info.midX === null) return null;
  if (bEdge.expanded !== null && info.gapX >= 0) {
    const viaBottomLength = Math.abs(bEdge.crossTarget - info.B.expanded.bottom) + Math.abs(aEdge.crossTarget - info.B.expanded.bottom);
    const viaTopLength = Math.abs(bEdge.crossTarget - info.B.expanded.top) + Math.abs(aEdge.crossTarget - info.B.expanded.top);
    const topOrBottom = viaBottomLength < viaTopLength ? "bottom" : "top";
    return new ElbowArrowRouteBuilder(info, `to right 2 via ${topOrBottom}`).add(aEdge.value, aEdge.crossTarget).add(info.midX, aEdge.crossTarget).add(info.midX, info.B.expanded[topOrBottom]).midpointHandle("x").add(bEdge.expanded, info.B.expanded[topOrBottom]).add(bEdge.expanded, bEdge.crossTarget).add(bEdge.value, bEdge.crossTarget).build();
  }
  if (aEdge.expanded !== null && info.gapX <= 0) {
    const viaBottomLength = Math.abs(bEdge.crossTarget - info.A.expanded.bottom) + Math.abs(aEdge.crossTarget - info.A.expanded.bottom);
    const viaTopLength = Math.abs(bEdge.crossTarget - info.A.expanded.top) + Math.abs(aEdge.crossTarget - info.A.expanded.top);
    const topOrBottom = viaBottomLength < viaTopLength ? "bottom" : "top";
    return new ElbowArrowRouteBuilder(info, `to right 3 via ${topOrBottom}`).add(aEdge.value, aEdge.crossTarget).add(aEdge.expanded, aEdge.crossTarget).add(aEdge.expanded, info.A.expanded[topOrBottom]).add(info.midX, info.A.expanded[topOrBottom]).add(info.midX, bEdge.crossTarget).midpointHandle("x").add(bEdge.value, bEdge.crossTarget).build();
  }
  return null;
}
var routes = {
  top: {
    top: [ElbowArrowTransform.Rotate270, routeRightToRight],
    left: [ElbowArrowTransform.Rotate270, routeRightToTop],
    bottom: [ElbowArrowTransform.Rotate270, routeRightToLeft],
    right: [ElbowArrowTransform.Rotate270, routeRightToBottom]
  },
  right: {
    top: [ElbowArrowTransform.Identity, routeRightToTop],
    right: [ElbowArrowTransform.Identity, routeRightToRight],
    bottom: [ElbowArrowTransform.Identity, routeRightToBottom],
    left: [ElbowArrowTransform.Identity, routeRightToLeft]
  },
  bottom: {
    top: [ElbowArrowTransform.Rotate90, routeRightToLeft],
    left: [ElbowArrowTransform.Rotate90, routeRightToBottom],
    bottom: [ElbowArrowTransform.Rotate90, routeRightToRight],
    right: [ElbowArrowTransform.Rotate90, routeRightToTop]
  },
  left: {
    top: [ElbowArrowTransform.Rotate180, routeRightToBottom],
    left: [ElbowArrowTransform.Rotate180, routeRightToRight],
    bottom: [ElbowArrowTransform.Rotate180, routeRightToTop],
    right: [ElbowArrowTransform.Rotate180, routeRightToLeft]
  }
};
function tryRouteArrow(info, aEdge, bEdge) {
  const [transform, routeFn] = routes[aEdge][bEdge];
  info.apply(transform);
  const route = routeFn(info);
  info.reset();
  return route;
}

// ../node_modules/tldraw/dist-esm/lib/shapes/arrow/elbow/routes/routeArrowWithAutoEdgePicking.mjs
function routeArrowWithAutoEdgePicking(info, reason) {
  let idealRoute = null;
  if (
    // +1 to bias us towards the x-axis. without this, we get flicker as we move an arrow locket
    // to 45 deg (as gapx/gapy are almost equal and the result depends on floating point
    // precision)
    Math.abs(info.gapX) + 1 > Math.abs(info.gapY) && info.midX !== null
  ) {
    if (info.gapX > 0) {
      idealRoute = tryRouteArrow(info, "right", "left");
    } else {
      idealRoute = tryRouteArrow(info, "left", "right");
    }
  } else {
    const aRight = info.A.edges.right;
    const aLeft = info.A.edges.left;
    const bTop = info.B.edges.top;
    const bBottom = info.B.edges.bottom;
    if (info.A.isPoint && info.B.isPoint) {
      if (info.gapY > 0) {
        idealRoute = tryRouteArrow(info, "bottom", "top");
      } else {
        idealRoute = tryRouteArrow(info, "top", "bottom");
      }
    } else if (aRight && bTop && (aRight.expanded ?? aRight.value) <= bTop.crossTarget && aRight.crossTarget <= (bTop.expanded ?? bTop.value)) {
      idealRoute = tryRouteArrow(info, "right", "top");
    } else if (aRight && bBottom && (aRight.expanded ?? aRight.value) <= bBottom.crossTarget && aRight.crossTarget >= (bBottom.expanded ?? bBottom.value)) {
      idealRoute = tryRouteArrow(info, "right", "bottom");
    } else if (aLeft && bTop && (aLeft.expanded ?? aLeft.value) >= bTop.crossTarget && aLeft.crossTarget <= (bTop.expanded ?? bTop.value)) {
      idealRoute = tryRouteArrow(info, "left", "top");
    } else if (aLeft && bBottom && (aLeft.expanded ?? aLeft.value) >= bBottom.crossTarget && aLeft.crossTarget >= (bBottom.expanded ?? bBottom.value)) {
      idealRoute = tryRouteArrow(info, "left", "bottom");
    } else if (info.gapY > 0 && info.midY !== null) {
      idealRoute = tryRouteArrow(info, "bottom", "top");
    } else if (info.gapY < 0 && info.midY !== null) {
      idealRoute = tryRouteArrow(info, "top", "bottom");
    }
  }
  if (idealRoute) {
    idealRoute.aEdgePicking = reason;
    idealRoute.bEdgePicking = reason;
    return idealRoute;
  }
  const aAvailableSide = ElbowArrowSides.filter((side) => info.A.edges[side]);
  const bAvailableSides = ElbowArrowSides.filter((side) => info.B.edges[side]);
  const nonPartialRouteCandidates = aAvailableSide.flatMap(
    (aSide) => bAvailableSides.map((bSide) => [aSide, bSide, reason, reason])
  );
  return pickBest(info, nonPartialRouteCandidates);
}
function routeArrowWithPartialEdgePicking(info, aSide) {
  let idealRoute = null;
  const aRight = info.A.edges.right;
  const aLeft = info.A.edges.left;
  const bTop = info.B.edges.top;
  const bBottom = info.B.edges.bottom;
  switch (aSide) {
    case "right":
      if (info.gapX > 0 && info.gapX > Math.abs(info.gapY) && info.midX !== null) {
        idealRoute = tryRouteArrow(info, "right", "left");
      } else if (aRight && bTop && (aRight.expanded ?? aRight.value) <= bTop.crossTarget && aRight.crossTarget <= (bTop.expanded ?? bTop.value)) {
        idealRoute = tryRouteArrow(info, "right", "top");
      } else if (aRight && bBottom && (aRight.expanded ?? aRight.value) <= bBottom.crossTarget && aRight.crossTarget >= (bBottom.expanded ?? bBottom.value)) {
        idealRoute = tryRouteArrow(info, "right", "bottom");
      }
      break;
    case "left":
      if (info.gapX < 0 && Math.abs(info.gapX) > Math.abs(info.gapY) && info.midX !== null) {
        idealRoute = tryRouteArrow(info, "left", "right");
      } else if (aLeft && bTop && (aLeft.expanded ?? aLeft.value) >= bTop.crossTarget && aLeft.crossTarget <= (bTop.expanded ?? bTop.value)) {
        idealRoute = tryRouteArrow(info, "left", "top");
      } else if (aLeft && bBottom && (aLeft.expanded ?? aLeft.value) >= bBottom.crossTarget && aLeft.crossTarget >= (bBottom.expanded ?? bBottom.value)) {
        idealRoute = tryRouteArrow(info, "left", "bottom");
      }
      break;
    case "top":
    case "bottom":
      break;
    default:
      exhaustiveSwitchError(aSide);
  }
  if (idealRoute) {
    idealRoute.aEdgePicking = "manual";
    idealRoute.bEdgePicking = "auto";
    return idealRoute;
  }
  switch (aSide) {
    case "top":
      return pickBest(info, [
        ["top", "bottom", "manual", "auto"],
        ["top", "right", "manual", "auto"],
        ["top", "left", "manual", "auto"],
        ["top", "top", "manual", "auto"]
      ]);
    case "bottom":
      return pickBest(info, [
        ["bottom", "top", "manual", "auto"],
        ["bottom", "right", "manual", "auto"],
        ["bottom", "left", "manual", "auto"],
        ["bottom", "bottom", "manual", "auto"]
      ]);
    case "left":
      return pickBest(info, [
        ["left", "right", "manual", "auto"],
        ["left", "bottom", "manual", "auto"],
        ["left", "left", "manual", "auto"],
        ["left", "top", "manual", "auto"]
      ]);
    case "right":
      return pickBest(info, [
        ["right", "left", "manual", "auto"],
        ["right", "bottom", "manual", "auto"],
        ["right", "right", "manual", "auto"],
        ["right", "top", "manual", "auto"]
      ]);
  }
}
function routeArrowWithManualEdgePicking(info, aSide, bSide) {
  const route = tryRouteArrow(info, aSide, bSide);
  if (route) return route;
  if (info.A.isPoint && info.B.isPoint) {
    return pickBest(info, [
      [ElbowArrowSideOpposites[aSide], ElbowArrowSideOpposites[bSide], "manual", "manual"],
      [aSide, ElbowArrowSideOpposites[bSide], "manual", "auto"],
      [ElbowArrowSideOpposites[aSide], bSide, "auto", "manual"]
    ]);
  } else if (info.A.isPoint) {
    return tryRouteArrow(info, ElbowArrowSideOpposites[aSide], bSide);
  } else if (info.B.isPoint) {
    return tryRouteArrow(info, aSide, ElbowArrowSideOpposites[bSide]);
  }
  return null;
}
function pickBest(info, edges) {
  let bestRoute = null;
  let bestCornerCount = Infinity;
  let bestDistance = Infinity;
  let distanceBias = 0;
  for (const [aSide, bSide, aEdgePicking, bEdgePicking] of edges) {
    distanceBias += 1;
    const route = tryRouteArrow(info, aSide, bSide);
    if (route) {
      route.aEdgePicking = aEdgePicking;
      route.bEdgePicking = bEdgePicking;
      if (route.points.length < bestCornerCount) {
        bestCornerCount = route.points.length;
        bestDistance = route.distance;
        bestRoute = route;
      } else if (route.points.length === bestCornerCount && route.distance + distanceBias < bestDistance) {
        bestDistance = route.distance;
        bestRoute = route;
      }
    }
  }
  return bestRoute;
}

// ../node_modules/tldraw/dist-esm/lib/shapes/arrow/elbow/getElbowArrowInfo.mjs
function getElbowArrowInfo(editor, arrow5, bindings) {
  const shapeOptions = editor.getShapeUtil(arrow5.type).options;
  const options2 = {
    elbowMidpoint: arrow5.props.elbowMidPoint,
    expandElbowLegLength: shapeOptions.expandElbowLegLength[arrow5.props.size] * arrow5.props.scale,
    minElbowLegLength: shapeOptions.minElbowLegLength[arrow5.props.size] * arrow5.props.scale
  };
  let startTerminal = getElbowArrowTerminalInfo(editor, arrow5, bindings.start, arrow5.props.start);
  let endTerminal = getElbowArrowTerminalInfo(editor, arrow5, bindings.end, arrow5.props.end);
  startTerminal = adjustTerminalForUnclosedPathIfNeeded(startTerminal, endTerminal, options2);
  endTerminal = adjustTerminalForUnclosedPathIfNeeded(endTerminal, startTerminal, options2);
  const swapOrder = !!(!startTerminal.side && endTerminal.side);
  let { aTerminal, bTerminal } = swapOrder ? { aTerminal: endTerminal, bTerminal: startTerminal } : { aTerminal: startTerminal, bTerminal: endTerminal };
  let edgesA = {
    top: getUsableEdge(aTerminal, bTerminal, "top", options2),
    right: getUsableEdge(aTerminal, bTerminal, "right", options2),
    bottom: getUsableEdge(aTerminal, bTerminal, "bottom", options2),
    left: getUsableEdge(aTerminal, bTerminal, "left", options2)
  };
  let edgesB = {
    top: getUsableEdge(bTerminal, aTerminal, "top", options2),
    right: getUsableEdge(bTerminal, aTerminal, "right", options2),
    bottom: getUsableEdge(bTerminal, aTerminal, "bottom", options2),
    left: getUsableEdge(bTerminal, aTerminal, "left", options2)
  };
  const aIsUsable = hasUsableEdge(edgesA, aTerminal.side);
  const bIsUsable = hasUsableEdge(edgesB, bTerminal.side);
  let needsNewEdges = false;
  if (!aIsUsable || !bIsUsable) {
    needsNewEdges = true;
    if (!aIsUsable) {
      bTerminal = convertTerminalToPoint(bTerminal);
    }
    if (!bIsUsable) {
      aTerminal = convertTerminalToPoint(aTerminal);
    }
    if (bTerminal.bounds.containsPoint(aTerminal.target, options2.expandElbowLegLength)) {
      bTerminal = convertTerminalToPoint(bTerminal);
    }
    if (aTerminal.bounds.containsPoint(bTerminal.target, options2.expandElbowLegLength)) {
      aTerminal = convertTerminalToPoint(aTerminal);
    }
  }
  if (needsNewEdges) {
    edgesA = {
      top: getUsableEdge(aTerminal, bTerminal, "top", options2),
      right: getUsableEdge(aTerminal, bTerminal, "right", options2),
      bottom: getUsableEdge(aTerminal, bTerminal, "bottom", options2),
      left: getUsableEdge(aTerminal, bTerminal, "left", options2)
    };
    edgesB = {
      top: getUsableEdge(bTerminal, aTerminal, "top", options2),
      right: getUsableEdge(bTerminal, aTerminal, "right", options2),
      bottom: getUsableEdge(bTerminal, aTerminal, "bottom", options2),
      left: getUsableEdge(bTerminal, aTerminal, "left", options2)
    };
  }
  const expandedA = aTerminal.isPoint ? aTerminal.bounds : aTerminal.bounds.clone().expandBy(options2.expandElbowLegLength);
  const expandedB = bTerminal.isPoint ? bTerminal.bounds : bTerminal.bounds.clone().expandBy(options2.expandElbowLegLength);
  const common = {
    original: Box.Common([aTerminal.bounds, bTerminal.bounds]),
    expanded: Box.Common([expandedA, expandedB])
  };
  let gapX = bTerminal.bounds.minX - aTerminal.bounds.maxX;
  if (gapX < 0) {
    gapX = aTerminal.bounds.minX - bTerminal.bounds.maxX;
    if (gapX < 0) {
      gapX = 0;
    }
    gapX = -gapX;
  }
  let gapY = bTerminal.bounds.minY - aTerminal.bounds.maxY;
  if (gapY < 0) {
    gapY = aTerminal.bounds.minY - bTerminal.bounds.maxY;
    if (gapY < 0) {
      gapY = 0;
    }
    gapY = -gapY;
  }
  const aMinLength = aTerminal.minEndSegmentLength * 3;
  const bMinLength = bTerminal.minEndSegmentLength * 3;
  const minLegDistanceNeeded = (aTerminal.isPoint ? aMinLength : options2.minElbowLegLength) + (bTerminal.isPoint ? bMinLength : options2.minElbowLegLength);
  let mxRange = null;
  if (gapX > minLegDistanceNeeded) {
    mxRange = {
      a: aTerminal.isPoint ? aTerminal.bounds.maxX + aMinLength : expandedA.maxX,
      b: bTerminal.isPoint ? bTerminal.bounds.minX - bMinLength : expandedB.minX
    };
  } else if (gapX < -minLegDistanceNeeded) {
    mxRange = {
      a: aTerminal.isPoint ? aTerminal.bounds.minX - aMinLength : expandedA.minX,
      b: bTerminal.isPoint ? bTerminal.bounds.maxX + bMinLength : expandedB.maxX
    };
  }
  let myRange = null;
  if (gapY > minLegDistanceNeeded) {
    myRange = {
      a: aTerminal.isPoint ? aTerminal.bounds.maxY + aMinLength : expandedA.maxY,
      b: bTerminal.isPoint ? bTerminal.bounds.minY - bMinLength : expandedB.minY
    };
  } else if (gapY < -minLegDistanceNeeded) {
    myRange = {
      a: aTerminal.isPoint ? aTerminal.bounds.minY - aMinLength : expandedA.minY,
      b: bTerminal.isPoint ? bTerminal.bounds.maxY + bMinLength : expandedB.maxY
    };
  }
  const midpoint = swapOrder ? 1 - options2.elbowMidpoint : options2.elbowMidpoint;
  const mx = mxRange ? lerp(mxRange.a, mxRange.b, midpoint) : null;
  const my = myRange ? lerp(myRange.a, myRange.b, midpoint) : null;
  const info = {
    options: options2,
    swapOrder,
    A: {
      isPoint: aTerminal.isPoint,
      target: aTerminal.target,
      isExact: aTerminal.isExact,
      arrowheadOffset: aTerminal.arrowheadOffset,
      minEndSegmentLength: aTerminal.minEndSegmentLength,
      original: aTerminal.bounds,
      expanded: expandedA,
      edges: edgesA,
      geometry: aTerminal.geometry
    },
    B: {
      isPoint: bTerminal.isPoint,
      target: bTerminal.target,
      isExact: bTerminal.isExact,
      arrowheadOffset: bTerminal.arrowheadOffset,
      minEndSegmentLength: bTerminal.minEndSegmentLength,
      original: bTerminal.bounds,
      expanded: expandedB,
      edges: edgesB,
      geometry: bTerminal.geometry
    },
    common,
    gapX,
    gapY,
    midX: mx,
    midY: my
  };
  const workingInfo = new ElbowArrowWorkingInfo(info);
  const aSide = getSideToUse(aTerminal, bTerminal, info.A.edges);
  const bSide = getSideToUse(bTerminal, aTerminal, info.B.edges);
  let route;
  if (aSide && bSide) {
    route = routeArrowWithManualEdgePicking(workingInfo, aSide, bSide);
  } else if (aSide && !bSide) {
    route = routeArrowWithPartialEdgePicking(workingInfo, aSide);
  }
  if (!route) {
    route = routeArrowWithAutoEdgePicking(workingInfo, aSide || bSide ? "fallback" : "auto");
  }
  if (route) {
    castPathSegmentIntoGeometry("first", info.A, info.B, route);
    castPathSegmentIntoGeometry("last", info.B, info.A, route);
    fixTinyEndNubs(route, aTerminal, bTerminal);
    if (swapOrder) route.points.reverse();
  }
  return {
    ...info,
    route,
    midXRange: mxRange ? swapOrder ? { lo: mxRange.b, hi: mxRange.a } : { lo: mxRange.a, hi: mxRange.b } : null,
    midYRange: myRange ? swapOrder ? { lo: myRange.b, hi: myRange.a } : { lo: myRange.a, hi: myRange.b } : null
  };
}
function getRouteHandlePath(info, route) {
  const startTarget = info.swapOrder ? info.B.target : info.A.target;
  const endTarget = info.swapOrder ? info.A.target : info.B.target;
  const firstSegmentLength = Vec.ManhattanDist(route.points[0], route.points[1]);
  const lastSegmentLength = Vec.ManhattanDist(
    route.points[route.points.length - 2],
    route.points[route.points.length - 1]
  );
  const newFirstSegmentLength = Vec.ManhattanDist(startTarget, route.points[1]);
  const newLastSegmentLength = Vec.ManhattanDist(route.points[route.points.length - 2], endTarget);
  const firstSegmentLengthChange = firstSegmentLength - newFirstSegmentLength;
  const lastSegmentLengthChange = lastSegmentLength - newLastSegmentLength;
  const newPoints = [startTarget, ...route.points, endTarget];
  return {
    name: route.name,
    distance: route.distance + firstSegmentLengthChange + lastSegmentLengthChange,
    points: newPoints.filter((p) => !route.skipPointsWhenDrawing.has(p)),
    aEdgePicking: route.aEdgePicking,
    bEdgePicking: route.bEdgePicking,
    skipPointsWhenDrawing: route.skipPointsWhenDrawing,
    midpointHandle: route.midpointHandle
  };
}
function getEdgeFromNormalizedAnchor(normalizedAnchor) {
  if (approximately(normalizedAnchor.x, 0.5) && approximately(normalizedAnchor.y, 0.5)) {
    return null;
  }
  if (Math.abs(normalizedAnchor.x - 0.5) > // slightly bias towards x arrows to prevent flickering when the anchor is right on the line
  // between the two directions
  Math.abs(normalizedAnchor.y - 0.5) - 1e-4) {
    return normalizedAnchor.x < 0.5 ? "left" : "right";
  }
  return normalizedAnchor.y < 0.5 ? "top" : "bottom";
}
function getElbowArrowTerminalInfo(editor, arrow5, binding, point) {
  const arrowStrokeSize = STROKE_SIZES[arrow5.props.size] * arrow5.props.scale / 2;
  const minEndSegmentLength = arrowStrokeSize * 3;
  if (binding) {
    const target = editor.getShape(binding.toId);
    const geometry = getBindingGeometryInArrowSpace(editor, arrow5, binding.toId, binding.props);
    if (geometry && target) {
      let arrowheadOffset = 0;
      const arrowheadProp = binding.props.terminal === "start" ? "arrowheadStart" : "arrowheadEnd";
      if (arrow5.props[arrowheadProp] !== "none") {
        const targetScale = "scale" in target.props ? target.props.scale : 1;
        const targetStrokeSize = "size" in target.props ? (STROKE_SIZES[target.props.size] ?? 0) * targetScale / 2 : 0;
        arrowheadOffset = arrowStrokeSize + targetStrokeSize + BOUND_ARROW_OFFSET * arrow5.props.scale;
      }
      let side = null;
      const targetPoint = geometry.target;
      if (binding.props.isPrecise) {
        side = getEdgeFromNormalizedAnchor(
          Vec.RotWith(
            binding.props.normalizedAnchor,
            { x: 0.5, y: 0.5 },
            geometry.shapeToArrowTransform.rotation()
          )
        );
      }
      return {
        targetShapeId: binding.toId,
        isPoint: false,
        isExact: binding.props.isExact,
        bounds: geometry.bounds,
        geometry: geometry.geometry,
        target: targetPoint,
        arrowheadOffset,
        minEndSegmentLength,
        side,
        snap: binding.props.snap
      };
    }
  }
  return {
    targetShapeId: null,
    bounds: Box.FromCenter(point, { x: 0, y: 0 }),
    geometry: null,
    isExact: false,
    isPoint: true,
    target: Vec.From(point),
    arrowheadOffset: 0,
    minEndSegmentLength,
    side: null,
    snap: "none"
  };
}
function getBindingGeometryInArrowSpace(editor, arrow5, targetId, bindingProps) {
  const hasArrowhead = bindingProps.terminal === "start" ? arrow5.props.arrowheadStart !== "none" : arrow5.props.arrowheadEnd !== "none";
  const targetGeometryInTargetSpace = editor.getShapeGeometry(
    targetId,
    hasArrowhead ? void 0 : { context: "@tldraw/arrow-without-arrowhead" }
  );
  if (!targetGeometryInTargetSpace) {
    return null;
  }
  const arrowTransform = editor.getShapePageTransform(arrow5.id);
  const shapeTransform = editor.getShapePageTransform(targetId);
  const shapeToArrowTransform = arrowTransform.clone().invert().multiply(shapeTransform);
  const targetGeometryInArrowSpace = targetGeometryInTargetSpace.transform(shapeToArrowTransform);
  const center = { x: 0.5, y: 0.5 };
  const normalizedAnchor = bindingProps.isPrecise ? bindingProps.normalizedAnchor : center;
  const targetInShapeSpace = {
    x: lerp(
      targetGeometryInTargetSpace.bounds.minX,
      targetGeometryInTargetSpace.bounds.maxX,
      normalizedAnchor.x
    ),
    y: lerp(
      targetGeometryInTargetSpace.bounds.minY,
      targetGeometryInTargetSpace.bounds.maxY,
      normalizedAnchor.y
    )
  };
  const centerInShapeSpace = {
    x: lerp(
      targetGeometryInTargetSpace.bounds.minX,
      targetGeometryInTargetSpace.bounds.maxX,
      center.x
    ),
    y: lerp(
      targetGeometryInTargetSpace.bounds.minY,
      targetGeometryInTargetSpace.bounds.maxY,
      center.y
    )
  };
  const targetInArrowSpace = Mat.applyToPoint(shapeToArrowTransform, targetInShapeSpace);
  const centerInArrowSpace = Mat.applyToPoint(shapeToArrowTransform, centerInShapeSpace);
  return {
    bounds: targetGeometryInArrowSpace.bounds,
    geometry: targetGeometryInArrowSpace,
    target: targetInArrowSpace,
    center: centerInArrowSpace,
    shapeToArrowTransform
  };
}
var sideProps = {
  top: {
    expand: -1,
    main: "minY",
    opposite: "maxY",
    crossMid: "midX",
    crossMin: "minX",
    crossMax: "maxX",
    bRangeExpand: "max",
    crossAxis: "x"
  },
  bottom: {
    expand: 1,
    main: "maxY",
    opposite: "minY",
    crossMid: "midX",
    crossMin: "minX",
    crossMax: "maxX",
    bRangeExpand: "min",
    crossAxis: "x"
  },
  left: {
    expand: -1,
    main: "minX",
    opposite: "maxX",
    crossMid: "midY",
    crossMin: "minY",
    crossMax: "maxY",
    bRangeExpand: "max",
    crossAxis: "y"
  },
  right: {
    expand: 1,
    main: "maxX",
    opposite: "minX",
    crossMid: "midY",
    crossMin: "minY",
    crossMax: "maxY",
    bRangeExpand: "min",
    crossAxis: "y"
  }
};
function getUsableEdge(a, b, side, options2) {
  const props = sideProps[side];
  const isSelfBoundAndShouldRouteExternal = a.targetShapeId === b.targetShapeId && a.targetShapeId !== null && (a.snap === "edge" || a.snap === "edge-point") && (b.snap === "edge" || b.snap === "edge-point");
  const aValue = a.bounds[props.main];
  const aExpanded = a.isPoint ? null : aValue + props.expand * options2.expandElbowLegLength;
  const originalACrossRange = createRange(a.bounds[props.crossMin], a.bounds[props.crossMax]);
  let aCrossRange = originalACrossRange;
  if (!aCrossRange) {
    return null;
  }
  assert(originalACrossRange);
  const bRange = createRange(b.bounds[props.main], b.bounds[props.opposite]);
  if (!b.isPoint) {
    bRange[props.bRangeExpand] -= options2.minElbowLegLength * 2 * props.expand;
  }
  const bCrossRange = expandRange(
    createRange(b.bounds[props.crossMin], b.bounds[props.crossMax]),
    options2.expandElbowLegLength
  );
  assert(bRange && bCrossRange);
  let isPartial = false;
  if (isWithinRange(aValue, bRange) && !a.isPoint && !b.isPoint && !isSelfBoundAndShouldRouteExternal) {
    const subtracted = subtractRange(aCrossRange, bCrossRange);
    switch (subtracted.length) {
      case 0:
        return null;
      case 1:
        isPartial = subtracted[0] !== aCrossRange;
        aCrossRange = subtracted[0];
        break;
      case 2:
        isPartial = true;
        aCrossRange = rangeSize(subtracted[0]) > rangeSize(subtracted[1]) ? subtracted[0] : subtracted[1];
        break;
      default:
        exhaustiveSwitchError(subtracted);
    }
  }
  if (!isWithinRange(a.target[props.crossAxis], aCrossRange)) {
    return null;
  }
  const crossTarget = a.target[props.crossAxis];
  return {
    value: aValue,
    expanded: aExpanded,
    cross: aCrossRange,
    crossTarget,
    isPartial
  };
}
function hasUsableEdge(edges, side) {
  if (side === null) {
    return !!(edges.bottom || edges.left || edges.right || edges.top);
  }
  if (side === "x") {
    return !!edges.left || !!edges.right;
  }
  if (side === "y") {
    return !!edges.top || !!edges.bottom;
  }
  return !!edges[side];
}
function getSideToUse(binding, other, edges) {
  switch (binding.side) {
    case null:
      return null;
    case "x":
      if (binding.bounds.center.x > other.bounds.center.x && (edges == null ? void 0 : edges.left)) {
        return "left";
      } else if (edges == null ? void 0 : edges.right) {
        return "right";
      }
      return null;
    case "y":
      if (binding.bounds.center.y > other.bounds.center.y && (edges == null ? void 0 : edges.top)) {
        return "top";
      } else if (edges == null ? void 0 : edges.bottom) {
        return "bottom";
      }
      return null;
    default:
      return binding.side;
  }
}
function convertTerminalToPoint(terminal) {
  if (terminal.isPoint) return terminal;
  let side = null;
  let arrowheadOffset = 0;
  if (terminal.snap === "edge" || terminal.snap === "edge-point") {
    arrowheadOffset = terminal.arrowheadOffset;
    if (terminal.side === "x" || terminal.side === "left" || terminal.side === "right") {
      side = "x";
    }
    if (terminal.side === "y" || terminal.side === "top" || terminal.side === "bottom") {
      side = "y";
    }
  }
  return {
    targetShapeId: terminal.targetShapeId,
    side,
    bounds: new Box(terminal.target.x, terminal.target.y, 0, 0),
    geometry: terminal.geometry,
    target: terminal.target,
    arrowheadOffset,
    minEndSegmentLength: terminal.minEndSegmentLength,
    isExact: terminal.isExact,
    isPoint: true,
    snap: terminal.snap
  };
}
function castPathSegmentIntoGeometry(segment, target, other, route) {
  if (!target.geometry) return;
  const point1 = segment === "first" ? route.points[0] : route.points[route.points.length - 1];
  const point2 = segment === "first" ? route.points[1] : route.points[route.points.length - 2];
  const pointToFindClosestIntersectionTo = target.geometry.isClosed ? point2 : target.target;
  const initialDistance = Vec.ManhattanDist(point1, pointToFindClosestIntersectionTo);
  let nearestIntersectionToPoint2 = null;
  let nearestDistanceToPoint2 = Infinity;
  if (target.isExact) {
    nearestIntersectionToPoint2 = target.target;
  } else if (target.geometry) {
    const intersections = target.geometry.intersectLineSegment(point2, target.target, {
      includeLabels: false,
      includeInternal: false
    });
    if (target.geometry.hitTestPoint(
      target.target,
      Math.max(1, target.arrowheadOffset),
      true,
      Geometry2dFilters.EXCLUDE_NON_STANDARD
    )) {
      intersections.push(target.target);
    }
    for (const intersection of intersections) {
      const point2Distance = Vec.ManhattanDist(pointToFindClosestIntersectionTo, intersection);
      if (point2Distance < nearestDistanceToPoint2) {
        nearestDistanceToPoint2 = point2Distance;
        nearestIntersectionToPoint2 = intersection;
      }
    }
  }
  if (nearestIntersectionToPoint2) {
    let offset4 = target.arrowheadOffset;
    const currentFinalSegmentLength = Vec.ManhattanDist(point2, nearestIntersectionToPoint2);
    const minLength = target.arrowheadOffset * 2;
    if (currentFinalSegmentLength < minLength) {
      const targetLength = minLength - target.arrowheadOffset;
      offset4 = currentFinalSegmentLength - targetLength;
    }
    if (offset4 < target.minEndSegmentLength) {
      if (target.geometry.bounds.containsPoint(other.target)) {
        offset4 = Math.max(0, offset4);
      } else {
        offset4 = -target.arrowheadOffset;
      }
    }
    let nudgedPoint = nearestIntersectionToPoint2;
    let shouldAddExtraPointForNudge = false;
    if (!target.isExact && offset4 !== 0) {
      const nudged = Vec.Nudge(nearestIntersectionToPoint2, point2, offset4);
      nudgedPoint = nudged;
      if (offset4 < 0 && !target.geometry.hitTestPoint(nudged, 0, true, Geometry2dFilters.EXCLUDE_NON_STANDARD)) {
        nudgedPoint = nearestIntersectionToPoint2;
      } else {
        if (offset4 < 0) {
          shouldAddExtraPointForNudge = true;
        }
        nudgedPoint = nudged;
      }
    }
    const newDistance = Vec.ManhattanDist(point2, nudgedPoint);
    route.distance += newDistance - initialDistance;
    point1.x = nudgedPoint.x;
    point1.y = nudgedPoint.y;
    if (shouldAddExtraPointForNudge) {
      const midPoint = Vec.Lrp(point2, point1, 0.5);
      route.skipPointsWhenDrawing.add(midPoint);
      route.points.splice(segment === "first" ? 1 : route.points.length - 1, 0, midPoint);
    }
  }
}
function fixTinyEndNubs(route, aTerminal, bTerminal) {
  if (!route) return;
  if (route.points.length >= 3) {
    const a = route.points[0];
    const b = route.points[1];
    const firstSegmentLength = Vec.ManhattanDist(a, b);
    if (firstSegmentLength < aTerminal.minEndSegmentLength) {
      route.points.splice(1, 1);
      if (route.points.length >= 3) {
        const matchAxis = approximately(a.x, b.x) ? "y" : "x";
        route.points[1][matchAxis] = a[matchAxis];
      }
    }
  }
  if (route.points.length >= 3) {
    const a = route.points[route.points.length - 1];
    const b = route.points[route.points.length - 2];
    const lastSegmentLength = Vec.ManhattanDist(a, b);
    if (lastSegmentLength < bTerminal.minEndSegmentLength) {
      route.points.splice(route.points.length - 2, 1);
      if (route.points.length >= 3) {
        const matchAxis = approximately(a.x, b.x) ? "y" : "x";
        route.points[route.points.length - 2][matchAxis] = a[matchAxis];
      }
    }
  }
}
function adjustTerminalForUnclosedPathIfNeeded(terminal, otherTerminal, options2) {
  if (!terminal.geometry || terminal.geometry.isClosed) return terminal;
  const normalizedPointAlongPath = terminal.geometry.uninterpolateAlongEdge(
    terminal.target,
    Geometry2dFilters.EXCLUDE_NON_STANDARD
  );
  const prev = terminal.geometry.interpolateAlongEdge(
    normalizedPointAlongPath - 0.01 / terminal.geometry.length
  );
  const next = terminal.geometry.interpolateAlongEdge(
    normalizedPointAlongPath + 0.01 / terminal.geometry.length
  );
  const normal = next.sub(prev).per().uni();
  const axis = Math.abs(normal.x) > Math.abs(normal.y) ? ElbowArrowAxes.x : ElbowArrowAxes.y;
  if (terminal.geometry.bounds.containsPoint(otherTerminal.target, options2.expandElbowLegLength)) {
    terminal.side = axis.self;
    return convertTerminalToPoint(terminal);
  }
  const min3 = axis.v(
    terminal.target[axis.self] - terminal.bounds[axis.size] * 2,
    terminal.target[axis.cross]
  );
  const max2 = axis.v(
    terminal.target[axis.self] + terminal.bounds[axis.size] * 2,
    terminal.target[axis.cross]
  );
  let furthestIntersectionTowardsMin = null;
  let furthestIntersectionTowardsMinDistance = 0;
  let furthestIntersectionTowardsMax = null;
  let furthestIntersectionTowardsMaxDistance = 0;
  let side = axis.self;
  for (const intersection of terminal.geometry.intersectLineSegment(
    min3,
    max2,
    Geometry2dFilters.EXCLUDE_NON_STANDARD
  )) {
    if (Math.abs(intersection[axis.self] - terminal.target[axis.self]) < 1) {
      continue;
    }
    if (intersection[axis.self] < terminal.target[axis.self]) {
      if (Vec.ManhattanDist(intersection, terminal.target) > furthestIntersectionTowardsMinDistance) {
        furthestIntersectionTowardsMinDistance = Vec.ManhattanDist(intersection, terminal.target);
        furthestIntersectionTowardsMin = intersection;
      }
    } else {
      if (Vec.ManhattanDist(intersection, terminal.target) > furthestIntersectionTowardsMaxDistance) {
        furthestIntersectionTowardsMaxDistance = Vec.ManhattanDist(intersection, terminal.target);
        furthestIntersectionTowardsMax = intersection;
      }
    }
  }
  if (furthestIntersectionTowardsMin && furthestIntersectionTowardsMax) {
    if (furthestIntersectionTowardsMinDistance > furthestIntersectionTowardsMaxDistance) {
      side = axis.hiEdge;
    } else {
      side = axis.loEdge;
    }
  } else if (furthestIntersectionTowardsMin && !furthestIntersectionTowardsMax) {
    side = axis.hiEdge;
  } else if (!furthestIntersectionTowardsMin && furthestIntersectionTowardsMax) {
    side = axis.loEdge;
  }
  terminal.side = side;
  return terminal;
}

// ../node_modules/tldraw/dist-esm/lib/shapes/arrow/shared.mjs
var MIN_ARROW_BEND = 8;
function getIsArrowStraight(shape) {
  if (shape.props.kind !== "arc") return false;
  return Math.abs(shape.props.bend) < MIN_ARROW_BEND * shape.props.scale;
}
function getBoundShapeInfoForTerminal(editor, arrow5, terminalName) {
  const binding = editor.getBindingsFromShape(arrow5, "arrow").find((b) => b.props.terminal === terminalName);
  if (!binding) return;
  const boundShape = editor.getShape(binding.toId);
  if (!boundShape) return;
  const transform = editor.getShapePageTransform(boundShape);
  const hasArrowhead = terminalName === "start" ? arrow5.props.arrowheadStart !== "none" : arrow5.props.arrowheadEnd !== "none";
  const geometry = editor.getShapeGeometry(
    boundShape,
    hasArrowhead ? void 0 : { context: "@tldraw/arrow-without-arrowhead" }
  );
  return {
    shape: boundShape,
    transform,
    isClosed: geometry.isClosed,
    isExact: binding.props.isExact,
    didIntersect: false,
    geometry
  };
}
function getArrowTerminalInArrowSpace(editor, arrowPageTransform, binding, forceImprecise) {
  const boundShape = editor.getShape(binding.toId);
  if (!boundShape) {
    return new Vec(0, 0);
  } else {
    const { point, size: size4 } = editor.getShapeGeometry(boundShape).bounds;
    const shapePoint = Vec.Add(
      point,
      Vec.MulV(
        // if the parent is the bound shape, then it's ALWAYS precise
        binding.props.isPrecise || forceImprecise ? binding.props.normalizedAnchor : { x: 0.5, y: 0.5 },
        size4
      )
    );
    const pagePoint = Mat.applyToPoint(editor.getShapePageTransform(boundShape), shapePoint);
    const arrowPoint = Mat.applyToPoint(Mat.Inverse(arrowPageTransform), pagePoint);
    return arrowPoint;
  }
}
var arrowBindingsCache = createComputedCache(
  "arrow bindings",
  (editor, arrow5) => {
    const bindings = editor.getBindingsFromShape(arrow5.id, "arrow");
    return {
      start: bindings.find((b) => b.props.terminal === "start"),
      end: bindings.find((b) => b.props.terminal === "end")
    };
  },
  {
    // we only look at the arrow IDs:
    areRecordsEqual: (a, b) => a.id === b.id,
    // the records should stay the same:
    areResultsEqual: (a, b) => a.start === b.start && a.end === b.end
  }
);
function getArrowBindings(editor, shape) {
  return arrowBindingsCache.get(editor, shape.id);
}
var arrowInfoCache = createComputedCache(
  "arrow info",
  (editor, shape) => {
    const bindings = getArrowBindings(editor, shape);
    if (shape.props.kind === "elbow") {
      const elbowInfo = getElbowArrowInfo(editor, shape, bindings);
      if (!(elbowInfo == null ? void 0 : elbowInfo.route)) return getStraightArrowInfo(editor, shape, bindings);
      const start = elbowInfo.swapOrder ? elbowInfo.B : elbowInfo.A;
      const end = elbowInfo.swapOrder ? elbowInfo.A : elbowInfo.B;
      return {
        type: "elbow",
        bindings,
        start: {
          handle: start.target,
          point: elbowInfo.route.points[0],
          arrowhead: shape.props.arrowheadStart
        },
        end: {
          handle: end.target,
          point: elbowInfo.route.points[elbowInfo.route.points.length - 1],
          arrowhead: shape.props.arrowheadEnd
        },
        elbow: elbowInfo,
        route: elbowInfo.route,
        isValid: true
      };
    }
    if (getIsArrowStraight(shape)) {
      return getStraightArrowInfo(editor, shape, bindings);
    } else {
      return getCurvedArrowInfo(editor, shape, bindings);
    }
  },
  {
    areRecordsEqual: (a, b) => a.props === b.props,
    areResultsEqual: isEqualAllowingForFloatingPointErrors
  }
);
function getArrowInfo(editor, shape) {
  const id = typeof shape === "string" ? shape : shape.id;
  return arrowInfoCache.get(editor, id);
}
function getArrowTerminalsInArrowSpace(editor, shape, bindings) {
  var _a6, _b3;
  const arrowPageTransform = editor.getShapePageTransform(shape);
  const boundShapeRelationships = getBoundShapeRelationships(
    editor,
    (_a6 = bindings.start) == null ? void 0 : _a6.toId,
    (_b3 = bindings.end) == null ? void 0 : _b3.toId
  );
  const start = bindings.start ? getArrowTerminalInArrowSpace(
    editor,
    arrowPageTransform,
    bindings.start,
    boundShapeRelationships === "double-bound" || boundShapeRelationships === "start-contains-end"
  ) : Vec.From(shape.props.start);
  const end = bindings.end ? getArrowTerminalInArrowSpace(
    editor,
    arrowPageTransform,
    bindings.end,
    boundShapeRelationships === "double-bound" || boundShapeRelationships === "end-contains-start"
  ) : Vec.From(shape.props.end);
  return { start, end };
}
function createOrUpdateArrowBinding(editor, arrow5, target, props) {
  const arrowId = typeof arrow5 === "string" ? arrow5 : arrow5.id;
  const targetId = typeof target === "string" ? target : target.id;
  const existingMany = editor.getBindingsFromShape(arrowId, "arrow").filter((b) => b.props.terminal === props.terminal);
  if (existingMany.length > 1) {
    editor.deleteBindings(existingMany.slice(1));
  }
  const existing = existingMany[0];
  if (existing) {
    editor.updateBinding({
      ...existing,
      toId: targetId,
      props
    });
  } else {
    editor.createBinding({
      type: "arrow",
      fromId: arrowId,
      toId: targetId,
      props
    });
  }
}
function removeArrowBinding(editor, arrow5, terminal) {
  const existing = editor.getBindingsFromShape(arrow5, "arrow").filter((b) => b.props.terminal === terminal);
  editor.deleteBindings(existing);
}
var MIN_ARROW_LENGTH = 10;
var BOUND_ARROW_OFFSET = 10;
var WAY_TOO_BIG_ARROW_BEND_FACTOR = 10;
var STROKE_SIZES = {
  s: 2,
  m: 3.5,
  l: 5,
  xl: 10
};
function getBoundShapeRelationships(editor, startShapeId, endShapeId) {
  if (!startShapeId || !endShapeId) return "safe";
  if (startShapeId === endShapeId) return "double-bound";
  const startBounds = editor.getShapePageBounds(startShapeId);
  const endBounds = editor.getShapePageBounds(endShapeId);
  if (startBounds && endBounds) {
    if (startBounds.contains(endBounds)) return "start-contains-end";
    if (endBounds.contains(startBounds)) return "end-contains-start";
  }
  return "safe";
}

// ../node_modules/tldraw/dist-esm/lib/ui/hooks/menu-hooks.mjs
function shapesWithUnboundArrows(editor) {
  const selectedShapeIds = editor.getSelectedShapeIds();
  const selectedShapes = selectedShapeIds.map((id) => {
    return editor.getShape(id);
  });
  return selectedShapes.filter((shape) => {
    if (!shape) return false;
    if (editor.isShapeOfType(shape, "arrow")) {
      const bindings = getArrowBindings(editor, shape);
      if (bindings.start || bindings.end) return false;
    }
    return true;
  });
}
var useThreeStackableItems = () => {
  const editor = useEditor();
  return useValue("threeStackableItems", () => shapesWithUnboundArrows(editor).length > 2, [editor]);
};
var useIsInSelectState = () => {
  const editor = useEditor();
  return useValue("isInSelectState", () => editor.isIn("select"), [editor]);
};
var useAllowGroup = () => {
  const editor = useEditor();
  return useValue(
    "allow group",
    () => {
      const selectedShapes = editor.getSelectedShapes();
      if (selectedShapes.length < 2) return false;
      for (const shape of selectedShapes) {
        if (editor.isShapeOfType(shape, "arrow")) {
          const bindings = getArrowBindings(editor, shape);
          if (bindings.start) {
            if (!selectedShapes.some((s) => s.id === bindings.start.toId)) {
              return false;
            }
          }
          if (bindings.end) {
            if (!selectedShapes.some((s) => s.id === bindings.end.toId)) {
              return false;
            }
          }
        }
      }
      return true;
    },
    [editor]
  );
};
var useAllowUngroup = () => {
  const editor = useEditor();
  return useValue(
    "allowUngroup",
    () => editor.getSelectedShapeIds().some((id) => {
      var _a6;
      return ((_a6 = editor.getShape(id)) == null ? void 0 : _a6.type) === "group";
    }),
    [editor]
  );
};
var showMenuPaste = typeof window !== "undefined" && "navigator" in window && Boolean(navigator.clipboard) && Boolean(navigator.clipboard.read);
function useAnySelectedShapesCount(min3, max2) {
  const editor = useEditor();
  return useValue(
    "selectedShapes",
    () => {
      const len = editor.getSelectedShapes().length;
      if (min3 === void 0) {
        if (max2 === void 0) {
          return len;
        } else {
          return len <= max2;
        }
      } else {
        if (max2 === void 0) {
          return len >= min3;
        } else {
          return len >= min3 && len <= max2;
        }
      }
    },
    [editor, min3, max2]
  );
}
function useUnlockedSelectedShapesCount(min3, max2) {
  const editor = useEditor();
  return useValue(
    "selectedShapes",
    () => {
      const len = editor.getSelectedShapes().filter((s) => !editor.isShapeOrAncestorLocked(s)).length;
      if (min3 === void 0) {
        if (max2 === void 0) {
          return len;
        } else {
          return len <= max2;
        }
      } else {
        if (max2 === void 0) {
          return len >= min3;
        } else {
          return len >= min3 && len <= max2;
        }
      }
    },
    [editor]
  );
}
function useShowAutoSizeToggle() {
  const editor = useEditor();
  return useValue(
    "showAutoSizeToggle",
    () => {
      const selectedShapes = editor.getSelectedShapes();
      return selectedShapes.length === 1 && editor.isShapeOfType(selectedShapes[0], "text") && selectedShapes[0].props.autoSize === false;
    },
    [editor]
  );
}
function useHasLinkShapeSelected() {
  const editor = useEditor();
  return useValue(
    "hasLinkShapeSelected",
    () => {
      const onlySelectedShape = editor.getOnlySelectedShape();
      return !!(onlySelectedShape && onlySelectedShape.type !== "embed" && "url" in onlySelectedShape.props && !onlySelectedShape.isLocked);
    },
    [editor]
  );
}
function useOnlyFlippableShape() {
  const editor = useEditor();
  return useValue(
    "onlyFlippableShape",
    () => {
      const shape = editor.getOnlySelectedShape();
      return shape && (editor.isShapeOfType(shape, "group") || editor.isShapeOfType(shape, "image") || editor.isShapeOfType(shape, "arrow") || editor.isShapeOfType(shape, "line") || editor.isShapeOfType(shape, "draw"));
    },
    [editor]
  );
}
function useCanRedo() {
  const editor = useEditor();
  return useValue("useCanRedo", () => editor.getCanRedo(), [editor]);
}
function useCanUndo() {
  const editor = useEditor();
  return useValue("useCanUndo", () => editor.getCanUndo(), [editor]);
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/ActionsMenu/DefaultActionsMenuContent.mjs
function DefaultActionsMenuContent() {
  return (0, import_jsx_runtime117.jsxs)(import_jsx_runtime117.Fragment, { children: [
    (0, import_jsx_runtime117.jsx)(AlignMenuItems, {}),
    (0, import_jsx_runtime117.jsx)(DistributeMenuItems, {}),
    (0, import_jsx_runtime117.jsx)(StackMenuItems, {}),
    (0, import_jsx_runtime117.jsx)(ReorderMenuItems, {}),
    (0, import_jsx_runtime117.jsx)(ZoomOrRotateMenuItem, {}),
    (0, import_jsx_runtime117.jsx)(RotateCWMenuItem, {}),
    (0, import_jsx_runtime117.jsx)(EditLinkMenuItem, {}),
    (0, import_jsx_runtime117.jsx)(GroupOrUngroupMenuItem, {})
  ] });
}
function AlignMenuItems() {
  const twoSelected = useUnlockedSelectedShapesCount(2);
  const isInSelectState = useIsInSelectState();
  const enabled = twoSelected && isInSelectState;
  return (0, import_jsx_runtime117.jsxs)(import_jsx_runtime117.Fragment, { children: [
    (0, import_jsx_runtime117.jsx)(TldrawUiMenuActionItem, { actionId: "align-left", disabled: !enabled }),
    (0, import_jsx_runtime117.jsx)(TldrawUiMenuActionItem, { actionId: "align-center-horizontal", disabled: !enabled }),
    (0, import_jsx_runtime117.jsx)(TldrawUiMenuActionItem, { actionId: "align-right", disabled: !enabled }),
    (0, import_jsx_runtime117.jsx)(TldrawUiMenuActionItem, { actionId: "stretch-horizontal", disabled: !enabled }),
    (0, import_jsx_runtime117.jsx)(TldrawUiMenuActionItem, { actionId: "align-top", disabled: !enabled }),
    (0, import_jsx_runtime117.jsx)(TldrawUiMenuActionItem, { actionId: "align-center-vertical", disabled: !enabled }),
    (0, import_jsx_runtime117.jsx)(TldrawUiMenuActionItem, { actionId: "align-bottom", disabled: !enabled }),
    (0, import_jsx_runtime117.jsx)(TldrawUiMenuActionItem, { actionId: "stretch-vertical", disabled: !enabled })
  ] });
}
function DistributeMenuItems() {
  const threeSelected = useUnlockedSelectedShapesCount(3);
  const isInSelectState = useIsInSelectState();
  const enabled = threeSelected && isInSelectState;
  return (0, import_jsx_runtime117.jsxs)(import_jsx_runtime117.Fragment, { children: [
    (0, import_jsx_runtime117.jsx)(TldrawUiMenuActionItem, { actionId: "distribute-horizontal", disabled: !enabled }),
    (0, import_jsx_runtime117.jsx)(TldrawUiMenuActionItem, { actionId: "distribute-vertical", disabled: !enabled })
  ] });
}
function StackMenuItems() {
  const threeStackableItems = useThreeStackableItems();
  const isInSelectState = useIsInSelectState();
  const enabled = threeStackableItems && isInSelectState;
  return (0, import_jsx_runtime117.jsxs)(import_jsx_runtime117.Fragment, { children: [
    (0, import_jsx_runtime117.jsx)(TldrawUiMenuActionItem, { actionId: "stack-horizontal", disabled: !enabled }),
    (0, import_jsx_runtime117.jsx)(TldrawUiMenuActionItem, { actionId: "stack-vertical", disabled: !enabled })
  ] });
}
function ReorderMenuItems() {
  const oneSelected = useUnlockedSelectedShapesCount(1);
  const isInSelectState = useIsInSelectState();
  const enabled = oneSelected && isInSelectState;
  return (0, import_jsx_runtime117.jsxs)(import_jsx_runtime117.Fragment, { children: [
    (0, import_jsx_runtime117.jsx)(TldrawUiMenuActionItem, { actionId: "send-to-back", disabled: !enabled }),
    (0, import_jsx_runtime117.jsx)(TldrawUiMenuActionItem, { actionId: "send-backward", disabled: !enabled }),
    (0, import_jsx_runtime117.jsx)(TldrawUiMenuActionItem, { actionId: "bring-forward", disabled: !enabled }),
    (0, import_jsx_runtime117.jsx)(TldrawUiMenuActionItem, { actionId: "bring-to-front", disabled: !enabled })
  ] });
}
function ZoomOrRotateMenuItem() {
  const breakpoint = useBreakpoint();
  return breakpoint < PORTRAIT_BREAKPOINT.TABLET_SM ? (0, import_jsx_runtime117.jsx)(ZoomTo100MenuItem, {}) : (0, import_jsx_runtime117.jsx)(RotateCCWMenuItem, {});
}
function RotateCCWMenuItem() {
  const oneSelected = useUnlockedSelectedShapesCount(1);
  const isInSelectState = useIsInSelectState();
  const enabled = oneSelected && isInSelectState;
  return (0, import_jsx_runtime117.jsx)(TldrawUiMenuActionItem, { actionId: "rotate-ccw", disabled: !enabled });
}
function RotateCWMenuItem() {
  const oneSelected = useUnlockedSelectedShapesCount(1);
  const isInSelectState = useIsInSelectState();
  const enabled = oneSelected && isInSelectState;
  return (0, import_jsx_runtime117.jsx)(TldrawUiMenuActionItem, { actionId: "rotate-cw", disabled: !enabled });
}
function EditLinkMenuItem() {
  const showEditLink = useHasLinkShapeSelected();
  const isInSelectState = useIsInSelectState();
  const enabled = showEditLink && isInSelectState;
  return (0, import_jsx_runtime117.jsx)(TldrawUiMenuActionItem, { actionId: "edit-link", disabled: !enabled });
}
function GroupOrUngroupMenuItem() {
  const allowGroup = useAllowGroup();
  const allowUngroup = useAllowUngroup();
  return allowGroup ? (0, import_jsx_runtime117.jsx)(GroupMenuItem, {}) : allowUngroup ? (0, import_jsx_runtime117.jsx)(UngroupMenuItem, {}) : (0, import_jsx_runtime117.jsx)(GroupMenuItem, {});
}
function GroupMenuItem() {
  const twoSelected = useUnlockedSelectedShapesCount(2);
  const isInSelectState = useIsInSelectState();
  const enabled = twoSelected && isInSelectState;
  return (0, import_jsx_runtime117.jsx)(TldrawUiMenuActionItem, { actionId: "group", disabled: !enabled });
}
function UngroupMenuItem() {
  return (0, import_jsx_runtime117.jsx)(TldrawUiMenuActionItem, { actionId: "ungroup" });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/ActionsMenu/DefaultActionsMenu.mjs
var DefaultActionsMenu = (0, import_react83.memo)(function DefaultActionsMenu2({
  children
}) {
  const msg2 = useTranslation();
  const breakpoint = useBreakpoint();
  const isReadonlyMode = useReadonly();
  const { orientation } = useTldrawUiOrientation();
  const ref = (0, import_react83.useRef)(null);
  usePassThroughWheelEvents(ref);
  const editor = useEditor();
  const isInAcceptableReadonlyState = useValue(
    "should display quick actions when in readonly",
    () => editor.isInAny("hand", "zoom"),
    [editor]
  );
  const content = children ?? (0, import_jsx_runtime118.jsx)(DefaultActionsMenuContent, {});
  if (isReadonlyMode && !isInAcceptableReadonlyState) return;
  return (0, import_jsx_runtime118.jsxs)(TldrawUiPopover, { id: "actions-menu", children: [
    (0, import_jsx_runtime118.jsx)(TldrawUiPopoverTrigger, { children: (0, import_jsx_runtime118.jsx)(
      TldrawUiToolbarButton,
      {
        type: "icon",
        "data-testid": "actions-menu.button",
        title: msg2("actions-menu.title"),
        children: (0, import_jsx_runtime118.jsx)(
          TldrawUiButtonIcon,
          {
            icon: orientation === "horizontal" ? "dots-vertical" : "dots-horizontal",
            small: true
          }
        )
      }
    ) }),
    (0, import_jsx_runtime118.jsx)(
      TldrawUiPopoverContent,
      {
        side: orientation === "horizontal" ? breakpoint >= PORTRAIT_BREAKPOINT.TABLET ? "bottom" : "top" : "right",
        sideOffset: 6,
        children: (0, import_jsx_runtime118.jsx)(
          TldrawUiToolbar,
          {
            ref,
            label: msg2("actions-menu.title"),
            className: "tlui-actions-menu",
            "data-testid": "actions-menu.content",
            orientation: "grid",
            children: (0, import_jsx_runtime118.jsx)(TldrawUiMenuContextProvider, { type: "icons", sourceId: "actions-menu", children: content })
          }
        )
      }
    )
  ] });
});

// ../node_modules/tldraw/dist-esm/lib/ui/components/ContextMenu/DefaultContextMenu.mjs
var import_jsx_runtime120 = __toESM(require_jsx_runtime(), 1);
var import_react84 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/components/ContextMenu/DefaultContextMenuContent.mjs
var import_jsx_runtime119 = __toESM(require_jsx_runtime(), 1);
function DefaultContextMenuContent() {
  const editor = useEditor();
  const showCollaborationUi = useShowCollaborationUi();
  const selectToolActive = useValue(
    "isSelectToolActive",
    () => editor.getCurrentToolId() === "select",
    [editor]
  );
  const isSinglePageMode = useValue("isSinglePageMode", () => editor.options.maxPages <= 1, [
    editor
  ]);
  if (!selectToolActive) return null;
  return (0, import_jsx_runtime119.jsxs)(import_jsx_runtime119.Fragment, { children: [
    showCollaborationUi && (0, import_jsx_runtime119.jsx)(CursorChatItem, {}),
    (0, import_jsx_runtime119.jsxs)(TldrawUiMenuGroup, { id: "modify", children: [
      (0, import_jsx_runtime119.jsx)(EditMenuSubmenu, {}),
      (0, import_jsx_runtime119.jsx)(ArrangeMenuSubmenu, {}),
      (0, import_jsx_runtime119.jsx)(ReorderMenuSubmenu, {}),
      !isSinglePageMode && (0, import_jsx_runtime119.jsx)(MoveToPageMenu, {})
    ] }),
    (0, import_jsx_runtime119.jsx)(ClipboardMenuGroup, {}),
    (0, import_jsx_runtime119.jsx)(ConversionsMenuGroup, {}),
    (0, import_jsx_runtime119.jsx)(TldrawUiMenuGroup, { id: "select-all", children: (0, import_jsx_runtime119.jsx)(SelectAllMenuItem, {}) })
  ] });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/ContextMenu/DefaultContextMenu.mjs
var DefaultContextMenu = (0, import_react84.memo)(function DefaultContextMenu2({
  children,
  disabled = false
}) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const { Canvas } = useEditorComponents();
  const preventEscapeFromLosingShapeFocus = (0, import_react84.useCallback)(
    (e) => {
      if (e.key === "Escape") {
        e.stopPropagation();
        editor.getContainer().focus();
      }
    },
    [editor]
  );
  (0, import_react84.useEffect)(() => {
    return () => {
      document.body.removeEventListener("keydown", preventEscapeFromLosingShapeFocus, {
        capture: true
      });
    };
  }, [preventEscapeFromLosingShapeFocus]);
  const cb = (0, import_react84.useCallback)(
    (isOpen2) => {
      if (!isOpen2) {
        const onlySelectedShape = editor.getOnlySelectedShape();
        if (onlySelectedShape && editor.isShapeOrAncestorLocked(onlySelectedShape)) {
          editor.setSelectedShapes([]);
        }
        editor.timers.requestAnimationFrame(() => {
          document.body.removeEventListener("keydown", preventEscapeFromLosingShapeFocus, {
            capture: true
          });
        });
      } else {
        document.body.addEventListener("keydown", preventEscapeFromLosingShapeFocus, {
          capture: true
        });
        if (editor.getInstanceState().isCoarsePointer) {
          const selectedShapes = editor.getSelectedShapes();
          const currentPagePoint = editor.inputs.getCurrentPagePoint();
          const shapesAtPoint = editor.getShapesAtPoint(currentPagePoint);
          if (
            // if there are no selected shapes
            !editor.getSelectedShapes().length || // OR if none of the shapes at the point include the selected shape
            !shapesAtPoint.some((s) => selectedShapes.includes(s))
          ) {
            const lockedShapes = shapesAtPoint.filter((s) => editor.isShapeOrAncestorLocked(s));
            if (lockedShapes.length) {
              editor.select(...lockedShapes.map((s) => s.id));
            }
          }
        }
      }
    },
    [editor, preventEscapeFromLosingShapeFocus]
  );
  const container = useContainer();
  const [isOpen, handleOpenChange] = useMenuIsOpen("context menu", cb);
  const content = children ?? (0, import_jsx_runtime120.jsx)(DefaultContextMenuContent, {});
  return (0, import_jsx_runtime120.jsxs)(dist_exports8.Root, { dir: "ltr", onOpenChange: handleOpenChange, modal: false, children: [
    (0, import_jsx_runtime120.jsx)(dist_exports8.Trigger, { onContextMenu: void 0, dir: "ltr", disabled, children: Canvas ? (0, import_jsx_runtime120.jsx)(Canvas, {}) : null }),
    isOpen && (0, import_jsx_runtime120.jsx)(dist_exports8.Portal, { container, children: (0, import_jsx_runtime120.jsx)(
      dist_exports8.Content,
      {
        className: "tlui-menu tlui-scrollable",
        "data-testid": "context-menu",
        "aria-label": msg2("context-menu.title"),
        alignOffset: -4,
        collisionPadding: 4,
        onContextMenu: preventDefault,
        children: (0, import_jsx_runtime120.jsx)(TldrawUiMenuContextProvider, { type: "context-menu", sourceId: "context-menu", children: content })
      }
    ) })
  ] });
});

// ../node_modules/tldraw/dist-esm/lib/ui/components/CursorChatBubble.mjs
var import_jsx_runtime121 = __toESM(require_jsx_runtime(), 1);
var import_react85 = __toESM(require_react(), 1);
var CHAT_MESSAGE_TIMEOUT_CLOSING = 2e3;
var CHAT_MESSAGE_TIMEOUT_CHATTING = 5e3;
var CursorChatBubble = track(function CursorChatBubble2() {
  const editor = useEditor();
  const { isChatting, chatMessage } = editor.getInstanceState();
  const rTimeout = (0, import_react85.useRef)(-1);
  const [value, setValue] = (0, import_react85.useState)("");
  (0, import_react85.useEffect)(() => {
    const closingUp = !isChatting && chatMessage;
    if (closingUp || isChatting) {
      const duration = isChatting ? CHAT_MESSAGE_TIMEOUT_CHATTING : CHAT_MESSAGE_TIMEOUT_CLOSING;
      rTimeout.current = editor.timers.setTimeout(() => {
        editor.updateInstanceState({ chatMessage: "", isChatting: false });
        setValue("");
        editor.focus();
      }, duration);
    }
    return () => {
      clearTimeout(rTimeout.current);
    };
  }, [editor, chatMessage, isChatting]);
  if (isChatting)
    return (0, import_jsx_runtime121.jsx)(CursorChatInput, { value, setValue, chatMessage });
  return chatMessage.trim() ? (0, import_jsx_runtime121.jsx)(NotEditingChatMessage, { chatMessage }) : null;
});
function usePositionBubble(ref) {
  const editor = useEditor();
  (0, import_react85.useLayoutEffect)(() => {
    var _a6;
    const elm = ref.current;
    if (!elm) return;
    const { x, y } = editor.inputs.getCurrentScreenPoint();
    (_a6 = ref.current) == null ? void 0 : _a6.style.setProperty("transform", `translate(${x}px, ${y}px)`);
    function positionChatBubble(e) {
      var _a7;
      const { minX, minY } = editor.getViewportScreenBounds();
      (_a7 = ref.current) == null ? void 0 : _a7.style.setProperty(
        "transform",
        `translate(${e.clientX - minX}px, ${e.clientY - minY}px)`
      );
    }
    window.addEventListener("pointermove", positionChatBubble);
    return () => {
      window.removeEventListener("pointermove", positionChatBubble);
    };
  }, [ref, editor]);
}
var NotEditingChatMessage = ({ chatMessage }) => {
  const editor = useEditor();
  const ref = (0, import_react85.useRef)(null);
  usePositionBubble(ref);
  return (0, import_jsx_runtime121.jsx)(
    "div",
    {
      ref,
      className: "tl-cursor-chat tl-cursor-chat__bubble",
      style: { backgroundColor: editor.user.getColor() },
      children: chatMessage
    }
  );
};
var CursorChatInput = track(function CursorChatInput2({
  chatMessage,
  value,
  setValue
}) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const ref = (0, import_react85.useRef)(null);
  const placeholder = chatMessage || msg2("cursor-chat.type-to-chat");
  usePositionBubble(ref);
  (0, import_react85.useLayoutEffect)(() => {
    const elm = ref.current;
    if (!elm) return;
    const textMeasurement = editor.textMeasure.measureText(value || placeholder, {
      fontFamily: "var(--font-body)",
      fontSize: 12,
      fontWeight: "500",
      fontStyle: "normal",
      maxWidth: null,
      lineHeight: 1,
      padding: "6px"
    });
    elm.style.setProperty("width", textMeasurement.w + "px");
  }, [editor, value, placeholder]);
  (0, import_react85.useLayoutEffect)(() => {
    const raf = editor.timers.requestAnimationFrame(() => {
      var _a6;
      (_a6 = ref.current) == null ? void 0 : _a6.focus();
    });
    return () => {
      cancelAnimationFrame(raf);
    };
  }, [editor]);
  const stopChatting = (0, import_react85.useCallback)(() => {
    editor.updateInstanceState({ isChatting: false });
    editor.focus();
  }, [editor]);
  const handleChange = (0, import_react85.useCallback)(
    (e) => {
      const { value: value2 } = e.target;
      setValue(value2.slice(0, 64));
      editor.updateInstanceState({ chatMessage: value2 });
    },
    [editor, setValue]
  );
  const handleKeyDown2 = (0, import_react85.useCallback)(
    (e) => {
      const elm = ref.current;
      if (!elm) return;
      const { value: currentValue } = elm;
      switch (e.key) {
        case "Enter": {
          preventDefault(e);
          e.stopPropagation();
          if (!currentValue) {
            stopChatting();
            return;
          }
          setValue("");
          break;
        }
        case "Escape": {
          preventDefault(e);
          e.stopPropagation();
          stopChatting();
          break;
        }
      }
    },
    [stopChatting, setValue]
  );
  const handlePaste = (0, import_react85.useCallback)((e) => {
    e.stopPropagation();
  }, []);
  return (0, import_jsx_runtime121.jsx)(
    "input",
    {
      ref,
      className: `tl-cursor-chat`,
      style: { backgroundColor: editor.user.getColor() },
      onBlur: stopChatting,
      onChange: handleChange,
      onKeyDown: handleKeyDown2,
      onPaste: handlePaste,
      value,
      placeholder,
      spellCheck: false
    }
  );
});

// ../node_modules/tldraw/dist-esm/lib/ui/components/DebugMenu/DefaultDebugMenu.mjs
var import_jsx_runtime126 = __toESM(require_jsx_runtime(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/components/DebugMenu/DefaultDebugMenuContent.mjs
var import_jsx_runtime125 = __toESM(require_jsx_runtime(), 1);
var import_react86 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/components/primitives/Button/TldrawUiButtonCheck.mjs
var import_jsx_runtime122 = __toESM(require_jsx_runtime(), 1);
function TldrawUiButtonCheck({ checked }) {
  const msg2 = useTranslation();
  return (0, import_jsx_runtime122.jsx)(
    TldrawUiIcon,
    {
      "data-checked": !!checked,
      label: msg2(checked ? "ui.checked" : "ui.unchecked"),
      icon: checked ? "check" : "none",
      className: "tlui-button__icon",
      small: true
    }
  );
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/primitives/menus/TldrawUiMenuCheckboxItem.mjs
var import_jsx_runtime123 = __toESM(require_jsx_runtime(), 1);
function TldrawUiMenuCheckboxItem({
  id,
  kbd: kbd2,
  label,
  lang,
  readonlyOk,
  onSelect,
  toggle = false,
  disabled = false,
  checked = false
}) {
  const { type: menuType, sourceId } = useTldrawUiMenuContext();
  const isReadonlyMode = useReadonly();
  const msg2 = useTranslation();
  if (isReadonlyMode && !readonlyOk) return null;
  const labelToUse = unwrapLabel(label, menuType);
  const labelStr = labelToUse ? msg2(labelToUse) : void 0;
  switch (menuType) {
    case "menu": {
      return (0, import_jsx_runtime123.jsxs)(
        dist_exports10.CheckboxItem,
        {
          dir: "ltr",
          lang,
          className: "tlui-button tlui-button__menu tlui-button__checkbox",
          title: labelStr,
          onSelect: (e) => {
            onSelect == null ? void 0 : onSelect(sourceId);
            preventDefault(e);
          },
          disabled,
          checked,
          children: [
            (0, import_jsx_runtime123.jsx)(
              TldrawUiIcon,
              {
                small: true,
                label: msg2(checked ? "ui.checked" : "ui.unchecked"),
                icon: toggle ? checked ? "toggle-on" : "toggle-off" : checked ? "check" : "none"
              }
            ),
            labelStr && (0, import_jsx_runtime123.jsx)("span", { className: "tlui-button__label", draggable: false, children: labelStr }),
            kbd2 && (0, import_jsx_runtime123.jsx)(TldrawUiKbd, { children: kbd2 })
          ]
        }
      );
    }
    case "context-menu": {
      return (0, import_jsx_runtime123.jsxs)(
        dist_exports8.CheckboxItem,
        {
          className: "tlui-button tlui-button__menu tlui-button__checkbox",
          dir: "ltr",
          lang,
          title: labelStr,
          onSelect: (e) => {
            onSelect(sourceId);
            preventDefault(e);
          },
          disabled,
          checked,
          children: [
            (0, import_jsx_runtime123.jsx)(
              TldrawUiIcon,
              {
                small: true,
                label: msg2(checked ? "ui.checked" : "ui.unchecked"),
                icon: toggle ? checked ? "toggle-on" : "toggle-off" : checked ? "check" : "none"
              }
            ),
            labelStr && (0, import_jsx_runtime123.jsx)("span", { className: "tlui-button__label", draggable: false, children: labelStr }),
            kbd2 && (0, import_jsx_runtime123.jsx)(TldrawUiKbd, { children: kbd2 })
          ]
        },
        id
      );
    }
    default: {
      return null;
    }
  }
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/primitives/menus/TldrawUiMenuSubmenu.mjs
var import_jsx_runtime124 = __toESM(require_jsx_runtime(), 1);
function TldrawUiMenuSubmenu({
  id,
  disabled = false,
  label,
  size: size4 = "small",
  children
}) {
  const { type: menuType, sourceId } = useTldrawUiMenuContext();
  const container = useContainer();
  const msg2 = useTranslation();
  const labelToUse = label ? typeof label === "string" ? label : label[menuType] ?? label["default"] : void 0;
  const labelStr = labelToUse ? msg2(labelToUse) : void 0;
  switch (menuType) {
    case "menu": {
      return (0, import_jsx_runtime124.jsxs)(TldrawUiDropdownMenuSub, { id: `${sourceId}-sub.${id}`, children: [
        (0, import_jsx_runtime124.jsx)(
          TldrawUiDropdownMenuSubTrigger,
          {
            id: `${sourceId}-sub.${id}-button`,
            disabled,
            label: labelStr,
            title: labelStr
          }
        ),
        (0, import_jsx_runtime124.jsx)(TldrawUiDropdownMenuSubContent, { id: `${sourceId}-sub.${id}-content`, size: size4, children })
      ] });
    }
    case "context-menu": {
      if (disabled) return null;
      return (0, import_jsx_runtime124.jsxs)(ContextMenuSubWithMenu, { id: `${sourceId}-sub.${id}`, children: [
        (0, import_jsx_runtime124.jsx)(dist_exports8.ContextMenuSubTrigger, { dir: "ltr", disabled, asChild: true, children: (0, import_jsx_runtime124.jsxs)(
          TldrawUiButton,
          {
            "data-testid": `${sourceId}-sub.${id}-button`,
            type: "menu",
            className: "tlui-menu__submenu__trigger",
            children: [
              (0, import_jsx_runtime124.jsx)(TldrawUiButtonLabel, { children: labelStr }),
              (0, import_jsx_runtime124.jsx)(TldrawUiButtonIcon, { icon: "chevron-right", small: true })
            ]
          }
        ) }),
        (0, import_jsx_runtime124.jsx)(dist_exports8.ContextMenuPortal, { container, children: (0, import_jsx_runtime124.jsx)(
          dist_exports8.ContextMenuSubContent,
          {
            "data-testid": `${sourceId}-sub.${id}-content`,
            className: "tlui-menu tlui-menu__submenu__content",
            alignOffset: -1,
            sideOffset: -4,
            collisionPadding: 4,
            "data-size": size4,
            children
          }
        ) })
      ] });
    }
    default: {
      return children;
    }
  }
}
function ContextMenuSubWithMenu({ id, children }) {
  const [open, onOpenChange] = useMenuIsOpen(id);
  return (0, import_jsx_runtime124.jsx)(dist_exports8.ContextMenuSub, { open, onOpenChange, children });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/DebugMenu/DefaultDebugMenuContent.mjs
function DefaultDebugMenuContent({
  customDebugFlags,
  customFeatureFlags
}) {
  const editor = useEditor();
  const { addToast } = useToasts();
  const { addDialog } = useDialogs();
  const [error, setError] = import_react86.default.useState(false);
  return (0, import_jsx_runtime125.jsxs)(import_jsx_runtime125.Fragment, { children: [
    (0, import_jsx_runtime125.jsxs)(TldrawUiMenuGroup, { id: "items", children: [
      (0, import_jsx_runtime125.jsx)(TldrawUiMenuItem, { id: "hard-reset", onSelect: hardResetEditor, label: "Hard reset" }),
      (0, import_jsx_runtime125.jsx)(
        TldrawUiMenuItem,
        {
          id: "add-toast",
          onSelect: () => {
            addToast({
              id: uniqueId(),
              title: "Something good happened",
              description: "Hey, attend to this thing over here. It might be important!",
              keepOpen: true,
              severity: "success"
            });
            addToast({
              id: uniqueId(),
              title: "Something happened",
              description: "Hey, attend to this thing over here. It might be important!",
              keepOpen: true,
              severity: "info",
              actions: [
                {
                  label: "Primary",
                  type: "primary",
                  onClick: () => {
                  }
                },
                {
                  label: "Normal",
                  type: "normal",
                  onClick: () => {
                  }
                },
                {
                  label: "Danger",
                  type: "danger",
                  onClick: () => {
                  }
                }
              ]
            });
            addToast({
              id: uniqueId(),
              title: "Something maybe bad happened",
              description: "Hey, attend to this thing over here. It might be important!",
              keepOpen: true,
              severity: "warning",
              actions: [
                {
                  label: "Primary",
                  type: "primary",
                  onClick: () => {
                  }
                },
                {
                  label: "Normal",
                  type: "normal",
                  onClick: () => {
                  }
                },
                {
                  label: "Danger",
                  type: "danger",
                  onClick: () => {
                  }
                }
              ]
            });
            addToast({
              id: uniqueId(),
              title: "Something bad happened",
              severity: "error",
              keepOpen: true
            });
          },
          label: untranslated("Show toast")
        }
      ),
      (0, import_jsx_runtime125.jsx)(
        TldrawUiMenuItem,
        {
          id: "show-dialog",
          label: "Show dialog",
          onSelect: () => {
            addDialog({
              component: ({ onClose }) => (0, import_jsx_runtime125.jsx)(
                ExampleDialog,
                {
                  displayDontShowAgain: true,
                  onCancel: () => onClose(),
                  onContinue: () => onClose()
                }
              ),
              onClose: () => {
              }
            });
          }
        }
      ),
      (0, import_jsx_runtime125.jsx)(
        TldrawUiMenuItem,
        {
          id: "create-shapes",
          label: "Create 100 shapes",
          onSelect: () => createNShapes(editor, 100)
        }
      ),
      (0, import_jsx_runtime125.jsx)(
        TldrawUiMenuItem,
        {
          id: "count-nodes",
          label: "Count shapes / nodes",
          onSelect: () => {
            var _a6;
            const selectedShapes = editor.getSelectedShapes();
            const shapes = selectedShapes.length === 0 ? editor.getRenderingShapes() : selectedShapes;
            window.alert(
              `Shapes ${shapes.length}, DOM nodes:${(_a6 = document.querySelector(".tl-shapes").querySelectorAll("*")) == null ? void 0 : _a6.length}`
            );
          }
        }
      ),
      (() => {
        if (error) throw Error("oh no!");
        return null;
      })(),
      (0, import_jsx_runtime125.jsx)(TldrawUiMenuItem, { id: "throw-error", onSelect: () => setError(true), label: "Throw error" })
    ] }),
    (0, import_jsx_runtime125.jsxs)(TldrawUiMenuGroup, { id: "flags", children: [
      (0, import_jsx_runtime125.jsx)(DebugFlags, { customDebugFlags }),
      (0, import_jsx_runtime125.jsx)(FeatureFlags, { customFeatureFlags })
    ] })
  ] });
}
function DebugFlags(props) {
  const items = Object.values(props.customDebugFlags ?? debugFlags);
  if (!items.length) return null;
  return (0, import_jsx_runtime125.jsx)(TldrawUiMenuSubmenu, { id: "debug flags", label: "Debug flags", children: (0, import_jsx_runtime125.jsx)(TldrawUiMenuGroup, { id: "debug flags", children: items.map((flag) => (0, import_jsx_runtime125.jsx)(DebugFlagToggle, { flag }, flag.name)) }) });
}
function FeatureFlags(props) {
  const items = Object.values(props.customFeatureFlags ?? featureFlags);
  if (!items.length) return null;
  return (0, import_jsx_runtime125.jsx)(TldrawUiMenuSubmenu, { id: "feature flags", label: "Feature flags", children: (0, import_jsx_runtime125.jsx)(TldrawUiMenuGroup, { id: "feature flags", children: items.map((flag) => (0, import_jsx_runtime125.jsx)(DebugFlagToggle, { flag }, flag.name)) }) });
}
function ExampleDialog({
  title = "title",
  body = "hello hello hello",
  cancel = "Cancel",
  confirm = "Continue",
  displayDontShowAgain = false,
  maxWidth = "350",
  onCancel,
  onContinue
}) {
  const [dontShowAgain, setDontShowAgain] = import_react86.default.useState(false);
  return (0, import_jsx_runtime125.jsxs)(import_jsx_runtime125.Fragment, { children: [
    (0, import_jsx_runtime125.jsxs)(TldrawUiDialogHeader, { children: [
      (0, import_jsx_runtime125.jsx)(TldrawUiDialogTitle, { children: title }),
      (0, import_jsx_runtime125.jsx)(TldrawUiDialogCloseButton, {})
    ] }),
    (0, import_jsx_runtime125.jsx)(TldrawUiDialogBody, { style: { maxWidth }, children: body }),
    (0, import_jsx_runtime125.jsxs)(TldrawUiDialogFooter, { className: "tlui-dialog__footer__actions", children: [
      displayDontShowAgain && (0, import_jsx_runtime125.jsxs)(
        TldrawUiButton,
        {
          type: "normal",
          onClick: () => setDontShowAgain(!dontShowAgain),
          style: { marginRight: "auto" },
          children: [
            (0, import_jsx_runtime125.jsx)(TldrawUiButtonCheck, { checked: dontShowAgain }),
            (0, import_jsx_runtime125.jsx)(TldrawUiButtonLabel, { children: "Don’t show again" })
          ]
        }
      ),
      (0, import_jsx_runtime125.jsx)(TldrawUiButton, { type: "normal", onClick: onCancel, children: (0, import_jsx_runtime125.jsx)(TldrawUiButtonLabel, { children: cancel }) }),
      (0, import_jsx_runtime125.jsx)(TldrawUiButton, { type: "primary", onClick: async () => onContinue(), children: (0, import_jsx_runtime125.jsx)(TldrawUiButtonLabel, { children: confirm }) })
    ] })
  ] });
}
var DebugFlagToggle = track(function DebugFlagToggle2({
  flag,
  onChange
}) {
  const value = flag.get();
  return (0, import_jsx_runtime125.jsx)(
    TldrawUiMenuCheckboxItem,
    {
      id: flag.name,
      title: flag.name,
      label: flag.name.replace(/([a-z0-9])([A-Z])/g, (m) => `${m[0]} ${m[1].toLowerCase()}`).replace(/^[a-z]/, (m) => m.toUpperCase()),
      checked: value,
      onSelect: () => {
        flag.set(!value);
        onChange == null ? void 0 : onChange(!value);
      }
    }
  );
});
var t = 0;
function createNShapes(editor, n) {
  const gap = editor.options.adjacentShapeMargin;
  const shapesToCreate = Array(n);
  const cols = Math.floor(Math.sqrt(n));
  for (let i = 0; i < n; i++) {
    t++;
    shapesToCreate[i] = {
      id: createShapeId("box" + t),
      type: "geo",
      x: i % cols * (100 + gap),
      y: Math.floor(i / cols) * (100 + gap)
    };
  }
  editor.run(() => {
    editor.createShapes(shapesToCreate).setSelectedShapes(shapesToCreate.map((s) => s.id));
  });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/DebugMenu/DefaultDebugMenu.mjs
function DefaultDebugMenu({ children }) {
  const content = children ?? (0, import_jsx_runtime126.jsx)(DefaultDebugMenuContent, {});
  return (0, import_jsx_runtime126.jsxs)(TldrawUiDropdownMenuRoot, { id: "debug", children: [
    (0, import_jsx_runtime126.jsx)(TldrawUiDropdownMenuTrigger, { children: (0, import_jsx_runtime126.jsx)(TldrawUiButton, { type: "icon", title: "Debug menu", children: (0, import_jsx_runtime126.jsx)(TldrawUiButtonIcon, { icon: "dots-horizontal" }) }) }),
    (0, import_jsx_runtime126.jsx)(TldrawUiDropdownMenuContent, { side: "top", align: "end", alignOffset: 0, children: (0, import_jsx_runtime126.jsx)(TldrawUiMenuContextProvider, { type: "menu", sourceId: "debug-panel", children: content }) })
  ] });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/DefaultDebugPanel.mjs
var import_jsx_runtime127 = __toESM(require_jsx_runtime(), 1);
var import_react87 = __toESM(require_react(), 1);
var DefaultDebugPanel = (0, import_react87.memo)(function DefaultDebugPanel2() {
  const { DebugMenu } = useTldrawUiComponents();
  const ref = (0, import_react87.useRef)(null);
  usePassThroughWheelEvents(ref);
  return (0, import_jsx_runtime127.jsxs)("footer", { ref, className: "tlui-debug-panel", children: [
    (0, import_jsx_runtime127.jsx)(CurrentState, {}),
    (0, import_jsx_runtime127.jsx)(FPS, {}),
    DebugMenu && (0, import_jsx_runtime127.jsx)(DebugMenu, {})
  ] });
});
var CurrentState = track(function CurrentState2() {
  const editor = useEditor();
  const path = editor.getPath();
  return (0, import_jsx_runtime127.jsx)("div", { className: "tlui-debug-panel__current-state", children: `${path}` });
});
function FPS() {
  const editor = useEditor();
  const showFps = useValue("show_fps", () => debugFlags.showFps.get(), [debugFlags]);
  const fpsRef = (0, import_react87.useRef)(null);
  (0, import_react87.useEffect)(() => {
    if (!showFps) return;
    const TICK_LENGTH = 250;
    let maxKnownFps = 0;
    let raf = -1;
    let start = performance.now();
    let currentTickLength = 0;
    let framesInCurrentTick = 0;
    let isSlow = false;
    function loop() {
      framesInCurrentTick++;
      currentTickLength = performance.now() - start;
      if (currentTickLength > TICK_LENGTH) {
        const fps = Math.round(
          framesInCurrentTick * (TICK_LENGTH / currentTickLength) * (1e3 / TICK_LENGTH)
        );
        if (fps > maxKnownFps) {
          maxKnownFps = fps;
        }
        const slowFps = maxKnownFps * 0.75;
        if (fps < slowFps && !isSlow || fps >= slowFps && isSlow) {
          isSlow = !isSlow;
        }
        fpsRef.current.innerHTML = `FPS ${fps.toString()}`;
        fpsRef.current.className = `tlui-debug-panel__fps` + (isSlow ? ` tlui-debug-panel__fps__slow` : ``);
        currentTickLength -= TICK_LENGTH;
        framesInCurrentTick = 0;
        start = performance.now();
      }
      raf = editor.timers.requestAnimationFrame(loop);
    }
    loop();
    return () => {
      cancelAnimationFrame(raf);
    };
  }, [showFps, editor]);
  if (!showFps) return null;
  return (0, import_jsx_runtime127.jsx)("div", { ref: fpsRef });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/DefaultFollowingIndicator.mjs
var import_jsx_runtime128 = __toESM(require_jsx_runtime(), 1);
function DefaultFollowingIndicator() {
  const editor = useEditor();
  const followingUserId = useValue("follow", () => editor.getInstanceState().followingUserId, [
    editor
  ]);
  if (!followingUserId) return null;
  return (0, import_jsx_runtime128.jsx)(FollowingIndicatorInner, { userId: followingUserId });
}
function FollowingIndicatorInner({ userId }) {
  const presence = usePresence(userId);
  if (!presence) return null;
  return (0, import_jsx_runtime128.jsx)("div", { className: "tlui-following-indicator", style: { borderColor: presence.color } });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/DefaultMenuPanel.mjs
var import_jsx_runtime129 = __toESM(require_jsx_runtime(), 1);
var import_react88 = __toESM(require_react(), 1);
var DefaultMenuPanel = (0, import_react88.memo)(function MenuPanel() {
  const breakpoint = useBreakpoint();
  const msg2 = useTranslation();
  const ref = (0, import_react88.useRef)(null);
  usePassThroughWheelEvents(ref);
  const { MainMenu, QuickActions, ActionsMenu, PageMenu } = useTldrawUiComponents();
  const editor = useEditor();
  const isSinglePageMode = useValue("isSinglePageMode", () => editor.options.maxPages <= 1, [
    editor
  ]);
  const showQuickActions = editor.options.actionShortcutsLocation === "menu" ? true : editor.options.actionShortcutsLocation === "toolbar" ? false : breakpoint >= PORTRAIT_BREAKPOINT.TABLET;
  if (!MainMenu && !PageMenu && !showQuickActions) return null;
  return (0, import_jsx_runtime129.jsx)("nav", { ref, className: "tlui-menu-zone", children: (0, import_jsx_runtime129.jsxs)(TldrawUiRow, { children: [
    MainMenu && (0, import_jsx_runtime129.jsx)(MainMenu, {}),
    PageMenu && !isSinglePageMode && (0, import_jsx_runtime129.jsx)(PageMenu, {}),
    showQuickActions ? (0, import_jsx_runtime129.jsxs)(TldrawUiToolbar, { orientation: "horizontal", label: msg2("actions-menu.title"), children: [
      QuickActions && (0, import_jsx_runtime129.jsx)(QuickActions, {}),
      ActionsMenu && (0, import_jsx_runtime129.jsx)(ActionsMenu, {})
    ] }) : null
  ] }) });
});

// ../node_modules/tldraw/dist-esm/lib/ui/components/Dialogs.mjs
var import_jsx_runtime130 = __toESM(require_jsx_runtime(), 1);
var import_react89 = __toESM(require_react(), 1);
var TldrawUiDialog = ({ id, component: ModalContent, preventBackgroundClose }) => {
  const { removeDialog } = useDialogs();
  const mouseDownInsideContentRef = (0, import_react89.useRef)(false);
  const container = useContainer();
  const handleOpenChange = (0, import_react89.useCallback)(
    (isOpen) => {
      if (!isOpen) {
        removeDialog(id);
      }
    },
    [id, removeDialog]
  );
  return (0, import_jsx_runtime130.jsx)(dist_exports4.Root, { onOpenChange: handleOpenChange, defaultOpen: true, children: (0, import_jsx_runtime130.jsx)(dist_exports4.Portal, { container, children: (0, import_jsx_runtime130.jsx)(
    dist_exports4.Overlay,
    {
      dir: "ltr",
      className: "tlui-dialog__overlay",
      onClick: (e) => {
        if (mouseDownInsideContentRef.current) return;
        if (!preventBackgroundClose && e.target === e.currentTarget) handleOpenChange(false);
      },
      children: (0, import_jsx_runtime130.jsx)(
        dist_exports4.Content,
        {
          dir: "ltr",
          className: "tlui-dialog__content",
          "aria-describedby": void 0,
          onMouseDown: () => mouseDownInsideContentRef.current = true,
          onMouseUp: () => mouseDownInsideContentRef.current = false,
          onInteractOutside: (e) => {
            mouseDownInsideContentRef.current = false;
            if (preventBackgroundClose) {
              e.preventDefault();
            }
          },
          children: (0, import_jsx_runtime130.jsx)(
            ModalContent,
            {
              onClose: () => {
                mouseDownInsideContentRef.current = false;
                handleOpenChange(false);
              }
            }
          )
        }
      )
    }
  ) }) });
};
var DefaultDialogs = (0, import_react89.memo)(function DefaultDialogs2() {
  const { dialogs } = useDialogs();
  const dialogsArray = useValue("dialogs", () => dialogs.get(), [dialogs]);
  return dialogsArray.map((dialog) => (0, import_jsx_runtime130.jsx)(TldrawUiDialog, { ...dialog }, dialog.id));
});

// ../node_modules/tldraw/dist-esm/lib/ui/components/HelperButtons/DefaultHelperButtons.mjs
var import_jsx_runtime135 = __toESM(require_jsx_runtime(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/components/HelperButtons/DefaultHelperButtonsContent.mjs
var import_jsx_runtime134 = __toESM(require_jsx_runtime(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/components/HelperButtons/BackToContent.mjs
var import_jsx_runtime131 = __toESM(require_jsx_runtime(), 1);
var import_react90 = __toESM(require_react(), 1);
function BackToContent() {
  const editor = useEditor();
  const actions = useActions();
  const [showBackToContent, setShowBackToContent] = (0, import_react90.useState)(false);
  const rIsShowing = (0, import_react90.useRef)(false);
  useQuickReactor(
    "toggle showback to content",
    () => {
      const showBackToContentPrev = rIsShowing.current;
      const shapeIds = editor.getCurrentPageShapeIds();
      let showBackToContentNow = false;
      if (shapeIds.size) {
        showBackToContentNow = shapeIds.size === editor.getNotVisibleShapes().size;
      }
      if (showBackToContentPrev !== showBackToContentNow) {
        setShowBackToContent(showBackToContentNow);
        rIsShowing.current = showBackToContentNow;
      }
    },
    [editor]
  );
  if (!showBackToContent) return null;
  return (0, import_jsx_runtime131.jsx)(
    TldrawUiMenuActionItem,
    {
      actionId: "back-to-content",
      onSelect: () => {
        actions["back-to-content"].onSelect("helper-buttons");
        setShowBackToContent(false);
      }
    }
  );
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/HelperButtons/ExitPenMode.mjs
var import_jsx_runtime132 = __toESM(require_jsx_runtime(), 1);
function ExitPenMode() {
  const editor = useEditor();
  const isPenMode = useValue("is pen mode", () => editor.getInstanceState().isPenMode, [editor]);
  if (!isPenMode) return null;
  return (0, import_jsx_runtime132.jsx)(TldrawUiMenuActionItem, { actionId: "exit-pen-mode" });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/HelperButtons/StopFollowing.mjs
var import_jsx_runtime133 = __toESM(require_jsx_runtime(), 1);
function StopFollowing() {
  const editor = useEditor();
  const actions = useActions();
  const followingUser = useValue(
    "is following user",
    () => !!editor.getInstanceState().followingUserId,
    [editor]
  );
  if (!followingUser) return null;
  return (0, import_jsx_runtime133.jsx)(TldrawUiMenuItem, { ...actions["stop-following"] });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/HelperButtons/DefaultHelperButtonsContent.mjs
function DefaultHelperButtonsContent() {
  return (0, import_jsx_runtime134.jsxs)(import_jsx_runtime134.Fragment, { children: [
    (0, import_jsx_runtime134.jsx)(ExitPenMode, {}),
    (0, import_jsx_runtime134.jsx)(BackToContent, {}),
    (0, import_jsx_runtime134.jsx)(StopFollowing, {})
  ] });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/HelperButtons/DefaultHelperButtons.mjs
function DefaultHelperButtons({ children }) {
  const content = children ?? (0, import_jsx_runtime135.jsx)(DefaultHelperButtonsContent, {});
  return (0, import_jsx_runtime135.jsx)("div", { className: "tlui-helper-buttons", children: (0, import_jsx_runtime135.jsx)(TldrawUiMenuContextProvider, { type: "helper-buttons", sourceId: "helper-buttons", children: content }) });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/MainMenu/DefaultMainMenu.mjs
var import_jsx_runtime141 = __toESM(require_jsx_runtime(), 1);
var import_react92 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/components/MainMenu/DefaultMainMenuContent.mjs
var import_jsx_runtime140 = __toESM(require_jsx_runtime(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/components/ColorSchemeMenu.mjs
var import_jsx_runtime136 = __toESM(require_jsx_runtime(), 1);
var COLOR_SCHEMES = [
  { colorScheme: "light", label: "theme.light" },
  { colorScheme: "dark", label: "theme.dark" },
  { colorScheme: "system", label: "theme.system" }
];
function ColorSchemeMenu() {
  const editor = useEditor();
  const trackEvent = useUiEvents();
  const currentColorScheme = useValue(
    "colorScheme",
    () => editor.user.getUserPreferences().colorScheme ?? (editor.user.getIsDarkMode() ? "dark" : "light"),
    [editor]
  );
  return (0, import_jsx_runtime136.jsx)(TldrawUiMenuSubmenu, { id: "help menu color-scheme", label: "menu.theme", children: (0, import_jsx_runtime136.jsx)(TldrawUiMenuGroup, { id: "theme", children: COLOR_SCHEMES.map(({ colorScheme, label }) => (0, import_jsx_runtime136.jsx)(
    TldrawUiMenuCheckboxItem,
    {
      id: `color-scheme-${colorScheme}`,
      label,
      checked: colorScheme === currentColorScheme,
      readonlyOk: true,
      onSelect: () => {
        editor.user.updateUserPreferences({ colorScheme });
        trackEvent("color-scheme", { source: "menu", value: colorScheme });
      }
    },
    colorScheme
  )) }) });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/HelpMenu/DefaultHelpMenuContent.mjs
var import_jsx_runtime138 = __toESM(require_jsx_runtime(), 1);
var import_react91 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/components/LanguageMenu.mjs
var import_jsx_runtime137 = __toESM(require_jsx_runtime(), 1);
function LanguageMenu() {
  const editor = useMaybeEditor();
  const trackEvent = useUiEvents();
  const currentLanguage = useValue("locale", () => editor == null ? void 0 : editor.user.getLocale(), [editor]);
  if (!editor) return null;
  return (0, import_jsx_runtime137.jsx)(TldrawUiMenuSubmenu, { id: "help menu language", label: "menu.language", children: (0, import_jsx_runtime137.jsx)(TldrawUiMenuGroup, { id: "languages", className: "tlui-language-menu", children: LANGUAGES.map(({ locale, label }) => (0, import_jsx_runtime137.jsx)(
    TldrawUiMenuCheckboxItem,
    {
      id: `language-${locale}`,
      lang: locale,
      title: locale,
      label,
      checked: locale === currentLanguage,
      readonlyOk: true,
      onSelect: () => {
        editor.user.updateUserPreferences({ locale });
        trackEvent("change-language", { source: "menu", locale });
      }
    },
    locale
  )) }) });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/HelpMenu/DefaultHelpMenuContent.mjs
function DefaultHelpMenuContent() {
  return (0, import_jsx_runtime138.jsxs)(import_jsx_runtime138.Fragment, { children: [
    (0, import_jsx_runtime138.jsx)(LanguageMenu, {}),
    (0, import_jsx_runtime138.jsx)(KeyboardShortcutsMenuItem, {})
  ] });
}
function KeyboardShortcutsMenuItem() {
  const { KeyboardShortcutsDialog } = useTldrawUiComponents();
  const { addDialog } = useDialogs();
  const handleSelect = (0, import_react91.useCallback)(() => {
    if (KeyboardShortcutsDialog) addDialog({ component: KeyboardShortcutsDialog });
  }, [addDialog, KeyboardShortcutsDialog]);
  if (!KeyboardShortcutsDialog) return null;
  return (0, import_jsx_runtime138.jsx)(
    TldrawUiMenuItem,
    {
      id: "keyboard-shortcuts-button",
      label: "help-menu.keyboard-shortcuts",
      readonlyOk: true,
      onSelect: handleSelect
    }
  );
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/InputModeMenu.mjs
var import_jsx_runtime139 = __toESM(require_jsx_runtime(), 1);
var MODES = ["auto", "trackpad", "mouse"];
function InputModeMenu() {
  const editor = useEditor();
  const trackEvent = useUiEvents();
  const inputMode = useValue("inputMode", () => editor.user.getUserPreferences().inputMode, [
    editor
  ]);
  const wheelBehavior = useValue("wheelBehavior", () => editor.getCameraOptions().wheelBehavior, [
    editor
  ]);
  const isModeChecked = (mode) => {
    if (mode === "auto") {
      return inputMode === null;
    }
    return inputMode === mode;
  };
  const getLabel2 = (mode, wheelBehavior2) => {
    if (mode === "auto") {
      return `action.toggle-auto-${wheelBehavior2}`;
    }
    return mode === "trackpad" ? "action.toggle-trackpad" : "action.toggle-mouse";
  };
  return (0, import_jsx_runtime139.jsx)(TldrawUiMenuSubmenu, { id: "help menu input-mode", label: "menu.input-mode", children: (0, import_jsx_runtime139.jsx)(TldrawUiMenuGroup, { id: "peripheral-mode", children: MODES.map((mode) => (0, import_jsx_runtime139.jsx)(
    TldrawUiMenuCheckboxItem,
    {
      id: `peripheral-mode-${mode}`,
      label: getLabel2(mode, wheelBehavior),
      checked: isModeChecked(mode),
      readonlyOk: true,
      onSelect: () => {
        trackEvent("input-mode", { source: "menu", value: mode });
        switch (mode) {
          case "auto":
            editor.user.updateUserPreferences({ inputMode: null });
            break;
          case "trackpad":
            editor.user.updateUserPreferences({ inputMode: "trackpad" });
            break;
          case "mouse":
            editor.user.updateUserPreferences({ inputMode: "mouse" });
            break;
        }
      }
    },
    mode
  )) }) });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/MainMenu/DefaultMainMenuContent.mjs
function DefaultMainMenuContent() {
  return (0, import_jsx_runtime140.jsxs)(import_jsx_runtime140.Fragment, { children: [
    (0, import_jsx_runtime140.jsxs)(TldrawUiMenuGroup, { id: "basic", children: [
      (0, import_jsx_runtime140.jsx)(EditSubmenu, {}),
      (0, import_jsx_runtime140.jsx)(ViewSubmenu, {}),
      (0, import_jsx_runtime140.jsx)(ExportFileContentSubMenu, {}),
      (0, import_jsx_runtime140.jsx)(ExtrasGroup, {})
    ] }),
    (0, import_jsx_runtime140.jsx)(PreferencesGroup, {})
  ] });
}
function ExportFileContentSubMenu() {
  return (0, import_jsx_runtime140.jsxs)(TldrawUiMenuSubmenu, { id: "export-all-as", label: "context-menu.export-all-as", size: "small", children: [
    (0, import_jsx_runtime140.jsxs)(TldrawUiMenuGroup, { id: "export-all-as-group", children: [
      (0, import_jsx_runtime140.jsx)(TldrawUiMenuActionItem, { actionId: "export-all-as-svg" }),
      (0, import_jsx_runtime140.jsx)(TldrawUiMenuActionItem, { actionId: "export-all-as-png" })
    ] }),
    (0, import_jsx_runtime140.jsx)(TldrawUiMenuGroup, { id: "export-all-as-bg", children: (0, import_jsx_runtime140.jsx)(ToggleTransparentBgMenuItem, {}) })
  ] });
}
function EditSubmenu() {
  return (0, import_jsx_runtime140.jsxs)(TldrawUiMenuSubmenu, { id: "edit", label: "menu.edit", children: [
    (0, import_jsx_runtime140.jsx)(UndoRedoGroup, {}),
    (0, import_jsx_runtime140.jsx)(ClipboardMenuGroup, {}),
    (0, import_jsx_runtime140.jsx)(ConversionsMenuGroup, {}),
    (0, import_jsx_runtime140.jsx)(MiscMenuGroup, {}),
    (0, import_jsx_runtime140.jsx)(LockGroup, {}),
    (0, import_jsx_runtime140.jsx)(TldrawUiMenuGroup, { id: "select-all", children: (0, import_jsx_runtime140.jsx)(SelectAllMenuItem, {}) })
  ] });
}
function MiscMenuGroup() {
  return (0, import_jsx_runtime140.jsxs)(TldrawUiMenuGroup, { id: "misc", children: [
    (0, import_jsx_runtime140.jsx)(GroupMenuItem2, {}),
    (0, import_jsx_runtime140.jsx)(UngroupMenuItem2, {}),
    (0, import_jsx_runtime140.jsx)(EditLinkMenuItem2, {}),
    (0, import_jsx_runtime140.jsx)(ToggleAutoSizeMenuItem, {}),
    (0, import_jsx_runtime140.jsx)(RemoveFrameMenuItem, {}),
    (0, import_jsx_runtime140.jsx)(FitFrameToContentMenuItem, {}),
    (0, import_jsx_runtime140.jsx)(ConvertToEmbedMenuItem, {}),
    (0, import_jsx_runtime140.jsx)(ConvertToBookmarkMenuItem, {}),
    (0, import_jsx_runtime140.jsx)(FlattenMenuItem, {})
  ] });
}
function LockGroup() {
  return (0, import_jsx_runtime140.jsxs)(TldrawUiMenuGroup, { id: "lock", children: [
    (0, import_jsx_runtime140.jsx)(ToggleLockMenuItem, {}),
    (0, import_jsx_runtime140.jsx)(UnlockAllMenuItem, {})
  ] });
}
function UndoRedoGroup() {
  const canUndo = useCanUndo();
  const canRedo = useCanRedo();
  return (0, import_jsx_runtime140.jsxs)(TldrawUiMenuGroup, { id: "undo-redo", children: [
    (0, import_jsx_runtime140.jsx)(TldrawUiMenuActionItem, { actionId: "undo", disabled: !canUndo }),
    (0, import_jsx_runtime140.jsx)(TldrawUiMenuActionItem, { actionId: "redo", disabled: !canRedo })
  ] });
}
function ViewSubmenu() {
  return (0, import_jsx_runtime140.jsx)(TldrawUiMenuSubmenu, { id: "view", label: "menu.view", children: (0, import_jsx_runtime140.jsxs)(TldrawUiMenuGroup, { id: "view-actions", children: [
    (0, import_jsx_runtime140.jsx)(TldrawUiMenuActionItem, { actionId: "zoom-in" }),
    (0, import_jsx_runtime140.jsx)(TldrawUiMenuActionItem, { actionId: "zoom-out" }),
    (0, import_jsx_runtime140.jsx)(ZoomTo100MenuItem, {}),
    (0, import_jsx_runtime140.jsx)(ZoomToFitMenuItem, {}),
    (0, import_jsx_runtime140.jsx)(ZoomToSelectionMenuItem, {})
  ] }) });
}
function ExtrasGroup() {
  return (0, import_jsx_runtime140.jsxs)(import_jsx_runtime140.Fragment, { children: [
    (0, import_jsx_runtime140.jsx)(TldrawUiMenuActionItem, { actionId: "insert-embed" }),
    (0, import_jsx_runtime140.jsx)(TldrawUiMenuActionItem, { actionId: "insert-media" })
  ] });
}
function PreferencesGroup() {
  return (0, import_jsx_runtime140.jsxs)(TldrawUiMenuGroup, { id: "preferences", children: [
    (0, import_jsx_runtime140.jsxs)(TldrawUiMenuSubmenu, { id: "preferences", label: "menu.preferences", children: [
      (0, import_jsx_runtime140.jsxs)(TldrawUiMenuGroup, { id: "preferences-actions", children: [
        (0, import_jsx_runtime140.jsx)(ToggleSnapModeItem, {}),
        (0, import_jsx_runtime140.jsx)(ToggleToolLockItem, {}),
        (0, import_jsx_runtime140.jsx)(ToggleGridItem, {}),
        (0, import_jsx_runtime140.jsx)(ToggleWrapModeItem, {}),
        (0, import_jsx_runtime140.jsx)(ToggleFocusModeItem, {}),
        (0, import_jsx_runtime140.jsx)(ToggleEdgeScrollingItem, {}),
        (0, import_jsx_runtime140.jsx)(ToggleDynamicSizeModeItem, {}),
        (0, import_jsx_runtime140.jsx)(TogglePasteAtCursorItem, {}),
        (0, import_jsx_runtime140.jsx)(ToggleDebugModeItem, {})
      ] }),
      (0, import_jsx_runtime140.jsxs)(TldrawUiMenuGroup, { id: "user-interface-submenus", children: [
        (0, import_jsx_runtime140.jsx)(InputModeMenu, {}),
        (0, import_jsx_runtime140.jsx)(ColorSchemeMenu, {}),
        (0, import_jsx_runtime140.jsx)(AccessibilityMenu, {})
      ] })
    ] }),
    (0, import_jsx_runtime140.jsx)(LanguageMenu, {}),
    (0, import_jsx_runtime140.jsx)(KeyboardShortcutsMenuItem, {})
  ] });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/MainMenu/DefaultMainMenu.mjs
var DefaultMainMenu = (0, import_react92.memo)(function DefaultMainMenu2({ children }) {
  const container = useContainer();
  const [isOpen, onOpenChange] = useMenuIsOpen("main menu");
  const msg2 = useTranslation();
  const content = children ?? (0, import_jsx_runtime141.jsx)(DefaultMainMenuContent, {});
  return (0, import_jsx_runtime141.jsxs)(dist_exports10.Root, { dir: "ltr", open: isOpen, onOpenChange, modal: false, children: [
    (0, import_jsx_runtime141.jsx)(dist_exports10.Trigger, { asChild: true, dir: "ltr", children: (0, import_jsx_runtime141.jsx)(TldrawUiButton, { type: "icon", "data-testid": "main-menu.button", title: msg2("menu.title"), children: (0, import_jsx_runtime141.jsx)(TldrawUiButtonIcon, { icon: "menu", small: true }) }) }),
    (0, import_jsx_runtime141.jsx)(dist_exports10.Portal, { container, children: (0, import_jsx_runtime141.jsx)(
      dist_exports10.Content,
      {
        className: "tlui-menu",
        side: "bottom",
        align: "start",
        collisionPadding: 4,
        alignOffset: 0,
        sideOffset: 6,
        children: (0, import_jsx_runtime141.jsx)(TldrawUiMenuContextProvider, { type: "menu", sourceId: "main-menu", children: content })
      }
    ) })
  ] });
});

// ../node_modules/tldraw/dist-esm/lib/ui/components/Minimap/DefaultMinimap.mjs
var import_jsx_runtime142 = __toESM(require_jsx_runtime(), 1);
var React90 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/components/Minimap/getRgba.mjs
var memo18 = {};
function getRgba(colorString) {
  if (memo18[colorString]) {
    return memo18[colorString];
  }
  const canvas = document.createElement("canvas");
  const context = canvas.getContext("2d");
  context.fillStyle = colorString;
  context.fillRect(0, 0, 1, 1);
  const [r, g, b, a] = context.getImageData(0, 0, 1, 1).data;
  const result = new Float32Array([r / 255, g / 255, b / 255, a / 255]);
  memo18[colorString] = result;
  return result;
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/Minimap/minimap-webgl-shapes.mjs
var numArcSegmentsPerCorner = 10;
var roundedRectangleDataSize = (
  // num triangles in corners
  // num triangles in outer rects
  4 * 6 * numArcSegmentsPerCorner + // num triangles in center rect
  12 + 4 * 12
);
function pie(array, {
  center,
  radius,
  numArcSegments = 20,
  startAngle = 0,
  endAngle = PI2,
  offset: offset4 = 0
}) {
  const angle = (endAngle - startAngle) / numArcSegments;
  let i = offset4;
  for (let a = startAngle; a < endAngle; a += angle) {
    array[i++] = center.x;
    array[i++] = center.y;
    array[i++] = center.x + Math.cos(a) * radius;
    array[i++] = center.y + Math.sin(a) * radius;
    array[i++] = center.x + Math.cos(a + angle) * radius;
    array[i++] = center.y + Math.sin(a + angle) * radius;
  }
  return array;
}
function rectangle(array, offset4, x, y, w, h2) {
  array[offset4++] = x;
  array[offset4++] = y;
  array[offset4++] = x;
  array[offset4++] = y + h2;
  array[offset4++] = x + w;
  array[offset4++] = y;
  array[offset4++] = x + w;
  array[offset4++] = y;
  array[offset4++] = x;
  array[offset4++] = y + h2;
  array[offset4++] = x + w;
  array[offset4++] = y + h2;
}
function roundedRectangle(data, box, radius) {
  const numArcSegments = numArcSegmentsPerCorner;
  radius = Math.min(radius, Math.min(box.w, box.h) / 2);
  const innerBox = Box.ExpandBy(box, -radius);
  if (innerBox.w <= 0 || innerBox.h <= 0) {
    pie(data, { center: box.center, radius, numArcSegments: numArcSegmentsPerCorner * 4 });
    return numArcSegmentsPerCorner * 4 * 6;
  }
  let offset4 = 0;
  rectangle(data, offset4, innerBox.minX, innerBox.minY, innerBox.w, innerBox.h);
  offset4 += 12;
  rectangle(data, offset4, innerBox.minX, box.minY, innerBox.w, radius);
  offset4 += 12;
  rectangle(data, offset4, innerBox.maxX, innerBox.minY, radius, innerBox.h);
  offset4 += 12;
  rectangle(data, offset4, innerBox.minX, innerBox.maxY, innerBox.w, radius);
  offset4 += 12;
  rectangle(data, offset4, box.minX, innerBox.minY, radius, innerBox.h);
  offset4 += 12;
  pie(data, {
    numArcSegments,
    offset: offset4,
    center: innerBox.point,
    radius,
    startAngle: PI,
    endAngle: PI * 1.5
  });
  offset4 += numArcSegments * 6;
  pie(data, {
    numArcSegments,
    offset: offset4,
    center: Vec.Add(innerBox.point, new Vec(innerBox.w, 0)),
    radius,
    startAngle: PI * 1.5,
    endAngle: PI2
  });
  offset4 += numArcSegments * 6;
  pie(data, {
    numArcSegments,
    offset: offset4,
    center: Vec.Add(innerBox.point, innerBox.size),
    radius,
    startAngle: 0,
    endAngle: HALF_PI
  });
  offset4 += numArcSegments * 6;
  pie(data, {
    numArcSegments,
    offset: offset4,
    center: Vec.Add(innerBox.point, new Vec(0, innerBox.h)),
    radius,
    startAngle: HALF_PI,
    endAngle: PI
  });
  return roundedRectangleDataSize;
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/Minimap/minimap-webgl-setup.mjs
function setupWebGl(canvas) {
  if (!canvas) throw new Error("Canvas element not found");
  const context = canvas.getContext("webgl2", {
    premultipliedAlpha: false
  });
  if (!context) throw new Error("Failed to get webgl2 context");
  const vertexShaderSourceCode = `#version 300 es
  precision mediump float;
  
  in vec2 shapeVertexPosition;

	uniform vec4 canvasPageBounds;

	// taken (with thanks) from
	// https://webglfundamentals.org/webgl/lessons/webgl-2d-matrices.html
  void main() {
		// convert the position from pixels to 0.0 to 1.0
		vec2 zeroToOne = (shapeVertexPosition - canvasPageBounds.xy) / canvasPageBounds.zw;
	
		// convert from 0->1 to 0->2
		vec2 zeroToTwo = zeroToOne * 2.0;
	
		// convert from 0->2 to -1->+1 (clipspace)
		vec2 clipSpace = zeroToTwo - 1.0;
	
		gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
  }`;
  const vertexShader = context.createShader(context.VERTEX_SHADER);
  if (!vertexShader) {
    throw new Error("Failed to create vertex shader");
  }
  context.shaderSource(vertexShader, vertexShaderSourceCode);
  context.compileShader(vertexShader);
  if (!context.getShaderParameter(vertexShader, context.COMPILE_STATUS)) {
    throw new Error("Failed to compile vertex shader");
  }
  const fragmentShaderSourceCode = `#version 300 es
  precision mediump float;
  
	uniform vec4 fillColor;
  out vec4 outputColor;

  void main() {
	outputColor = fillColor;
  }`;
  const fragmentShader = context.createShader(context.FRAGMENT_SHADER);
  if (!fragmentShader) {
    throw new Error("Failed to create fragment shader");
  }
  context.shaderSource(fragmentShader, fragmentShaderSourceCode);
  context.compileShader(fragmentShader);
  if (!context.getShaderParameter(fragmentShader, context.COMPILE_STATUS)) {
    throw new Error("Failed to compile fragment shader");
  }
  const program = context.createProgram();
  if (!program) {
    throw new Error("Failed to create program");
  }
  context.attachShader(program, vertexShader);
  context.attachShader(program, fragmentShader);
  context.linkProgram(program);
  if (!context.getProgramParameter(program, context.LINK_STATUS)) {
    throw new Error("Failed to link program");
  }
  context.useProgram(program);
  const shapeVertexPositionAttributeLocation = context.getAttribLocation(
    program,
    "shapeVertexPosition"
  );
  if (shapeVertexPositionAttributeLocation < 0) {
    throw new Error("Failed to get shapeVertexPosition attribute location");
  }
  context.enableVertexAttribArray(shapeVertexPositionAttributeLocation);
  const canvasPageBoundsLocation = context.getUniformLocation(program, "canvasPageBounds");
  const fillColorLocation = context.getUniformLocation(program, "fillColor");
  const selectedShapesBuffer = context.createBuffer();
  if (!selectedShapesBuffer) throw new Error("Failed to create buffer");
  const unselectedShapesBuffer = context.createBuffer();
  if (!unselectedShapesBuffer) throw new Error("Failed to create buffer");
  return {
    context,
    selectedShapes: allocateBuffer(context, 1024),
    unselectedShapes: allocateBuffer(context, 4096),
    viewport: allocateBuffer(context, roundedRectangleDataSize),
    collaborators: allocateBuffer(context, 1024),
    prepareTriangles(stuff, len) {
      context.bindBuffer(context.ARRAY_BUFFER, stuff.buffer);
      context.bufferData(context.ARRAY_BUFFER, stuff.vertices, context.STATIC_DRAW, 0, len);
      context.enableVertexAttribArray(shapeVertexPositionAttributeLocation);
      context.vertexAttribPointer(
        shapeVertexPositionAttributeLocation,
        2,
        context.FLOAT,
        false,
        0,
        0
      );
    },
    drawTrianglesTransparently(len) {
      context.enable(context.BLEND);
      context.blendFunc(context.SRC_ALPHA, context.ONE_MINUS_SRC_ALPHA);
      context.drawArrays(context.TRIANGLES, 0, len / 2);
      context.disable(context.BLEND);
    },
    drawTriangles(len) {
      context.drawArrays(context.TRIANGLES, 0, len / 2);
    },
    setFillColor(color) {
      context.uniform4fv(fillColorLocation, color);
    },
    setCanvasPageBounds(bounds) {
      context.uniform4fv(canvasPageBoundsLocation, bounds);
    }
  };
}
function allocateBuffer(context, size4) {
  const buffer = context.createBuffer();
  if (!buffer) throw new Error("Failed to create buffer");
  return { buffer, vertices: new Float32Array(size4) };
}
function appendVertices(bufferStuff, offset4, data) {
  let len = bufferStuff.vertices.length;
  while (len < offset4 + data.length) {
    len *= 2;
  }
  if (len != bufferStuff.vertices.length) {
    const newVertices = new Float32Array(len);
    newVertices.set(bufferStuff.vertices);
    bufferStuff.vertices = newVertices;
  }
  bufferStuff.vertices.set(data, offset4);
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/Minimap/MinimapManager.mjs
var __create11 = Object.create;
var __defProp12 = Object.defineProperty;
var __getOwnPropDesc11 = Object.getOwnPropertyDescriptor;
var __knownSymbol11 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError11 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp11 = (obj, key, value) => key in obj ? __defProp12(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name11 = (target, value) => __defProp12(target, "name", { value, configurable: true });
var __decoratorStart11 = (base2) => [, , , __create11((base2 == null ? void 0 : base2[__knownSymbol11("metadata")]) ?? null)];
var __decoratorStrings11 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn11 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError11("Function expected") : fn;
var __decoratorContext11 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings11[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError11("Already initialized") : fns.push(__expectFn11(fn || null)) });
var __decoratorMetadata11 = (array, target) => __defNormalProp11(target, __knownSymbol11("metadata"), array[3]);
var __runInitializers11 = (array, flags, self2, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self2) : value = fns[i].call(self2, value);
  return value;
};
var __decorateElement11 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings11[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc11(k < 4 ? target : { get [name]() {
    return __privateGet12(this, extra);
  }, set [name](x) {
    return __privateSet12(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name11(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name11(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext11(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn11(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet12 : __privateMethod11)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet12(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn11(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError11("Object expected");
    else __expectFn11(fn = it.get) && (desc.get = fn), __expectFn11(fn = it.set) && (desc.set = fn), __expectFn11(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata11(array, target), desc && __defProp12(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __publicField12 = (obj, key, value) => __defNormalProp11(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck11 = (obj, member, msg2) => member.has(obj) || __typeError11("Cannot " + msg2);
var __privateIn11 = (member, obj) => Object(obj) !== obj ? __typeError11('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet12 = (obj, member, getter) => (__accessCheck11(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet12 = (obj, member, value, setter) => (__accessCheck11(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod11 = (obj, member, method) => (__accessCheck11(obj, member, "access private method"), method);
var _render_dec;
var _getCanvasPageBoundsArray_dec;
var _getZoom_dec;
var _getCanvasPageBounds_dec;
var _getCanvasClientPosition_dec;
var _getCanvasSize_dec;
var _getContentScreenBounds_dec;
var _getContentPageBounds_dec;
var _getDpr_dec;
var _close_dec;
var _init11;
_close_dec = [bind], _getDpr_dec = [computed], _getContentPageBounds_dec = [computed], _getContentScreenBounds_dec = [computed], _getCanvasSize_dec = [computed], _getCanvasClientPosition_dec = [computed], _getCanvasPageBounds_dec = [computed], _getZoom_dec = [computed], _getCanvasPageBoundsArray_dec = [computed], _render_dec = [bind];
var MinimapManager = class {
  constructor(editor, elem, container) {
    this.editor = editor;
    this.elem = elem;
    this.container = container;
    __runInitializers11(_init11, 5, this);
    __publicField12(this, "disposables", []);
    __publicField12(this, "gl");
    __publicField12(this, "shapeGeometryCache");
    __publicField12(this, "colors");
    __publicField12(this, "id", uniqueId());
    __publicField12(this, "canvasBoundingClientRect", atom("canvasBoundingClientRect", new Box()));
    __publicField12(this, "originPagePoint", new Vec());
    __publicField12(this, "originPageCenter", new Vec());
    __publicField12(this, "isInViewport", false);
    this.gl = setupWebGl(elem);
    this.shapeGeometryCache = editor.store.createComputedCache("webgl-geometry", (r) => {
      const bounds = editor.getShapeMaskedPageBounds(r.id);
      if (!bounds) return null;
      const arr = new Float32Array(12);
      rectangle(arr, 0, bounds.x, bounds.y, bounds.w, bounds.h);
      return arr;
    });
    this.colors = this._getColors();
    this.disposables.push(this._listenForCanvasResize(), react("minimap render", this.render));
  }
  close() {
    return this.disposables.forEach((d) => d());
  }
  _getColors() {
    const style2 = getComputedStyle(this.editor.getContainer());
    return {
      shapeFill: getRgba(style2.getPropertyValue("--tl-color-text-3").trim()),
      selectFill: getRgba(style2.getPropertyValue("--tl-color-selected").trim()),
      viewportFill: getRgba(style2.getPropertyValue("--tl-color-muted-1").trim()),
      background: getRgba(style2.getPropertyValue("--tl-color-low").trim())
    };
  }
  // this should be called after dark/light mode changes have propagated to the dom
  updateColors() {
    this.colors = this._getColors();
  }
  getDpr() {
    return this.editor.getInstanceState().devicePixelRatio;
  }
  getContentPageBounds() {
    const viewportPageBounds = this.editor.getViewportPageBounds();
    const commonShapeBounds = this.editor.getCurrentPageBounds();
    return commonShapeBounds ? Box.Expand(commonShapeBounds, viewportPageBounds) : viewportPageBounds;
  }
  getContentScreenBounds() {
    const contentPageBounds = this.getContentPageBounds();
    const topLeft = this.editor.pageToScreen(contentPageBounds.point);
    const bottomRight = this.editor.pageToScreen(
      new Vec(contentPageBounds.maxX, contentPageBounds.maxY)
    );
    return new Box(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);
  }
  _getCanvasBoundingRect() {
    const { x, y, width, height } = this.elem.getBoundingClientRect();
    return new Box(x, y, width, height);
  }
  getCanvasScreenBounds() {
    return this.canvasBoundingClientRect.get();
  }
  _listenForCanvasResize() {
    const observer = new ResizeObserver(() => {
      const rect = this._getCanvasBoundingRect();
      this.canvasBoundingClientRect.set(rect);
    });
    observer.observe(this.elem);
    observer.observe(this.container);
    return () => observer.disconnect();
  }
  getCanvasSize() {
    const rect = this.canvasBoundingClientRect.get();
    const dpr = this.getDpr();
    return new Vec(rect.width * dpr, rect.height * dpr);
  }
  getCanvasClientPosition() {
    return this.canvasBoundingClientRect.get().point;
  }
  getCanvasPageBounds() {
    const canvasScreenBounds = this.getCanvasScreenBounds();
    const contentPageBounds = this.getContentPageBounds();
    const aspectRatio = canvasScreenBounds.width / canvasScreenBounds.height;
    let targetWidth = contentPageBounds.width;
    let targetHeight = targetWidth / aspectRatio;
    if (targetHeight < contentPageBounds.height) {
      targetHeight = contentPageBounds.height;
      targetWidth = targetHeight * aspectRatio;
    }
    const box = new Box(0, 0, targetWidth, targetHeight);
    box.center = contentPageBounds.center;
    return box;
  }
  getZoom() {
    return this.getCanvasPageBounds().width / this.getCanvasScreenBounds().width;
  }
  getCanvasPageBoundsArray() {
    const { x, y, w, h: h2 } = this.getCanvasPageBounds();
    return new Float32Array([x, y, w, h2]);
  }
  getMinimapPagePoint(clientX, clientY) {
    const canvasPageBounds = this.getCanvasPageBounds();
    const canvasScreenBounds = this.getCanvasScreenBounds();
    let x = clientX - canvasScreenBounds.x;
    let y = clientY - canvasScreenBounds.y;
    x *= canvasPageBounds.width / canvasScreenBounds.width;
    y *= canvasPageBounds.height / canvasScreenBounds.height;
    x += canvasPageBounds.minX;
    y += canvasPageBounds.minY;
    return new Vec(x, y, 1);
  }
  minimapScreenPointToPagePoint(x, y, shiftKey = false, clampToBounds = false) {
    const { editor } = this;
    const vpPageBounds = editor.getViewportPageBounds();
    let { x: px, y: py } = this.getMinimapPagePoint(x, y);
    if (clampToBounds) {
      const shapesPageBounds = this.editor.getCurrentPageBounds() ?? new Box();
      const minX = shapesPageBounds.minX - vpPageBounds.width / 2;
      const maxX = shapesPageBounds.maxX + vpPageBounds.width / 2;
      const minY = shapesPageBounds.minY - vpPageBounds.height / 2;
      const maxY = shapesPageBounds.maxY + vpPageBounds.height / 2;
      const lx = Math.max(0, minX + vpPageBounds.width - px);
      const rx = Math.max(0, -(maxX - vpPageBounds.width - px));
      const ly = Math.max(0, minY + vpPageBounds.height - py);
      const ry = Math.max(0, -(maxY - vpPageBounds.height - py));
      px += (lx - rx) / 2;
      py += (ly - ry) / 2;
      px = clamp(px, minX, maxX);
      py = clamp(py, minY, maxY);
    }
    if (shiftKey) {
      const { originPagePoint } = this;
      const dx = Math.abs(px - originPagePoint.x);
      const dy = Math.abs(py - originPagePoint.y);
      if (dx > dy) {
        py = originPagePoint.y;
      } else {
        px = originPagePoint.x;
      }
    }
    return new Vec(px, py);
  }
  render() {
    var _a6;
    const context = this.gl.context;
    const canvasSize = this.getCanvasSize();
    this.gl.setCanvasPageBounds(this.getCanvasPageBoundsArray());
    this.elem.width = canvasSize.x;
    this.elem.height = canvasSize.y;
    context.viewport(0, 0, canvasSize.x, canvasSize.y);
    context.clearColor(
      this.colors.background[0],
      this.colors.background[1],
      this.colors.background[2],
      1
    );
    context.clear(context.COLOR_BUFFER_BIT);
    const selectedShapes = new Set(this.editor.getSelectedShapeIds());
    const colors = this.colors;
    let selectedShapeOffset = 0;
    let unselectedShapeOffset = 0;
    const ids = this.editor.getCurrentPageShapeIdsSorted();
    for (let i = 0, len = ids.length; i < len; i++) {
      const shapeId = ids[i];
      const geometry = this.shapeGeometryCache.get(shapeId);
      if (!geometry) continue;
      const len2 = geometry.length;
      const shape = this.editor.getShape(shapeId);
      if (shape) {
        const shapeUtil = this.editor.getShapeUtil(shape.type);
        if ((_a6 = shapeUtil.hideInMinimap) == null ? void 0 : _a6.call(shapeUtil, shape)) continue;
      }
      if (selectedShapes.has(shapeId)) {
        appendVertices(this.gl.selectedShapes, selectedShapeOffset, geometry);
        selectedShapeOffset += len2;
      } else {
        appendVertices(this.gl.unselectedShapes, unselectedShapeOffset, geometry);
        unselectedShapeOffset += len2;
      }
    }
    this.drawShapes(this.gl.unselectedShapes, unselectedShapeOffset, colors.shapeFill);
    this.drawShapes(this.gl.selectedShapes, selectedShapeOffset, colors.selectFill);
    this.drawViewport();
    this.drawCollaborators();
  }
  drawShapes(stuff, len, color) {
    this.gl.prepareTriangles(stuff, len);
    this.gl.setFillColor(color);
    this.gl.drawTriangles(len);
  }
  drawViewport() {
    const viewport = this.editor.getViewportPageBounds();
    const len = roundedRectangle(this.gl.viewport.vertices, viewport, 4 * this.getZoom());
    this.gl.prepareTriangles(this.gl.viewport, len);
    this.gl.setFillColor(this.colors.viewportFill);
    this.gl.drawTrianglesTransparently(len);
    if (tlenv.isSafari) {
      this.gl.drawTrianglesTransparently(len);
      this.gl.drawTrianglesTransparently(len);
      this.gl.drawTrianglesTransparently(len);
    }
  }
  drawCollaborators() {
    const collaborators = this.editor.getCollaboratorsOnCurrentPage();
    if (!collaborators.length) return;
    const numSegmentsPerCircle = 20;
    const dataSizePerCircle = numSegmentsPerCircle * 6;
    const totalSize = dataSizePerCircle * collaborators.length;
    if (this.gl.collaborators.vertices.length < totalSize) {
      this.gl.collaborators.vertices = new Float32Array(totalSize);
    }
    const vertices = this.gl.collaborators.vertices;
    let offset4 = 0;
    const zoom = this.getZoom();
    for (const { cursor } of collaborators) {
      if (!cursor) continue;
      pie(vertices, {
        center: Vec.From(cursor),
        radius: 3 * zoom,
        offset: offset4,
        numArcSegments: numSegmentsPerCircle
      });
      offset4 += dataSizePerCircle;
    }
    this.gl.prepareTriangles(this.gl.collaborators, totalSize);
    offset4 = 0;
    for (const { color } of collaborators) {
      this.gl.setFillColor(getRgba(color));
      this.gl.context.drawArrays(this.gl.context.TRIANGLES, offset4 / 2, dataSizePerCircle / 2);
      offset4 += dataSizePerCircle;
    }
  }
};
_init11 = __decoratorStart11(null);
__decorateElement11(_init11, 1, "close", _close_dec, MinimapManager);
__decorateElement11(_init11, 1, "getDpr", _getDpr_dec, MinimapManager);
__decorateElement11(_init11, 1, "getContentPageBounds", _getContentPageBounds_dec, MinimapManager);
__decorateElement11(_init11, 1, "getContentScreenBounds", _getContentScreenBounds_dec, MinimapManager);
__decorateElement11(_init11, 1, "getCanvasSize", _getCanvasSize_dec, MinimapManager);
__decorateElement11(_init11, 1, "getCanvasClientPosition", _getCanvasClientPosition_dec, MinimapManager);
__decorateElement11(_init11, 1, "getCanvasPageBounds", _getCanvasPageBounds_dec, MinimapManager);
__decorateElement11(_init11, 1, "getZoom", _getZoom_dec, MinimapManager);
__decorateElement11(_init11, 1, "getCanvasPageBoundsArray", _getCanvasPageBoundsArray_dec, MinimapManager);
__decorateElement11(_init11, 1, "render", _render_dec, MinimapManager);
__decoratorMetadata11(_init11, MinimapManager);

// ../node_modules/tldraw/dist-esm/lib/ui/components/Minimap/DefaultMinimap.mjs
function DefaultMinimap() {
  const editor = useEditor();
  const container = useContainer();
  const msg2 = useTranslation();
  const rCanvas = React90.useRef(null);
  const rPointing = React90.useRef(false);
  const minimapRef = React90.useRef(void 0);
  React90.useEffect(() => {
    try {
      const minimap = new MinimapManager(editor, rCanvas.current, container);
      minimapRef.current = minimap;
      return minimapRef.current.close;
    } catch (e) {
      editor.annotateError(e, {
        origin: "minimap",
        willCrashApp: false
      });
      editor.timers.setTimeout(() => {
        throw e;
      });
    }
  }, [editor, container]);
  const onDoubleClick = React90.useCallback(
    (e) => {
      if (!editor.getCurrentPageShapeIds().size) return;
      if (!minimapRef.current) return;
      const point = minimapRef.current.minimapScreenPointToPagePoint(
        e.clientX,
        e.clientY,
        false,
        false
      );
      const clampedPoint = minimapRef.current.minimapScreenPointToPagePoint(
        e.clientX,
        e.clientY,
        false,
        true
      );
      minimapRef.current.originPagePoint.setTo(clampedPoint);
      minimapRef.current.originPageCenter.setTo(editor.getViewportPageBounds().center);
      editor.centerOnPoint(point, { animation: { duration: editor.options.animationMediumMs } });
    },
    [editor]
  );
  const onPointerDown = React90.useCallback(
    (e) => {
      if (!minimapRef.current) return;
      const elm = e.currentTarget;
      setPointerCapture(elm, e);
      if (!editor.getCurrentPageShapeIds().size) return;
      rPointing.current = true;
      minimapRef.current.isInViewport = false;
      const point = minimapRef.current.minimapScreenPointToPagePoint(
        e.clientX,
        e.clientY,
        false,
        false
      );
      const _vpPageBounds = editor.getViewportPageBounds();
      const commonBounds = minimapRef.current.getContentPageBounds();
      const allowedBounds = new Box(
        commonBounds.x - _vpPageBounds.width / 2,
        commonBounds.y - _vpPageBounds.height / 2,
        commonBounds.width + _vpPageBounds.width,
        commonBounds.height + _vpPageBounds.height
      );
      if (allowedBounds.containsPoint(point) && !_vpPageBounds.containsPoint(point)) {
        minimapRef.current.isInViewport = _vpPageBounds.containsPoint(point);
        const delta = Vec.Sub(_vpPageBounds.center, _vpPageBounds.point);
        const pagePoint = Vec.Add(point, delta);
        minimapRef.current.originPagePoint.setTo(pagePoint);
        minimapRef.current.originPageCenter.setTo(point);
        editor.centerOnPoint(point, { animation: { duration: editor.options.animationMediumMs } });
      } else {
        const clampedPoint = minimapRef.current.minimapScreenPointToPagePoint(
          e.clientX,
          e.clientY,
          false,
          true
        );
        minimapRef.current.isInViewport = _vpPageBounds.containsPoint(clampedPoint);
        minimapRef.current.originPagePoint.setTo(clampedPoint);
        minimapRef.current.originPageCenter.setTo(_vpPageBounds.center);
      }
      function release(e2) {
        if (elm) {
          releasePointerCapture(elm, e2);
        }
        rPointing.current = false;
        document.body.removeEventListener("pointerup", release);
      }
      document.body.addEventListener("pointerup", release);
    },
    [editor]
  );
  const onPointerMove = React90.useCallback(
    (e) => {
      if (!minimapRef.current) return;
      const point = minimapRef.current.minimapScreenPointToPagePoint(
        e.clientX,
        e.clientY,
        e.shiftKey,
        true
      );
      if (rPointing.current) {
        if (minimapRef.current.isInViewport) {
          const delta = minimapRef.current.originPagePoint.clone().sub(minimapRef.current.originPageCenter);
          editor.centerOnPoint(Vec.Sub(point, delta));
          return;
        }
        editor.centerOnPoint(point);
      }
      const pagePoint = minimapRef.current.getMinimapPagePoint(e.clientX, e.clientY);
      const screenPoint = editor.pageToScreen(pagePoint);
      const info = {
        type: "pointer",
        target: "canvas",
        name: "pointer_move",
        ...getPointerInfo(editor, e),
        point: screenPoint,
        isPen: editor.getInstanceState().isPenMode
      };
      editor.dispatch(info);
    },
    [editor]
  );
  const onWheel = React90.useCallback(
    (e) => {
      const offset4 = normalizeWheel(e);
      editor.dispatch({
        type: "wheel",
        name: "wheel",
        delta: offset4,
        point: new Vec(e.clientX, e.clientY),
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        ctrlKey: e.metaKey || e.ctrlKey,
        metaKey: e.metaKey,
        accelKey: isAccelKey(e)
      });
    },
    [editor]
  );
  const isDarkMode = useIsDarkMode();
  React90.useEffect(() => {
    editor.timers.setTimeout(() => {
      var _a6, _b3;
      (_a6 = minimapRef.current) == null ? void 0 : _a6.updateColors();
      (_b3 = minimapRef.current) == null ? void 0 : _b3.render();
    });
  }, [isDarkMode, editor]);
  return (0, import_jsx_runtime142.jsx)("div", { className: "tlui-minimap", children: (0, import_jsx_runtime142.jsx)(
    "canvas",
    {
      role: "img",
      "aria-label": msg2("navigation-zone.minimap"),
      "data-testid": "minimap.canvas",
      ref: rCanvas,
      className: "tlui-minimap__canvas",
      onDoubleClick,
      onPointerMove,
      onPointerDown,
      onWheelCapture: onWheel
    }
  ) });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/NavigationPanel/DefaultNavigationPanel.mjs
var import_jsx_runtime143 = __toESM(require_jsx_runtime(), 1);
var import_react94 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/hooks/useLocalStorageState.mjs
var import_react93 = __toESM(require_react(), 1);
function useLocalStorageState(key, defaultValue) {
  const [state, setState] = import_react93.default.useState(defaultValue);
  import_react93.default.useLayoutEffect(() => {
    const value = getFromLocalStorage(key);
    if (value) {
      try {
        setState(JSON.parse(value));
      } catch {
        console.error(`Could not restore value ${key} from local storage.`);
      }
    }
  }, [key]);
  const updateValue = import_react93.default.useCallback(
    (setter) => {
      setState((s) => {
        const value = typeof setter === "function" ? setter(s) : setter;
        setInLocalStorage(key, JSON.stringify(value));
        return value;
      });
    },
    [key]
  );
  return [state, updateValue];
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/NavigationPanel/DefaultNavigationPanel.mjs
var DefaultNavigationPanel = (0, import_react94.memo)(function DefaultNavigationPanel2() {
  const actions = useActions();
  const msg2 = useTranslation();
  const breakpoint = useBreakpoint();
  const ref = (0, import_react94.useRef)(null);
  usePassThroughWheelEvents(ref);
  const [collapsed, setCollapsed] = useLocalStorageState("minimap", true);
  const toggleMinimap = (0, import_react94.useCallback)(() => {
    setCollapsed((s) => !s);
  }, [setCollapsed]);
  const { ZoomMenu, Minimap } = useTldrawUiComponents();
  if (breakpoint < PORTRAIT_BREAKPOINT.MOBILE) {
    return null;
  }
  return (0, import_jsx_runtime143.jsxs)("div", { ref, className: "tlui-navigation-panel", children: [
    (0, import_jsx_runtime143.jsx)(TldrawUiToolbar, { orientation: "horizontal", label: msg2("navigation-zone.title"), children: ZoomMenu && breakpoint < PORTRAIT_BREAKPOINT.TABLET ? (0, import_jsx_runtime143.jsx)(ZoomMenu, {}) : (0, import_jsx_runtime143.jsxs)(import_jsx_runtime143.Fragment, { children: [
      !collapsed && (0, import_jsx_runtime143.jsx)(
        TldrawUiToolbarButton,
        {
          type: "icon",
          "data-testid": "minimap.zoom-out",
          title: `${msg2(unwrapLabel(actions["zoom-out"].label))} ${kbdStr(actions["zoom-out"].kbd)}`,
          onClick: () => actions["zoom-out"].onSelect("navigation-zone"),
          children: (0, import_jsx_runtime143.jsx)(TldrawUiButtonIcon, { small: true, icon: "minus" })
        }
      ),
      ZoomMenu && (0, import_jsx_runtime143.jsx)(ZoomMenu, {}, "zoom-menu"),
      !collapsed && (0, import_jsx_runtime143.jsx)(
        TldrawUiToolbarButton,
        {
          type: "icon",
          "data-testid": "minimap.zoom-in",
          title: `${msg2(unwrapLabel(actions["zoom-in"].label))} ${kbdStr(actions["zoom-in"].kbd)}`,
          onClick: () => actions["zoom-in"].onSelect("navigation-zone"),
          children: (0, import_jsx_runtime143.jsx)(TldrawUiButtonIcon, { small: true, icon: "plus" })
        }
      ),
      Minimap && (0, import_jsx_runtime143.jsx)(
        TldrawUiToolbarButton,
        {
          type: "icon",
          "data-testid": "minimap.toggle-button",
          title: msg2("navigation-zone.toggle-minimap"),
          onClick: toggleMinimap,
          children: (0, import_jsx_runtime143.jsx)(TldrawUiButtonIcon, { small: true, icon: collapsed ? "chevron-right" : "chevron-left" })
        }
      )
    ] }) }),
    Minimap && breakpoint >= PORTRAIT_BREAKPOINT.TABLET && !collapsed && (0, import_jsx_runtime143.jsx)(Minimap, {})
  ] });
});

// ../node_modules/tldraw/dist-esm/lib/ui/components/PageMenu/DefaultPageMenu.mjs
var import_jsx_runtime146 = __toESM(require_jsx_runtime(), 1);
var import_react97 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/components/PageMenu/PageItemInput.mjs
var import_jsx_runtime144 = __toESM(require_jsx_runtime(), 1);
var import_react95 = __toESM(require_react(), 1);
var PageItemInput = function PageItemInput2({
  name,
  id,
  isCurrentPage,
  onCancel,
  onComplete
}) {
  const editor = useEditor();
  const trackEvent = useUiEvents();
  const rInput = (0, import_react95.useRef)(null);
  const rMark = (0, import_react95.useRef)(null);
  const handleFocus = (0, import_react95.useCallback)(() => {
    rMark.current = editor.markHistoryStoppingPoint("rename page");
  }, [editor]);
  const handleChange = (0, import_react95.useCallback)(
    (value) => {
      editor.renamePage(id, value || "New Page");
      trackEvent("rename-page", { source: "page-menu" });
    },
    [editor, id, trackEvent]
  );
  const handleCancel = (0, import_react95.useCallback)(() => {
    if (rMark.current) {
      editor.bailToMark(rMark.current);
    }
    onCancel();
  }, [editor, onCancel]);
  return (0, import_jsx_runtime144.jsx)(
    TldrawUiInput,
    {
      className: "tlui-page-menu__item__input",
      ref: (el) => {
        rInput.current = el;
      },
      defaultValue: name,
      onValueChange: handleChange,
      onComplete,
      onCancel: handleCancel,
      onFocus: handleFocus,
      shouldManuallyMaintainScrollPositionWhenFocused: true,
      autoFocus: isCurrentPage,
      autoSelect: true
    }
  );
};

// ../node_modules/tldraw/dist-esm/lib/ui/components/PageMenu/PageItemSubmenu.mjs
var import_jsx_runtime145 = __toESM(require_jsx_runtime(), 1);
var import_react96 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/components/PageMenu/edit-pages-shared.mjs
var onMovePage = (editor, id, from2, to, trackEvent) => {
  let index2;
  const pages = editor.getPages();
  const below = from2 > to ? pages[to - 1] : pages[to];
  const above = from2 > to ? pages[to] : pages[to + 1];
  if (below && !above) {
    index2 = getIndexAbove(below.index);
  } else if (!below && above) {
    index2 = getIndexBelow(pages[0].index);
  } else {
    index2 = getIndexBetween(below.index, above.index);
  }
  if (index2 !== pages[from2].index) {
    editor.markHistoryStoppingPoint("moving page");
    editor.updatePage({
      id,
      index: index2
    });
    trackEvent("move-page", { source: "page-menu" });
  }
};

// ../node_modules/tldraw/dist-esm/lib/ui/components/PageMenu/PageItemSubmenu.mjs
var PageItemSubmenu = track(function PageItemSubmenu2({
  index: index2,
  listSize,
  item,
  onRename
}) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const pages = editor.getPages();
  const trackEvent = useUiEvents();
  const onDuplicate = (0, import_react96.useCallback)(() => {
    editor.markHistoryStoppingPoint("creating page");
    const newId = PageRecordType.createId();
    editor.duplicatePage(item.id, newId);
    trackEvent("duplicate-page", { source: "page-menu" });
  }, [editor, item, trackEvent]);
  const onMoveUp = (0, import_react96.useCallback)(() => {
    onMovePage(editor, item.id, index2, index2 - 1, trackEvent);
  }, [editor, item, index2, trackEvent]);
  const onMoveDown = (0, import_react96.useCallback)(() => {
    onMovePage(editor, item.id, index2, index2 + 1, trackEvent);
  }, [editor, item, index2, trackEvent]);
  const onDelete = (0, import_react96.useCallback)(() => {
    editor.markHistoryStoppingPoint("deleting page");
    editor.deletePage(item.id);
    trackEvent("delete-page", { source: "page-menu" });
  }, [editor, item, trackEvent]);
  return (0, import_jsx_runtime145.jsxs)(TldrawUiDropdownMenuRoot, { id: `page item submenu ${index2}`, children: [
    (0, import_jsx_runtime145.jsx)(TldrawUiDropdownMenuTrigger, { children: (0, import_jsx_runtime145.jsx)(TldrawUiButton, { type: "icon", title: msg2("page-menu.submenu.title"), children: (0, import_jsx_runtime145.jsx)(TldrawUiButtonIcon, { icon: "dots-vertical", small: true }) }) }),
    (0, import_jsx_runtime145.jsx)(TldrawUiDropdownMenuContent, { alignOffset: 0, side: "right", sideOffset: -4, children: (0, import_jsx_runtime145.jsxs)(TldrawUiMenuContextProvider, { type: "menu", sourceId: "page-menu", children: [
      (0, import_jsx_runtime145.jsxs)(TldrawUiMenuGroup, { id: "modify", children: [
        onRename && (0, import_jsx_runtime145.jsx)(TldrawUiMenuItem, { id: "rename", label: "page-menu.submenu.rename", onSelect: onRename }),
        (0, import_jsx_runtime145.jsx)(
          TldrawUiMenuItem,
          {
            id: "duplicate",
            label: "page-menu.submenu.duplicate-page",
            onSelect: onDuplicate,
            disabled: pages.length >= editor.options.maxPages
          }
        ),
        index2 > 0 && (0, import_jsx_runtime145.jsx)(
          TldrawUiMenuItem,
          {
            id: "move-up",
            onSelect: onMoveUp,
            label: "page-menu.submenu.move-up"
          }
        ),
        index2 < listSize - 1 && (0, import_jsx_runtime145.jsx)(
          TldrawUiMenuItem,
          {
            id: "move-down",
            label: "page-menu.submenu.move-down",
            onSelect: onMoveDown
          }
        )
      ] }),
      listSize > 1 && (0, import_jsx_runtime145.jsx)(TldrawUiMenuGroup, { id: "delete", children: (0, import_jsx_runtime145.jsx)(TldrawUiMenuItem, { id: "delete", onSelect: onDelete, label: "page-menu.submenu.delete" }) })
    ] }) })
  ] });
});

// ../node_modules/tldraw/dist-esm/lib/ui/components/PageMenu/DefaultPageMenu.mjs
var DefaultPageMenu = (0, import_react97.memo)(function DefaultPageMenu2() {
  const editor = useEditor();
  const trackEvent = useUiEvents();
  const msg2 = useTranslation();
  const breakpoint = useBreakpoint();
  const handleOpenChange = (0, import_react97.useCallback)(() => setIsEditing(false), []);
  const [isOpen, onOpenChange] = useMenuIsOpen("page-menu", handleOpenChange);
  const ITEM_HEIGHT = 36;
  const rSortableContainer = (0, import_react97.useRef)(null);
  const pages = useValue("pages", () => editor.getPages(), [editor]);
  const currentPage = useValue("currentPage", () => editor.getCurrentPage(), [editor]);
  const currentPageId = useValue("currentPageId", () => editor.getCurrentPageId(), [editor]);
  const isReadonlyMode = useReadonly();
  const maxPageCountReached = useValue(
    "maxPageCountReached",
    () => editor.getPages().length >= editor.options.maxPages,
    [editor]
  );
  const isCoarsePointer = useValue(
    "isCoarsePointer",
    () => editor.getInstanceState().isCoarsePointer,
    [editor]
  );
  const [isEditing, setIsEditing] = (0, import_react97.useState)(false);
  (0, import_react97.useEffect)(
    function closePageMenuOnEnterPressAfterPressingEnterToConfirmRename() {
      function handleKeyDown22() {
        if (isEditing) return;
        if (document.activeElement === document.body) {
          editor.menus.clearOpenMenus();
        }
      }
      document.addEventListener("keydown", handleKeyDown22, { passive: true });
      return () => {
        document.removeEventListener("keydown", handleKeyDown22);
      };
    },
    [editor, isEditing]
  );
  const toggleEditing = (0, import_react97.useCallback)(() => {
    if (isReadonlyMode) return;
    setIsEditing((s) => !s);
  }, [isReadonlyMode]);
  const rMutables = (0, import_react97.useRef)({
    isPointing: false,
    status: "idle",
    pointing: null,
    startY: 0,
    startIndex: 0,
    dragIndex: 0
  });
  const [sortablePositionItems, setSortablePositionItems] = (0, import_react97.useState)(
    Object.fromEntries(
      pages.map((page, i) => [page.id, { y: i * ITEM_HEIGHT, offsetY: 0, isSelected: false }])
    )
  );
  (0, import_react97.useLayoutEffect)(() => {
    setSortablePositionItems(
      Object.fromEntries(
        pages.map((page, i) => [page.id, { y: i * ITEM_HEIGHT, offsetY: 0, isSelected: false }])
      )
    );
  }, [ITEM_HEIGHT, pages]);
  (0, import_react97.useEffect)(() => {
    if (!isOpen) return;
    editor.timers.requestAnimationFrame(() => {
      var _a6;
      const elm = document.querySelector(`[data-pageid="${currentPageId}"]`);
      if (elm) {
        (_a6 = elm.querySelector("button")) == null ? void 0 : _a6.focus();
        const container = rSortableContainer.current;
        if (!container) return;
        const elmTopPosition = elm.offsetTop;
        const containerScrollTopPosition = container.scrollTop;
        if (elmTopPosition < containerScrollTopPosition) {
          container.scrollTo({ top: elmTopPosition });
        }
        const elmBottomPosition = elmTopPosition + ITEM_HEIGHT;
        const containerScrollBottomPosition = container.scrollTop + container.offsetHeight;
        if (elmBottomPosition > containerScrollBottomPosition) {
          container.scrollTo({ top: elmBottomPosition - container.offsetHeight });
        }
      }
    });
  }, [ITEM_HEIGHT, currentPageId, isOpen, editor]);
  const handlePointerDown = (0, import_react97.useCallback)(
    (e) => {
      const { clientY, currentTarget } = e;
      const {
        dataset: { id, index: index2 }
      } = currentTarget;
      if (!id || !index2) return;
      const mut = rMutables.current;
      setPointerCapture(e.currentTarget, e);
      mut.status = "pointing";
      mut.pointing = { id, index: +index2 };
      const current = sortablePositionItems[id];
      const dragY = current.y;
      mut.startY = clientY;
      mut.startIndex = Math.max(0, Math.min(Math.round(dragY / ITEM_HEIGHT), pages.length - 1));
    },
    [ITEM_HEIGHT, pages.length, sortablePositionItems]
  );
  const handlePointerMove = (0, import_react97.useCallback)(
    (e) => {
      const mut = rMutables.current;
      if (mut.status === "pointing") {
        const { clientY } = e;
        const offset4 = clientY - mut.startY;
        if (Math.abs(offset4) > 5) {
          mut.status = "dragging";
        }
      }
      if (mut.status === "dragging") {
        const { clientY } = e;
        const offsetY = clientY - mut.startY;
        const current = sortablePositionItems[mut.pointing.id];
        const { startIndex, pointing } = mut;
        const dragY = current.y + offsetY;
        const dragIndex = Math.max(0, Math.min(Math.round(dragY / ITEM_HEIGHT), pages.length - 1));
        const next = { ...sortablePositionItems };
        next[pointing.id] = {
          y: current.y,
          offsetY,
          isSelected: true
        };
        if (dragIndex !== mut.dragIndex) {
          mut.dragIndex = dragIndex;
          for (let i = 0; i < pages.length; i++) {
            const item = pages[i];
            if (item.id === mut.pointing.id) {
              continue;
            }
            let { y } = next[item.id];
            if (dragIndex === startIndex) {
              y = i * ITEM_HEIGHT;
            } else if (dragIndex < startIndex) {
              if (dragIndex <= i && i < startIndex) {
                y = (i + 1) * ITEM_HEIGHT;
              } else {
                y = i * ITEM_HEIGHT;
              }
            } else if (dragIndex > startIndex) {
              if (dragIndex >= i && i > startIndex) {
                y = (i - 1) * ITEM_HEIGHT;
              } else {
                y = i * ITEM_HEIGHT;
              }
            }
            if (y !== next[item.id].y) {
              next[item.id] = { y, offsetY: 0, isSelected: true };
            }
          }
        }
        setSortablePositionItems(next);
      }
    },
    [ITEM_HEIGHT, pages, sortablePositionItems]
  );
  const handlePointerUp = (0, import_react97.useCallback)(
    (e) => {
      const mut = rMutables.current;
      if (mut.status === "dragging") {
        const { id, index: index2 } = mut.pointing;
        onMovePage(editor, id, index2, mut.dragIndex, trackEvent);
      }
      releasePointerCapture(e.currentTarget, e);
      mut.status = "idle";
    },
    [editor, trackEvent]
  );
  const handleKeyDown2 = (0, import_react97.useCallback)(
    (e) => {
      const mut = rMutables.current;
      if (e.key === "Escape") {
        if (mut.status === "dragging") {
          setSortablePositionItems(
            Object.fromEntries(
              pages.map((page, i) => [
                page.id,
                { y: i * ITEM_HEIGHT, offsetY: 0, isSelected: false }
              ])
            )
          );
        }
        mut.status = "idle";
      }
    },
    [ITEM_HEIGHT, pages]
  );
  const handleCreatePageClick = (0, import_react97.useCallback)(() => {
    if (isReadonlyMode) return;
    editor.run(() => {
      editor.markHistoryStoppingPoint("creating page");
      const newPageId = PageRecordType.createId();
      editor.createPage({ name: msg2("page-menu.new-page-initial-name"), id: newPageId });
      editor.setCurrentPage(newPageId);
      setIsEditing(true);
      editor.timers.requestAnimationFrame(() => {
        var _a6;
        const elm = document.querySelector(`[data-pageid="${newPageId}"]`);
        if (elm) {
          (_a6 = elm.querySelector("button")) == null ? void 0 : _a6.focus();
        }
      });
    });
    trackEvent("new-page", { source: "page-menu" });
  }, [editor, msg2, isReadonlyMode, trackEvent]);
  const changePage = (0, import_react97.useCallback)(
    (id) => {
      editor.setCurrentPage(id);
      trackEvent("change-page", { source: "page-menu" });
    },
    [editor, trackEvent]
  );
  const renamePage = (0, import_react97.useCallback)(
    (id, name) => {
      editor.renamePage(id, name);
      trackEvent("rename-page", { source: "page-menu" });
    },
    [editor, trackEvent]
  );
  const shouldUseWindowPrompt = breakpoint < PORTRAIT_BREAKPOINT.TABLET_SM && isCoarsePointer;
  return (0, import_jsx_runtime146.jsxs)(TldrawUiPopover, { id: "pages", onOpenChange, open: isOpen, children: [
    (0, import_jsx_runtime146.jsx)(TldrawUiPopoverTrigger, { "data-testid": "main.page-menu", children: (0, import_jsx_runtime146.jsxs)(
      TldrawUiButton,
      {
        type: "menu",
        title: currentPage.name,
        "data-testid": "page-menu.button",
        className: "tlui-page-menu__trigger",
        children: [
          (0, import_jsx_runtime146.jsx)("div", { className: "tlui-page-menu__name", children: currentPage.name }),
          (0, import_jsx_runtime146.jsx)(TldrawUiButtonIcon, { icon: "chevron-down", small: true })
        ]
      }
    ) }),
    (0, import_jsx_runtime146.jsx)(
      TldrawUiPopoverContent,
      {
        side: "bottom",
        align: "start",
        sideOffset: 0,
        disableEscapeKeyDown: isEditing,
        children: (0, import_jsx_runtime146.jsxs)("div", { className: "tlui-page-menu__wrapper", children: [
          (0, import_jsx_runtime146.jsxs)("div", { className: "tlui-page-menu__header", children: [
            (0, import_jsx_runtime146.jsx)("div", { className: "tlui-page-menu__header__title", children: msg2("page-menu.title") }),
            !isReadonlyMode && (0, import_jsx_runtime146.jsxs)(TldrawUiRow, { children: [
              (0, import_jsx_runtime146.jsx)(
                TldrawUiButton,
                {
                  type: "icon",
                  "data-testid": "page-menu.edit",
                  title: msg2(isEditing ? "page-menu.edit-done" : "page-menu.edit-start"),
                  onClick: toggleEditing,
                  children: (0, import_jsx_runtime146.jsx)(TldrawUiButtonIcon, { icon: isEditing ? "check" : "edit" })
                }
              ),
              (0, import_jsx_runtime146.jsx)(
                TldrawUiButton,
                {
                  type: "icon",
                  "data-testid": "page-menu.create",
                  title: msg2(
                    maxPageCountReached ? "page-menu.max-page-count-reached" : "page-menu.create-new-page"
                  ),
                  disabled: maxPageCountReached,
                  onClick: handleCreatePageClick,
                  children: (0, import_jsx_runtime146.jsx)(TldrawUiButtonIcon, { icon: "plus" })
                }
              )
            ] })
          ] }),
          (0, import_jsx_runtime146.jsx)(
            "div",
            {
              "data-testid": "page-menu.list",
              className: "tlui-page-menu__list tlui-menu__group",
              style: { height: ITEM_HEIGHT * pages.length + 4 },
              ref: rSortableContainer,
              children: pages.map((page, index2) => {
                const position = sortablePositionItems[page.id] ?? {
                  position: index2 * 40,
                  offsetY: 0
                };
                return isEditing ? (0, import_jsx_runtime146.jsxs)(
                  "div",
                  {
                    "data-testid": "page-menu.item",
                    "data-pageid": page.id,
                    className: "tlui-page_menu__item__sortable",
                    style: {
                      zIndex: page.id === currentPage.id ? 888 : index2,
                      transform: `translate(0px, ${position.y + position.offsetY}px)`
                    },
                    children: [
                      (0, import_jsx_runtime146.jsx)(
                        TldrawUiButton,
                        {
                          type: "icon",
                          tabIndex: -1,
                          className: "tlui-page_menu__item__sortable__handle",
                          onPointerDown: handlePointerDown,
                          onPointerUp: handlePointerUp,
                          onPointerMove: handlePointerMove,
                          onKeyDown: handleKeyDown2,
                          "data-id": page.id,
                          "data-index": index2,
                          children: (0, import_jsx_runtime146.jsx)(TldrawUiButtonIcon, { icon: "drag-handle-dots" })
                        }
                      ),
                      shouldUseWindowPrompt ? (
                        // sigh, this is a workaround for iOS Safari
                        // because the device and the radix popover seem
                        // to be fighting over scroll position. Nothing
                        // else seems to work!
                        (0, import_jsx_runtime146.jsxs)(TldrawUiButton, {
                          type: "normal",
                          className: "tlui-page-menu__item__button",
                          onClick: () => {
                            const name = window.prompt(msg2("action.rename"), page.name);
                            if (name && name !== page.name) {
                              renamePage(page.id, name);
                            }
                          },
                          onDoubleClick: toggleEditing,
                          children: [
                            (0, import_jsx_runtime146.jsx)(TldrawUiButtonCheck, { checked: page.id === currentPage.id }),
                            (0, import_jsx_runtime146.jsx)(TldrawUiButtonLabel, { children: page.name })
                          ]
                        })
                      ) : (0, import_jsx_runtime146.jsx)(
                        "div",
                        {
                          className: "tlui-page_menu__item__sortable__title",
                          style: { height: ITEM_HEIGHT },
                          children: (0, import_jsx_runtime146.jsx)(
                            PageItemInput,
                            {
                              id: page.id,
                              name: page.name,
                              isCurrentPage: page.id === currentPage.id,
                              onComplete: () => {
                                setIsEditing(false);
                              },
                              onCancel: () => {
                                setIsEditing(false);
                              }
                            }
                          )
                        }
                      ),
                      !isReadonlyMode && (0, import_jsx_runtime146.jsx)("div", { className: "tlui-page_menu__item__submenu", "data-isediting": isEditing, children: (0, import_jsx_runtime146.jsx)(PageItemSubmenu, { index: index2, item: page, listSize: pages.length }) })
                    ]
                  },
                  page.id + "_editing"
                ) : (0, import_jsx_runtime146.jsxs)(
                  "div",
                  {
                    "data-pageid": page.id,
                    "data-testid": "page-menu.item",
                    className: "tlui-page-menu__item",
                    children: [
                      (0, import_jsx_runtime146.jsxs)(
                        TldrawUiButton,
                        {
                          type: "normal",
                          className: "tlui-page-menu__item__button",
                          onClick: () => changePage(page.id),
                          onDoubleClick: toggleEditing,
                          title: msg2("page-menu.go-to-page"),
                          onKeyDown: (e) => {
                            if (e.key === "Enter") {
                              if (page.id === currentPage.id) {
                                toggleEditing();
                                editor.markEventAsHandled(e);
                              }
                            }
                          },
                          children: [
                            (0, import_jsx_runtime146.jsx)(TldrawUiButtonCheck, { checked: page.id === currentPage.id }),
                            (0, import_jsx_runtime146.jsx)(TldrawUiButtonLabel, { children: page.name })
                          ]
                        }
                      ),
                      !isReadonlyMode && (0, import_jsx_runtime146.jsx)("div", { className: "tlui-page_menu__item__submenu", children: (0, import_jsx_runtime146.jsx)(
                        PageItemSubmenu,
                        {
                          index: index2,
                          item: page,
                          listSize: pages.length,
                          onRename: () => {
                            if (shouldUseWindowPrompt) {
                              const name = window.prompt(msg2("action.rename"), page.name);
                              if (name && name !== page.name) {
                                renamePage(page.id, name);
                              }
                            } else {
                              setIsEditing(true);
                              if (currentPageId !== page.id) {
                                changePage(page.id);
                              }
                            }
                          }
                        }
                      ) })
                    ]
                  },
                  page.id
                );
              })
            }
          )
        ] })
      }
    )
  ] });
});

// ../node_modules/tldraw/dist-esm/lib/ui/components/QuickActions/DefaultQuickActions.mjs
var import_jsx_runtime148 = __toESM(require_jsx_runtime(), 1);
var import_react98 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/components/QuickActions/DefaultQuickActionsContent.mjs
var import_jsx_runtime147 = __toESM(require_jsx_runtime(), 1);
function DefaultQuickActionsContent() {
  const editor = useEditor();
  const isReadonlyMode = useReadonly();
  const isInAcceptableReadonlyState = useValue(
    "should display quick actions",
    () => editor.isInAny("select", "hand", "zoom"),
    [editor]
  );
  if (isReadonlyMode && !isInAcceptableReadonlyState) return;
  return (0, import_jsx_runtime147.jsxs)(import_jsx_runtime147.Fragment, { children: [
    (0, import_jsx_runtime147.jsx)(UndoRedoGroup2, {}),
    (0, import_jsx_runtime147.jsx)(DeleteDuplicateGroup, {})
  ] });
}
function DeleteDuplicateGroup() {
  const oneSelected = useUnlockedSelectedShapesCount(1);
  const isInSelectState = useIsInSelectState();
  const selectDependentActionsEnabled = oneSelected && isInSelectState;
  return (0, import_jsx_runtime147.jsxs)(import_jsx_runtime147.Fragment, { children: [
    (0, import_jsx_runtime147.jsx)(TldrawUiMenuActionItem, { actionId: "delete", disabled: !selectDependentActionsEnabled }),
    (0, import_jsx_runtime147.jsx)(TldrawUiMenuActionItem, { actionId: "duplicate", disabled: !selectDependentActionsEnabled })
  ] });
}
function UndoRedoGroup2() {
  const canUndo = useCanUndo();
  const canRedo = useCanRedo();
  return (0, import_jsx_runtime147.jsxs)(import_jsx_runtime147.Fragment, { children: [
    (0, import_jsx_runtime147.jsx)(TldrawUiMenuActionItem, { actionId: "undo", disabled: !canUndo }),
    (0, import_jsx_runtime147.jsx)(TldrawUiMenuActionItem, { actionId: "redo", disabled: !canRedo })
  ] });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/QuickActions/DefaultQuickActions.mjs
var DefaultQuickActions = (0, import_react98.memo)(function DefaultQuickActions2({
  children
}) {
  const content = children ?? (0, import_jsx_runtime148.jsx)(DefaultQuickActionsContent, {});
  return (0, import_jsx_runtime148.jsx)(TldrawUiMenuContextProvider, { type: "small-icons", sourceId: "quick-actions", children: content });
});

// ../node_modules/tldraw/dist-esm/lib/ui/components/SharePanel/DefaultSharePanel.mjs
var import_jsx_runtime156 = __toESM(require_jsx_runtime(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/components/SharePanel/PeopleMenu.mjs
var import_jsx_runtime155 = __toESM(require_jsx_runtime(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/components/OfflineIndicator/OfflineIndicator.mjs
var import_jsx_runtime149 = __toESM(require_jsx_runtime(), 1);
function OfflineIndicator() {
  const msg2 = useTranslation();
  return (0, import_jsx_runtime149.jsx)(TldrawUiTooltip, { content: msg2("status.offline"), children: (0, import_jsx_runtime149.jsx)("div", { className: "tlui-offline-indicator", children: (0, import_jsx_runtime149.jsx)(TldrawUiIcon, { icon: "status-offline", label: msg2("status.offline"), small: true }) }) });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/SharePanel/PeopleMenuAvatar.mjs
var import_jsx_runtime150 = __toESM(require_jsx_runtime(), 1);
function PeopleMenuAvatar({ userId }) {
  var _a6;
  const presence = usePresence(userId);
  if (!presence) return null;
  return (0, import_jsx_runtime150.jsx)(
    "div",
    {
      className: "tlui-people-menu__avatar",
      style: {
        backgroundColor: presence.color
      },
      children: ((_a6 = presence.userName) == null ? void 0 : _a6[0]) ?? ""
    },
    userId
  );
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/SharePanel/PeopleMenuItem.mjs
var import_jsx_runtime151 = __toESM(require_jsx_runtime(), 1);
var import_react99 = __toESM(require_react(), 1);
var PeopleMenuItem = track(function PeopleMenuItem2({ userId }) {
  var _a6;
  const editor = useEditor();
  const msg2 = useTranslation();
  const trackEvent = useUiEvents();
  const presence = usePresence(userId);
  const handleFollowClick = (0, import_react99.useCallback)(() => {
    if (editor.getInstanceState().followingUserId === userId) {
      editor.stopFollowingUser();
      trackEvent("stop-following", { source: "people-menu" });
    } else {
      editor.startFollowingUser(userId);
      trackEvent("start-following", { source: "people-menu" });
    }
  }, [editor, userId, trackEvent]);
  const theyAreFollowingYou = (presence == null ? void 0 : presence.followingUserId) === editor.user.getId();
  const youAreFollowingThem = editor.getInstanceState().followingUserId === userId;
  if (!presence) return null;
  return (0, import_jsx_runtime151.jsxs)(
    TldrawUiRow,
    {
      className: "tlui-people-menu__item",
      "data-follow": youAreFollowingThem || theyAreFollowingYou,
      children: [
        (0, import_jsx_runtime151.jsxs)(
          TldrawUiButton,
          {
            type: "menu",
            className: "tlui-people-menu__item__button",
            onClick: () => editor.zoomToUser(userId),
            onDoubleClick: handleFollowClick,
            children: [
              (0, import_jsx_runtime151.jsx)(TldrawUiIcon, { label: msg2("people-menu.avatar-color"), icon: "color", color: presence.color }),
              (0, import_jsx_runtime151.jsx)("div", { className: "tlui-people-menu__name", children: ((_a6 = presence.userName) == null ? void 0 : _a6.trim()) || msg2("people-menu.anonymous-user") })
            ]
          }
        ),
        (0, import_jsx_runtime151.jsx)(
          TldrawUiButton,
          {
            type: "icon",
            className: "tlui-people-menu__item__follow",
            title: theyAreFollowingYou ? msg2("people-menu.leading") : youAreFollowingThem ? msg2("people-menu.following") : msg2("people-menu.follow"),
            onClick: handleFollowClick,
            disabled: theyAreFollowingYou,
            children: (0, import_jsx_runtime151.jsx)(
              TldrawUiButtonIcon,
              {
                icon: theyAreFollowingYou ? "leading" : youAreFollowingThem ? "following" : "follow"
              }
            )
          }
        )
      ]
    }
  );
});

// ../node_modules/tldraw/dist-esm/lib/ui/components/SharePanel/PeopleMenuMore.mjs
var import_jsx_runtime152 = __toESM(require_jsx_runtime(), 1);
function PeopleMenuMore({ count: count3 }) {
  return (0, import_jsx_runtime152.jsx)("div", { className: "tlui-people-menu__avatar tlui-people-menu__more", children: Math.abs(count3) });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/SharePanel/UserPresenceEditor.mjs
var import_jsx_runtime154 = __toESM(require_jsx_runtime(), 1);
var import_react101 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/components/SharePanel/UserPresenceColorPicker.mjs
var import_jsx_runtime153 = __toESM(require_jsx_runtime(), 1);
var import_react100 = __toESM(require_react(), 1);
var UserPresenceColorPicker = track(function UserPresenceColorPicker2() {
  const editor = useEditor();
  const container = useContainer();
  const msg2 = useTranslation();
  const trackEvent = useUiEvents();
  const rPointing = (0, import_react100.useRef)(false);
  const [isOpen, setIsOpen] = (0, import_react100.useState)(false);
  const handleOpenChange = (0, import_react100.useCallback)((isOpen2) => {
    setIsOpen(isOpen2);
  }, []);
  const value = editor.user.getColor();
  const onValueChange = (0, import_react100.useCallback)(
    (item) => {
      editor.user.updateUserPreferences({ color: item });
      trackEvent("set-color", { source: "people-menu" });
    },
    [editor, trackEvent]
  );
  const {
    handleButtonClick,
    handleButtonPointerDown,
    handleButtonPointerEnter,
    handleButtonPointerUp
  } = import_react100.default.useMemo(() => {
    const handlePointerUp = () => {
      rPointing.current = false;
      window.removeEventListener("pointerup", handlePointerUp);
    };
    const handleButtonClick2 = (e) => {
      const { id } = e.currentTarget.dataset;
      if (!id) return;
      if (value === id) return;
      onValueChange(id);
    };
    const handleButtonPointerDown2 = (e) => {
      const { id } = e.currentTarget.dataset;
      if (!id) return;
      onValueChange(id);
      rPointing.current = true;
      window.addEventListener("pointerup", handlePointerUp);
    };
    const handleButtonPointerEnter2 = (e) => {
      if (!rPointing.current) return;
      const { id } = e.currentTarget.dataset;
      if (!id) return;
      onValueChange(id);
    };
    const handleButtonPointerUp2 = (e) => {
      const { id } = e.currentTarget.dataset;
      if (!id) return;
      onValueChange(id);
    };
    return {
      handleButtonClick: handleButtonClick2,
      handleButtonPointerDown: handleButtonPointerDown2,
      handleButtonPointerEnter: handleButtonPointerEnter2,
      handleButtonPointerUp: handleButtonPointerUp2
    };
  }, [value, onValueChange]);
  return (0, import_jsx_runtime153.jsxs)(dist_exports12.Root, { onOpenChange: handleOpenChange, open: isOpen, children: [
    (0, import_jsx_runtime153.jsx)(dist_exports12.Trigger, { dir: "ltr", asChild: true, children: (0, import_jsx_runtime153.jsx)(
      TldrawUiButton,
      {
        type: "icon",
        className: "tlui-people-menu__user__color",
        style: { color: editor.user.getColor() },
        title: msg2("people-menu.change-color"),
        children: (0, import_jsx_runtime153.jsx)(TldrawUiButtonIcon, { icon: "color" })
      }
    ) }),
    (0, import_jsx_runtime153.jsx)(dist_exports12.Portal, { container, children: (0, import_jsx_runtime153.jsx)(
      dist_exports12.Content,
      {
        dir: "ltr",
        className: "tlui-menu tlui-people-menu__user__color-picker",
        align: "start",
        side: "left",
        sideOffset: 8,
        children: (0, import_jsx_runtime153.jsx)(TldrawUiGrid, { children: USER_COLORS.map((item) => (0, import_jsx_runtime153.jsx)(
          TldrawUiButton,
          {
            type: "icon",
            "data-id": item,
            "data-testid": item,
            "aria-label": item,
            isActive: value === item,
            title: item,
            style: { color: item },
            onPointerEnter: handleButtonPointerEnter,
            onPointerDown: handleButtonPointerDown,
            onPointerUp: handleButtonPointerUp,
            onClick: handleButtonClick,
            children: (0, import_jsx_runtime153.jsx)(TldrawUiButtonIcon, { icon: "color" })
          },
          item
        )) })
      }
    ) })
  ] });
});

// ../node_modules/tldraw/dist-esm/lib/ui/components/SharePanel/UserPresenceEditor.mjs
function UserPresenceEditor() {
  const editor = useEditor();
  const trackEvent = useUiEvents();
  const userName = useValue("userName", () => editor.user.getName(), []);
  const msg2 = useTranslation();
  const rOriginalName = (0, import_react101.useRef)(userName);
  const rCurrentName = (0, import_react101.useRef)(userName);
  const [isEditingName, setIsEditingName] = (0, import_react101.useState)(false);
  const toggleEditingName = (0, import_react101.useCallback)(() => {
    setIsEditingName((s) => !s);
  }, []);
  const handleValueChange = (0, import_react101.useCallback)(
    (value) => {
      rCurrentName.current = value;
      editor.user.updateUserPreferences({ name: value });
    },
    [editor]
  );
  const handleBlur = (0, import_react101.useCallback)(() => {
    if (rOriginalName.current === rCurrentName.current) return;
    trackEvent("change-user-name", { source: "people-menu" });
    rOriginalName.current = rCurrentName.current;
  }, [trackEvent]);
  const handleCancel = (0, import_react101.useCallback)(() => {
    setIsEditingName(false);
    editor.user.updateUserPreferences({ name: rOriginalName.current });
    editor.menus.clearOpenMenus();
  }, [editor]);
  return (0, import_jsx_runtime154.jsxs)("div", { className: "tlui-people-menu__user", children: [
    (0, import_jsx_runtime154.jsx)(UserPresenceColorPicker, {}),
    isEditingName ? (0, import_jsx_runtime154.jsx)(
      TldrawUiInput,
      {
        className: "tlui-people-menu__user__input",
        defaultValue: userName,
        onValueChange: handleValueChange,
        onComplete: toggleEditingName,
        onCancel: handleCancel,
        onBlur: handleBlur,
        shouldManuallyMaintainScrollPositionWhenFocused: true,
        autoFocus: true,
        autoSelect: true
      }
    ) : (0, import_jsx_runtime154.jsxs)(import_jsx_runtime154.Fragment, { children: [
      (0, import_jsx_runtime154.jsx)(
        "div",
        {
          className: "tlui-people-menu__user__name",
          onDoubleClick: () => {
            if (!isEditingName) setIsEditingName(true);
          },
          children: userName || msg2("people-menu.anonymous-user")
        }
      ),
      !userName ? (0, import_jsx_runtime154.jsx)("div", { className: "tlui-people-menu__user__label", children: msg2("people-menu.user") }) : null
    ] }),
    (0, import_jsx_runtime154.jsx)(
      TldrawUiButton,
      {
        type: "icon",
        className: "tlui-people-menu__user__edit",
        "data-testid": "people-menu.change-name",
        title: msg2("people-menu.change-name"),
        onClick: toggleEditingName,
        children: (0, import_jsx_runtime154.jsx)(TldrawUiButtonIcon, { icon: isEditingName ? "check" : "edit" })
      }
    )
  ] });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/SharePanel/PeopleMenu.mjs
function PeopleMenu({ children }) {
  const msg2 = useTranslation();
  const container = useContainer();
  const editor = useEditor();
  const userIds = usePeerIds();
  const userColor = useValue("user", () => editor.user.getColor(), [editor]);
  const userName = useValue("user", () => editor.user.getName(), [editor]);
  const [isOpen, onOpenChange] = useMenuIsOpen("people menu");
  const breakpoint = useBreakpoint();
  const maxAvatars = breakpoint <= PORTRAIT_BREAKPOINT.MOBILE_XS ? 1 : 5;
  const collaborationStatus = useCollaborationStatus();
  if (collaborationStatus === "offline") {
    return (0, import_jsx_runtime155.jsx)(OfflineIndicator, {});
  }
  if (!userIds.length) return null;
  return (0, import_jsx_runtime155.jsxs)(dist_exports12.Root, { onOpenChange, open: isOpen, children: [
    (0, import_jsx_runtime155.jsx)(dist_exports12.Trigger, { dir: "ltr", asChild: true, children: (0, import_jsx_runtime155.jsx)("button", { className: "tlui-people-menu__avatars-button", title: msg2("people-menu.title"), children: (0, import_jsx_runtime155.jsxs)("div", { className: "tlui-people-menu__avatars", children: [
      userIds.slice(-maxAvatars).map((userId) => (0, import_jsx_runtime155.jsx)(PeopleMenuAvatar, { userId }, userId)),
      userIds.length > 0 && (0, import_jsx_runtime155.jsx)(
        "div",
        {
          className: "tlui-people-menu__avatar",
          style: {
            backgroundColor: userColor
          },
          children: (userName == null ? void 0 : userName[0]) ?? ""
        }
      ),
      userIds.length > maxAvatars && (0, import_jsx_runtime155.jsx)(PeopleMenuMore, { count: userIds.length - maxAvatars })
    ] }) }) }),
    (0, import_jsx_runtime155.jsx)(dist_exports12.Portal, { container, children: (0, import_jsx_runtime155.jsx)(
      dist_exports12.Content,
      {
        dir: "ltr",
        className: "tlui-menu",
        side: "bottom",
        sideOffset: 2,
        collisionPadding: 4,
        children: (0, import_jsx_runtime155.jsxs)("div", { className: "tlui-people-menu__wrapper", children: [
          (0, import_jsx_runtime155.jsx)("div", { className: "tlui-people-menu__section", children: (0, import_jsx_runtime155.jsx)(UserPresenceEditor, {}) }),
          userIds.length > 0 && (0, import_jsx_runtime155.jsx)("div", { className: "tlui-people-menu__section", children: userIds.map((userId) => {
            return (0, import_jsx_runtime155.jsx)(PeopleMenuItem, { userId }, userId + "_presence");
          }) }),
          children
        ] })
      }
    ) })
  ] });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/SharePanel/DefaultSharePanel.mjs
function DefaultSharePanel() {
  return (0, import_jsx_runtime156.jsx)("div", { className: "tlui-share-zone", draggable: false, children: (0, import_jsx_runtime156.jsx)(PeopleMenu, {}) });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/StylePanel/DefaultStylePanel.mjs
var import_jsx_runtime164 = __toESM(require_jsx_runtime(), 1);
var import_classnames25 = __toESM(require_classnames(), 1);
var import_react106 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/hooks/useRelevantStyles.mjs
var selectToolStyles = Object.freeze([
  DefaultColorStyle,
  DefaultDashStyle,
  DefaultFillStyle,
  DefaultSizeStyle
]);
function useRelevantStyles(stylesToCheck = selectToolStyles) {
  const editor = useEditor();
  return useValue(
    "getRelevantStyles",
    () => {
      var _a6;
      const styles = new SharedStyleMap(editor.getSharedStyles());
      const isInShapeSpecificTool = !!((_a6 = editor.root.getCurrent()) == null ? void 0 : _a6.shapeType);
      const hasShapesSelected = editor.isIn("select") && editor.getSelectedShapeIds().length > 0;
      if (styles.size === 0 && editor.isIn("select") && editor.getSelectedShapeIds().length === 0) {
        for (const style2 of stylesToCheck) {
          styles.applyValue(style2, editor.getStyleForNextShape(style2));
        }
      }
      if (isInShapeSpecificTool || hasShapesSelected || styles.size > 0) {
        return styles;
      }
      return null;
    },
    [editor]
  );
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/StylePanel/DefaultStylePanelContent.mjs
var import_jsx_runtime163 = __toESM(require_jsx_runtime(), 1);
var import_react105 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/styles.mjs
var STYLES = {
  color: [
    { value: "black", icon: "color" },
    { value: "grey", icon: "color" },
    { value: "light-violet", icon: "color" },
    { value: "violet", icon: "color" },
    { value: "blue", icon: "color" },
    { value: "light-blue", icon: "color" },
    { value: "yellow", icon: "color" },
    { value: "orange", icon: "color" },
    { value: "green", icon: "color" },
    { value: "light-green", icon: "color" },
    { value: "light-red", icon: "color" },
    { value: "red", icon: "color" }
  ],
  fill: [
    { value: "none", icon: "fill-none" },
    { value: "semi", icon: "fill-semi" },
    { value: "solid", icon: "fill-solid" },
    { value: "pattern", icon: "fill-pattern" }
    // { value: 'fill', icon: 'fill-fill' },
  ],
  dash: [
    { value: "draw", icon: "dash-draw" },
    { value: "dashed", icon: "dash-dashed" },
    { value: "dotted", icon: "dash-dotted" },
    { value: "solid", icon: "dash-solid" }
  ],
  size: [
    { value: "s", icon: "size-small" },
    { value: "m", icon: "size-medium" },
    { value: "l", icon: "size-large" },
    { value: "xl", icon: "size-extra-large" }
  ],
  font: [
    { value: "draw", icon: "font-draw" },
    { value: "sans", icon: "font-sans" },
    { value: "serif", icon: "font-serif" },
    { value: "mono", icon: "font-mono" }
  ],
  textAlign: [
    { value: "start", icon: "text-align-left" },
    { value: "middle", icon: "text-align-center" },
    { value: "end", icon: "text-align-right" }
  ],
  horizontalAlign: [
    { value: "start", icon: "horizontal-align-start" },
    { value: "middle", icon: "horizontal-align-middle" },
    { value: "end", icon: "horizontal-align-end" }
  ],
  verticalAlign: [
    { value: "start", icon: "vertical-align-start" },
    { value: "middle", icon: "vertical-align-middle" },
    { value: "end", icon: "vertical-align-end" }
  ],
  geo: [
    { value: "rectangle", icon: "geo-rectangle" },
    { value: "ellipse", icon: "geo-ellipse" },
    { value: "triangle", icon: "geo-triangle" },
    { value: "diamond", icon: "geo-diamond" },
    { value: "star", icon: "geo-star" },
    { value: "pentagon", icon: "geo-pentagon" },
    { value: "hexagon", icon: "geo-hexagon" },
    { value: "octagon", icon: "geo-octagon" },
    { value: "rhombus", icon: "geo-rhombus" },
    { value: "rhombus-2", icon: "geo-rhombus-2" },
    { value: "oval", icon: "geo-oval" },
    { value: "trapezoid", icon: "geo-trapezoid" },
    { value: "arrow-left", icon: "geo-arrow-left" },
    { value: "arrow-up", icon: "geo-arrow-up" },
    { value: "arrow-down", icon: "geo-arrow-down" },
    { value: "arrow-right", icon: "geo-arrow-right" },
    { value: "cloud", icon: "geo-cloud" },
    { value: "x-box", icon: "geo-x-box" },
    { value: "check-box", icon: "geo-check-box" },
    { value: "heart", icon: "geo-heart" }
  ],
  arrowKind: [
    { value: "arc", icon: "arrow-arc" },
    { value: "elbow", icon: "arrow-elbow" }
  ],
  arrowheadStart: [
    { value: "none", icon: "arrowhead-none" },
    { value: "arrow", icon: "arrowhead-arrow" },
    { value: "triangle", icon: "arrowhead-triangle" },
    { value: "square", icon: "arrowhead-square" },
    { value: "dot", icon: "arrowhead-dot" },
    { value: "diamond", icon: "arrowhead-diamond" },
    { value: "inverted", icon: "arrowhead-triangle-inverted" },
    { value: "bar", icon: "arrowhead-bar" }
  ],
  arrowheadEnd: [
    { value: "none", icon: "arrowhead-none" },
    { value: "arrow", icon: "arrowhead-arrow" },
    { value: "triangle", icon: "arrowhead-triangle" },
    { value: "square", icon: "arrowhead-square" },
    { value: "dot", icon: "arrowhead-dot" },
    { value: "diamond", icon: "arrowhead-diamond" },
    { value: "inverted", icon: "arrowhead-triangle-inverted" },
    { value: "bar", icon: "arrowhead-bar" }
  ],
  spline: [
    { value: "line", icon: "spline-line" },
    { value: "cubic", icon: "spline-cubic" }
  ]
};

// ../node_modules/tldraw/dist-esm/lib/ui/components/primitives/TldrawUiSlider.mjs
var import_jsx_runtime157 = __toESM(require_jsx_runtime(), 1);
var import_react102 = __toESM(require_react(), 1);
var TldrawUiSlider = import_react102.default.forwardRef(function Slider2({
  onHistoryMark,
  title,
  min: min3,
  steps,
  value,
  label,
  onValueChange,
  ["data-testid"]: testId,
  ariaValueModifier = 1
}, ref) {
  const msg2 = useTranslation();
  const [titleAndLabel, setTitleAndLabel] = (0, import_react102.useState)("");
  const [tabIndex, setTabIndex] = (0, import_react102.useState)(-1);
  (0, import_react102.useEffect)(() => {
    setTabIndex(0);
  }, []);
  const handleValueChange = (0, import_react102.useCallback)(
    (value2) => {
      onValueChange(value2[0]);
    },
    [onValueChange]
  );
  const handlePointerDown = (0, import_react102.useCallback)(() => {
    hideAllTooltips();
    onHistoryMark == null ? void 0 : onHistoryMark("click slider");
  }, [onHistoryMark]);
  (0, import_react102.useEffect)(() => {
    const timeout = tltime.setTimeout(
      "set title and label",
      () => {
        setTitleAndLabel(title + " — " + msg2(label));
      },
      0
    );
    return () => clearTimeout(timeout);
  }, [label, msg2, title]);
  const handleKeyEvent = (0, import_react102.useCallback)((event) => {
    if (event.key === "Tab") {
      event.stopPropagation();
    }
  }, []);
  return (0, import_jsx_runtime157.jsx)("div", { className: "tlui-slider__container", children: (0, import_jsx_runtime157.jsx)(TldrawUiTooltip, { content: titleAndLabel, children: (0, import_jsx_runtime157.jsxs)(
    dist_exports13.Root,
    {
      "data-testid": testId,
      className: "tlui-slider",
      dir: "ltr",
      min: min3 ?? 0,
      max: steps,
      step: 1,
      value: value !== null ? [value] : void 0,
      onPointerDown: handlePointerDown,
      onValueChange: handleValueChange,
      onKeyDownCapture: handleKeyEvent,
      onKeyUpCapture: handleKeyEvent,
      children: [
        (0, import_jsx_runtime157.jsx)(dist_exports13.Track, { className: "tlui-slider__track", dir: "ltr", children: value !== null && (0, import_jsx_runtime157.jsx)(dist_exports13.Range, { className: "tlui-slider__range", dir: "ltr" }) }),
        value !== null && (0, import_jsx_runtime157.jsx)(
          dist_exports13.Thumb,
          {
            "aria-valuemin": (min3 ?? 0) * ariaValueModifier,
            "aria-valuenow": value * ariaValueModifier,
            "aria-valuemax": steps * ariaValueModifier,
            "aria-label": titleAndLabel,
            className: "tlui-slider__thumb",
            dir: "ltr",
            ref,
            tabIndex
          }
        )
      ]
    }
  ) }) });
});

// ../node_modules/tldraw/dist-esm/lib/ui/components/StylePanel/StylePanelButtonPicker.mjs
var import_jsx_runtime160 = __toESM(require_jsx_runtime(), 1);
var import_react104 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/shapes/shared/useDefaultColorTheme.mjs
function useDefaultColorTheme() {
  return getDefaultColorTheme({ isDarkMode: useIsDarkMode() });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/StylePanel/StylePanelContext.mjs
var import_jsx_runtime158 = __toESM(require_jsx_runtime(), 1);
var import_react103 = __toESM(require_react(), 1);
var StylePanelContext = (0, import_react103.createContext)(null);
function StylePanelContextProvider({ children, styles }) {
  const editor = useEditor();
  const trackEvent = useUiEvents();
  const onHistoryMark = (0, import_react103.useCallback)((id) => editor.markHistoryStoppingPoint(id), [editor]);
  const enhancedA11yMode = useValue("enhancedA11yMode", () => editor.user.getEnhancedA11yMode(), [
    editor
  ]);
  const onValueChange = (0, import_react103.useCallback)(
    function(style2, value) {
      editor.run(() => {
        if (editor.isIn("select")) {
          editor.setStyleForSelectedShapes(style2, value);
        }
        editor.setStyleForNextShapes(style2, value);
        editor.updateInstanceState({ isChangingStyle: true });
      });
      trackEvent("set-style", { source: "style-panel", id: style2.id, value });
    },
    [editor, trackEvent]
  );
  return (0, import_jsx_runtime158.jsx)(
    StylePanelContext.Provider,
    {
      value: {
        styles,
        enhancedA11yMode,
        onHistoryMark,
        onValueChange
      },
      children
    }
  );
}
function useStylePanelContext() {
  const context = (0, import_react103.useContext)(StylePanelContext);
  if (!context) {
    throw new Error("useStylePanelContext must be used within a StylePanelContextProvider");
  }
  return context;
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/StylePanel/StylePanelSubheading.mjs
var import_jsx_runtime159 = __toESM(require_jsx_runtime(), 1);
function StylePanelSubheading({ children }) {
  return (0, import_jsx_runtime159.jsx)("h3", { className: "tlui-style-panel__subheading", children });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/StylePanel/StylePanelButtonPicker.mjs
function StylePanelButtonPickerInner(props) {
  const { enhancedA11yMode } = useStylePanelContext();
  return (0, import_jsx_runtime160.jsxs)(import_jsx_runtime160.Fragment, { children: [
    enhancedA11yMode && (0, import_jsx_runtime160.jsx)(StylePanelSubheading, { children: props.title }),
    (0, import_jsx_runtime160.jsx)(TldrawUiToolbar, { label: props.title, children: (0, import_jsx_runtime160.jsx)(StylePanelButtonPickerInline, { ...props }) })
  ] });
}
function StylePanelButtonPickerInlineInner(props) {
  const ctx = useStylePanelContext();
  const {
    uiType,
    items,
    title,
    style: style2,
    value,
    onValueChange = ctx.onValueChange,
    onHistoryMark = ctx.onHistoryMark
  } = props;
  const theme = useDefaultColorTheme();
  const editor = useEditor();
  const msg2 = useTranslation();
  const breakpoint = useBreakpoint();
  const rPointing = (0, import_react104.useRef)(false);
  const rPointingOriginalActiveElement = (0, import_react104.useRef)(null);
  const {
    handleButtonClick,
    handleButtonPointerDown,
    handleButtonPointerEnter,
    handleButtonPointerUp
  } = (0, import_react104.useMemo)(() => {
    const handlePointerUp = () => {
      rPointing.current = false;
      window.removeEventListener("pointerup", handlePointerUp);
      const origActiveEl = rPointingOriginalActiveElement.current;
      if (origActiveEl && (["TEXTAREA", "INPUT"].includes(origActiveEl.nodeName) || origActiveEl.isContentEditable)) {
        origActiveEl.focus();
      } else if (breakpoint >= PORTRAIT_BREAKPOINT.TABLET_SM) {
        editor.getContainer().focus();
      }
      rPointingOriginalActiveElement.current = null;
    };
    const handleButtonClick2 = (e) => {
      const { id } = e.currentTarget.dataset;
      if (value.type === "shared" && value.value === id) return;
      onHistoryMark == null ? void 0 : onHistoryMark("point picker item");
      onValueChange(style2, id);
    };
    const handleButtonPointerDown2 = (e) => {
      const { id } = e.currentTarget.dataset;
      onHistoryMark == null ? void 0 : onHistoryMark("point picker item");
      onValueChange(style2, id);
      rPointing.current = true;
      rPointingOriginalActiveElement.current = document.activeElement;
      window.addEventListener("pointerup", handlePointerUp);
    };
    const handleButtonPointerEnter2 = (e) => {
      if (!rPointing.current) return;
      const { id } = e.currentTarget.dataset;
      onValueChange(style2, id);
    };
    const handleButtonPointerUp2 = (e) => {
      const { id } = e.currentTarget.dataset;
      if (value.type === "shared" && value.value === id) return;
      onValueChange(style2, id);
    };
    return {
      handleButtonClick: handleButtonClick2,
      handleButtonPointerDown: handleButtonPointerDown2,
      handleButtonPointerEnter: handleButtonPointerEnter2,
      handleButtonPointerUp: handleButtonPointerUp2
    };
  }, [editor, breakpoint, value, onHistoryMark, onValueChange, style2]);
  const Layout2 = items.length > 4 ? TldrawUiGrid : TldrawUiRow;
  return (0, import_jsx_runtime160.jsx)(
    TldrawUiToolbarToggleGroup,
    {
      "data-testid": `style.${uiType}`,
      type: "single",
      value: value.type === "shared" ? value.value : null,
      asChild: true,
      children: (0, import_jsx_runtime160.jsx)(Layout2, { children: items.map((item) => {
        const isActive2 = value.type === "shared" && value.value === item.value;
        const label = title + " — " + msg2(`${uiType}-style.${item.value}`);
        return (0, import_jsx_runtime160.jsx)(
          TldrawUiToolbarToggleItem,
          {
            type: "icon",
            "data-id": item.value,
            "data-testid": `style.${uiType}.${item.value}`,
            "aria-label": label + (isActive2 ? ` (${msg2("style-panel.selected")})` : ""),
            tooltip: (0, import_jsx_runtime160.jsxs)(import_jsx_runtime160.Fragment, { children: [
              (0, import_jsx_runtime160.jsx)("div", { children: label }),
              isActive2 ? (0, import_jsx_runtime160.jsxs)("div", { children: [
                "(",
                msg2("style-panel.selected"),
                ")"
              ] }) : null
            ] }),
            value: item.value,
            "data-state": value.type === "shared" && value.value === item.value ? "on" : "off",
            "data-isactive": isActive2,
            title: label,
            style: style2 === DefaultColorStyle ? { color: getColorValue(theme, item.value, "solid") } : void 0,
            onPointerEnter: handleButtonPointerEnter,
            onPointerDown: handleButtonPointerDown,
            onPointerUp: handleButtonPointerUp,
            onClick: handleButtonClick,
            children: (0, import_jsx_runtime160.jsx)(TldrawUiButtonIcon, { icon: item.icon })
          },
          item.value
        );
      }) })
    }
  );
}
var StylePanelButtonPicker = (0, import_react104.memo)(StylePanelButtonPickerInner);
var StylePanelButtonPickerInline = (0, import_react104.memo)(StylePanelButtonPickerInlineInner);

// ../node_modules/tldraw/dist-esm/lib/ui/components/StylePanel/StylePanelDoubleDropdownPicker.mjs
var import_jsx_runtime161 = __toESM(require_jsx_runtime(), 1);
var React94 = __toESM(require_react(), 1);
function StylePanelDoubleDropdownPickerInner(props) {
  const msg2 = useTranslation();
  return (0, import_jsx_runtime161.jsxs)("div", { className: "tlui-style-panel__double-select-picker", children: [
    (0, import_jsx_runtime161.jsx)("div", { title: msg2(props.label), className: "tlui-style-panel__double-select-picker-label", children: msg2(props.label) }),
    (0, import_jsx_runtime161.jsx)(TldrawUiToolbar, { orientation: "horizontal", label: msg2(props.label), children: (0, import_jsx_runtime161.jsx)(StylePanelDoubleDropdownPickerInline, { ...props }) })
  ] });
}
function StylePanelDoubleDropdownPickerInlineInner(props) {
  const ctx = useStylePanelContext();
  const {
    uiTypeA,
    uiTypeB,
    labelA,
    labelB,
    itemsA,
    itemsB,
    styleA,
    styleB,
    valueA,
    valueB,
    onValueChange = ctx.onValueChange
  } = props;
  const editor = useEditor();
  const msg2 = useTranslation();
  const [isOpenA, setIsOpenA] = React94.useState(false);
  const [isOpenB, setIsOpenB] = React94.useState(false);
  const iconA = React94.useMemo(
    () => {
      var _a6;
      return ((_a6 = itemsA.find((item) => valueA.type === "shared" && valueA.value === item.value)) == null ? void 0 : _a6.icon) ?? "mixed";
    },
    [itemsA, valueA]
  );
  const iconB = React94.useMemo(
    () => {
      var _a6;
      return ((_a6 = itemsB.find((item) => valueB.type === "shared" && valueB.value === item.value)) == null ? void 0 : _a6.icon) ?? "mixed";
    },
    [itemsB, valueB]
  );
  if (valueA === void 0 && valueB === void 0) return null;
  const idA = `style panel ${uiTypeA} A`;
  const idB = `style panel ${uiTypeB} B`;
  return (0, import_jsx_runtime161.jsxs)(import_jsx_runtime161.Fragment, { children: [
    (0, import_jsx_runtime161.jsxs)(TldrawUiPopover, { id: idA, open: isOpenA, onOpenChange: setIsOpenA, children: [
      (0, import_jsx_runtime161.jsx)(TldrawUiPopoverTrigger, { children: (0, import_jsx_runtime161.jsx)(
        TldrawUiToolbarButton,
        {
          type: "icon",
          "data-testid": `style.${uiTypeA}`,
          title: msg2(labelA) + " — " + (valueA === null || valueA.type === "mixed" ? msg2("style-panel.mixed") : msg2(`${uiTypeA}-style.${valueA.value}`)),
          children: (0, import_jsx_runtime161.jsx)(TldrawUiButtonIcon, { icon: iconA, small: true, invertIcon: true })
        }
      ) }),
      (0, import_jsx_runtime161.jsx)(TldrawUiPopoverContent, { side: "left", align: "center", sideOffset: 80, alignOffset: 0, children: (0, import_jsx_runtime161.jsx)(TldrawUiToolbar, { orientation: "grid", label: msg2(labelA), children: (0, import_jsx_runtime161.jsx)(TldrawUiMenuContextProvider, { type: "icons", sourceId: "style-panel", children: itemsA.map((item) => {
        return (0, import_jsx_runtime161.jsx)(
          TldrawUiToolbarButton,
          {
            "data-testid": `style.${uiTypeA}.${item.value}`,
            type: "icon",
            onClick: () => {
              onValueChange(styleA, item.value);
              tlmenus.deleteOpenMenu(idA, editor.contextId);
              setIsOpenA(false);
            },
            title: `${msg2(labelA)} — ${msg2(`${uiTypeA}-style.${item.value}`)}`,
            children: (0, import_jsx_runtime161.jsx)(TldrawUiButtonIcon, { icon: item.icon, invertIcon: true })
          },
          item.value
        );
      }) }) }) })
    ] }),
    (0, import_jsx_runtime161.jsxs)(TldrawUiPopover, { id: idB, open: isOpenB, onOpenChange: setIsOpenB, children: [
      (0, import_jsx_runtime161.jsx)(TldrawUiPopoverTrigger, { children: (0, import_jsx_runtime161.jsx)(
        TldrawUiToolbarButton,
        {
          type: "icon",
          "data-testid": `style.${uiTypeB}`,
          title: msg2(labelB) + " — " + (valueB === null || valueB.type === "mixed" ? msg2("style-panel.mixed") : msg2(`${uiTypeB}-style.${valueB.value}`)),
          children: (0, import_jsx_runtime161.jsx)(TldrawUiButtonIcon, { icon: iconB, small: true })
        }
      ) }),
      (0, import_jsx_runtime161.jsx)(TldrawUiPopoverContent, { side: "left", align: "center", sideOffset: 116, alignOffset: 0, children: (0, import_jsx_runtime161.jsx)(TldrawUiToolbar, { orientation: "grid", label: msg2(labelB), children: (0, import_jsx_runtime161.jsx)(TldrawUiMenuContextProvider, { type: "icons", sourceId: "style-panel", children: itemsB.map((item) => {
        return (0, import_jsx_runtime161.jsx)(
          TldrawUiToolbarButton,
          {
            type: "icon",
            title: `${msg2(labelB)} — ${msg2(`${uiTypeB}-style.${item.value}`)}`,
            "data-testid": `style.${uiTypeB}.${item.value}`,
            onClick: () => {
              onValueChange(styleB, item.value);
              tlmenus.deleteOpenMenu(idB, editor.contextId);
              setIsOpenB(false);
            },
            children: (0, import_jsx_runtime161.jsx)(TldrawUiButtonIcon, { icon: item.icon })
          },
          item.value
        );
      }) }) }) })
    ] })
  ] });
}
var StylePanelDoubleDropdownPicker = React94.memo(StylePanelDoubleDropdownPickerInner);
var StylePanelDoubleDropdownPickerInline = React94.memo(
  StylePanelDoubleDropdownPickerInlineInner
);

// ../node_modules/tldraw/dist-esm/lib/ui/components/StylePanel/StylePanelDropdownPicker.mjs
var import_jsx_runtime162 = __toESM(require_jsx_runtime(), 1);
var React95 = __toESM(require_react(), 1);
function StylePanelDropdownPickerInner(props) {
  const msg2 = useTranslation();
  const toolbarLabel = props.label ? msg2(props.label) : msg2(`style-panel.${props.stylePanelType}`);
  return (0, import_jsx_runtime162.jsx)(TldrawUiToolbar, { label: toolbarLabel, children: (0, import_jsx_runtime162.jsx)(StylePanelDropdownPickerInline, { ...props }) });
}
function StylePanelDropdownPickerInlineInner(props) {
  const ctx = useStylePanelContext();
  const {
    id,
    label,
    uiType,
    stylePanelType,
    style: style2,
    items,
    type,
    value,
    onValueChange = ctx.onValueChange
  } = props;
  const msg2 = useTranslation();
  const editor = useEditor();
  const [isOpen, setIsOpen] = React95.useState(false);
  const icon = React95.useMemo(
    () => {
      var _a6;
      return (_a6 = items.find((item) => value.type === "shared" && item.value === value.value)) == null ? void 0 : _a6.icon;
    },
    [items, value]
  );
  const stylePanelName = msg2(`style-panel.${stylePanelType}`);
  const titleStr = value.type === "mixed" ? msg2("style-panel.mixed") : stylePanelName + " — " + msg2(`${uiType}-style.${value.value}`);
  const labelStr = label ? msg2(label) : "";
  const popoverId = `style panel ${id}`;
  return (0, import_jsx_runtime162.jsxs)(
    TldrawUiPopover,
    {
      id: popoverId,
      open: isOpen,
      onOpenChange: setIsOpen,
      className: "tlui-style-panel__dropdown-picker",
      children: [
        (0, import_jsx_runtime162.jsx)(TldrawUiPopoverTrigger, { children: (0, import_jsx_runtime162.jsxs)(
          TldrawUiToolbarButton,
          {
            type,
            "data-testid": `style.${uiType}`,
            "data-direction": "left",
            title: titleStr,
            children: [
              labelStr && (0, import_jsx_runtime162.jsx)(TldrawUiButtonLabel, { children: labelStr }),
              (0, import_jsx_runtime162.jsx)(TldrawUiButtonIcon, { icon: icon ?? "mixed" })
            ]
          }
        ) }),
        (0, import_jsx_runtime162.jsx)(TldrawUiPopoverContent, { side: "left", align: "center", children: (0, import_jsx_runtime162.jsx)(TldrawUiToolbar, { orientation: items.length > 4 ? "grid" : "horizontal", label: labelStr, children: (0, import_jsx_runtime162.jsx)(TldrawUiMenuContextProvider, { type: "icons", sourceId: "style-panel", children: items.map((item) => {
          return (0, import_jsx_runtime162.jsx)(
            TldrawUiToolbarButton,
            {
              type: "icon",
              "data-testid": `style.${uiType}.${item.value}`,
              title: stylePanelName + " — " + msg2(`${uiType}-style.${item.value}`),
              isActive: icon === item.icon,
              onClick: () => {
                ctx.onHistoryMark("select style dropdown item");
                onValueChange(style2, item.value);
                tlmenus.deleteOpenMenu(popoverId, editor.contextId);
                setIsOpen(false);
              },
              children: (0, import_jsx_runtime162.jsx)(TldrawUiButtonIcon, { icon: item.icon })
            },
            item.value
          );
        }) }) }) })
      ]
    }
  );
}
var StylePanelDropdownPicker = React95.memo(StylePanelDropdownPickerInner);
var StylePanelDropdownPickerInline = React95.memo(StylePanelDropdownPickerInlineInner);

// ../node_modules/tldraw/dist-esm/lib/ui/components/StylePanel/DefaultStylePanelContent.mjs
function DefaultStylePanelContent() {
  return (0, import_jsx_runtime163.jsxs)(import_jsx_runtime163.Fragment, { children: [
    (0, import_jsx_runtime163.jsxs)(StylePanelSection, { children: [
      (0, import_jsx_runtime163.jsx)(StylePanelColorPicker, {}),
      (0, import_jsx_runtime163.jsx)(StylePanelOpacityPicker, {})
    ] }),
    (0, import_jsx_runtime163.jsxs)(StylePanelSection, { children: [
      (0, import_jsx_runtime163.jsx)(StylePanelFillPicker, {}),
      (0, import_jsx_runtime163.jsx)(StylePanelDashPicker, {}),
      (0, import_jsx_runtime163.jsx)(StylePanelSizePicker, {})
    ] }),
    (0, import_jsx_runtime163.jsxs)(StylePanelSection, { children: [
      (0, import_jsx_runtime163.jsx)(StylePanelFontPicker, {}),
      (0, import_jsx_runtime163.jsx)(StylePanelTextAlignPicker, {}),
      (0, import_jsx_runtime163.jsx)(StylePanelLabelAlignPicker, {})
    ] }),
    (0, import_jsx_runtime163.jsxs)(StylePanelSection, { children: [
      (0, import_jsx_runtime163.jsx)(StylePanelGeoShapePicker, {}),
      (0, import_jsx_runtime163.jsx)(StylePanelArrowKindPicker, {}),
      (0, import_jsx_runtime163.jsx)(StylePanelArrowheadPicker, {}),
      (0, import_jsx_runtime163.jsx)(StylePanelSplinePicker, {})
    ] })
  ] });
}
function StylePanelSection({ children }) {
  return (0, import_jsx_runtime163.jsx)("div", { className: "tlui-style-panel__section", children });
}
function StylePanelColorPicker() {
  const { styles } = useStylePanelContext();
  const msg2 = useTranslation();
  const color = styles.get(DefaultColorStyle);
  if (color === void 0) return null;
  return (0, import_jsx_runtime163.jsx)(
    StylePanelButtonPicker,
    {
      title: msg2("style-panel.color"),
      uiType: "color",
      style: DefaultColorStyle,
      items: STYLES.color,
      value: color
    }
  );
}
var tldrawSupportedOpacities = [0.1, 0.25, 0.5, 0.75, 1];
function StylePanelOpacityPicker() {
  const editor = useEditor();
  const { onHistoryMark, enhancedA11yMode } = useStylePanelContext();
  const opacity = useValue("opacity", () => editor.getSharedOpacity(), [editor]);
  const trackEvent = useUiEvents();
  const msg2 = useTranslation();
  const handleOpacityValueChange = import_react105.default.useCallback(
    (value) => {
      const item = tldrawSupportedOpacities[value];
      editor.run(() => {
        if (editor.isIn("select")) {
          editor.setOpacityForSelectedShapes(item);
        }
        editor.setOpacityForNextShapes(item);
        editor.updateInstanceState({ isChangingStyle: true });
      });
      trackEvent("set-style", { source: "style-panel", id: "opacity", value });
    },
    [editor, trackEvent]
  );
  if (opacity === void 0) return null;
  const opacityIndex = opacity.type === "mixed" ? -1 : tldrawSupportedOpacities.indexOf(
    minBy(
      tldrawSupportedOpacities,
      (supportedOpacity) => Math.abs(supportedOpacity - opacity.value)
    )
  );
  return (0, import_jsx_runtime163.jsxs)(import_jsx_runtime163.Fragment, { children: [
    enhancedA11yMode && (0, import_jsx_runtime163.jsx)(StylePanelSubheading, { children: msg2("style-panel.opacity") }),
    (0, import_jsx_runtime163.jsx)(
      TldrawUiSlider,
      {
        "data-testid": "style.opacity",
        value: opacityIndex >= 0 ? opacityIndex : tldrawSupportedOpacities.length - 1,
        label: opacity.type === "mixed" ? "style-panel.mixed" : `opacity-style.${opacity.value}`,
        onValueChange: handleOpacityValueChange,
        steps: tldrawSupportedOpacities.length - 1,
        title: msg2("style-panel.opacity"),
        onHistoryMark,
        ariaValueModifier: 25
      }
    )
  ] });
}
function StylePanelFillPicker() {
  const { styles } = useStylePanelContext();
  const msg2 = useTranslation();
  const fill = styles.get(DefaultFillStyle);
  if (fill === void 0) return null;
  return (0, import_jsx_runtime163.jsx)(
    StylePanelButtonPicker,
    {
      title: msg2("style-panel.fill"),
      uiType: "fill",
      style: DefaultFillStyle,
      items: STYLES.fill,
      value: fill
    }
  );
}
function StylePanelDashPicker() {
  const { styles } = useStylePanelContext();
  const msg2 = useTranslation();
  const dash = styles.get(DefaultDashStyle);
  if (dash === void 0) return null;
  return (0, import_jsx_runtime163.jsx)(
    StylePanelButtonPicker,
    {
      title: msg2("style-panel.dash"),
      uiType: "dash",
      style: DefaultDashStyle,
      items: STYLES.dash,
      value: dash
    }
  );
}
function StylePanelSizePicker() {
  const editor = useEditor();
  const { styles, onValueChange } = useStylePanelContext();
  const msg2 = useTranslation();
  const size4 = styles.get(DefaultSizeStyle);
  if (size4 === void 0) return null;
  return (0, import_jsx_runtime163.jsx)(
    StylePanelButtonPicker,
    {
      title: msg2("style-panel.size"),
      uiType: "size",
      style: DefaultSizeStyle,
      items: STYLES.size,
      value: size4,
      onValueChange: (style2, value) => {
        onValueChange(style2, value);
        const selectedShapeIds = editor.getSelectedShapeIds();
        if (selectedShapeIds.length > 0) {
          kickoutOccludedShapes(editor, selectedShapeIds);
        }
      }
    }
  );
}
function StylePanelFontPicker() {
  const { styles } = useStylePanelContext();
  const msg2 = useTranslation();
  const font = styles.get(DefaultFontStyle);
  if (font === void 0) return null;
  return (0, import_jsx_runtime163.jsx)(
    StylePanelButtonPicker,
    {
      title: msg2("style-panel.font"),
      uiType: "font",
      style: DefaultFontStyle,
      items: STYLES.font,
      value: font
    }
  );
}
function StylePanelTextAlignPicker() {
  const { styles, enhancedA11yMode } = useStylePanelContext();
  const msg2 = useTranslation();
  const textAlign = styles.get(DefaultTextAlignStyle);
  if (textAlign === void 0) return null;
  const title = msg2("style-panel.align");
  return (0, import_jsx_runtime163.jsxs)(import_jsx_runtime163.Fragment, { children: [
    enhancedA11yMode && (0, import_jsx_runtime163.jsx)(StylePanelSubheading, { children: title }),
    (0, import_jsx_runtime163.jsxs)(TldrawUiToolbar, { orientation: "horizontal", label: title, children: [
      (0, import_jsx_runtime163.jsx)(
        StylePanelButtonPickerInline,
        {
          title,
          uiType: "align",
          style: DefaultTextAlignStyle,
          items: STYLES.textAlign,
          value: textAlign
        }
      ),
      (0, import_jsx_runtime163.jsx)(
        TldrawUiToolbarButton,
        {
          type: "icon",
          title: msg2("style-panel.vertical-align"),
          "data-testid": "vertical-align",
          disabled: true,
          children: (0, import_jsx_runtime163.jsx)(TldrawUiButtonIcon, { icon: "vertical-align-middle" })
        }
      )
    ] })
  ] });
}
function StylePanelLabelAlignPicker() {
  const { styles, enhancedA11yMode } = useStylePanelContext();
  const msg2 = useTranslation();
  const labelAlign = styles.get(DefaultHorizontalAlignStyle);
  const verticalLabelAlign = styles.get(DefaultVerticalAlignStyle);
  if (labelAlign === void 0) return null;
  const title = msg2("style-panel.label-align");
  return (0, import_jsx_runtime163.jsxs)(import_jsx_runtime163.Fragment, { children: [
    enhancedA11yMode && (0, import_jsx_runtime163.jsx)(StylePanelSubheading, { children: title }),
    (0, import_jsx_runtime163.jsxs)(TldrawUiToolbar, { orientation: "horizontal", label: title, children: [
      (0, import_jsx_runtime163.jsx)(
        StylePanelButtonPickerInline,
        {
          title,
          uiType: "align",
          style: DefaultHorizontalAlignStyle,
          items: STYLES.horizontalAlign,
          value: labelAlign
        }
      ),
      verticalLabelAlign === void 0 ? (0, import_jsx_runtime163.jsx)(
        TldrawUiToolbarButton,
        {
          type: "icon",
          title: msg2("style-panel.vertical-align"),
          "data-testid": "vertical-align",
          disabled: true,
          children: (0, import_jsx_runtime163.jsx)(TldrawUiButtonIcon, { icon: "vertical-align-middle" })
        }
      ) : (0, import_jsx_runtime163.jsx)(
        StylePanelDropdownPickerInline,
        {
          type: "icon",
          id: "geo-vertical-alignment",
          uiType: "verticalAlign",
          stylePanelType: "vertical-align",
          style: DefaultVerticalAlignStyle,
          items: STYLES.verticalAlign,
          value: verticalLabelAlign
        }
      )
    ] })
  ] });
}
function StylePanelGeoShapePicker() {
  const { styles } = useStylePanelContext();
  const geo = styles.get(GeoShapeGeoStyle);
  if (geo === void 0) return null;
  return (0, import_jsx_runtime163.jsx)(
    StylePanelDropdownPicker,
    {
      label: "style-panel.geo",
      type: "menu",
      id: "geo",
      uiType: "geo",
      stylePanelType: "geo",
      style: GeoShapeGeoStyle,
      items: STYLES.geo,
      value: geo
    }
  );
}
function StylePanelArrowKindPicker() {
  const { styles } = useStylePanelContext();
  const arrowKind = styles.get(ArrowShapeKindStyle);
  if (arrowKind === void 0) return null;
  return (0, import_jsx_runtime163.jsx)(
    StylePanelDropdownPicker,
    {
      id: "arrow-kind",
      type: "menu",
      label: "style-panel.arrow-kind",
      uiType: "arrow-kind",
      stylePanelType: "arrow-kind",
      style: ArrowShapeKindStyle,
      items: STYLES.arrowKind,
      value: arrowKind
    }
  );
}
function StylePanelArrowheadPicker() {
  const { styles } = useStylePanelContext();
  const arrowheadEnd = styles.get(ArrowShapeArrowheadEndStyle);
  const arrowheadStart = styles.get(ArrowShapeArrowheadStartStyle);
  if (arrowheadEnd === void 0 || arrowheadStart === void 0) return null;
  return (0, import_jsx_runtime163.jsx)(
    StylePanelDoubleDropdownPicker,
    {
      label: "style-panel.arrowheads",
      uiTypeA: "arrowheadStart",
      styleA: ArrowShapeArrowheadStartStyle,
      itemsA: STYLES.arrowheadStart,
      valueA: arrowheadStart,
      uiTypeB: "arrowheadEnd",
      styleB: ArrowShapeArrowheadEndStyle,
      itemsB: STYLES.arrowheadEnd,
      valueB: arrowheadEnd,
      labelA: "style-panel.arrowhead-start",
      labelB: "style-panel.arrowhead-end"
    }
  );
}
function StylePanelSplinePicker() {
  const { styles } = useStylePanelContext();
  const spline = styles.get(LineShapeSplineStyle);
  if (spline === void 0) return null;
  return (0, import_jsx_runtime163.jsx)(
    StylePanelDropdownPicker,
    {
      type: "menu",
      id: "spline",
      uiType: "spline",
      stylePanelType: "spline",
      label: "style-panel.spline",
      style: LineShapeSplineStyle,
      items: STYLES.spline,
      value: spline
    }
  );
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/StylePanel/DefaultStylePanel.mjs
var DefaultStylePanel = (0, import_react106.memo)(function DefaultStylePanel2({
  isMobile,
  styles,
  children
}) {
  const editor = useEditor();
  const enhancedA11yMode = useValue("enhancedA11yMode", () => editor.user.getEnhancedA11yMode(), [
    editor
  ]);
  const ref = (0, import_react106.useRef)(null);
  usePassThroughWheelEvents(ref);
  const handlePointerOut = (0, import_react106.useCallback)(() => {
    if (!isMobile) {
      editor.updateInstanceState({ isChangingStyle: false });
    }
  }, [editor, isMobile]);
  const defaultStyles = useRelevantStyles();
  if (styles === void 0) {
    styles = defaultStyles;
  }
  (0, import_react106.useEffect)(() => {
    function handleKeyDown2(event) {
      var _a6;
      if (event.key === "Escape" && ((_a6 = ref.current) == null ? void 0 : _a6.contains(document.activeElement))) {
        event.stopPropagation();
        editor.getContainer().focus();
      }
    }
    const stylePanelContainerEl = ref.current;
    stylePanelContainerEl == null ? void 0 : stylePanelContainerEl.addEventListener("keydown", handleKeyDown2, { capture: true });
    return () => {
      stylePanelContainerEl == null ? void 0 : stylePanelContainerEl.removeEventListener("keydown", handleKeyDown2, { capture: true });
    };
  }, [editor]);
  return styles && (0, import_jsx_runtime164.jsx)(
    "div",
    {
      ref,
      "data-testid": "style.panel",
      className: (0, import_classnames25.default)("tlui-style-panel", { "tlui-style-panel__wrapper": !isMobile }),
      "data-ismobile": isMobile,
      "data-enhanced-a11y-mode": enhancedA11yMode,
      onPointerLeave: handlePointerOut,
      children: (0, import_jsx_runtime164.jsx)(StylePanelContextProvider, { styles, children: children ?? (0, import_jsx_runtime164.jsx)(DefaultStylePanelContent, {}) })
    }
  );
});

// ../node_modules/tldraw/dist-esm/lib/ui/components/Toasts.mjs
var import_jsx_runtime165 = __toESM(require_jsx_runtime(), 1);
var import_react107 = __toESM(require_react(), 1);
var DEFAULT_TOAST_DURATION = 4e3;
var SEVERITY_TO_ICON = {
  success: "check-circle",
  warning: "warning-triangle",
  error: "cross-circle",
  info: "info-circle"
};
function TldrawUiToast({ toast }) {
  const { removeToast } = useToasts();
  const msg2 = useTranslation();
  const onOpenChange = (isOpen) => {
    if (!isOpen) {
      removeToast(toast.id);
    }
  };
  const hasActions = toast.actions && toast.actions.length > 0;
  const icon = toast.icon || toast.severity && SEVERITY_TO_ICON[toast.severity];
  const iconLabel = toast.iconLabel || (toast.severity ? msg2(`toast.${toast.severity}`) : "");
  return (0, import_jsx_runtime165.jsxs)(
    dist_exports14.Root,
    {
      onOpenChange,
      className: "tlui-toast__container",
      duration: toast.keepOpen ? Infinity : DEFAULT_TOAST_DURATION,
      "data-severity": toast.severity,
      children: [
        icon && (0, import_jsx_runtime165.jsx)("div", { className: "tlui-toast__icon", children: (0, import_jsx_runtime165.jsx)(TldrawUiIcon, { label: iconLabel, icon }) }),
        (0, import_jsx_runtime165.jsxs)(
          "div",
          {
            className: "tlui-toast__main",
            "data-title": !!toast.title,
            "data-description": !!toast.description,
            "data-actions": !!toast.actions,
            children: [
              (0, import_jsx_runtime165.jsxs)("div", { className: "tlui-toast__content", children: [
                toast.title && (0, import_jsx_runtime165.jsx)(dist_exports14.Title, { className: "tlui-toast__title", children: toast.title }),
                toast.description && (0, import_jsx_runtime165.jsx)(dist_exports14.Description, { className: "tlui-toast__description", children: toast.description })
              ] }),
              toast.actions && (0, import_jsx_runtime165.jsxs)("div", { className: "tlui-toast__actions", children: [
                toast.actions.map((action, i) => (0, import_jsx_runtime165.jsx)(dist_exports14.Action, { altText: action.label, asChild: true, onClick: action.onClick, children: (0, import_jsx_runtime165.jsx)(TldrawUiButton, { type: action.type, children: (0, import_jsx_runtime165.jsx)(TldrawUiButtonLabel, { children: action.label }) }) }, i)),
                (0, import_jsx_runtime165.jsx)(dist_exports14.Close, { asChild: true, children: (0, import_jsx_runtime165.jsx)(
                  TldrawUiButton,
                  {
                    type: "normal",
                    className: "tlui-toast__close",
                    style: { marginLeft: "auto" },
                    children: (0, import_jsx_runtime165.jsx)(TldrawUiButtonLabel, { children: toast.closeLabel ?? msg2("toast.close") })
                  }
                ) })
              ] })
            ]
          }
        ),
        !hasActions && (0, import_jsx_runtime165.jsx)(dist_exports14.Close, { asChild: true, children: (0, import_jsx_runtime165.jsx)(TldrawUiButton, { type: "normal", className: "tlui-toast__close", children: (0, import_jsx_runtime165.jsx)(TldrawUiButtonLabel, { children: toast.closeLabel ?? msg2("toast.close") }) }) })
      ]
    }
  );
}
var DefaultToasts = (0, import_react107.memo)(function TldrawUiToasts() {
  const { toasts } = useToasts();
  const toastsArray = useValue("toasts", () => toasts.get(), []);
  return (0, import_jsx_runtime165.jsxs)(import_jsx_runtime165.Fragment, { children: [
    toastsArray.map((toast) => (0, import_jsx_runtime165.jsx)(TldrawUiToast, { toast }, toast.id)),
    (0, import_jsx_runtime165.jsx)(dist_exports14.ToastViewport, { className: "tlui-toast__viewport" })
  ] });
});

// ../node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/DefaultImageToolbar.mjs
var import_jsx_runtime169 = __toESM(require_jsx_runtime(), 1);
var import_react111 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/components/primitives/TldrawUiContextualToolbar.mjs
var import_jsx_runtime166 = __toESM(require_jsx_runtime(), 1);
var import_classnames26 = __toESM(require_classnames(), 1);
var import_react108 = __toESM(require_react(), 1);
var import_react_dom8 = __toESM(require_react_dom(), 1);
var MOVE_TIMEOUT = 150;
var HIDE_VISIBILITY_TIMEOUT = 16;
var SHOW_VISIBILITY_TIMEOUT = 16;
var MIN_DISTANCE_TO_REPOSITION_SQUARED = 16 ** 2;
var TOOLBAR_GAP = 8;
var SCREEN_MARGIN = 16;
var HIDE_TOOLBAR_WHEN_CAMERA_IS_MOVING = false;
var LEFT_ALIGN_TOOLBAR = false;
var TldrawUiContextualToolbar = ({
  children,
  className,
  isMousingDown,
  getSelectionBounds,
  changeOnlyWhenYChanges = false,
  label
}) => {
  const editor = useEditor();
  const toolbarRef = (0, import_react108.useRef)(null);
  usePassThroughWheelEvents(toolbarRef);
  usePassThroughMouseOverEvents(toolbarRef);
  const { isVisible, isInteractive, hide: hide4, show, position, move } = useToolbarVisibilityStateMachine(changeOnlyWhenYChanges);
  const rCouldShowToolbar = (0, import_react108.useRef)(false);
  const [hasValidToolbarPosition, setHasValidToolbarPosition] = (0, import_react108.useState)(false);
  const contentSizeUpdateCounter = useAtom("content size update counter", 0);
  (0, import_react108.useEffect)(() => {
    assert(toolbarRef.current);
    const observer = new ResizeObserver(() => {
      contentSizeUpdateCounter.update((n) => n + 1);
    });
    observer.observe(toolbarRef.current);
    return () => observer.disconnect();
  }, [contentSizeUpdateCounter]);
  (0, import_react108.useEffect)(() => {
    let lastContentSizeUpdateCounter = contentSizeUpdateCounter.get();
    return react("toolbar position", function updateToolbarPositionAndDisplay() {
      const toolbarElm = toolbarRef.current;
      if (!toolbarElm) return;
      const nextContentSizeUpdateCounter = contentSizeUpdateCounter.get();
      editor.getCamera();
      contentSizeUpdateCounter.get();
      const position2 = getToolbarScreenPosition(editor, toolbarElm, getSelectionBounds);
      if (!position2) {
        if (rCouldShowToolbar.current) {
          rCouldShowToolbar.current = false;
          setHasValidToolbarPosition(false);
        }
      } else {
        const cameraState2 = editor.getCameraState();
        if (cameraState2 === "moving") {
          const elm = toolbarRef.current;
          if (elm) {
            elm.style.setProperty("transform", `translate(${position2.x}px, ${position2.y}px)`);
          }
        } else {
          const moveImmediately = lastContentSizeUpdateCounter !== nextContentSizeUpdateCounter;
          move(position2.x, position2.y, moveImmediately);
        }
        if (!rCouldShowToolbar.current) {
          rCouldShowToolbar.current = true;
          setHasValidToolbarPosition(true);
        }
      }
      lastContentSizeUpdateCounter = nextContentSizeUpdateCounter;
    });
  }, [editor, getSelectionBounds, contentSizeUpdateCounter, move]);
  const cameraState = useValue("camera state", () => editor.getCameraState(), [editor]);
  (0, import_react108.useEffect)(() => {
    if (cameraState === "moving" && HIDE_TOOLBAR_WHEN_CAMERA_IS_MOVING) {
      hide4(true);
      return;
    }
    if (isMousingDown || !hasValidToolbarPosition) {
      hide4();
      return;
    }
    show();
  }, [hasValidToolbarPosition, cameraState, isMousingDown, show, hide4]);
  (0, import_react108.useLayoutEffect)(() => {
    const elm = toolbarRef.current;
    if (!elm) return;
    elm.dataset.visible = `${isVisible}`;
  }, [isVisible, position]);
  (0, import_react108.useLayoutEffect)(() => {
    const elm = toolbarRef.current;
    if (!elm) return;
    elm.style.setProperty("transform", `translate(${position.x}px, ${position.y}px)`);
  }, [position]);
  (0, import_react108.useLayoutEffect)(() => {
    const elm = toolbarRef.current;
    if (!elm) return;
    elm.dataset.interactive = `${isInteractive}`;
  }, [isInteractive]);
  return (0, import_jsx_runtime166.jsx)(
    "div",
    {
      ref: toolbarRef,
      "data-interactive": false,
      "data-visible": false,
      "data-testid": "contextual-toolbar",
      className: (0, import_classnames26.default)("tlui-contextual-toolbar", className),
      onPointerDown: editor.markEventAsHandled,
      children: (0, import_jsx_runtime166.jsx)(
        TldrawUiToolbar,
        {
          orientation: "horizontal",
          className: "tlui-menu",
          label,
          tooltipSide: "top",
          children
        }
      )
    }
  );
};
function rectToBox(rect) {
  return new Box(rect.x, rect.y, rect.width, rect.height);
}
function getToolbarScreenPosition(editor, toolbarElm, getSelectionBounds) {
  var _a6;
  const selectionBounds = (_a6 = getSelectionBounds()) == null ? void 0 : _a6.clone();
  if (!selectionBounds) return;
  const vsb = editor.getViewportScreenBounds();
  selectionBounds.x -= vsb.x;
  selectionBounds.y -= vsb.y;
  if (selectionBounds.midY < SCREEN_MARGIN || selectionBounds.midY > vsb.h - SCREEN_MARGIN || selectionBounds.midX < SCREEN_MARGIN || selectionBounds.midX > vsb.w - SCREEN_MARGIN) {
    return;
  }
  const toolbarBounds = rectToBox(toolbarElm.getBoundingClientRect());
  if (!toolbarBounds.width || !toolbarBounds.height) return;
  const { scrollLeft, scrollTop } = editor.getContainer();
  let x = LEFT_ALIGN_TOOLBAR ? selectionBounds.x : selectionBounds.midX - toolbarBounds.w / 2;
  let y = selectionBounds.y - toolbarBounds.h - TOOLBAR_GAP;
  x = clamp(x, SCREEN_MARGIN, vsb.w - toolbarBounds.w - SCREEN_MARGIN);
  y = clamp(y, SCREEN_MARGIN, vsb.h - toolbarBounds.h - SCREEN_MARGIN);
  x += scrollLeft;
  y += scrollTop;
  x = Math.round(x);
  y = Math.round(y);
  return { x, y };
}
function sufficientlyDistant(curr, next, changeOnlyWhenYChanges) {
  if (changeOnlyWhenYChanges) {
    return Vec.Sub(next, curr).y ** 2 >= MIN_DISTANCE_TO_REPOSITION_SQUARED;
  }
  return Vec.Len2(Vec.Sub(next, curr)) >= MIN_DISTANCE_TO_REPOSITION_SQUARED;
}
function useToolbarVisibilityStateMachine(changeOnlyWhenYChanges) {
  const editor = useEditor();
  const rState = (0, import_react108.useRef)({ name: "hidden" });
  const [isInteractive, setIsInteractive] = (0, import_react108.useState)(false);
  const [isVisible, setIsVisible] = (0, import_react108.useState)(false);
  const [position, setPosition] = (0, import_react108.useState)({ x: -1e3, y: -1e3 });
  const rCurrPosition = (0, import_react108.useRef)(new Vec(-1e3, -1e3));
  const rNextPosition = (0, import_react108.useRef)(new Vec(-1e3, -1e3));
  const rStableVisibilityTimeout = (0, import_react108.useRef)(-1);
  const rStablePositionTimeout = (0, import_react108.useRef)(-1);
  const move = (0, import_react108.useCallback)(
    (x, y, immediate = false) => {
      rNextPosition.current.x = x;
      rNextPosition.current.y = y;
      if (rState.current.name === "hidden" || rState.current.name === "showing") return;
      clearTimeout(rStablePositionTimeout.current);
      const flushMove = () => {
        if (rState.current.name === "shown" && sufficientlyDistant(rNextPosition.current, rCurrPosition.current, changeOnlyWhenYChanges)) {
          const { x: x2, y: y2 } = rNextPosition.current;
          rCurrPosition.current = new Vec(x2, y2);
          if (immediate) {
            (0, import_react_dom8.flushSync)(() => setPosition({ x: x2, y: y2 }));
          } else {
            setPosition({ x: x2, y: y2 });
          }
        }
      };
      if (immediate) {
        flushMove();
      } else {
        rStablePositionTimeout.current = editor.timers.setTimeout(flushMove, MOVE_TIMEOUT);
      }
    },
    [editor, changeOnlyWhenYChanges]
  );
  const hide4 = (0, import_react108.useCallback)(
    (immediate = false) => {
      switch (rState.current.name) {
        case "showing": {
          clearTimeout(rStableVisibilityTimeout.current);
          rState.current = { name: "hidden" };
          break;
        }
        case "shown": {
          rState.current = { name: "hiding" };
          setIsInteractive(false);
          if (immediate) {
            rState.current = { name: "hidden" };
            setIsVisible(false);
          } else {
            rStableVisibilityTimeout.current = editor.timers.setTimeout(() => {
              rState.current = { name: "hidden" };
              setIsVisible(false);
            }, HIDE_VISIBILITY_TIMEOUT);
          }
          break;
        }
        default: {
        }
      }
    },
    [editor]
  );
  const show = (0, import_react108.useCallback)(() => {
    switch (rState.current.name) {
      case "hidden": {
        rState.current = { name: "showing" };
        rStableVisibilityTimeout.current = editor.timers.setTimeout(() => {
          const { x, y } = rNextPosition.current;
          rCurrPosition.current = new Vec(x, y);
          setPosition({ x, y });
          rState.current = { name: "shown" };
          setIsVisible(true);
          setIsInteractive(true);
        }, SHOW_VISIBILITY_TIMEOUT);
        break;
      }
      case "hiding": {
        clearTimeout(rStableVisibilityTimeout.current);
        rState.current = { name: "shown" };
        setIsInteractive(true);
        move(rNextPosition.current.x, rNextPosition.current.y);
        break;
      }
      default: {
      }
    }
  }, [editor, move]);
  return { isVisible, isInteractive, show, hide: hide4, move, position };
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/AltTextEditor.mjs
var import_jsx_runtime167 = __toESM(require_jsx_runtime(), 1);
var import_react109 = __toESM(require_react(), 1);
function AltTextEditor({ shapeId, onClose, source }) {
  const editor = useEditor();
  const [altText, setAltText] = (0, import_react109.useState)(() => {
    const shape = editor.getShape(shapeId);
    if (!shape) return "";
    if (!("altText" in shape.props)) throw Error("Shape does not have altText property");
    return shape.props.altText || "";
  });
  const msg2 = useTranslation();
  const ref = (0, import_react109.useRef)(null);
  const trackEvent = useUiEvents();
  const isReadonly = editor.getIsReadonly();
  const handleValueChange = (value) => setAltText(value);
  const handleComplete = () => {
    trackEvent("set-alt-text", { source });
    const shape = editor.getShape(shapeId);
    if (!shape) return;
    editor.updateShapes([
      {
        id: shape.id,
        type: shape.type,
        props: { altText }
      }
    ]);
    onClose();
  };
  const handleConfirm = () => handleComplete();
  const handleAltTextCancel = (0, import_react109.useCallback)(() => onClose(), [onClose]);
  (0, import_react109.useEffect)(() => {
    var _a6;
    (_a6 = ref.current) == null ? void 0 : _a6.select();
    function handleKeyDown2(event) {
      if (event.key === "Escape") {
        event.stopPropagation();
        handleAltTextCancel();
      }
    }
    document.addEventListener("keydown", handleKeyDown2, { capture: true });
    return () => {
      document.removeEventListener("keydown", handleKeyDown2, { capture: true });
    };
  }, [handleAltTextCancel]);
  return (0, import_jsx_runtime167.jsxs)(import_jsx_runtime167.Fragment, { children: [
    (0, import_jsx_runtime167.jsx)(
      TldrawUiInput,
      {
        ref,
        className: "tlui-media__toolbar-alt-text-input",
        "data-testid": "media-toolbar.alt-text-input",
        value: altText,
        placeholder: msg2("tool.media-alt-text-desc"),
        "aria-label": msg2("tool.media-alt-text-desc"),
        onValueChange: handleValueChange,
        onComplete: handleComplete,
        onCancel: handleAltTextCancel,
        disabled: isReadonly
      }
    ),
    !isReadonly && (0, import_jsx_runtime167.jsx)(
      TldrawUiButton,
      {
        title: msg2("tool.media-alt-text-confirm"),
        "data-testid": "tool.media-alt-text-confirm",
        type: "icon",
        onPointerDown: preventDefault,
        onClick: handleConfirm,
        children: (0, import_jsx_runtime167.jsx)(TldrawUiButtonIcon, { small: true, icon: "check" })
      }
    )
  ] });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/DefaultImageToolbarContent.mjs
var import_jsx_runtime168 = __toESM(require_jsx_runtime(), 1);
var import_react110 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/shapes/shared/crop.mjs
var MIN_CROP_SIZE = 8;
function getDefaultCrop() {
  return {
    topLeft: { x: 0, y: 0 },
    bottomRight: { x: 1, y: 1 }
  };
}
var ASPECT_RATIO_OPTIONS = [
  "original",
  "square",
  "circle",
  "landscape",
  "portrait",
  "wide"
];
var ASPECT_RATIO_TO_VALUE = {
  original: 0,
  square: 1,
  circle: 1,
  landscape: 4 / 3,
  portrait: 3 / 4,
  wide: 16 / 9
};
function getUncroppedSize(shapeSize, crop) {
  if (!crop) return { w: shapeSize.w, h: shapeSize.h };
  const w = shapeSize.w / (crop.bottomRight.x - crop.topLeft.x);
  const h2 = shapeSize.h / (crop.bottomRight.y - crop.topLeft.y);
  return { w, h: h2 };
}
function getCropDimensions(crop) {
  return {
    width: crop.bottomRight.x - crop.topLeft.x,
    height: crop.bottomRight.y - crop.topLeft.y
  };
}
function getCropCenter(crop) {
  const { width, height } = getCropDimensions(crop);
  return {
    x: crop.topLeft.x + width / 2,
    y: crop.topLeft.y + height / 2
  };
}
function createCropAroundCenter(centerX, centerY, width, height, isCircle) {
  const topLeftX = Math.max(0, Math.min(1 - width, centerX - width / 2));
  const topLeftY = Math.max(0, Math.min(1 - height, centerY - height / 2));
  return {
    topLeft: { x: topLeftX, y: topLeftY },
    bottomRight: { x: topLeftX + width, y: topLeftY + height },
    isCircle
  };
}
function getCropBox(shape, info, opts = {}) {
  const { handle, change, crop, aspectRatioLocked } = info;
  const { w, h: h2 } = info.uncroppedSize;
  const { minWidth = MIN_CROP_SIZE, minHeight = MIN_CROP_SIZE } = opts;
  if (w < minWidth || h2 < minHeight || change.x === 0 && change.y === 0) {
    return;
  }
  const prevCropBox = new Box(
    crop.topLeft.x * w,
    crop.topLeft.y * h2,
    (crop.bottomRight.x - crop.topLeft.x) * w,
    (crop.bottomRight.y - crop.topLeft.y) * h2
  );
  const targetRatio = prevCropBox.aspectRatio;
  const tempBox = prevCropBox.clone();
  if (handle === "top_left" || handle === "bottom_left" || handle === "left") {
    tempBox.x = clamp(tempBox.x + change.x, 0, prevCropBox.maxX - minWidth);
    tempBox.w = prevCropBox.maxX - tempBox.x;
  } else if (handle === "top_right" || handle === "bottom_right" || handle === "right") {
    const tempRight = clamp(tempBox.maxX + change.x, prevCropBox.x + minWidth, w);
    tempBox.w = tempRight - tempBox.x;
  }
  if (handle === "top_left" || handle === "top_right" || handle === "top") {
    tempBox.y = clamp(tempBox.y + change.y, 0, prevCropBox.maxY - minHeight);
    tempBox.h = prevCropBox.maxY - tempBox.y;
  } else if (handle === "bottom_left" || handle === "bottom_right" || handle === "bottom") {
    const tempBottom = clamp(tempBox.maxY + change.y, prevCropBox.y + minHeight, h2);
    tempBox.h = tempBottom - tempBox.y;
  }
  if (aspectRatioLocked) {
    const isXLimiting = tempBox.aspectRatio > targetRatio;
    if (isXLimiting) {
      tempBox.h = tempBox.w / targetRatio;
    } else {
      tempBox.w = tempBox.h * targetRatio;
    }
    switch (handle) {
      case "top_left": {
        tempBox.x = prevCropBox.maxX - tempBox.w;
        tempBox.y = prevCropBox.maxY - tempBox.h;
        if (tempBox.x <= 0) {
          tempBox.x = 0;
          tempBox.w = prevCropBox.maxX - tempBox.x;
          tempBox.h = tempBox.w / targetRatio;
          tempBox.y = prevCropBox.maxY - tempBox.h;
        }
        if (tempBox.y <= 0) {
          tempBox.y = 0;
          tempBox.h = prevCropBox.maxY - tempBox.y;
          tempBox.w = tempBox.h * targetRatio;
          tempBox.x = prevCropBox.maxX - tempBox.w;
        }
        break;
      }
      case "top_right": {
        tempBox.x = prevCropBox.x;
        tempBox.y = prevCropBox.maxY - tempBox.h;
        if (tempBox.maxX >= w) {
          tempBox.w = w - prevCropBox.x;
          tempBox.h = tempBox.w / targetRatio;
          tempBox.y = prevCropBox.maxY - tempBox.h;
        }
        if (tempBox.y <= 0) {
          tempBox.y = 0;
          tempBox.h = prevCropBox.maxY - tempBox.y;
          tempBox.w = tempBox.h * targetRatio;
        }
        break;
      }
      case "bottom_left": {
        tempBox.x = prevCropBox.maxX - tempBox.w;
        tempBox.y = prevCropBox.y;
        if (tempBox.x <= 0) {
          tempBox.x = 0;
          tempBox.w = prevCropBox.maxX - tempBox.x;
          tempBox.h = tempBox.w / targetRatio;
        }
        if (tempBox.maxY >= h2) {
          tempBox.h = h2 - prevCropBox.y;
          tempBox.w = tempBox.h * targetRatio;
          tempBox.x = prevCropBox.maxX - tempBox.w;
        }
        break;
      }
      case "bottom_right": {
        tempBox.x = prevCropBox.x;
        tempBox.y = prevCropBox.y;
        if (tempBox.maxX >= w) {
          tempBox.w = w - prevCropBox.x;
          tempBox.h = tempBox.w / targetRatio;
        }
        if (tempBox.maxY >= h2) {
          tempBox.h = h2 - prevCropBox.y;
          tempBox.w = tempBox.h * targetRatio;
        }
        break;
      }
      case "top": {
        tempBox.h = prevCropBox.maxY - tempBox.y;
        tempBox.w = tempBox.h * targetRatio;
        tempBox.x -= (tempBox.w - prevCropBox.w) / 2;
        if (tempBox.x <= 0) {
          const leftSide = prevCropBox.midX;
          tempBox.w = leftSide * 2;
          tempBox.h = tempBox.w / targetRatio;
          tempBox.x = 0;
        }
        if (tempBox.maxX >= w) {
          const rightSide = w - prevCropBox.midX;
          tempBox.w = rightSide * 2;
          tempBox.h = tempBox.w / targetRatio;
          tempBox.x = w - tempBox.w;
        }
        tempBox.y = prevCropBox.maxY - tempBox.h;
        break;
      }
      case "right": {
        tempBox.w = tempBox.maxX - prevCropBox.x;
        tempBox.h = tempBox.w / targetRatio;
        tempBox.y -= (tempBox.h - prevCropBox.h) / 2;
        if (tempBox.y <= 0) {
          const topSide = prevCropBox.midY;
          tempBox.h = topSide * 2;
          tempBox.w = tempBox.h * targetRatio;
          tempBox.y = 0;
        }
        if (tempBox.maxY >= h2) {
          const bottomSide = h2 - prevCropBox.midY;
          tempBox.h = bottomSide * 2;
          tempBox.w = tempBox.h * targetRatio;
          tempBox.y = h2 - tempBox.h;
        }
        break;
      }
      case "bottom": {
        tempBox.h = tempBox.maxY - prevCropBox.y;
        tempBox.w = tempBox.h * targetRatio;
        tempBox.x -= (tempBox.w - prevCropBox.w) / 2;
        if (tempBox.x <= 0) {
          const leftSide = prevCropBox.midX;
          tempBox.w = leftSide * 2;
          tempBox.h = tempBox.w / targetRatio;
          tempBox.x = 0;
        }
        if (tempBox.maxX >= w) {
          const rightSide = w - prevCropBox.midX;
          tempBox.w = rightSide * 2;
          tempBox.h = tempBox.w / targetRatio;
          tempBox.x = w - tempBox.w;
        }
        break;
      }
      case "left": {
        tempBox.w = prevCropBox.maxX - tempBox.x;
        tempBox.h = tempBox.w / targetRatio;
        tempBox.y -= (tempBox.h - prevCropBox.h) / 2;
        if (tempBox.y <= 0) {
          const topSide = prevCropBox.midY;
          tempBox.h = topSide * 2;
          tempBox.w = tempBox.h * targetRatio;
          tempBox.y = 0;
        }
        if (tempBox.maxY >= h2) {
          const bottomSide = h2 - prevCropBox.midY;
          tempBox.h = bottomSide * 2;
          tempBox.w = tempBox.h * targetRatio;
          tempBox.y = h2 - tempBox.h;
        }
        tempBox.x = prevCropBox.maxX - tempBox.w;
        break;
      }
    }
  }
  const newCrop = {
    topLeft: { x: tempBox.x / w, y: tempBox.y / h2 },
    bottomRight: { x: tempBox.maxX / w, y: tempBox.maxY / h2 },
    isCircle: crop.isCircle
  };
  if (newCrop.topLeft.x === crop.topLeft.x && newCrop.topLeft.y === crop.topLeft.y && newCrop.bottomRight.x === crop.bottomRight.x && newCrop.bottomRight.y === crop.bottomRight.y) {
    return;
  }
  const newPoint = new Vec(tempBox.x - crop.topLeft.x * w, tempBox.y - crop.topLeft.y * h2).rot(shape.rotation).add(shape);
  return {
    id: shape.id,
    type: shape.type,
    x: newPoint.x,
    y: newPoint.y,
    props: {
      ...shape.props,
      w: tempBox.w,
      h: tempBox.h,
      crop: newCrop
    }
  };
}
function calculateCropChange(imageShape, newCropWidth, newCropHeight, centerOnCurrentCrop = true, isCircle = false) {
  const { w, h: h2 } = getUncroppedSize(imageShape.props, imageShape.props.crop ?? getDefaultCrop());
  const currentCrop = imageShape.props.crop || getDefaultCrop();
  const imageCenterX = imageShape.x + imageShape.props.w / 2;
  const imageCenterY = imageShape.y + imageShape.props.h / 2;
  let cropCenterX, cropCenterY;
  if (centerOnCurrentCrop) {
    const { x, y } = getCropCenter(currentCrop);
    cropCenterX = x;
    cropCenterY = y;
  } else {
    cropCenterX = 0.5;
    cropCenterY = 0.5;
  }
  const newCrop = createCropAroundCenter(
    cropCenterX,
    cropCenterY,
    newCropWidth,
    newCropHeight,
    isCircle
  );
  const croppedW = newCropWidth * w;
  const croppedH = newCropHeight * h2;
  return {
    crop: newCrop,
    w: croppedW,
    h: croppedH,
    x: imageCenterX - croppedW / 2,
    y: imageCenterY - croppedH / 2
  };
}
var MAX_ZOOM = 3;
function getCroppedImageDataWhenZooming(zoom, imageShape, maxZoom) {
  const oldCrop = imageShape.props.crop || getDefaultCrop();
  const { width: oldWidth, height: oldHeight } = getCropDimensions(oldCrop);
  const aspectRatio = oldWidth / oldHeight;
  const derivedMaxZoom = maxZoom ? 1 / (1 - maxZoom) : MAX_ZOOM;
  const zoomScale = 1 + zoom * (derivedMaxZoom - 1);
  let newWidth, newHeight;
  if (aspectRatio > 1) {
    newWidth = Math.min(1, 1 / zoomScale);
    newHeight = newWidth / aspectRatio;
  } else {
    newHeight = Math.min(1, 1 / zoomScale);
    newWidth = newHeight * aspectRatio;
  }
  const result = calculateCropChange(imageShape, newWidth, newHeight, true, oldCrop.isCircle);
  const scaleFactor = Math.min(MAX_ZOOM, oldWidth / newWidth);
  result.w *= scaleFactor;
  result.h *= scaleFactor;
  const imageCenterX = imageShape.x + imageShape.props.w / 2;
  const imageCenterY = imageShape.y + imageShape.props.h / 2;
  result.x = imageCenterX - result.w / 2;
  result.y = imageCenterY - result.h / 2;
  return result;
}
function getCroppedImageDataForReplacedImage(imageShape, newImageWidth, newImageHeight) {
  const defaultCrop = getDefaultCrop();
  const currentCrop = imageShape.props.crop || defaultCrop;
  const origDisplayW = imageShape.props.w;
  const origDisplayH = imageShape.props.h;
  const newImageAspectRatio = newImageWidth / newImageHeight;
  let crop = defaultCrop;
  let newDisplayW = origDisplayW;
  let newDisplayH = origDisplayH;
  const isOriginalCrop = (0, import_lodash.default)(imageShape.props.crop, defaultCrop);
  if (isOriginalCrop) {
    newDisplayW = origDisplayW;
    newDisplayH = origDisplayW * newImageHeight / newImageWidth;
  } else {
    const { w: uncroppedW, h: uncroppedH } = getUncroppedSize(
      imageShape.props,
      imageShape.props.crop || getDefaultCrop()
      // Use the ACTUAL current crop to correctly infer uncropped size
    );
    const { width: cropW, height: cropH } = getCropDimensions(currentCrop);
    const targetRatio = cropW / cropH;
    const oldImageAspectRatio = uncroppedW / uncroppedH;
    let newRelativeWidth;
    let newRelativeHeight;
    const currentCropCenter = getCropCenter(currentCrop);
    newRelativeWidth = cropW;
    const ratioConversion = newImageAspectRatio / oldImageAspectRatio / targetRatio;
    newRelativeHeight = newRelativeWidth * ratioConversion;
    const maxRatioConversion = MAX_ZOOM / (MAX_ZOOM - 1);
    if (ratioConversion > maxRatioConversion) {
      const minDimension = 1 / MAX_ZOOM;
      if (1 / newRelativeHeight < 1 / newRelativeWidth) {
        const scale = newRelativeHeight / minDimension;
        newRelativeHeight = newRelativeHeight / scale;
        newRelativeWidth = newRelativeWidth / scale;
      } else {
        const scale = newRelativeWidth / minDimension;
        newRelativeWidth = newRelativeWidth / scale;
        newRelativeHeight = newRelativeHeight / scale;
      }
    }
    newRelativeWidth = Math.max(0, Math.min(1, newRelativeWidth));
    newRelativeHeight = Math.max(0, Math.min(1, newRelativeHeight));
    crop = createCropAroundCenter(
      currentCropCenter.x,
      currentCropCenter.y,
      newRelativeWidth,
      newRelativeHeight,
      currentCrop.isCircle
    );
  }
  const pageCenterX = imageShape.x + origDisplayW / 2;
  const pageCenterY = imageShape.y + origDisplayH / 2;
  const newX = pageCenterX - newDisplayW / 2;
  const newY = pageCenterY - newDisplayH / 2;
  return {
    crop,
    w: newDisplayW,
    h: newDisplayH,
    x: newX,
    y: newY
  };
}
function getCroppedImageDataForAspectRatio(aspectRatioOption, imageShape) {
  if (aspectRatioOption === "original") {
    const { w, h: h2 } = getUncroppedSize(imageShape.props, imageShape.props.crop ?? getDefaultCrop());
    const imageCenterX = imageShape.x + imageShape.props.w / 2;
    const imageCenterY = imageShape.y + imageShape.props.h / 2;
    return {
      crop: getDefaultCrop(),
      w,
      h: h2,
      x: imageCenterX - w / 2,
      y: imageCenterY - h2 / 2
    };
  }
  const targetRatio = ASPECT_RATIO_TO_VALUE[aspectRatioOption];
  const isCircle = aspectRatioOption === "circle";
  const { w: uncroppedW, h: uncroppedH } = getUncroppedSize(
    imageShape.props,
    imageShape.props.crop || getDefaultCrop()
    // Use the ACTUAL current crop to correctly infer uncropped size
  );
  const imageAspectRatio = uncroppedW / uncroppedH;
  const currentCrop = imageShape.props.crop || getDefaultCrop();
  const { width: cropW, height: cropH } = getCropDimensions(currentCrop);
  const currentCropCenter = getCropCenter(currentCrop);
  const currentCropZoom = Math.min(1 / cropW, 1 / cropH);
  let newRelativeWidth;
  let newRelativeHeight;
  if (imageAspectRatio === 0 || !Number.isFinite(imageAspectRatio) || targetRatio === 0) {
    newRelativeWidth = 1;
    newRelativeHeight = 1;
  } else {
    const currentAbsoluteWidth = cropW * uncroppedW;
    const currentAbsoluteHeight = cropH * uncroppedH;
    const longestCurrentDimension = Math.max(currentAbsoluteWidth, currentAbsoluteHeight);
    const isWidthLongest = currentAbsoluteWidth >= currentAbsoluteHeight;
    let newAbsoluteWidth;
    let newAbsoluteHeight;
    if (isWidthLongest) {
      newAbsoluteWidth = longestCurrentDimension;
      newAbsoluteHeight = newAbsoluteWidth / targetRatio;
    } else {
      newAbsoluteHeight = longestCurrentDimension;
      newAbsoluteWidth = newAbsoluteHeight * targetRatio;
    }
    newRelativeWidth = newAbsoluteWidth / uncroppedW;
    newRelativeHeight = newAbsoluteHeight / uncroppedH;
    if (newRelativeWidth > 1) {
      newRelativeWidth = 1;
      newRelativeHeight = imageAspectRatio / targetRatio;
    }
    if (newRelativeHeight > 1) {
      newRelativeHeight = 1;
      newRelativeWidth = targetRatio / imageAspectRatio;
    }
    newRelativeWidth = Math.max(0, Math.min(1, newRelativeWidth));
    newRelativeHeight = Math.max(0, Math.min(1, newRelativeHeight));
  }
  const newCropZoom = Math.min(1 / newRelativeWidth, 1 / newRelativeHeight);
  newRelativeWidth *= newCropZoom / currentCropZoom;
  newRelativeHeight *= newCropZoom / currentCropZoom;
  newRelativeWidth = Math.max(0, Math.min(1, newRelativeWidth));
  newRelativeHeight = Math.max(0, Math.min(1, newRelativeHeight));
  const newCrop = createCropAroundCenter(
    currentCropCenter.x,
    currentCropCenter.y,
    newRelativeWidth,
    newRelativeHeight,
    isCircle
  );
  const finalRelativeWidth = newCrop.bottomRight.x - newCrop.topLeft.x;
  const finalRelativeHeight = newCrop.bottomRight.y - newCrop.topLeft.y;
  const baseW = finalRelativeWidth * uncroppedW;
  const baseH = finalRelativeHeight * uncroppedH;
  let currentScale = 1;
  if (cropW > 0) {
    currentScale = imageShape.props.w / (cropW * uncroppedW);
  } else if (cropH > 0) {
    currentScale = imageShape.props.h / (cropH * uncroppedH);
  }
  const newW = baseW * currentScale;
  const newH = baseH * currentScale;
  const currentCenterXPage = imageShape.x + imageShape.props.w / 2;
  const currentCenterYPage = imageShape.y + imageShape.props.h / 2;
  const newX = currentCenterXPage - newW / 2;
  const newY = currentCenterYPage - newH / 2;
  return {
    crop: newCrop,
    w: newW,
    h: newH,
    x: newX,
    y: newY
  };
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/DefaultImageToolbarContent.mjs
var DefaultImageToolbarContent = track(function DefaultImageToolbarContent2({
  imageShapeId,
  isManipulating,
  onEditAltTextStart,
  onManipulatingStart,
  onManipulatingEnd
}) {
  const editor = useEditor();
  const trackEvent = useUiEvents();
  const msg2 = useTranslation();
  const source = "image-toolbar";
  const sliderRef = (0, import_react110.useRef)(null);
  const isReadonly = editor.getIsReadonly();
  const crop = useValue("crop", () => editor.getShape(imageShapeId).props.crop, [
    editor,
    imageShapeId
  ]);
  const zoom = crop ? Math.min(1 - (crop.bottomRight.x - crop.topLeft.x), 1 - (crop.bottomRight.y - crop.topLeft.y)) : 0;
  const [maxZoom, setMaxZoom] = (0, import_react110.useState)(
    crop ? Math.max(zoom, 1 - 1 / MAX_ZOOM) : MAX_ZOOM
  );
  const actions = useActions();
  (0, import_react110.useEffect)(() => {
    setMaxZoom(crop ? Math.max(zoom, 1 - 1 / MAX_ZOOM) : MAX_ZOOM);
  }, [crop, zoom, maxZoom]);
  const onHistoryMark = (0, import_react110.useCallback)((id) => editor.markHistoryStoppingPoint(id), [editor]);
  const easeZoom = (0, import_react110.useCallback)((value, maxValue) => {
    const maxRatioConversion = MAX_ZOOM / (MAX_ZOOM - 1);
    return Math.pow(value / maxValue, maxRatioConversion) * maxValue;
  }, []);
  const displayValue = crop && maxZoom ? modulate(
    easeZoom(zoom, maxZoom),
    [0, maxZoom],
    [0, 100],
    true
    /* clamp */
  ) : 0;
  const handleZoomChange = (0, import_react110.useCallback)(
    (value) => {
      editor.setCurrentTool("select.crop.idle");
      const sliderPercent = value / 100;
      const maxDimension = 1 - 1 / MAX_ZOOM;
      const clampedMaxZoom = Math.min(maxDimension, maxZoom ?? maxDimension);
      const maxRatioConversion = MAX_ZOOM / (MAX_ZOOM - 1);
      const zOut = Math.pow(sliderPercent, 1 / maxRatioConversion) * clampedMaxZoom;
      const zoom2 = zOut >= 1 ? 1 : zOut / (2 * (1 - zOut));
      const imageShape = editor.getShape(imageShapeId);
      if (!imageShape) return;
      const change = getCroppedImageDataWhenZooming(zoom2, imageShape, maxZoom);
      editor.updateShape({
        id: imageShape.id,
        type: imageShape.type,
        x: change.x,
        y: change.y,
        props: {
          w: change.w,
          h: change.h,
          crop: change.crop
        }
      });
      trackEvent("set-style", { source: "image-toolbar", id: "zoom", value });
    },
    [editor, trackEvent, imageShapeId, maxZoom]
  );
  const handleImageReplace = (0, import_react110.useCallback)(
    () => actions["image-replace"].onSelect("image-toolbar"),
    [actions]
  );
  const handleImageDownload = (0, import_react110.useCallback)(
    () => actions["download-original"].onSelect("image-toolbar"),
    [actions]
  );
  const handleAspectRatioChange = (aspectRatio) => {
    const imageShape = editor.getShape(imageShapeId);
    if (!imageShape) return;
    editor.run(() => {
      editor.setCurrentTool("select.crop.idle");
      const change = getCroppedImageDataForAspectRatio(aspectRatio, imageShape);
      editor.markHistoryStoppingPoint("aspect ratio");
      editor.updateShape({
        id: imageShapeId,
        type: "image",
        x: change.x,
        y: change.y,
        props: {
          crop: change.crop,
          w: change.w,
          h: change.h
        }
      });
      kickoutOccludedShapes(editor, [imageShapeId]);
    });
  };
  const altText = useValue(
    "altText",
    () => editor.getShape(imageShapeId).props.altText,
    [editor, imageShapeId]
  );
  const shapeAspectRatio = useValue(
    "shapeAspectRatio",
    () => {
      const imageShape = editor.getShape(imageShapeId);
      return imageShape.props.w / imageShape.props.h;
    },
    [editor, imageShapeId]
  );
  const isOriginalCrop = !crop || (0, import_lodash.default)(crop, getDefaultCrop());
  (0, import_react110.useEffect)(() => {
    if (isManipulating) {
      editor.timers.setTimeout(() => {
        var _a6;
        return (_a6 = sliderRef.current) == null ? void 0 : _a6.focus();
      }, 0);
    }
  }, [editor, isManipulating]);
  (0, import_react110.useEffect)(() => {
    function handleKeyDown2(e) {
      if (isManipulating) {
        if (e.key === "Escape") {
          editor.cancel();
          onManipulatingEnd();
        } else if (e.key === "Enter") {
          editor.complete();
          onManipulatingEnd();
        }
      }
    }
    const elm = sliderRef.current;
    if (elm) {
      elm.addEventListener("keydown", handleKeyDown2);
    }
    return () => {
      if (elm) {
        elm.removeEventListener("keydown", handleKeyDown2);
      }
    };
  }, [editor, isManipulating, onManipulatingEnd]);
  if (isManipulating) {
    return (0, import_jsx_runtime168.jsxs)(import_jsx_runtime168.Fragment, { children: [
      (0, import_jsx_runtime168.jsx)(
        TldrawUiSlider,
        {
          ref: sliderRef,
          value: displayValue,
          label: "tool.image-zoom",
          onValueChange: handleZoomChange,
          onHistoryMark,
          min: 0,
          steps: 100,
          "data-testid": "tool.image-zoom",
          title: msg2("tool.image-zoom")
        }
      ),
      (0, import_jsx_runtime168.jsxs)(TldrawUiDropdownMenuRoot, { id: "image-toolbar-aspect-ratio", children: [
        (0, import_jsx_runtime168.jsx)(TldrawUiDropdownMenuTrigger, { children: (0, import_jsx_runtime168.jsx)(
          TldrawUiToolbarButton,
          {
            title: msg2("tool.aspect-ratio"),
            type: "icon",
            "data-testid": "tool.image-aspect-ratio",
            children: (0, import_jsx_runtime168.jsx)(TldrawUiButtonIcon, { icon: "corners" })
          }
        ) }),
        (0, import_jsx_runtime168.jsx)(TldrawUiDropdownMenuContent, { side: "top", align: "center", children: ASPECT_RATIO_OPTIONS.map((aspectRatio) => {
          let checked = false;
          if (isOriginalCrop) {
            if (aspectRatio === "original") {
              checked = true;
            }
          } else {
            if (aspectRatio === "circle") {
              checked = !!crop.isCircle;
            } else if (aspectRatio === "square") {
              checked = !(crop == null ? void 0 : crop.isCircle) && approximately(shapeAspectRatio, ASPECT_RATIO_TO_VALUE[aspectRatio], 0.1);
            } else if (aspectRatio === "original") {
              checked = false;
            } else {
              checked = !isOriginalCrop && approximately(shapeAspectRatio, ASPECT_RATIO_TO_VALUE[aspectRatio], 0.01);
            }
          }
          return (0, import_jsx_runtime168.jsx)(
            TldrawUiDropdownMenuCheckboxItem,
            {
              onSelect: () => handleAspectRatioChange(aspectRatio),
              checked,
              title: msg2(`tool.aspect-ratio.${aspectRatio}`),
              children: (0, import_jsx_runtime168.jsx)(TldrawUiButtonLabel, { children: msg2(`tool.aspect-ratio.${aspectRatio}`) })
            },
            aspectRatio
          );
        }) })
      ] }),
      (0, import_jsx_runtime168.jsx)(
        TldrawUiToolbarButton,
        {
          type: "icon",
          onClick: onManipulatingEnd,
          "data-testid": "tool.image-crop-confirm",
          style: { borderLeft: "1px solid var(--tl-color-divider)", marginLeft: "2px" },
          title: msg2("tool.image-crop-confirm"),
          children: (0, import_jsx_runtime168.jsx)(TldrawUiButtonIcon, { small: true, icon: "check" })
        }
      )
    ] });
  }
  return (0, import_jsx_runtime168.jsxs)(import_jsx_runtime168.Fragment, { children: [
    !isReadonly && (0, import_jsx_runtime168.jsx)(
      TldrawUiToolbarButton,
      {
        type: "icon",
        "data-testid": "tool.image-replace",
        onClick: handleImageReplace,
        title: msg2("tool.replace-media"),
        children: (0, import_jsx_runtime168.jsx)(TldrawUiButtonIcon, { small: true, icon: "tool-media" })
      }
    ),
    !isReadonly && (0, import_jsx_runtime168.jsx)(
      TldrawUiToolbarButton,
      {
        type: "icon",
        title: msg2("tool.image-crop"),
        onClick: onManipulatingStart,
        "data-testid": "tool.image-crop",
        children: (0, import_jsx_runtime168.jsx)(TldrawUiButtonIcon, { small: true, icon: "crop" })
      }
    ),
    (0, import_jsx_runtime168.jsx)(
      TldrawUiToolbarButton,
      {
        type: "icon",
        title: msg2("action.download-original"),
        onClick: handleImageDownload,
        "data-testid": "tool.image-download",
        children: (0, import_jsx_runtime168.jsx)(TldrawUiButtonIcon, { small: true, icon: "download" })
      }
    ),
    (altText || !isReadonly) && (0, import_jsx_runtime168.jsx)(
      TldrawUiToolbarButton,
      {
        type: "icon",
        title: msg2("tool.media-alt-text"),
        "data-testid": "tool.image-alt-text",
        onClick: () => {
          trackEvent("alt-text-start", { source });
          onEditAltTextStart();
        },
        children: (0, import_jsx_runtime168.jsx)(TldrawUiButtonIcon, { small: true, icon: "alt" })
      }
    )
  ] });
});

// ../node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/DefaultImageToolbar.mjs
function DefaultImageToolbar({ children }) {
  const editor = useEditor();
  const imageShapeId = useValue(
    "imageShape",
    () => {
      const onlySelectedShape = editor.getOnlySelectedShape();
      if (!onlySelectedShape || onlySelectedShape.type !== "image") return null;
      return onlySelectedShape.id;
    },
    [editor]
  );
  const showToolbar = useValue(
    "showToolbar",
    () => editor.isInAny("select.idle", "select.pointing_shape", "select.crop"),
    [editor]
  );
  const isLocked = useValue(
    "locked",
    () => {
      var _a6;
      return imageShapeId ? (_a6 = editor.getShape(imageShapeId)) == null ? void 0 : _a6.isLocked : false;
    },
    [editor, imageShapeId]
  );
  if (!imageShapeId || !showToolbar || isLocked) return null;
  return (0, import_jsx_runtime169.jsx)(ContextualToolbarInner, { imageShapeId, children }, imageShapeId);
}
function ContextualToolbarInner({
  children,
  imageShapeId
}) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const isChangingCrop = useValue(
    "editor path",
    () => editor.isInAny(
      "select.crop.cropping",
      "select.crop.pointing_crop_handle",
      "select.crop.translating_crop"
    ),
    [editor]
  );
  const camera = useValue("camera", () => editor.getCamera(), [editor]);
  const isInCropTool = useValue("editor path", () => editor.isIn("select.crop."), [editor]);
  const previousSelectionBounds = (0, import_react111.useRef)(void 0);
  const handleManipulatingEnd = (0, import_react111.useCallback)(() => {
    editor.setCroppingShape(null);
    editor.setCurrentTool("select.idle");
  }, [editor]);
  const [isEditingAltText, setIsEditingAltText] = (0, import_react111.useState)(false);
  const handleEditAltTextStart = (0, import_react111.useCallback)(() => setIsEditingAltText(true), []);
  const handleManipulatingStart = (0, import_react111.useCallback)(
    () => editor.setCurrentTool("select.crop.idle"),
    [editor]
  );
  const onEditAltTextClose = (0, import_react111.useCallback)(() => setIsEditingAltText(false), []);
  (0, import_react111.useEffect)(() => {
    previousSelectionBounds.current = void 0;
  }, [camera]);
  const getSelectionBounds = (0, import_react111.useCallback)(() => {
    if (isInCropTool && previousSelectionBounds.current) {
      return previousSelectionBounds.current;
    }
    const fullBounds = editor.getSelectionScreenBounds();
    if (!fullBounds) return void 0;
    const bounds = new Box(fullBounds.x, fullBounds.y, fullBounds.width, 0);
    previousSelectionBounds.current = bounds;
    return bounds;
  }, [editor, isInCropTool]);
  if (isChangingCrop) {
    previousSelectionBounds.current = void 0;
    return null;
  }
  return (0, import_jsx_runtime169.jsx)(
    TldrawUiContextualToolbar,
    {
      className: "tlui-image__toolbar",
      getSelectionBounds,
      label: msg2("tool.image-toolbar-title"),
      children: children ? children : isEditingAltText ? (0, import_jsx_runtime169.jsx)(AltTextEditor, { shapeId: imageShapeId, onClose: onEditAltTextClose, source: "image-toolbar" }) : (0, import_jsx_runtime169.jsx)(
        DefaultImageToolbarContent,
        {
          imageShapeId,
          isManipulating: isInCropTool,
          onEditAltTextStart: handleEditAltTextStart,
          onManipulatingStart: handleManipulatingStart,
          onManipulatingEnd: handleManipulatingEnd
        }
      )
    }
  );
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/DefaultRichTextToolbar.mjs
var import_jsx_runtime172 = __toESM(require_jsx_runtime(), 1);
var import_react114 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/DefaultRichTextToolbarContent.mjs
var import_jsx_runtime170 = __toESM(require_jsx_runtime(), 1);
var import_react112 = __toESM(require_react(), 1);
function DefaultRichTextToolbarContent({
  textEditor,
  onEditLinkStart
}) {
  const trackEvent = useUiEvents();
  const msg2 = useTranslation();
  const source = "rich-text-menu";
  const [_, set] = (0, import_react112.useState)(0);
  (0, import_react112.useEffect)(
    function forceUpdateWhenContentChanges() {
      function forceUpdate() {
        set((t2) => t2 + 1);
      }
      textEditor.on("update", forceUpdate);
      textEditor.on("selectionUpdate", forceUpdate);
    },
    [textEditor]
  );
  (0, import_react112.useEffect)(() => {
    function handleKeyDown2(event) {
      if (onEditLinkStart && isAccelKey(event) && event.shiftKey && event.key === "k") {
        event.preventDefault();
        onEditLinkStart();
      }
    }
    document.addEventListener("keydown", handleKeyDown2);
    return () => {
      document.removeEventListener("keydown", handleKeyDown2);
    };
  }, [onEditLinkStart]);
  const actions = (0, import_react112.useMemo)(() => {
    function handleOp(name, op) {
      if (!textEditor.view) return;
      trackEvent("rich-text", { operation: name, source });
      textEditor.chain().focus()[op]().run();
    }
    return [
      // { name: 'heading', attrs: { level: 3 }, onSelect() { textEditor.chain().focus().toggleHeading({ level: 3}).run() }},
      {
        name: "bold",
        onSelect() {
          handleOp("bold", "toggleBold");
        }
      },
      {
        name: "italic",
        onSelect() {
          handleOp("bold", "toggleItalic");
        }
      },
      // { name: 'underline', onSelect() { handleOp('underline', 'toggleUnderline') }},
      // { name: 'strike', onSelect() { handleOp('strike', 'toggleStrike')  }},
      {
        name: "code",
        onSelect() {
          handleOp("bold", "toggleCode");
        }
      },
      onEditLinkStart ? {
        name: "link",
        onSelect() {
          onEditLinkStart();
        }
      } : void 0,
      // ? is this really optional?
      {
        name: "bulletList",
        onSelect() {
          handleOp("bulletList", "toggleBulletList");
        }
      },
      {
        name: "highlight",
        onSelect() {
          handleOp("bulletList", "toggleHighlight");
        }
      }
    ].filter(Boolean);
  }, [textEditor, trackEvent, onEditLinkStart]);
  return actions.map(({ name, attrs, onSelect }) => {
    const isActive2 = textEditor.view ? textEditor.isActive(name, attrs) : false;
    return (0, import_jsx_runtime170.jsx)(
      TldrawUiToolbarButton,
      {
        title: msg2(`tool.rich-text-${name}`),
        "data-testid": `rich-text.${name}`,
        type: "icon",
        isActive: isActive2,
        onPointerDown: preventDefault,
        onClick: onSelect,
        role: "option",
        "aria-pressed": isActive2,
        children: (0, import_jsx_runtime170.jsx)(TldrawUiButtonIcon, { small: true, icon: name })
      },
      name
    );
  });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/LinkEditor.mjs
var import_jsx_runtime171 = __toESM(require_jsx_runtime(), 1);
var import_react113 = __toESM(require_react(), 1);
function LinkEditor({ textEditor, value: initialValue, onClose }) {
  const editor = useEditor();
  const [value, setValue] = (0, import_react113.useState)(initialValue);
  const msg2 = useTranslation();
  const ref = (0, import_react113.useRef)(null);
  const trackEvent = useUiEvents();
  const source = "rich-text-menu";
  const linkifiedValue = value.startsWith("http") ? value : `https://${value}`;
  const handleValueChange = (value2) => setValue(value2);
  const handleLinkComplete = (link) => {
    trackEvent("rich-text", { operation: "link-edit", source });
    if (!link.startsWith("http://") && !link.startsWith("https://")) {
      link = `https://${link}`;
    }
    textEditor.chain().setLink({ href: link }).run();
    if (editor.getInstanceState().isCoarsePointer) {
      textEditor.commands.blur();
    } else {
      textEditor.commands.focus();
    }
    onClose();
  };
  const handleVisitLink = () => {
    trackEvent("rich-text", { operation: "link-visit", source });
    openWindow(linkifiedValue, "_blank");
    onClose();
  };
  const handleRemoveLink = () => {
    trackEvent("rich-text", { operation: "link-remove", source });
    textEditor.chain().unsetLink().focus().run();
    onClose();
  };
  const handleLinkCancel = () => onClose();
  (0, import_react113.useEffect)(() => {
    var _a6;
    (_a6 = ref.current) == null ? void 0 : _a6.focus();
  }, [value]);
  (0, import_react113.useEffect)(() => {
    setValue(initialValue);
  }, [initialValue]);
  return (0, import_jsx_runtime171.jsxs)(import_jsx_runtime171.Fragment, { children: [
    (0, import_jsx_runtime171.jsx)(
      TldrawUiInput,
      {
        ref,
        "data-testid": "rich-text.link-input",
        className: "tlui-rich-text__toolbar-link-input",
        value,
        onValueChange: handleValueChange,
        onComplete: handleLinkComplete,
        onCancel: handleLinkCancel,
        placeholder: "example.com",
        "aria-label": "example.com"
      }
    ),
    (0, import_jsx_runtime171.jsx)(
      TldrawUiButton,
      {
        className: "tlui-rich-text__toolbar-link-visit",
        title: msg2("tool.rich-text-link-visit"),
        type: "icon",
        onPointerDown: preventDefault,
        onClick: handleVisitLink,
        disabled: !value,
        children: (0, import_jsx_runtime171.jsx)(TldrawUiButtonIcon, { small: true, icon: "external-link" })
      }
    ),
    (0, import_jsx_runtime171.jsx)(
      TldrawUiButton,
      {
        className: "tlui-rich-text__toolbar-link-remove",
        title: msg2("tool.rich-text-link-remove"),
        "data-testid": "rich-text.link-remove",
        type: "icon",
        onPointerDown: preventDefault,
        onClick: handleRemoveLink,
        children: (0, import_jsx_runtime171.jsx)(TldrawUiButtonIcon, { small: true, icon: "trash" })
      }
    )
  ] });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/DefaultRichTextToolbar.mjs
var DefaultRichTextToolbar = track(function DefaultRichTextToolbar2({
  children
}) {
  const editor = useEditor();
  const textEditor = useValue("textEditor", () => editor.getRichTextEditor(), [editor]);
  if (editor.getInstanceState().isCoarsePointer || !textEditor) return null;
  return (0, import_jsx_runtime172.jsx)(ContextualToolbarInner2, { textEditor, children });
});
function ContextualToolbarInner2({
  textEditor,
  children
}) {
  const { isEditingLink, onEditLinkStart, onEditLinkClose } = useEditingLinkBehavior(textEditor);
  const [currentSelection, setCurrentSelection] = (0, import_react114.useState)(null);
  const previousSelectionBounds = (0, import_react114.useRef)(void 0);
  const isMousingDown = useIsMousingDownOnTextEditor(textEditor);
  const msg2 = useTranslation();
  const getSelectionBounds = (0, import_react114.useCallback)(() => {
    if (isEditingLink) {
      return previousSelectionBounds.current;
    }
    const selection = window.getSelection();
    if (!currentSelection || !selection || selection.rangeCount === 0 || selection.isCollapsed)
      return;
    const rangeBoxes = [];
    for (let i = 0; i < selection.rangeCount; i++) {
      const range = selection.getRangeAt(i);
      rangeBoxes.push(rectToBox(range.getBoundingClientRect()));
    }
    const bounds = Box.Common(rangeBoxes);
    previousSelectionBounds.current = bounds;
    return bounds;
  }, [currentSelection, isEditingLink]);
  (0, import_react114.useEffect)(() => {
    const handleSelectionUpdate = ({ editor: textEditor2 }) => setCurrentSelection(textEditor2.state.selection);
    textEditor.on("selectionUpdate", handleSelectionUpdate);
    handleSelectionUpdate({ editor: textEditor });
    return () => {
      textEditor.off("selectionUpdate", handleSelectionUpdate);
    };
  }, [textEditor]);
  return (0, import_jsx_runtime172.jsx)(
    TldrawUiContextualToolbar,
    {
      className: "tlui-rich-text__toolbar",
      getSelectionBounds,
      isMousingDown,
      changeOnlyWhenYChanges: true,
      label: msg2("tool.rich-text-toolbar-title"),
      children: children ? children : isEditingLink ? (0, import_jsx_runtime172.jsx)(
        LinkEditor,
        {
          textEditor,
          value: textEditor.isActive("link") ? textEditor.getAttributes("link").href : "",
          onClose: onEditLinkClose
        }
      ) : (0, import_jsx_runtime172.jsx)(DefaultRichTextToolbarContent, { textEditor, onEditLinkStart })
    }
  );
}
function useEditingLinkBehavior(textEditor) {
  const [isEditingLink, setIsEditingLink] = (0, import_react114.useState)(false);
  (0, import_react114.useEffect)(() => {
    if (!textEditor) {
      setIsEditingLink(false);
      return;
    }
    const handleClick2 = () => {
      const isLinkActive = textEditor.isActive("link");
      setIsEditingLink(isLinkActive);
    };
    textEditor.view.dom.addEventListener("click", handleClick2);
    return () => {
      if (textEditor.isInitialized) {
        textEditor.view.dom.removeEventListener("click", handleClick2);
      }
    };
  }, [textEditor, isEditingLink]);
  (0, import_react114.useEffect)(() => {
    if (!textEditor) {
      return;
    }
    if (textEditor.isActive("link")) {
      try {
        const { from: from2, to } = getMarkRange(
          textEditor.state.doc.resolve(textEditor.state.selection.from),
          textEditor.schema.marks.link
        );
        if (textEditor.state.selection.empty) {
          textEditor.commands.setTextSelection({ from: from2, to });
        }
      } catch {
      }
    }
  }, [textEditor, isEditingLink]);
  const onEditLinkStart = (0, import_react114.useCallback)(() => {
    setIsEditingLink(true);
  }, []);
  const onEditLinkCancel = (0, import_react114.useCallback)(() => {
    setIsEditingLink(false);
  }, []);
  const onEditLinkClose = (0, import_react114.useCallback)(() => {
    setIsEditingLink(false);
    if (!textEditor) return;
    const from2 = textEditor.state.selection.from;
    textEditor.commands.setTextSelection({ from: from2, to: from2 });
  }, [textEditor]);
  return { isEditingLink, onEditLinkStart, onEditLinkClose, onEditLinkCancel };
}
function useIsMousingDownOnTextEditor(textEditor) {
  const [isMousingDown, setIsMousingDown] = (0, import_react114.useState)(false);
  (0, import_react114.useEffect)(() => {
    if (!textEditor) return;
    const handlePointingStateChange = debounce(({ isPointing }) => {
      setIsMousingDown(isPointing);
    }, 16);
    const handlePointingDown = () => handlePointingStateChange({ isPointing: true });
    const handlePointingUp = () => handlePointingStateChange({ isPointing: false });
    const touchDownEvents = ["touchstart", "pointerdown", "mousedown"];
    const touchUpEvents = ["touchend", "pointerup", "mouseup"];
    touchDownEvents.forEach((eventName) => {
      textEditor.view.dom.addEventListener(eventName, handlePointingDown);
    });
    touchUpEvents.forEach((eventName) => {
      document.body.addEventListener(eventName, handlePointingUp);
    });
    return () => {
      touchDownEvents.forEach((eventName) => {
        if (textEditor.isInitialized) {
          textEditor.view.dom.removeEventListener(eventName, handlePointingDown);
        }
      });
      touchUpEvents.forEach((eventName) => {
        document.body.removeEventListener(eventName, handlePointingUp);
      });
    };
  }, [textEditor]);
  return isMousingDown;
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/DefaultToolbar.mjs
var import_jsx_runtime177 = __toESM(require_jsx_runtime(), 1);
var import_classnames29 = __toESM(require_classnames(), 1);
var import_react118 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/components/MobileStylePanel.mjs
var import_jsx_runtime173 = __toESM(require_jsx_runtime(), 1);
var import_react115 = __toESM(require_react(), 1);
function MobileStylePanel() {
  const editor = useEditor();
  const msg2 = useTranslation();
  const { orientation } = useTldrawUiOrientation();
  const relevantStyles = useRelevantStyles();
  const color = relevantStyles == null ? void 0 : relevantStyles.get(DefaultColorStyle);
  const theme = getDefaultColorTheme({ isDarkMode: editor.user.getIsDarkMode() });
  const currentColor = (color == null ? void 0 : color.type) === "shared" ? getColorValue(theme, color.value, "solid") : getColorValue(theme, "black", "solid");
  const disableStylePanel = useValue(
    "disable style panel",
    () => editor.isInAny("hand", "zoom", "eraser", "laser"),
    [editor]
  );
  const handleStylesOpenChange = (0, import_react115.useCallback)(
    (isOpen) => {
      if (!isOpen) {
        editor.updateInstanceState({ isChangingStyle: false });
      }
    },
    [editor]
  );
  const { StylePanel } = useTldrawUiComponents();
  if (!StylePanel) return null;
  return (0, import_jsx_runtime173.jsxs)(TldrawUiPopover, { id: "mobile style menu", onOpenChange: handleStylesOpenChange, children: [
    (0, import_jsx_runtime173.jsx)(TldrawUiPopoverTrigger, { children: (0, import_jsx_runtime173.jsx)(
      TldrawUiButton,
      {
        type: "tool",
        "data-testid": "mobile-styles.button",
        style: {
          color: disableStylePanel ? "var(--tl-color-muted-1)" : currentColor
        },
        title: msg2("style-panel.title"),
        disabled: disableStylePanel,
        children: (0, import_jsx_runtime173.jsx)(
          TldrawUiButtonIcon,
          {
            icon: disableStylePanel ? "blob" : (color == null ? void 0 : color.type) === "mixed" ? "mixed" : "blob"
          }
        )
      }
    ) }),
    (0, import_jsx_runtime173.jsx)(TldrawUiPopoverContent, { side: orientation === "horizontal" ? "top" : "right", align: "end", children: StylePanel && (0, import_jsx_runtime173.jsx)(StylePanel, { isMobile: true }) })
  ] });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/DefaultToolbarContent.mjs
var import_jsx_runtime174 = __toESM(require_jsx_runtime(), 1);
function DefaultToolbarContent() {
  return (0, import_jsx_runtime174.jsxs)(import_jsx_runtime174.Fragment, { children: [
    (0, import_jsx_runtime174.jsx)(SelectToolbarItem, {}),
    (0, import_jsx_runtime174.jsx)(HandToolbarItem, {}),
    (0, import_jsx_runtime174.jsx)(DrawToolbarItem, {}),
    (0, import_jsx_runtime174.jsx)(EraserToolbarItem, {}),
    (0, import_jsx_runtime174.jsx)(ArrowToolbarItem, {}),
    (0, import_jsx_runtime174.jsx)(TextToolbarItem, {}),
    (0, import_jsx_runtime174.jsx)(NoteToolbarItem, {}),
    (0, import_jsx_runtime174.jsx)(AssetToolbarItem, {}),
    (0, import_jsx_runtime174.jsx)(RectangleToolbarItem, {}),
    (0, import_jsx_runtime174.jsx)(EllipseToolbarItem, {}),
    (0, import_jsx_runtime174.jsx)(TriangleToolbarItem, {}),
    (0, import_jsx_runtime174.jsx)(DiamondToolbarItem, {}),
    (0, import_jsx_runtime174.jsx)(HexagonToolbarItem, {}),
    (0, import_jsx_runtime174.jsx)(OvalToolbarItem, {}),
    (0, import_jsx_runtime174.jsx)(RhombusToolbarItem, {}),
    (0, import_jsx_runtime174.jsx)(StarToolbarItem, {}),
    (0, import_jsx_runtime174.jsx)(CloudToolbarItem, {}),
    (0, import_jsx_runtime174.jsx)(HeartToolbarItem, {}),
    (0, import_jsx_runtime174.jsx)(XBoxToolbarItem, {}),
    (0, import_jsx_runtime174.jsx)(CheckBoxToolbarItem, {}),
    (0, import_jsx_runtime174.jsx)(ArrowLeftToolbarItem, {}),
    (0, import_jsx_runtime174.jsx)(ArrowUpToolbarItem, {}),
    (0, import_jsx_runtime174.jsx)(ArrowDownToolbarItem, {}),
    (0, import_jsx_runtime174.jsx)(ArrowRightToolbarItem, {}),
    (0, import_jsx_runtime174.jsx)(LineToolbarItem, {}),
    (0, import_jsx_runtime174.jsx)(HighlightToolbarItem, {}),
    (0, import_jsx_runtime174.jsx)(LaserToolbarItem, {}),
    (0, import_jsx_runtime174.jsx)(FrameToolbarItem, {})
  ] });
}
function useIsToolSelected(tool) {
  var _a6;
  const editor = useEditor();
  const geo = (_a6 = tool == null ? void 0 : tool.meta) == null ? void 0 : _a6.geo;
  return useValue(
    "is tool selected",
    () => {
      if (!tool) return false;
      const activeToolId = editor.getCurrentToolId();
      if (activeToolId === "geo") {
        return geo === editor.getSharedStyles().getAsKnownValue(GeoShapeGeoStyle);
      } else {
        return activeToolId === tool.id;
      }
    },
    [editor, tool == null ? void 0 : tool.id, geo]
  );
}
function ToolbarItem({ tool }) {
  const tools = useTools();
  const isSelected = useIsToolSelected(tools[tool]);
  return (0, import_jsx_runtime174.jsx)(TldrawUiMenuToolItem, { toolId: tool, isSelected });
}
function SelectToolbarItem() {
  return (0, import_jsx_runtime174.jsx)(ToolbarItem, { tool: "select" });
}
function HandToolbarItem() {
  return (0, import_jsx_runtime174.jsx)(ToolbarItem, { tool: "hand" });
}
function DrawToolbarItem() {
  return (0, import_jsx_runtime174.jsx)(ToolbarItem, { tool: "draw" });
}
function EraserToolbarItem() {
  return (0, import_jsx_runtime174.jsx)(ToolbarItem, { tool: "eraser" });
}
function ArrowToolbarItem() {
  return (0, import_jsx_runtime174.jsx)(ToolbarItem, { tool: "arrow" });
}
function TextToolbarItem() {
  return (0, import_jsx_runtime174.jsx)(ToolbarItem, { tool: "text" });
}
function NoteToolbarItem() {
  return (0, import_jsx_runtime174.jsx)(ToolbarItem, { tool: "note" });
}
function AssetToolbarItem() {
  return (0, import_jsx_runtime174.jsx)(TldrawUiMenuToolItem, { toolId: "asset" });
}
function RectangleToolbarItem() {
  return (0, import_jsx_runtime174.jsx)(ToolbarItem, { tool: "rectangle" });
}
function EllipseToolbarItem() {
  return (0, import_jsx_runtime174.jsx)(ToolbarItem, { tool: "ellipse" });
}
function DiamondToolbarItem() {
  return (0, import_jsx_runtime174.jsx)(ToolbarItem, { tool: "diamond" });
}
function TriangleToolbarItem() {
  return (0, import_jsx_runtime174.jsx)(ToolbarItem, { tool: "triangle" });
}
function TrapezoidToolbarItem() {
  return (0, import_jsx_runtime174.jsx)(ToolbarItem, { tool: "trapezoid" });
}
function RhombusToolbarItem() {
  return (0, import_jsx_runtime174.jsx)(ToolbarItem, { tool: "rhombus" });
}
function HeartToolbarItem() {
  return (0, import_jsx_runtime174.jsx)(ToolbarItem, { tool: "heart" });
}
function HexagonToolbarItem() {
  return (0, import_jsx_runtime174.jsx)(ToolbarItem, { tool: "hexagon" });
}
function CloudToolbarItem() {
  return (0, import_jsx_runtime174.jsx)(ToolbarItem, { tool: "cloud" });
}
function StarToolbarItem() {
  return (0, import_jsx_runtime174.jsx)(ToolbarItem, { tool: "star" });
}
function OvalToolbarItem() {
  return (0, import_jsx_runtime174.jsx)(ToolbarItem, { tool: "oval" });
}
function XBoxToolbarItem() {
  return (0, import_jsx_runtime174.jsx)(ToolbarItem, { tool: "x-box" });
}
function CheckBoxToolbarItem() {
  return (0, import_jsx_runtime174.jsx)(ToolbarItem, { tool: "check-box" });
}
function ArrowLeftToolbarItem() {
  return (0, import_jsx_runtime174.jsx)(ToolbarItem, { tool: "arrow-left" });
}
function ArrowUpToolbarItem() {
  return (0, import_jsx_runtime174.jsx)(ToolbarItem, { tool: "arrow-up" });
}
function ArrowDownToolbarItem() {
  return (0, import_jsx_runtime174.jsx)(ToolbarItem, { tool: "arrow-down" });
}
function ArrowRightToolbarItem() {
  return (0, import_jsx_runtime174.jsx)(ToolbarItem, { tool: "arrow-right" });
}
function LineToolbarItem() {
  return (0, import_jsx_runtime174.jsx)(ToolbarItem, { tool: "line" });
}
function HighlightToolbarItem() {
  return (0, import_jsx_runtime174.jsx)(ToolbarItem, { tool: "highlight" });
}
function FrameToolbarItem() {
  return (0, import_jsx_runtime174.jsx)(ToolbarItem, { tool: "frame" });
}
function LaserToolbarItem() {
  return (0, import_jsx_runtime174.jsx)(ToolbarItem, { tool: "laser" });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/OverflowingToolbar.mjs
var import_jsx_runtime175 = __toESM(require_jsx_runtime(), 1);
var import_classnames27 = __toESM(require_classnames(), 1);
var import_react117 = __toESM(require_react(), 1);

// ../node_modules/hotkeys-js/dist/hotkeys.esm.js
var isff = typeof navigator !== "undefined" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : false;
function addEvent(object, event, method, useCapture) {
  if (object.addEventListener) {
    object.addEventListener(event, method, useCapture);
  } else if (object.attachEvent) {
    object.attachEvent("on".concat(event), method);
  }
}
function removeEvent(object, event, method, useCapture) {
  if (object.removeEventListener) {
    object.removeEventListener(event, method, useCapture);
  } else if (object.detachEvent) {
    object.detachEvent("on".concat(event), method);
  }
}
function getMods2(modifier, key) {
  const mods = key.slice(0, key.length - 1);
  for (let i = 0; i < mods.length; i++) mods[i] = modifier[mods[i].toLowerCase()];
  return mods;
}
function getKeys(key) {
  if (typeof key !== "string") key = "";
  key = key.replace(/\s/g, "");
  const keys3 = key.split(",");
  let index2 = keys3.lastIndexOf("");
  for (; index2 >= 0; ) {
    keys3[index2 - 1] += ",";
    keys3.splice(index2, 1);
    index2 = keys3.lastIndexOf("");
  }
  return keys3;
}
function compareArray(a1, a2) {
  const arr1 = a1.length >= a2.length ? a1 : a2;
  const arr2 = a1.length >= a2.length ? a2 : a1;
  let isIndex = true;
  for (let i = 0; i < arr1.length; i++) {
    if (arr2.indexOf(arr1[i]) === -1) isIndex = false;
  }
  return isIndex;
}
var _keyMap = {
  backspace: 8,
  "⌫": 8,
  tab: 9,
  clear: 12,
  enter: 13,
  "↩": 13,
  return: 13,
  esc: 27,
  escape: 27,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  /// https://w3c.github.io/uievents/#events-keyboard-key-location
  arrowup: 38,
  arrowdown: 40,
  arrowleft: 37,
  arrowright: 39,
  del: 46,
  delete: 46,
  ins: 45,
  insert: 45,
  home: 36,
  end: 35,
  pageup: 33,
  pagedown: 34,
  capslock: 20,
  num_0: 96,
  num_1: 97,
  num_2: 98,
  num_3: 99,
  num_4: 100,
  num_5: 101,
  num_6: 102,
  num_7: 103,
  num_8: 104,
  num_9: 105,
  num_multiply: 106,
  num_add: 107,
  num_enter: 108,
  num_subtract: 109,
  num_decimal: 110,
  num_divide: 111,
  "⇪": 20,
  ",": 188,
  ".": 190,
  "/": 191,
  "`": 192,
  "-": isff ? 173 : 189,
  "=": isff ? 61 : 187,
  ";": isff ? 59 : 186,
  "'": 222,
  "{": 219,
  "}": 221,
  "[": 219,
  "]": 221,
  "\\": 220
};
var _modifier = {
  // shiftKey
  "⇧": 16,
  shift: 16,
  // altKey
  "⌥": 18,
  alt: 18,
  option: 18,
  // ctrlKey
  "⌃": 17,
  ctrl: 17,
  control: 17,
  // metaKey
  "⌘": 91,
  cmd: 91,
  meta: 91,
  command: 91
};
var modifierMap = {
  16: "shiftKey",
  18: "altKey",
  17: "ctrlKey",
  91: "metaKey",
  shiftKey: 16,
  ctrlKey: 17,
  altKey: 18,
  metaKey: 91
};
var _mods = {
  16: false,
  18: false,
  17: false,
  91: false
};
var _handlers = {};
for (let k = 1; k < 20; k++) {
  _keyMap["f".concat(k)] = 111 + k;
}
var _downKeys = [];
var winListendFocus = null;
var _scope = "all";
var elementEventMap = /* @__PURE__ */ new Map();
var code = (x) => _keyMap[x.toLowerCase()] || _modifier[x.toLowerCase()] || x.toUpperCase().charCodeAt(0);
var getKey = (x) => Object.keys(_keyMap).find((k) => _keyMap[k] === x);
var getModifier = (x) => Object.keys(_modifier).find((k) => _modifier[k] === x);
function setScope(scope) {
  _scope = scope || "all";
}
function getScope() {
  return _scope || "all";
}
function getPressedKeyCodes() {
  return _downKeys.slice(0);
}
function getPressedKeyString() {
  return _downKeys.map((c) => getKey(c) || getModifier(c) || String.fromCharCode(c));
}
function getAllKeyCodes() {
  const result = [];
  Object.keys(_handlers).forEach((k) => {
    _handlers[k].forEach((_ref) => {
      let {
        key,
        scope,
        mods,
        shortcut
      } = _ref;
      result.push({
        scope,
        shortcut,
        mods,
        keys: key.split("+").map((v) => code(v))
      });
    });
  });
  return result;
}
function filter(event) {
  const target = event.target || event.srcElement;
  const {
    tagName
  } = target;
  let flag = true;
  const isInput = tagName === "INPUT" && !["checkbox", "radio", "range", "button", "file", "reset", "submit", "color"].includes(target.type);
  if (target.isContentEditable || (isInput || tagName === "TEXTAREA" || tagName === "SELECT") && !target.readOnly) {
    flag = false;
  }
  return flag;
}
function isPressed(keyCode) {
  if (typeof keyCode === "string") {
    keyCode = code(keyCode);
  }
  return _downKeys.indexOf(keyCode) !== -1;
}
function deleteScope(scope, newScope) {
  let handlers2;
  let i;
  if (!scope) scope = getScope();
  for (const key in _handlers) {
    if (Object.prototype.hasOwnProperty.call(_handlers, key)) {
      handlers2 = _handlers[key];
      for (i = 0; i < handlers2.length; ) {
        if (handlers2[i].scope === scope) {
          const deleteItems = handlers2.splice(i, 1);
          deleteItems.forEach((_ref2) => {
            let {
              element
            } = _ref2;
            return removeKeyEvent(element);
          });
        } else {
          i++;
        }
      }
    }
  }
  if (getScope() === scope) setScope(newScope || "all");
}
function clearModifier(event) {
  let key = event.keyCode || event.which || event.charCode;
  if (event.key && event.key.toLowerCase() === "capslock") {
    key = code(event.key);
  }
  const i = _downKeys.indexOf(key);
  if (i >= 0) {
    _downKeys.splice(i, 1);
  }
  if (event.key && event.key.toLowerCase() === "meta") {
    _downKeys.splice(0, _downKeys.length);
  }
  if (key === 93 || key === 224) key = 91;
  if (key in _mods) {
    _mods[key] = false;
    for (const k in _modifier) if (_modifier[k] === key) hotkeys[k] = false;
  }
}
function unbind(keysInfo) {
  if (typeof keysInfo === "undefined") {
    Object.keys(_handlers).forEach((key) => {
      Array.isArray(_handlers[key]) && _handlers[key].forEach((info) => eachUnbind(info));
      delete _handlers[key];
    });
    removeKeyEvent(null);
  } else if (Array.isArray(keysInfo)) {
    keysInfo.forEach((info) => {
      if (info.key) eachUnbind(info);
    });
  } else if (typeof keysInfo === "object") {
    if (keysInfo.key) eachUnbind(keysInfo);
  } else if (typeof keysInfo === "string") {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    let [scope, method] = args;
    if (typeof scope === "function") {
      method = scope;
      scope = "";
    }
    eachUnbind({
      key: keysInfo,
      scope,
      method,
      splitKey: "+"
    });
  }
}
var eachUnbind = (_ref3) => {
  let {
    key,
    scope,
    method,
    splitKey = "+"
  } = _ref3;
  const multipleKeys = getKeys(key);
  multipleKeys.forEach((originKey) => {
    const unbindKeys = originKey.split(splitKey);
    const len = unbindKeys.length;
    const lastKey = unbindKeys[len - 1];
    const keyCode = lastKey === "*" ? "*" : code(lastKey);
    if (!_handlers[keyCode]) return;
    if (!scope) scope = getScope();
    const mods = len > 1 ? getMods2(_modifier, unbindKeys) : [];
    const unbindElements = [];
    _handlers[keyCode] = _handlers[keyCode].filter((record) => {
      const isMatchingMethod = method ? record.method === method : true;
      const isUnbind = isMatchingMethod && record.scope === scope && compareArray(record.mods, mods);
      if (isUnbind) unbindElements.push(record.element);
      return !isUnbind;
    });
    unbindElements.forEach((element) => removeKeyEvent(element));
  });
};
function eventHandler(event, handler, scope, element) {
  if (handler.element !== element) {
    return;
  }
  let modifiersMatch;
  if (handler.scope === scope || handler.scope === "all") {
    modifiersMatch = handler.mods.length > 0;
    for (const y in _mods) {
      if (Object.prototype.hasOwnProperty.call(_mods, y)) {
        if (!_mods[y] && handler.mods.indexOf(+y) > -1 || _mods[y] && handler.mods.indexOf(+y) === -1) {
          modifiersMatch = false;
        }
      }
    }
    if (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch || handler.shortcut === "*") {
      handler.keys = [];
      handler.keys = handler.keys.concat(_downKeys);
      if (handler.method(event, handler) === false) {
        if (event.preventDefault) event.preventDefault();
        else event.returnValue = false;
        if (event.stopPropagation) event.stopPropagation();
        if (event.cancelBubble) event.cancelBubble = true;
      }
    }
  }
}
function dispatch(event, element) {
  const asterisk = _handlers["*"];
  let key = event.keyCode || event.which || event.charCode;
  if (event.key && event.key.toLowerCase() === "capslock") {
    return;
  }
  if (!hotkeys.filter.call(this, event)) return;
  if (key === 93 || key === 224) key = 91;
  if (_downKeys.indexOf(key) === -1 && key !== 229) _downKeys.push(key);
  ["metaKey", "ctrlKey", "altKey", "shiftKey"].forEach((keyName2) => {
    const keyNum = modifierMap[keyName2];
    if (event[keyName2] && _downKeys.indexOf(keyNum) === -1) {
      _downKeys.push(keyNum);
    } else if (!event[keyName2] && _downKeys.indexOf(keyNum) > -1) {
      _downKeys.splice(_downKeys.indexOf(keyNum), 1);
    } else if (keyName2 === "metaKey" && event[keyName2]) {
      _downKeys = _downKeys.filter((k) => k in modifierMap || k === key);
    }
  });
  if (key in _mods) {
    _mods[key] = true;
    for (const k in _modifier) {
      if (Object.prototype.hasOwnProperty.call(_modifier, k)) {
        const eventKey = modifierMap[_modifier[k]];
        hotkeys[k] = event[eventKey];
      }
    }
    if (!asterisk) return;
  }
  for (const e in _mods) {
    if (Object.prototype.hasOwnProperty.call(_mods, e)) {
      _mods[e] = event[modifierMap[e]];
    }
  }
  if (event.getModifierState && !(event.altKey && !event.ctrlKey) && event.getModifierState("AltGraph")) {
    if (_downKeys.indexOf(17) === -1) {
      _downKeys.push(17);
    }
    if (_downKeys.indexOf(18) === -1) {
      _downKeys.push(18);
    }
    _mods[17] = true;
    _mods[18] = true;
  }
  const scope = getScope();
  if (asterisk) {
    for (let i = 0; i < asterisk.length; i++) {
      if (asterisk[i].scope === scope && (event.type === "keydown" && asterisk[i].keydown || event.type === "keyup" && asterisk[i].keyup)) {
        eventHandler(event, asterisk[i], scope, element);
      }
    }
  }
  if (!(key in _handlers)) return;
  const handlerKey = _handlers[key];
  const keyLen = handlerKey.length;
  for (let i = 0; i < keyLen; i++) {
    if (event.type === "keydown" && handlerKey[i].keydown || event.type === "keyup" && handlerKey[i].keyup) {
      if (handlerKey[i].key) {
        const record = handlerKey[i];
        const {
          splitKey
        } = record;
        const keyShortcut = record.key.split(splitKey);
        const _downKeysCurrent = [];
        for (let a = 0; a < keyShortcut.length; a++) {
          _downKeysCurrent.push(code(keyShortcut[a]));
        }
        if (_downKeysCurrent.sort().join("") === _downKeys.sort().join("")) {
          eventHandler(event, record, scope, element);
        }
      }
    }
  }
}
function hotkeys(key, option, method) {
  _downKeys = [];
  const keys3 = getKeys(key);
  let mods = [];
  let scope = "all";
  let element = document;
  let i = 0;
  let keyup = false;
  let keydown = true;
  let splitKey = "+";
  let capture = false;
  let single = false;
  if (method === void 0 && typeof option === "function") {
    method = option;
  }
  if (Object.prototype.toString.call(option) === "[object Object]") {
    if (option.scope) scope = option.scope;
    if (option.element) element = option.element;
    if (option.keyup) keyup = option.keyup;
    if (option.keydown !== void 0) keydown = option.keydown;
    if (option.capture !== void 0) capture = option.capture;
    if (typeof option.splitKey === "string") splitKey = option.splitKey;
    if (option.single === true) single = true;
  }
  if (typeof option === "string") scope = option;
  if (single) unbind(key, scope);
  for (; i < keys3.length; i++) {
    key = keys3[i].split(splitKey);
    mods = [];
    if (key.length > 1) mods = getMods2(_modifier, key);
    key = key[key.length - 1];
    key = key === "*" ? "*" : code(key);
    if (!(key in _handlers)) _handlers[key] = [];
    _handlers[key].push({
      keyup,
      keydown,
      scope,
      mods,
      shortcut: keys3[i],
      method,
      key: keys3[i],
      splitKey,
      element
    });
  }
  if (typeof element !== "undefined" && window) {
    if (!elementEventMap.has(element)) {
      const keydownListener = function() {
        let event = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;
        return dispatch(event, element);
      };
      const keyupListenr = function() {
        let event = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;
        dispatch(event, element);
        clearModifier(event);
      };
      elementEventMap.set(element, {
        keydownListener,
        keyupListenr,
        capture
      });
      addEvent(element, "keydown", keydownListener, capture);
      addEvent(element, "keyup", keyupListenr, capture);
    }
    if (!winListendFocus) {
      const listener = () => {
        _downKeys = [];
      };
      winListendFocus = {
        listener,
        capture
      };
      addEvent(window, "focus", listener, capture);
    }
  }
}
function trigger(shortcut) {
  let scope = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "all";
  Object.keys(_handlers).forEach((key) => {
    const dataList = _handlers[key].filter((item) => item.scope === scope && item.shortcut === shortcut);
    dataList.forEach((data) => {
      if (data && data.method) {
        data.method();
      }
    });
  });
}
function removeKeyEvent(element) {
  const values = Object.values(_handlers).flat();
  const findindex = values.findIndex((_ref4) => {
    let {
      element: el
    } = _ref4;
    return el === element;
  });
  if (findindex < 0) {
    const {
      keydownListener,
      keyupListenr,
      capture
    } = elementEventMap.get(element) || {};
    if (keydownListener && keyupListenr) {
      removeEvent(element, "keyup", keyupListenr, capture);
      removeEvent(element, "keydown", keydownListener, capture);
      elementEventMap.delete(element);
    }
  }
  if (values.length <= 0 || elementEventMap.size <= 0) {
    const eventKeys = Object.keys(elementEventMap);
    eventKeys.forEach((el) => {
      const {
        keydownListener,
        keyupListenr,
        capture
      } = elementEventMap.get(el) || {};
      if (keydownListener && keyupListenr) {
        removeEvent(el, "keyup", keyupListenr, capture);
        removeEvent(el, "keydown", keydownListener, capture);
        elementEventMap.delete(el);
      }
    });
    elementEventMap.clear();
    Object.keys(_handlers).forEach((key) => delete _handlers[key]);
    if (winListendFocus) {
      const {
        listener,
        capture
      } = winListendFocus;
      removeEvent(window, "focus", listener, capture);
      winListendFocus = null;
    }
  }
}
var _api = {
  getPressedKeyString,
  setScope,
  getScope,
  deleteScope,
  getPressedKeyCodes,
  getAllKeyCodes,
  isPressed,
  filter,
  trigger,
  unbind,
  keyMap: _keyMap,
  modifier: _modifier,
  modifierMap
};
for (const a in _api) {
  if (Object.prototype.hasOwnProperty.call(_api, a)) {
    hotkeys[a] = _api[a];
  }
}
if (typeof window !== "undefined") {
  const _hotkeys = window.hotkeys;
  hotkeys.noConflict = (deep) => {
    if (deep && window.hotkeys === hotkeys) {
      window.hotkeys = _hotkeys;
    }
    return hotkeys;
  };
  window.hotkeys = hotkeys;
}

// ../node_modules/tldraw/dist-esm/lib/ui/hooks/useKeyboardShortcuts.mjs
var import_react116 = __toESM(require_react(), 1);
var SKIP_KBDS = [
  // we set these in useNativeClipboardEvents instead
  "copy",
  "cut",
  "paste",
  // There's also an upload asset action, so we don't want to set the kbd twice
  "asset"
];
function useKeyboardShortcuts() {
  const editor = useEditor();
  const isReadonlyMode = useReadonly();
  const actions = useActions();
  const tools = useTools();
  const isFocused = useValue("is focused", () => editor.getInstanceState().isFocused, [editor]);
  (0, import_react116.useEffect)(() => {
    if (!isFocused) return;
    const disposables = new Array();
    const container = editor.getContainer();
    const hot = (keys3, callback) => {
      hotkeys(keys3, { element: container.ownerDocument.body }, callback);
      disposables.push(() => {
        hotkeys.unbind(keys3, callback);
      });
    };
    const hotUp = (keys3, callback) => {
      hotkeys(
        keys3,
        { element: container.ownerDocument.body, keyup: true, keydown: false },
        callback
      );
      disposables.push(() => {
        hotkeys.unbind(keys3, callback);
      });
    };
    for (const action of Object.values(actions)) {
      if (!action.kbd) continue;
      if (isReadonlyMode && !action.readonlyOk) continue;
      if (SKIP_KBDS.includes(action.id)) continue;
      hot(getHotkeysStringFromKbd(action.kbd), (event) => {
        if (areShortcutsDisabled3(editor) && !action.isRequiredA11yAction) return;
        preventDefault(event);
        action.onSelect("kbd");
      });
    }
    for (const tool of Object.values(tools)) {
      if (!tool.kbd || !tool.readonlyOk && editor.getIsReadonly()) {
        continue;
      }
      if (SKIP_KBDS.includes(tool.id)) continue;
      hot(getHotkeysStringFromKbd(tool.kbd), (event) => {
        if (areShortcutsDisabled3(editor)) return;
        preventDefault(event);
        tool.onSelect("kbd");
      });
    }
    hot(",", (e) => {
      if (areShortcutsDisabled3(editor)) return;
      if (editor.inputs.keys.has("Comma")) return;
      preventDefault(e);
      editor.focus();
      editor.inputs.keys.add("Comma");
      const { x, y, z } = editor.inputs.getCurrentPagePoint();
      const screenpoints = editor.pageToScreen({ x, y });
      const info = {
        type: "pointer",
        name: "pointer_down",
        point: { x: screenpoints.x, y: screenpoints.y, z },
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        ctrlKey: e.metaKey || e.ctrlKey,
        metaKey: e.metaKey,
        accelKey: isAccelKey(e),
        pointerId: 0,
        button: 0,
        isPen: editor.getInstanceState().isPenMode,
        target: "canvas"
      };
      editor.dispatch(info);
    });
    hotUp(",", (e) => {
      if (areShortcutsDisabled3(editor)) return;
      if (!editor.inputs.keys.has("Comma")) return;
      editor.inputs.keys.delete("Comma");
      const { x, y, z } = editor.inputs.getCurrentScreenPoint();
      const info = {
        type: "pointer",
        name: "pointer_up",
        point: { x, y, z },
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        ctrlKey: e.metaKey || e.ctrlKey,
        metaKey: e.metaKey,
        accelKey: isAccelKey(e),
        pointerId: 0,
        button: 0,
        isPen: editor.getInstanceState().isPenMode,
        target: "canvas"
      };
      editor.dispatch(info);
    });
    return () => {
      disposables.forEach((d) => d());
    };
  }, [actions, tools, isReadonlyMode, editor, isFocused]);
}
function areShortcutsDisabled3(editor) {
  return editor.menus.hasAnyOpenMenus() || editor.getEditingShapeId() !== null || editor.getCrashingError() || !editor.user.getAreKeyboardShortcutsEnabled();
}
function getHotkeysStringFromKbd(kbd2) {
  return getKeys2(kbd2).map((kbd22) => {
    let str = "";
    const shift5 = kbd22.includes("!");
    const alt = kbd22.includes("?");
    const cmd = kbd22.includes("$");
    const k = kbd22.replace(/[!?$]/g, "");
    if (shift5 && alt && cmd) {
      str = `cmd+shift+alt+${k},ctrl+shift+alt+${k}`;
    } else if (shift5 && cmd) {
      str = `cmd+shift+${k},ctrl+shift+${k}`;
    } else if (alt && cmd) {
      str = `cmd+alt+${k},ctrl+alt+${k}`;
    } else if (alt && shift5) {
      str = `shift+alt+${k}`;
    } else if (shift5) {
      str = `shift+${k}`;
    } else if (alt) {
      str = `alt+${k}`;
    } else if (cmd) {
      str = `cmd+${k},ctrl+${k}`;
    } else {
      str = k;
    }
    return str;
  }).join(",");
}
function getKeys2(key) {
  if (typeof key !== "string") key = "";
  key = key.replace(/\s/g, "");
  const keys3 = key.split(",");
  let index2 = keys3.lastIndexOf("");
  for (; index2 >= 0; ) {
    keys3[index2 - 1] += ",";
    keys3.splice(index2, 1);
    index2 = keys3.lastIndexOf("");
  }
  return keys3;
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/OverflowingToolbar.mjs
var IsInOverflowContext = (0, import_react117.createContext)(false);
var NUMBERED_SHORTCUT_KEYS = {
  "1": 0,
  "2": 1,
  "3": 2,
  "4": 3,
  "5": 4,
  "6": 5,
  "7": 6,
  "8": 7,
  "9": 8,
  "0": 9
};
function OverflowingToolbar({
  children,
  orientation,
  sizingParentClassName,
  minItems,
  minSizePx,
  maxItems,
  maxSizePx
}) {
  const editor = useEditor();
  const id = useUniqueSafeId();
  const breakpoint = useBreakpoint();
  const msg2 = useTranslation();
  const rButtons = (0, import_react117.useRef)([]);
  const [isOpen, setIsOpen] = (0, import_react117.useState)(false);
  const mainToolsRef = (0, import_react117.useRef)(null);
  const [overflowTools, setOverflowTools] = (0, import_react117.useState)(null);
  const [lastActiveOverflowItem, setLastActiveOverflowItem] = (0, import_react117.useState)(null);
  const [shouldShowOverflow, setShouldShowOverflow] = (0, import_react117.useState)(false);
  const onDomUpdate = useEvent(() => {
    if (!mainToolsRef.current) return;
    const sizeProp = orientation === "horizontal" ? "offsetWidth" : "offsetHeight";
    const mainItems = collectItems(mainToolsRef.current.children);
    const overflowItems = overflowTools ? collectItems(overflowTools.children) : null;
    function collectItems(collection) {
      const items = [];
      for (const child of collection) {
        if (child.classList.contains("tlui-main-toolbar__group")) {
          items.push({
            type: "group",
            items: collectItems(child.children),
            element: child
          });
        } else if (!child.hasAttribute("data-radix-popper-content-wrapper")) {
          items.push({ type: "item", element: child });
        }
      }
      return items;
    }
    const sizingParent = findParentWithClassName(mainToolsRef.current, sizingParentClassName);
    const size4 = sizingParent[sizeProp];
    const itemsToShow = Math.floor(
      modulate(size4, [minSizePx, maxSizePx], [minItems, maxItems], true)
    );
    let mainItemCount = 0;
    let newActiveOverflowItem = null;
    let shouldInvalidateLastActiveOverflowItem = false;
    const numberedButtons = [];
    function visitItems(mainItems2, overflowItems2) {
      if (overflowItems2) assert(mainItems2.length === overflowItems2.length);
      let didShowAnyInMain = false;
      let didShowAnyInOverflow2 = false;
      for (let i = 0; i < mainItems2.length; i++) {
        const mainItem = mainItems2[i];
        const overflowItem = overflowItems2 == null ? void 0 : overflowItems2[i];
        if (mainItem.type === "item") {
          const isLastActiveOverflowItem = mainItem.element.getAttribute("data-value") === lastActiveOverflowItem;
          let shouldShowInMain;
          if (lastActiveOverflowItem) {
            shouldShowInMain = mainItemCount < itemsToShow || isLastActiveOverflowItem;
          } else {
            shouldShowInMain = mainItemCount <= itemsToShow;
          }
          const shouldShowInOverflow = mainItemCount >= itemsToShow;
          didShowAnyInMain || (didShowAnyInMain = shouldShowInMain);
          didShowAnyInOverflow2 || (didShowAnyInOverflow2 = shouldShowInOverflow);
          setAttribute(
            mainItem.element,
            "data-toolbar-visible",
            shouldShowInMain ? "true" : "false"
          );
          if (overflowItem) {
            assert(overflowItem.type === "item");
            setAttribute(
              overflowItem.element,
              "data-toolbar-visible",
              shouldShowInOverflow ? "true" : "false"
            );
          }
          if (shouldShowInOverflow && mainItem.element.getAttribute("aria-pressed") === "true") {
            newActiveOverflowItem = mainItem.element.getAttribute("data-value");
          }
          if (shouldShowInMain && mainItem.element.tagName === "BUTTON") {
            numberedButtons.push(mainItem.element);
          }
          if (!shouldShowInOverflow && isLastActiveOverflowItem) {
            shouldInvalidateLastActiveOverflowItem = true;
          }
          mainItemCount++;
        } else {
          let result, overflowGroup;
          if (overflowItem) {
            assert(overflowItem.type === "group");
            overflowGroup = overflowItem;
            result = visitItems(mainItem.items, overflowGroup.items);
          } else {
            result = visitItems(mainItem.items, null);
          }
          didShowAnyInMain || (didShowAnyInMain = result.didShowAnyInMain);
          didShowAnyInOverflow2 || (didShowAnyInOverflow2 = result.didShowAnyInOverflow);
          setAttribute(
            mainItem.element,
            "data-toolbar-visible",
            result.didShowAnyInMain ? "true" : "false"
          );
          if (overflowGroup) {
            setAttribute(
              overflowGroup.element,
              "data-toolbar-visible",
              result.didShowAnyInOverflow ? "true" : "false"
            );
          }
        }
      }
      return { didShowAnyInMain, didShowAnyInOverflow: didShowAnyInOverflow2 };
    }
    const { didShowAnyInOverflow } = visitItems(mainItems, overflowItems);
    setShouldShowOverflow(didShowAnyInOverflow);
    if (newActiveOverflowItem) {
      setLastActiveOverflowItem(newActiveOverflowItem);
    } else if (shouldInvalidateLastActiveOverflowItem) {
      setLastActiveOverflowItem(null);
    }
    rButtons.current = numberedButtons;
  });
  (0, import_react117.useLayoutEffect)(() => {
    onDomUpdate();
  });
  (0, import_react117.useLayoutEffect)(() => {
    if (!mainToolsRef.current) return;
    const mutationObserver = new MutationObserver(onDomUpdate);
    mutationObserver.observe(mainToolsRef.current, {
      childList: true,
      subtree: true,
      attributes: true,
      characterData: true
    });
    const sizingParent = findParentWithClassName(mainToolsRef.current, sizingParentClassName);
    const resizeObserver = new ResizeObserver(onDomUpdate);
    resizeObserver.observe(sizingParent);
    return () => {
      mutationObserver.disconnect();
      resizeObserver.disconnect();
    };
  }, [onDomUpdate, sizingParentClassName]);
  (0, import_react117.useEffect)(() => {
    if (!editor.options.enableToolbarKeyboardShortcuts) return;
    function handleKeyDown2(event) {
      var _a6;
      if (areShortcutsDisabled3(editor) || activeElementShouldCaptureKeys(
        true
        /* allow buttons */
      )) {
        return;
      }
      if (event.ctrlKey || event.metaKey || event.altKey || event.shiftKey) return;
      const index2 = NUMBERED_SHORTCUT_KEYS[event.key];
      if (typeof index2 === "number") {
        preventDefault(event);
        (_a6 = rButtons.current[index2]) == null ? void 0 : _a6.click();
      }
    }
    document.addEventListener("keydown", handleKeyDown2);
    return () => {
      document.removeEventListener("keydown", handleKeyDown2);
    };
  }, [editor]);
  const popoverId = "toolbar overflow";
  const Layout2 = orientation === "horizontal" ? TldrawUiRow : TldrawUiColumn;
  return (0, import_jsx_runtime175.jsx)(import_jsx_runtime175.Fragment, { children: (0, import_jsx_runtime175.jsxs)(
    TldrawUiToolbar,
    {
      orientation,
      className: (0, import_classnames27.default)("tlui-main-toolbar__tools", {
        "tlui-main-toolbar__tools__mobile": breakpoint < PORTRAIT_BREAKPOINT.TABLET_SM
      }),
      label: msg2("tool-panel.title"),
      children: [
        (0, import_jsx_runtime175.jsx)(Layout2, { id: `${id}_main`, ref: mainToolsRef, children: (0, import_jsx_runtime175.jsx)(TldrawUiMenuContextProvider, { type: "toolbar", sourceId: "toolbar", children }) }),
        shouldShowOverflow && (0, import_jsx_runtime175.jsx)(IsInOverflowContext.Provider, { value: true, children: (0, import_jsx_runtime175.jsxs)(TldrawUiPopover, { id: popoverId, open: isOpen, onOpenChange: setIsOpen, children: [
          (0, import_jsx_runtime175.jsx)(TldrawUiPopoverTrigger, { children: (0, import_jsx_runtime175.jsx)(
            TldrawUiToolbarButton,
            {
              title: msg2("tool-panel.more"),
              type: "tool",
              className: "tlui-main-toolbar__overflow",
              "data-testid": "tools.more-button",
              children: (0, import_jsx_runtime175.jsx)(
                TldrawUiButtonIcon,
                {
                  icon: orientation === "horizontal" ? "chevron-up" : "chevron-right"
                }
              )
            }
          ) }),
          (0, import_jsx_runtime175.jsx)(
            TldrawUiPopoverContent,
            {
              side: orientation === "horizontal" ? "top" : "right",
              align: orientation === "horizontal" ? "center" : "end",
              children: (0, import_jsx_runtime175.jsx)(
                TldrawUiToolbar,
                {
                  orientation: "grid",
                  className: "tlui-main-toolbar__overflow-content",
                  ref: setOverflowTools,
                  "data-testid": "tools.more-content",
                  label: msg2("tool-panel.more"),
                  id: `${id}_more`,
                  onClick: () => {
                    tlmenus.deleteOpenMenu(popoverId, editor.contextId);
                    setIsOpen(false);
                  },
                  children: (0, import_jsx_runtime175.jsx)(TldrawUiMenuContextProvider, { type: "toolbar-overflow", sourceId: "toolbar", children })
                }
              )
            }
          )
        ] }) })
      ]
    }
  ) });
}
function findParentWithClassName(startingElement, className) {
  let element = startingElement;
  while (element) {
    if (element.classList.contains(className)) {
      return element;
    }
    element = element.parentElement;
  }
  throw new Error("Could not find parent with class name " + className);
}
function setAttribute(element, name, value) {
  if (element.getAttribute(name) === value) return;
  element.setAttribute(name, value);
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/ToggleToolLockedButton.mjs
var import_jsx_runtime176 = __toESM(require_jsx_runtime(), 1);
var import_classnames28 = __toESM(require_classnames(), 1);
function ToggleToolLockedButton({ activeToolId }) {
  const editor = useEditor();
  const breakpoint = useBreakpoint();
  const msg2 = useTranslation();
  const actions = useActions();
  const isToolLocked = useValue("is tool locked", () => editor.getInstanceState().isToolLocked, [
    editor
  ]);
  const tool = useValue("current tool", () => editor.getCurrentTool(), [editor]);
  if (!activeToolId || !tool.isLockable) return null;
  const toggleLockAction = actions["toggle-tool-lock"];
  const tooltipContent = (toggleLockAction == null ? void 0 : toggleLockAction.kbd) ? `${msg2("action.toggle-tool-lock")} ${kbdStr(toggleLockAction.kbd)}` : msg2("action.toggle-tool-lock");
  return (0, import_jsx_runtime176.jsx)(TldrawUiTooltip, { content: tooltipContent, children: (0, import_jsx_runtime176.jsx)(
    TldrawUiButton,
    {
      type: "normal",
      "data-testid": "tool-lock",
      className: (0, import_classnames28.default)("tlui-main-toolbar__lock-button", {
        "tlui-main-toolbar__lock-button__mobile": breakpoint < PORTRAIT_BREAKPOINT.TABLET_SM
      }),
      onClick: () => editor.updateInstanceState({ isToolLocked: !isToolLocked }),
      children: (0, import_jsx_runtime176.jsx)(TldrawUiButtonIcon, { icon: isToolLocked ? "lock" : "unlock", small: true })
    }
  ) });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/DefaultToolbar.mjs
var DefaultToolbar = (0, import_react118.memo)(function DefaultToolbar2({
  children,
  orientation = "horizontal",
  minItems = 4,
  minSizePx = 310,
  maxItems = 8,
  maxSizePx = 470
}) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const breakpoint = useBreakpoint();
  const isReadonlyMode = useReadonly();
  const activeToolId = useValue("current tool id", () => editor.getCurrentToolId(), [editor]);
  const ref = (0, import_react118.useRef)(null);
  usePassThroughWheelEvents(ref);
  const { ActionsMenu, QuickActions } = useTldrawUiComponents();
  const showQuickActions = editor.options.actionShortcutsLocation === "menu" ? false : editor.options.actionShortcutsLocation === "toolbar" ? true : breakpoint < PORTRAIT_BREAKPOINT.TABLET;
  return (0, import_jsx_runtime177.jsx)(
    TldrawUiOrientationProvider,
    {
      orientation,
      tooltipSide: orientation === "horizontal" ? "top" : "right",
      children: (0, import_jsx_runtime177.jsx)(
        "div",
        {
          ref,
          className: (0, import_classnames29.default)("tlui-main-toolbar", `tlui-main-toolbar--${orientation}`),
          children: (0, import_jsx_runtime177.jsxs)("div", { className: "tlui-main-toolbar__inner", children: [
            (0, import_jsx_runtime177.jsxs)("div", { className: "tlui-main-toolbar__left", children: [
              !isReadonlyMode && (0, import_jsx_runtime177.jsxs)("div", { className: "tlui-main-toolbar__extras", children: [
                showQuickActions && (0, import_jsx_runtime177.jsxs)(
                  TldrawUiToolbar,
                  {
                    orientation,
                    className: "tlui-main-toolbar__extras__controls",
                    label: msg2("actions-menu.title"),
                    children: [
                      QuickActions && (0, import_jsx_runtime177.jsx)(QuickActions, {}),
                      ActionsMenu && (0, import_jsx_runtime177.jsx)(ActionsMenu, {})
                    ]
                  }
                ),
                (0, import_jsx_runtime177.jsx)(ToggleToolLockedButton, { activeToolId })
              ] }),
              (0, import_jsx_runtime177.jsx)(
                OverflowingToolbar,
                {
                  orientation,
                  sizingParentClassName: "tlui-main-toolbar",
                  minItems,
                  maxItems,
                  minSizePx,
                  maxSizePx,
                  children: children ?? (0, import_jsx_runtime177.jsx)(DefaultToolbarContent, {})
                }
              )
            ] }),
            breakpoint < PORTRAIT_BREAKPOINT.TABLET_SM && !isReadonlyMode && (0, import_jsx_runtime177.jsx)("div", { className: "tlui-main-toolbar__tools tlui-main-toolbar__mobile-style-panel", children: (0, import_jsx_runtime177.jsx)(MobileStylePanel, {}) })
          ] })
        }
      )
    }
  );
});

// ../node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/DefaultVideoToolbar.mjs
var import_jsx_runtime179 = __toESM(require_jsx_runtime(), 1);
var import_react120 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/DefaultVideoToolbarContent.mjs
var import_jsx_runtime178 = __toESM(require_jsx_runtime(), 1);
var import_react119 = __toESM(require_react(), 1);
var DefaultVideoToolbarContent = track(function DefaultVideoToolbarContent2({
  videoShapeId,
  onEditAltTextStart
}) {
  const editor = useEditor();
  const trackEvent = useUiEvents();
  const msg2 = useTranslation();
  const source = "video-toolbar";
  const isReadonly = editor.getIsReadonly();
  const actions = useActions();
  const handleVideoReplace = (0, import_react119.useCallback)(
    () => actions["video-replace"].onSelect("video-toolbar"),
    [actions]
  );
  const handleVideoDownload = (0, import_react119.useCallback)(
    () => actions["download-original"].onSelect("video-toolbar"),
    [actions]
  );
  const altText = useValue(
    "altText",
    () => editor.getShape(videoShapeId).props.altText,
    [editor, videoShapeId]
  );
  return (0, import_jsx_runtime178.jsxs)(import_jsx_runtime178.Fragment, { children: [
    !isReadonly && (0, import_jsx_runtime178.jsx)(
      TldrawUiButton,
      {
        type: "icon",
        title: msg2("tool.replace-media"),
        onClick: handleVideoReplace,
        "data-testid": "tool.video-replace",
        children: (0, import_jsx_runtime178.jsx)(TldrawUiButtonIcon, { small: true, icon: "tool-media" })
      }
    ),
    (0, import_jsx_runtime178.jsx)(
      TldrawUiButton,
      {
        type: "icon",
        title: msg2("action.download-original"),
        onClick: handleVideoDownload,
        "data-testid": "tool.video-download",
        children: (0, import_jsx_runtime178.jsx)(TldrawUiButtonIcon, { small: true, icon: "download" })
      }
    ),
    (altText || !isReadonly) && (0, import_jsx_runtime178.jsx)(
      TldrawUiToolbarButton,
      {
        type: "icon",
        isActive: !!altText,
        title: msg2("tool.media-alt-text"),
        "data-testid": "tool.video-alt-text",
        onClick: () => {
          trackEvent("alt-text-start", { source });
          onEditAltTextStart();
        },
        children: (0, import_jsx_runtime178.jsx)(TldrawUiButtonIcon, { small: true, icon: "alt" })
      }
    )
  ] });
});

// ../node_modules/tldraw/dist-esm/lib/ui/components/Toolbar/DefaultVideoToolbar.mjs
var DefaultVideoToolbar = track(function DefaultVideoToolbar2({
  children
}) {
  const editor = useEditor();
  const videoShapeId = useValue(
    "videoShape",
    () => {
      const onlySelectedShape = editor.getOnlySelectedShape();
      if (!onlySelectedShape || onlySelectedShape.type !== "video") return null;
      return onlySelectedShape.id;
    },
    [editor]
  );
  const showToolbar = editor.isInAny("select.idle", "select.pointing_shape");
  const isLocked = useValue(
    "locked",
    () => {
      var _a6;
      return videoShapeId ? (_a6 = editor.getShape(videoShapeId)) == null ? void 0 : _a6.isLocked : false;
    },
    [editor, videoShapeId]
  );
  if (!videoShapeId || !showToolbar || isLocked) return null;
  return (0, import_jsx_runtime179.jsx)(ContextualToolbarInner3, { videoShapeId, children }, videoShapeId);
});
function ContextualToolbarInner3({
  children,
  videoShapeId
}) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const [isEditingAltText, setIsEditingAltText] = (0, import_react120.useState)(false);
  const handleEditAltTextStart = (0, import_react120.useCallback)(() => setIsEditingAltText(true), []);
  const onEditAltTextClose = (0, import_react120.useCallback)(() => setIsEditingAltText(false), []);
  const getSelectionBounds = (0, import_react120.useCallback)(() => {
    const fullBounds = editor.getSelectionScreenBounds();
    if (!fullBounds) return void 0;
    return new Box(fullBounds.x, fullBounds.y, fullBounds.width, 0);
  }, [editor]);
  return (0, import_jsx_runtime179.jsx)(
    TldrawUiContextualToolbar,
    {
      className: "tlui-video__toolbar",
      getSelectionBounds,
      label: msg2("tool.video-toolbar-title"),
      children: children ? children : isEditingAltText ? (0, import_jsx_runtime179.jsx)(AltTextEditor, { shapeId: videoShapeId, onClose: onEditAltTextClose, source: "video-toolbar" }) : (0, import_jsx_runtime179.jsx)(
        DefaultVideoToolbarContent,
        {
          videoShapeId,
          onEditAltTextStart: handleEditAltTextStart
        }
      )
    }
  );
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/ZoomMenu/DefaultZoomMenu.mjs
var import_jsx_runtime181 = __toESM(require_jsx_runtime(), 1);
var import_react121 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/components/ZoomMenu/DefaultZoomMenuContent.mjs
var import_jsx_runtime180 = __toESM(require_jsx_runtime(), 1);
function DefaultZoomMenuContent() {
  return (0, import_jsx_runtime180.jsxs)(import_jsx_runtime180.Fragment, { children: [
    (0, import_jsx_runtime180.jsx)(TldrawUiMenuActionItem, { actionId: "zoom-in", noClose: true }),
    (0, import_jsx_runtime180.jsx)(TldrawUiMenuActionItem, { actionId: "zoom-out", noClose: true }),
    (0, import_jsx_runtime180.jsx)(ZoomTo100MenuItem, {}),
    (0, import_jsx_runtime180.jsx)(ZoomToFitMenuItem, {}),
    (0, import_jsx_runtime180.jsx)(ZoomToSelectionMenuItem, {})
  ] });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/ZoomMenu/DefaultZoomMenu.mjs
var DefaultZoomMenu = (0, import_react121.memo)(function DefaultZoomMenu2({ children }) {
  const container = useContainer();
  const [isOpen, onOpenChange] = useMenuIsOpen("zoom menu");
  const content = children ?? (0, import_jsx_runtime181.jsx)(DefaultZoomMenuContent, {});
  return (0, import_jsx_runtime181.jsxs)(dist_exports10.Root, { dir: "ltr", open: isOpen, onOpenChange, modal: false, children: [
    (0, import_jsx_runtime181.jsx)(ZoomTriggerButton, {}),
    (0, import_jsx_runtime181.jsx)(dist_exports10.Portal, { container, children: (0, import_jsx_runtime181.jsx)(
      dist_exports10.Content,
      {
        className: "tlui-menu",
        side: "top",
        align: "start",
        alignOffset: 0,
        sideOffset: 8,
        collisionPadding: 4,
        children: (0, import_jsx_runtime181.jsx)(TldrawUiMenuContextProvider, { type: "menu", sourceId: "zoom-menu", children: content })
      }
    ) })
  ] });
});
var ZoomTriggerButton = () => {
  const editor = useEditor();
  const breakpoint = useBreakpoint();
  const zoom = useValue("zoom", () => editor.getZoomLevel(), [editor]);
  const msg2 = useTranslation();
  const handleDoubleClick2 = (0, import_react121.useCallback)(() => {
    editor.resetZoom(editor.getViewportScreenCenter(), {
      animation: { duration: editor.options.animationMediumMs }
    });
  }, [editor]);
  const value = `${Math.floor(zoom * 100)}%`;
  return (0, import_jsx_runtime181.jsx)(
    TldrawUiToolbarButton,
    {
      asChild: true,
      type: "icon",
      "aria-label": `${msg2("navigation-zone.zoom")} — ${value}`,
      title: `${msg2("navigation-zone.zoom")} — ${value}`,
      "data-testid": "minimap.zoom-menu-button",
      className: "tlui-zoom-menu__button",
      onDoubleClick: handleDoubleClick2,
      children: (0, import_jsx_runtime181.jsx)(dist_exports10.Trigger, { dir: "ltr", children: breakpoint < PORTRAIT_BREAKPOINT.MOBILE ? null : (0, import_jsx_runtime181.jsx)("span", { style: { flexGrow: 0, textAlign: "center" }, children: value }) })
    }
  );
};

// ../node_modules/tldraw/dist-esm/lib/ui/context/components.mjs
var TldrawUiComponentsContext = (0, import_react122.createContext)(null);
function TldrawUiComponentsProvider({
  overrides = {},
  children
}) {
  const _overrides = useShallowObjectIdentity(overrides);
  const showCollaborationUi = useShowCollaborationUi();
  return (0, import_jsx_runtime182.jsx)(
    TldrawUiComponentsContext.Provider,
    {
      value: (0, import_react122.useMemo)(
        () => ({
          ContextMenu: DefaultContextMenu,
          ActionsMenu: DefaultActionsMenu,
          HelpMenu: null,
          ZoomMenu: DefaultZoomMenu,
          MainMenu: DefaultMainMenu,
          Minimap: DefaultMinimap,
          StylePanel: DefaultStylePanel,
          PageMenu: DefaultPageMenu,
          NavigationPanel: DefaultNavigationPanel,
          Toolbar: DefaultToolbar,
          RichTextToolbar: DefaultRichTextToolbar,
          ImageToolbar: DefaultImageToolbar,
          VideoToolbar: DefaultVideoToolbar,
          KeyboardShortcutsDialog: DefaultKeyboardShortcutsDialog,
          QuickActions: DefaultQuickActions,
          HelperButtons: DefaultHelperButtons,
          DebugPanel: DefaultDebugPanel,
          DebugMenu: DefaultDebugMenu,
          MenuPanel: DefaultMenuPanel,
          SharePanel: showCollaborationUi ? DefaultSharePanel : null,
          CursorChatBubble: showCollaborationUi ? CursorChatBubble : null,
          TopPanel: null,
          Dialogs: DefaultDialogs,
          Toasts: DefaultToasts,
          A11y: DefaultA11yAnnouncer,
          FollowingIndicator: DefaultFollowingIndicator,
          ..._overrides
        }),
        [_overrides, showCollaborationUi]
      ),
      children
    }
  );
}
function useTldrawUiComponents() {
  const components = (0, import_react122.useContext)(TldrawUiComponentsContext);
  if (!components) {
    throw new Error("useTldrawUiComponents must be used within a TldrawUiComponentsProvider");
  }
  return components;
}

// ../node_modules/tldraw/dist-esm/lib/ui/context/actions.mjs
var ActionsContext = React97.createContext(null);
function supportsDownloadingOriginal(shape, editor) {
  return (editor.isShapeOfType(shape, "image") || editor.isShapeOfType(shape, "video")) && !!shape.props.assetId;
}
function makeActions(actions) {
  return Object.fromEntries(actions.map((action) => [action.id, action]));
}
function getExportName(editor, defaultName) {
  const selectedShapes = editor.getSelectedShapes();
  if (selectedShapes.length === 0) {
    return editor.getDocumentSettings().name || defaultName;
  }
  return void 0;
}
function ActionsProvider({ overrides, children }) {
  const _editor = useMaybeEditor();
  const showCollaborationUi = useShowCollaborationUi();
  const helpers = useDefaultHelpers();
  const components = useTldrawUiComponents();
  const trackEvent = useUiEvents();
  const a11y = useA11y();
  const msg2 = useTranslation();
  const defaultDocumentName = helpers.msg("document.default-name");
  const actions = React97.useMemo(() => {
    const editor = _editor;
    if (!editor) return {};
    function mustGoBackToSelectToolFirst() {
      if (!editor.isIn("select")) {
        editor.complete();
        editor.setCurrentTool("select");
        return false;
      }
      return false;
    }
    function canApplySelectionAction() {
      return editor.isIn("select") && editor.getSelectedShapeIds().length > 0;
    }
    function scaleShapes(scaleFactor) {
      if (!canApplySelectionAction()) return;
      if (mustGoBackToSelectToolFirst()) return;
      editor.markHistoryStoppingPoint("resize shapes");
      const selectedShapeIds = editor.getSelectedShapeIds();
      if (selectedShapeIds.length === 0) return;
      editor.run(() => {
        const shapes = selectedShapeIds.map((id) => editor.getShape(id)).filter(Boolean);
        shapes.forEach((shape) => {
          var _a6;
          editor.resizeShape(shape.id, new Vec(scaleFactor, scaleFactor), {
            scaleOrigin: (_a6 = editor.getSelectionPageBounds()) == null ? void 0 : _a6.center
          });
        });
      });
    }
    const actionItems = [
      {
        id: "edit-link",
        label: "action.edit-link",
        icon: "link",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("edit-link", { source });
          editor.markHistoryStoppingPoint("edit-link");
          helpers.addDialog({ component: EditLinkDialog });
        }
      },
      {
        id: "insert-embed",
        label: "action.insert-embed",
        kbd: "cmd+i,ctrl+i",
        onSelect(source) {
          trackEvent("insert-embed", { source });
          helpers.addDialog({ component: EmbedDialog });
        }
      },
      {
        id: "open-kbd-shortcuts",
        label: "action.open-kbd-shortcuts",
        kbd: "cmd+alt+/,ctrl+alt+/",
        onSelect(source) {
          trackEvent("open-kbd-shortcuts", { source });
          helpers.addDialog({
            component: components.KeyboardShortcutsDialog ?? DefaultKeyboardShortcutsDialog
          });
        }
      },
      {
        id: "insert-media",
        label: "action.insert-media",
        kbd: "cmd+u,ctrl+u",
        onSelect(source) {
          trackEvent("insert-media", { source });
          helpers.insertMedia();
        }
      },
      {
        id: "undo",
        label: "action.undo",
        icon: "undo",
        kbd: "cmd+z,ctrl+z",
        onSelect(source) {
          trackEvent("undo", { source });
          editor.undo();
        }
      },
      {
        id: "redo",
        label: "action.redo",
        icon: "redo",
        kbd: "cmd+shift+z,ctrl+shift+z",
        onSelect(source) {
          trackEvent("redo", { source });
          editor.redo();
        }
      },
      {
        id: "export-as-svg",
        label: {
          default: "action.export-as-svg",
          menu: "action.export-as-svg.short",
          ["context-menu"]: "action.export-as-svg.short"
        },
        readonlyOk: true,
        onSelect(source) {
          let ids = editor.getSelectedShapeIds();
          if (ids.length === 0) ids = Array.from(editor.getCurrentPageShapeIds().values());
          if (ids.length === 0) return;
          trackEvent("export-as", { format: "svg", source });
          helpers.exportAs(ids, { format: "svg", name: getExportName(editor, defaultDocumentName) });
        }
      },
      {
        id: "export-as-png",
        label: {
          default: "action.export-as-png",
          menu: "action.export-as-png.short",
          ["context-menu"]: "action.export-as-png.short"
        },
        readonlyOk: true,
        onSelect(source) {
          let ids = editor.getSelectedShapeIds();
          if (ids.length === 0) ids = Array.from(editor.getCurrentPageShapeIds().values());
          if (ids.length === 0) return;
          trackEvent("export-as", { format: "png", source });
          helpers.exportAs(ids, { format: "png", name: getExportName(editor, defaultDocumentName) });
        }
      },
      {
        id: "export-all-as-svg",
        label: {
          default: "action.export-all-as-svg",
          menu: "action.export-all-as-svg.short",
          ["context-menu"]: "action.export-all-as-svg.short"
        },
        readonlyOk: true,
        onSelect(source) {
          let ids = editor.getSelectedShapeIds();
          if (ids.length === 0) ids = Array.from(editor.getCurrentPageShapeIds().values());
          if (ids.length === 0) return;
          trackEvent("export-all-as", { format: "svg", source });
          helpers.exportAs(Array.from(editor.getCurrentPageShapeIds()), {
            format: "svg",
            name: getExportName(editor, defaultDocumentName)
          });
        }
      },
      {
        id: "export-all-as-png",
        label: {
          default: "action.export-all-as-png",
          menu: "action.export-all-as-png.short",
          ["context-menu"]: "action.export-all-as-png.short"
        },
        readonlyOk: true,
        onSelect(source) {
          const ids = Array.from(editor.getCurrentPageShapeIds().values());
          if (ids.length === 0) return;
          trackEvent("export-all-as", { format: "png", source });
          helpers.exportAs(ids, { format: "png", name: getExportName(editor, defaultDocumentName) });
        }
      },
      {
        id: "copy-as-svg",
        label: {
          default: "action.copy-as-svg",
          menu: "action.copy-as-svg.short",
          ["context-menu"]: "action.copy-as-svg.short"
        },
        kbd: "cmd+shift+c,ctrl+shift+c",
        readonlyOk: true,
        onSelect(source) {
          let ids = editor.getSelectedShapeIds();
          if (ids.length === 0) ids = Array.from(editor.getCurrentPageShapeIds().values());
          if (ids.length === 0) return;
          trackEvent("copy-as", { format: "svg", source });
          helpers.copyAs(ids, "svg");
        }
      },
      {
        id: "copy-as-png",
        label: {
          default: "action.copy-as-png",
          menu: "action.copy-as-png.short",
          ["context-menu"]: "action.copy-as-png.short"
        },
        readonlyOk: true,
        onSelect(source) {
          let ids = editor.getSelectedShapeIds();
          if (ids.length === 0) ids = Array.from(editor.getCurrentPageShapeIds().values());
          if (ids.length === 0) return;
          trackEvent("copy-as", { format: "png", source });
          helpers.copyAs(ids, "png");
        }
      },
      {
        id: "toggle-auto-size",
        label: "action.toggle-auto-size",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("toggle-auto-size", { source });
          editor.markHistoryStoppingPoint("toggling auto size");
          editor.run(() => {
            const shapes = editor.getSelectedShapes().filter(
              (shape) => editor.isShapeOfType(shape, "text") && shape.props.autoSize === false
            );
            editor.updateShapes(
              shapes.map((shape) => {
                return {
                  id: shape.id,
                  type: shape.type,
                  props: {
                    ...shape.props,
                    w: 8,
                    autoSize: true
                  }
                };
              })
            );
            kickoutOccludedShapes(
              editor,
              shapes.map((shape) => shape.id)
            );
          });
        }
      },
      {
        id: "open-embed-link",
        label: "action.open-embed-link",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("open-embed-link", { source });
          const ids = editor.getSelectedShapeIds();
          const warnMsg = "No embed shapes selected";
          if (ids.length !== 1) {
            console.error(warnMsg);
            return;
          }
          const shape = editor.getShape(ids[0]);
          if (!shape || !editor.isShapeOfType(shape, "embed")) {
            console.error(warnMsg);
            return;
          }
          openWindow(shape.props.url, "_blank");
        }
      },
      {
        id: "select-zoom-tool",
        readonlyOk: true,
        kbd: "z",
        onSelect(source) {
          var _a6, _b3;
          if (((_a6 = editor.root.getCurrent()) == null ? void 0 : _a6.id) === "zoom") return;
          trackEvent("zoom-tool", { source });
          if (!(editor.inputs.getShiftKey() || editor.inputs.getCtrlKey())) {
            const currentTool = editor.root.getCurrent();
            if (currentTool && ((_b3 = currentTool.getCurrent()) == null ? void 0 : _b3.id) === "idle") {
              editor.setCurrentTool("zoom", { onInteractionEnd: currentTool.id, maskAs: "zoom" });
            }
          }
        }
      },
      {
        id: "convert-to-bookmark",
        label: "action.convert-to-bookmark",
        async onSelect(source) {
          var _a6;
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("convert-to-bookmark", { source });
          const shapes = editor.getSelectedShapes();
          const markId = editor.markHistoryStoppingPoint("convert shapes to bookmark");
          const creationPromises = [];
          for (const shape of shapes) {
            if (!shape || !editor.isShapeOfType(shape, "embed") || !shape.props.url) continue;
            const center = (_a6 = editor.getShapePageBounds(shape)) == null ? void 0 : _a6.center;
            if (!center) continue;
            editor.deleteShapes([shape.id]);
            creationPromises.push(
              createBookmarkFromUrl(editor, { url: shape.props.url, center }).then((res) => {
                if (!res.ok) {
                  throw new Error(res.error);
                }
                return res;
              })
            );
          }
          await Promise.all(creationPromises).catch((error) => {
            editor.bailToMark(markId);
            console.error(error);
          });
        }
      },
      {
        id: "convert-to-embed",
        label: "action.convert-to-embed",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("convert-to-embed", { source });
          editor.run(() => {
            const ids = editor.getSelectedShapeIds();
            const shapes = compact(ids.map((id) => editor.getShape(id)));
            const createList = [];
            const deleteList = [];
            for (const shape of shapes) {
              if (!editor.isShapeOfType(shape, "bookmark")) continue;
              const { url } = shape.props;
              const embedInfo = helpers.getEmbedDefinition(url);
              if (!embedInfo) continue;
              if (!embedInfo.definition) continue;
              const { width, height } = embedInfo.definition;
              const newPos = new Vec(shape.x, shape.y);
              newPos.rot(-shape.rotation);
              newPos.add(new Vec(shape.props.w / 2 - width / 2, shape.props.h / 2 - height / 2));
              newPos.rot(shape.rotation);
              const shapeToCreate = {
                id: createShapeId(),
                type: "embed",
                x: newPos.x,
                y: newPos.y,
                rotation: shape.rotation,
                props: {
                  url,
                  w: width,
                  h: height
                }
              };
              createList.push(shapeToCreate);
              deleteList.push(shape.id);
            }
            editor.markHistoryStoppingPoint("convert shapes to embed");
            editor.deleteShapes(deleteList);
            editor.createShapes(createList);
          });
        }
      },
      {
        id: "duplicate",
        kbd: "cmd+d,ctrl+d",
        label: "action.duplicate",
        icon: "duplicate",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("duplicate-shapes", { source });
          const instanceState = editor.getInstanceState();
          let ids;
          let offset4;
          if (instanceState.duplicateProps) {
            ids = instanceState.duplicateProps.shapeIds;
            offset4 = instanceState.duplicateProps.offset;
          } else {
            ids = editor.getSelectedShapeIds();
            const commonBounds = Box.Common(compact(ids.map((id) => editor.getShapePageBounds(id))));
            offset4 = editor.getCameraOptions().isLocked ? {
              // same as the adjacent note margin
              x: editor.options.adjacentShapeMargin,
              y: editor.options.adjacentShapeMargin
            } : {
              x: commonBounds.width + editor.options.adjacentShapeMargin,
              y: 0
            };
          }
          editor.markHistoryStoppingPoint("duplicate shapes");
          editor.duplicateShapes(ids, offset4);
          if (instanceState.duplicateProps) {
            editor.updateInstanceState({
              duplicateProps: {
                ...instanceState.duplicateProps,
                shapeIds: editor.getSelectedShapeIds()
              }
            });
          }
        }
      },
      {
        id: "ungroup",
        label: "action.ungroup",
        kbd: "cmd+shift+g,ctrl+shift+g",
        icon: "ungroup",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("ungroup-shapes", { source });
          editor.markHistoryStoppingPoint("ungroup");
          editor.ungroupShapes(editor.getSelectedShapeIds());
        }
      },
      {
        id: "group",
        label: "action.group",
        kbd: "cmd+g,ctrl+g",
        icon: "group",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("group-shapes", { source });
          const onlySelectedShape = editor.getOnlySelectedShape();
          if (onlySelectedShape && editor.isShapeOfType(onlySelectedShape, "group")) {
            editor.markHistoryStoppingPoint("ungroup");
            editor.ungroupShapes(editor.getSelectedShapeIds());
          } else {
            editor.markHistoryStoppingPoint("group");
            editor.groupShapes(editor.getSelectedShapeIds());
          }
        }
      },
      {
        id: "remove-frame",
        label: "action.remove-frame",
        kbd: "cmd+shift+f,ctrl+shift+f",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          trackEvent("remove-frame", { source });
          const selectedShapes = editor.getSelectedShapes();
          if (selectedShapes.length > 0 && selectedShapes.every((shape) => editor.isShapeOfType(shape, "frame"))) {
            editor.markHistoryStoppingPoint("remove-frame");
            removeFrame(
              editor,
              selectedShapes.map((shape) => shape.id)
            );
          }
        }
      },
      {
        id: "fit-frame-to-content",
        label: "action.fit-frame-to-content",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          trackEvent("fit-frame-to-content", { source });
          const onlySelectedShape = editor.getOnlySelectedShape();
          if (onlySelectedShape && editor.isShapeOfType(onlySelectedShape, "frame")) {
            editor.markHistoryStoppingPoint("fit-frame-to-content");
            fitFrameToContent(editor, onlySelectedShape.id);
          }
        }
      },
      {
        id: "align-left",
        label: "action.align-left",
        kbd: "alt+A",
        icon: "align-left",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("align-shapes", { operation: "left", source });
          editor.markHistoryStoppingPoint("align left");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.alignShapes(selectedShapeIds, "left");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "align-center-horizontal",
        label: {
          default: "action.align-center-horizontal",
          ["context-menu"]: "action.align-center-horizontal.short"
        },
        kbd: "alt+H",
        icon: "align-center-horizontal",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("align-shapes", { operation: "center-horizontal", source });
          editor.markHistoryStoppingPoint("align center horizontal");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.alignShapes(selectedShapeIds, "center-horizontal");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "align-right",
        label: "action.align-right",
        kbd: "alt+D",
        icon: "align-right",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("align-shapes", { operation: "right", source });
          editor.markHistoryStoppingPoint("align right");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.alignShapes(selectedShapeIds, "right");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "align-center-vertical",
        label: {
          default: "action.align-center-vertical",
          ["context-menu"]: "action.align-center-vertical.short"
        },
        kbd: "alt+V",
        icon: "align-center-vertical",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("align-shapes", { operation: "center-vertical", source });
          editor.markHistoryStoppingPoint("align center vertical");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.alignShapes(selectedShapeIds, "center-vertical");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "align-top",
        label: "action.align-top",
        icon: "align-top",
        kbd: "alt+W",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("align-shapes", { operation: "top", source });
          editor.markHistoryStoppingPoint("align top");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.alignShapes(selectedShapeIds, "top");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "align-bottom",
        label: "action.align-bottom",
        icon: "align-bottom",
        kbd: "alt+S",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("align-shapes", { operation: "bottom", source });
          editor.markHistoryStoppingPoint("align bottom");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.alignShapes(selectedShapeIds, "bottom");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "distribute-horizontal",
        label: {
          default: "action.distribute-horizontal",
          ["context-menu"]: "action.distribute-horizontal.short"
        },
        icon: "distribute-horizontal",
        kbd: "alt+shift+h",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("distribute-shapes", { operation: "horizontal", source });
          editor.markHistoryStoppingPoint("distribute horizontal");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.distributeShapes(selectedShapeIds, "horizontal");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "distribute-vertical",
        label: {
          default: "action.distribute-vertical",
          ["context-menu"]: "action.distribute-vertical.short"
        },
        icon: "distribute-vertical",
        kbd: "alt+shift+V",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("distribute-shapes", { operation: "vertical", source });
          editor.markHistoryStoppingPoint("distribute vertical");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.distributeShapes(selectedShapeIds, "vertical");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "stretch-horizontal",
        label: {
          default: "action.stretch-horizontal",
          ["context-menu"]: "action.stretch-horizontal.short"
        },
        icon: "stretch-horizontal",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("stretch-shapes", { operation: "horizontal", source });
          editor.markHistoryStoppingPoint("stretch horizontal");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.stretchShapes(selectedShapeIds, "horizontal");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "stretch-vertical",
        label: {
          default: "action.stretch-vertical",
          ["context-menu"]: "action.stretch-vertical.short"
        },
        icon: "stretch-vertical",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("stretch-shapes", { operation: "vertical", source });
          editor.markHistoryStoppingPoint("stretch vertical");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.stretchShapes(selectedShapeIds, "vertical");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "flip-horizontal",
        label: {
          default: "action.flip-horizontal",
          ["context-menu"]: "action.flip-horizontal.short"
        },
        kbd: "shift+h",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("flip-shapes", { operation: "horizontal", source });
          editor.markHistoryStoppingPoint("flip horizontal");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.flipShapes(selectedShapeIds, "horizontal");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "flip-vertical",
        label: { default: "action.flip-vertical", ["context-menu"]: "action.flip-vertical.short" },
        kbd: "shift+v",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("flip-shapes", { operation: "vertical", source });
          editor.markHistoryStoppingPoint("flip vertical");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.flipShapes(selectedShapeIds, "vertical");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "pack",
        label: "action.pack",
        icon: "pack",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("pack-shapes", { source });
          editor.markHistoryStoppingPoint("pack");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.packShapes(selectedShapeIds, editor.options.adjacentShapeMargin);
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "stack-vertical",
        label: {
          default: "action.stack-vertical",
          ["context-menu"]: "action.stack-vertical.short"
        },
        icon: "stack-vertical",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("stack-shapes", { operation: "vertical", source });
          editor.markHistoryStoppingPoint("stack-vertical");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.stackShapes(selectedShapeIds, "vertical", editor.options.adjacentShapeMargin);
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "stack-horizontal",
        label: {
          default: "action.stack-horizontal",
          ["context-menu"]: "action.stack-horizontal.short"
        },
        icon: "stack-horizontal",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("stack-shapes", { operation: "horizontal", source });
          editor.markHistoryStoppingPoint("stack-horizontal");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.stackShapes(selectedShapeIds, "horizontal", editor.options.adjacentShapeMargin);
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "bring-to-front",
        label: "action.bring-to-front",
        kbd: "]",
        icon: "bring-to-front",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("reorder-shapes", { operation: "toFront", source });
          editor.markHistoryStoppingPoint("bring to front");
          editor.bringToFront(editor.getSelectedShapeIds());
        }
      },
      {
        id: "bring-forward",
        label: "action.bring-forward",
        icon: "bring-forward",
        kbd: "alt+]",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("reorder-shapes", { operation: "forward", source });
          editor.markHistoryStoppingPoint("bring forward");
          editor.bringForward(editor.getSelectedShapeIds());
        }
      },
      {
        id: "send-backward",
        label: "action.send-backward",
        icon: "send-backward",
        kbd: "alt+[",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("reorder-shapes", { operation: "backward", source });
          editor.markHistoryStoppingPoint("send backward");
          editor.sendBackward(editor.getSelectedShapeIds());
        }
      },
      {
        id: "send-to-back",
        label: "action.send-to-back",
        icon: "send-to-back",
        kbd: "[",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("reorder-shapes", { operation: "toBack", source });
          editor.markHistoryStoppingPoint("send to back");
          editor.sendToBack(editor.getSelectedShapeIds());
        }
      },
      {
        id: "cut",
        label: "action.cut",
        kbd: "cmd+x,ctrl+x",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          editor.markHistoryStoppingPoint("cut");
          helpers.cut(source);
        }
      },
      {
        id: "copy",
        label: "action.copy",
        kbd: "cmd+c,ctrl+c",
        readonlyOk: true,
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          helpers.copy(source);
        }
      },
      {
        id: "paste",
        label: "action.paste",
        kbd: "cmd+v,ctrl+v",
        onSelect(source) {
          var _a6;
          (_a6 = navigator.clipboard) == null ? void 0 : _a6.read().then((clipboardItems) => {
            helpers.paste(
              clipboardItems,
              source,
              source === "context-menu" ? editor.inputs.getCurrentPagePoint() : void 0
            );
          }).catch(() => {
            helpers.addToast({
              title: helpers.msg("action.paste-error-title"),
              description: helpers.msg("action.paste-error-description"),
              severity: "error"
            });
          });
        }
      },
      {
        id: "select-all",
        label: "action.select-all",
        kbd: "cmd+a,ctrl+a",
        readonlyOk: true,
        onSelect(source) {
          editor.run(() => {
            if (mustGoBackToSelectToolFirst()) return;
            trackEvent("select-all-shapes", { source });
            editor.markHistoryStoppingPoint("select all kbd");
            editor.selectAll();
          });
        }
      },
      {
        id: "select-none",
        label: "action.select-none",
        readonlyOk: true,
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("select-none-shapes", { source });
          editor.markHistoryStoppingPoint("select none");
          editor.selectNone();
        }
      },
      {
        id: "delete",
        label: "action.delete",
        kbd: "⌫,del",
        icon: "trash",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("delete-shapes", { source });
          editor.markHistoryStoppingPoint("delete");
          editor.deleteShapes(editor.getSelectedShapeIds());
        }
      },
      {
        id: "rotate-cw",
        label: "action.rotate-cw",
        icon: "rotate-cw",
        kbd: "shift+.,shift+alt+.",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          const isFine = editor.inputs.getAltKey();
          trackEvent("rotate-cw", { source, fine: isFine });
          editor.markHistoryStoppingPoint("rotate-cw");
          editor.run(() => {
            const rotation = HALF_PI / (isFine ? 96 : 6);
            const offset4 = editor.getSelectionRotation() % rotation;
            const dontUseOffset = approximately(offset4, 0) || approximately(offset4, rotation);
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.rotateShapesBy(selectedShapeIds, rotation - (dontUseOffset ? 0 : offset4));
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "rotate-ccw",
        label: "action.rotate-ccw",
        icon: "rotate-ccw",
        // omg double comma
        kbd: "shift+,,shift+alt+,",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          const isFine = editor.inputs.getAltKey();
          trackEvent("rotate-ccw", { source, fine: isFine });
          editor.markHistoryStoppingPoint("rotate-ccw");
          editor.run(() => {
            const rotation = HALF_PI / (isFine ? 96 : 6);
            const offset4 = editor.getSelectionRotation() % rotation;
            const offsetCloseToZero = approximately(offset4, 0);
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.rotateShapesBy(selectedShapeIds, offsetCloseToZero ? -rotation : -offset4);
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "zoom-in",
        label: "action.zoom-in",
        kbd: "cmd+=,ctrl+=,=",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("zoom-in", { source, towardsCursor: false });
          editor.zoomIn(void 0, {
            animation: { duration: editor.options.animationMediumMs }
          });
        }
      },
      {
        id: "zoom-in-on-cursor",
        label: "action.zoom-in",
        kbd: "shift+cmd+=,shift+ctrl+=,shift+=",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("zoom-in", { source, towardsCursor: true });
          editor.zoomIn(editor.inputs.getCurrentScreenPoint(), {
            animation: { duration: editor.options.animationMediumMs }
          });
        }
      },
      {
        id: "zoom-out",
        label: "action.zoom-out",
        kbd: "cmd+-,ctrl+-,-",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("zoom-out", { source, towardsCursor: false });
          editor.zoomOut(void 0, {
            animation: { duration: editor.options.animationMediumMs }
          });
        }
      },
      {
        id: "zoom-out-on-cursor",
        label: "action.zoom-out",
        kbd: "shift+cmd+-,shift+ctrl+-,shift+-",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("zoom-out", { source, towardsCursor: true });
          editor.zoomOut(editor.inputs.getCurrentScreenPoint(), {
            animation: { duration: editor.options.animationMediumMs }
          });
        }
      },
      {
        id: "zoom-to-100",
        label: "action.zoom-to-100",
        icon: "reset-zoom",
        kbd: "shift+0",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("reset-zoom", { source });
          editor.resetZoom(void 0, {
            animation: { duration: editor.options.animationMediumMs }
          });
        }
      },
      {
        id: "zoom-to-fit",
        label: "action.zoom-to-fit",
        kbd: "shift+1",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("zoom-to-fit", { source });
          editor.zoomToFit({ animation: { duration: editor.options.animationMediumMs } });
        }
      },
      {
        id: "zoom-to-selection",
        label: "action.zoom-to-selection",
        kbd: "shift+2",
        readonlyOk: true,
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("zoom-to-selection", { source });
          editor.zoomToSelection({ animation: { duration: editor.options.animationMediumMs } });
        }
      },
      {
        id: "toggle-snap-mode",
        label: {
          default: "action.toggle-snap-mode",
          menu: "action.toggle-snap-mode.menu"
        },
        onSelect(source) {
          trackEvent("toggle-snap-mode", { source });
          editor.user.updateUserPreferences({ isSnapMode: !editor.user.getIsSnapMode() });
        },
        checkbox: true
      },
      {
        id: "toggle-dark-mode",
        label: {
          default: "action.toggle-dark-mode",
          menu: "action.toggle-dark-mode.menu"
        },
        kbd: "cmd+/,ctrl+/",
        readonlyOk: true,
        onSelect(source) {
          const value = editor.user.getIsDarkMode() ? "light" : "dark";
          trackEvent("color-scheme", { source, value });
          editor.user.updateUserPreferences({
            colorScheme: value
          });
        },
        checkbox: true
      },
      {
        id: "toggle-wrap-mode",
        label: {
          default: "action.toggle-wrap-mode",
          menu: "action.toggle-wrap-mode.menu"
        },
        readonlyOk: true,
        onSelect(source) {
          trackEvent("toggle-wrap-mode", { source });
          editor.user.updateUserPreferences({
            isWrapMode: !editor.user.getIsWrapMode()
          });
        },
        checkbox: true
      },
      {
        id: "toggle-dynamic-size-mode",
        label: {
          default: "action.toggle-dynamic-size-mode",
          menu: "action.toggle-dynamic-size-mode.menu"
        },
        readonlyOk: false,
        onSelect(source) {
          trackEvent("toggle-dynamic-size-mode", { source });
          editor.user.updateUserPreferences({
            isDynamicSizeMode: !editor.user.getIsDynamicResizeMode()
          });
        },
        checkbox: true
      },
      {
        id: "toggle-paste-at-cursor",
        label: {
          default: "action.toggle-paste-at-cursor",
          menu: "action.toggle-paste-at-cursor.menu"
        },
        readonlyOk: false,
        onSelect(source) {
          trackEvent("toggle-paste-at-cursor", { source });
          editor.user.updateUserPreferences({
            isPasteAtCursorMode: !editor.user.getIsPasteAtCursorMode()
          });
        },
        checkbox: true
      },
      {
        id: "toggle-reduce-motion",
        label: {
          default: "action.toggle-reduce-motion",
          menu: "action.toggle-reduce-motion.menu"
        },
        readonlyOk: true,
        onSelect(source) {
          trackEvent("toggle-reduce-motion", { source });
          editor.user.updateUserPreferences({
            animationSpeed: editor.user.getAnimationSpeed() === 0 ? 1 : 0
          });
        },
        checkbox: true
      },
      {
        id: "toggle-keyboard-shortcuts",
        label: {
          default: "action.toggle-keyboard-shortcuts",
          menu: "action.toggle-keyboard-shortcuts.menu"
        },
        readonlyOk: true,
        onSelect(source) {
          trackEvent("toggle-keyboard-shortcuts", { source });
          editor.user.updateUserPreferences({
            areKeyboardShortcutsEnabled: !editor.user.getAreKeyboardShortcutsEnabled()
          });
        },
        checkbox: true
      },
      {
        id: "enhanced-a11y-mode",
        label: {
          default: "action.enhanced-a11y-mode",
          menu: "action.enhanced-a11y-mode.menu"
        },
        readonlyOk: true,
        onSelect(source) {
          trackEvent("enhanced-a11y-mode", { source });
          editor.user.updateUserPreferences({
            enhancedA11yMode: !editor.user.getEnhancedA11yMode()
          });
        },
        checkbox: true
      },
      {
        id: "toggle-edge-scrolling",
        label: {
          default: "action.toggle-edge-scrolling",
          menu: "action.toggle-edge-scrolling.menu"
        },
        readonlyOk: true,
        onSelect(source) {
          trackEvent("toggle-edge-scrolling", { source });
          editor.user.updateUserPreferences({
            edgeScrollSpeed: editor.user.getEdgeScrollSpeed() === 0 ? 1 : 0
          });
        },
        checkbox: true
      },
      {
        id: "toggle-transparent",
        label: {
          default: "action.toggle-transparent",
          menu: "action.toggle-transparent.menu",
          ["context-menu"]: "action.toggle-transparent.context-menu"
        },
        readonlyOk: true,
        onSelect(source) {
          trackEvent("toggle-transparent", { source });
          editor.updateInstanceState({
            exportBackground: !editor.getInstanceState().exportBackground
          });
        },
        checkbox: true
      },
      {
        id: "toggle-tool-lock",
        label: {
          default: "action.toggle-tool-lock",
          menu: "action.toggle-tool-lock.menu"
        },
        kbd: "q",
        onSelect(source) {
          trackEvent("toggle-tool-lock", { source });
          editor.updateInstanceState({ isToolLocked: !editor.getInstanceState().isToolLocked });
        },
        checkbox: true
      },
      {
        id: "unlock-all",
        label: "action.unlock-all",
        onSelect(source) {
          trackEvent("unlock-all", { source });
          const updates = [];
          for (const shape of editor.getCurrentPageShapes()) {
            if (shape.isLocked) {
              updates.push({ id: shape.id, type: shape.type, isLocked: false });
            }
          }
          if (updates.length > 0) {
            editor.updateShapes(updates);
          }
        }
      },
      {
        id: "toggle-focus-mode",
        label: {
          default: "action.toggle-focus-mode",
          menu: "action.toggle-focus-mode.menu"
        },
        readonlyOk: true,
        kbd: "cmd+.,ctrl+.",
        checkbox: true,
        onSelect(source) {
          editor.timers.requestAnimationFrame(() => {
            editor.run(() => {
              trackEvent("toggle-focus-mode", { source });
              helpers.clearDialogs();
              helpers.clearToasts();
              editor.updateInstanceState({ isFocusMode: !editor.getInstanceState().isFocusMode });
            });
          });
        }
      },
      {
        id: "toggle-grid",
        label: {
          default: "action.toggle-grid",
          menu: "action.toggle-grid.menu"
        },
        readonlyOk: true,
        kbd: "cmd+',ctrl+'",
        onSelect(source) {
          trackEvent("toggle-grid-mode", { source });
          editor.updateInstanceState({ isGridMode: !editor.getInstanceState().isGridMode });
        },
        checkbox: true
      },
      {
        id: "toggle-debug-mode",
        label: {
          default: "action.toggle-debug-mode",
          menu: "action.toggle-debug-mode.menu"
        },
        readonlyOk: true,
        onSelect(source) {
          trackEvent("toggle-debug-mode", { source });
          editor.updateInstanceState({
            isDebugMode: !editor.getInstanceState().isDebugMode
          });
        },
        checkbox: true
      },
      {
        id: "print",
        label: "action.print",
        kbd: "cmd+p,ctrl+p",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("print", { source });
          helpers.printSelectionOrPages();
        }
      },
      {
        id: "exit-pen-mode",
        label: "action.exit-pen-mode",
        icon: "cross-2",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("exit-pen-mode", { source });
          editor.updateInstanceState({ isPenMode: false });
        }
      },
      {
        id: "stop-following",
        label: "action.stop-following",
        icon: "cross-2",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("stop-following", { source });
          editor.stopFollowingUser();
        }
      },
      {
        id: "back-to-content",
        label: "action.back-to-content",
        icon: "arrow-left",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("zoom-to-content", { source });
          const bounds = editor.getSelectionPageBounds() ?? editor.getCurrentPageBounds();
          if (!bounds) return;
          editor.zoomToBounds(bounds, {
            targetZoom: Math.min(1, editor.getZoomLevel()),
            animation: { duration: 220 }
          });
        }
      },
      {
        id: "toggle-lock",
        label: "action.toggle-lock",
        kbd: "shift+l",
        onSelect(source) {
          editor.markHistoryStoppingPoint("locking");
          trackEvent("toggle-lock", { source });
          editor.toggleLock(editor.getSelectedShapeIds());
        }
      },
      {
        id: "move-to-new-page",
        label: "context.pages.new-page",
        onSelect(source) {
          const newPageId = PageRecordType.createId();
          const ids = editor.getSelectedShapeIds();
          editor.run(() => {
            editor.markHistoryStoppingPoint("move_shapes_to_page");
            editor.createPage({
              name: helpers.msg("page-menu.new-page-initial-name"),
              id: newPageId
            });
            editor.moveShapesToPage(ids, newPageId);
          });
          trackEvent("move-to-new-page", { source });
        }
      },
      {
        id: "select-white-color",
        label: "color-style.white",
        kbd: "alt+t",
        onSelect(source) {
          const style2 = DefaultColorStyle;
          editor.run(() => {
            editor.markHistoryStoppingPoint("change-color");
            if (editor.isIn("select")) {
              editor.setStyleForSelectedShapes(style2, "white");
            }
            editor.setStyleForNextShapes(style2, "white");
          });
          trackEvent("set-style", { source, id: style2.id, value: "white" });
        }
      },
      {
        id: "select-fill-fill",
        label: "fill-style.fill",
        kbd: "alt+f",
        onSelect(source) {
          const style2 = DefaultFillStyle;
          editor.run(() => {
            editor.markHistoryStoppingPoint("change-fill");
            if (editor.isIn("select")) {
              editor.setStyleForSelectedShapes(style2, "fill");
            }
            editor.setStyleForNextShapes(style2, "fill");
          });
          trackEvent("set-style", { source, id: style2.id, value: "fill" });
        }
      },
      {
        id: "select-fill-lined-fill",
        label: "fill-style.lined-fill",
        kbd: "alt+shift+f",
        onSelect(source) {
          const style2 = DefaultFillStyle;
          editor.run(() => {
            editor.markHistoryStoppingPoint("change-fill");
            if (editor.isIn("select")) {
              editor.setStyleForSelectedShapes(style2, "lined-fill");
            }
            editor.setStyleForNextShapes(style2, "lined-fill");
          });
          trackEvent("set-style", { source, id: style2.id, value: "lined-fill" });
        }
      },
      {
        id: "flatten-to-image",
        label: "action.flatten-to-image",
        kbd: "shift+f",
        onSelect: async (source) => {
          const ids = editor.getSelectedShapeIds();
          if (ids.length === 0) return;
          editor.markHistoryStoppingPoint("flattening to image");
          trackEvent("flatten-to-image", { source });
          const newShapeIds = await flattenShapesToImages(
            editor,
            ids,
            editor.options.flattenImageBoundsExpand
          );
          if (newShapeIds == null ? void 0 : newShapeIds.length) {
            editor.setSelectedShapes(newShapeIds);
          }
        }
      },
      {
        id: "select-geo-tool",
        kbd: "g",
        onSelect: async (source) => {
          trackEvent("select-tool", { source, id: `geo-previous` });
          editor.setCurrentTool("geo");
        }
      },
      {
        id: "change-page-prev",
        kbd: "alt+left,alt+up",
        readonlyOk: true,
        onSelect: async (source) => {
          const pages = editor.getPages();
          const currentPageIndex = pages.findIndex((page) => page.id === editor.getCurrentPageId());
          if (currentPageIndex < 1) return;
          trackEvent("change-page", { source, direction: "prev" });
          editor.setCurrentPage(pages[currentPageIndex - 1].id);
        }
      },
      {
        id: "change-page-next",
        kbd: "alt+right,alt+down",
        readonlyOk: true,
        onSelect: async (source) => {
          const pages = editor.getPages();
          const currentPageIndex = pages.findIndex((page) => page.id === editor.getCurrentPageId());
          if (currentPageIndex === -1 || currentPageIndex >= pages.length - 1) {
            if (editor.getCurrentPageShapes().length <= 0 || editor.getIsReadonly()) {
              return;
            }
            trackEvent("new-page", { source });
            editor.run(() => {
              editor.markHistoryStoppingPoint("creating page");
              const newPageId = PageRecordType.createId();
              editor.createPage({
                name: helpers.msg("page-menu.new-page-initial-name"),
                id: newPageId
              });
              editor.setCurrentPage(newPageId);
            });
            return;
          }
          editor.setCurrentPage(pages[currentPageIndex + 1].id);
          trackEvent("change-page", { source, direction: "next" });
        }
      },
      {
        id: "adjust-shape-styles",
        label: "a11y.adjust-shape-styles",
        kbd: "cmd+Enter,ctrl+Enter",
        isRequiredA11yAction: true,
        onSelect: async (source) => {
          if (!canApplySelectionAction()) return;
          const onlySelectedShape = editor.getOnlySelectedShape();
          if (onlySelectedShape && (editor.isShapeOfType(onlySelectedShape, "image") || editor.isShapeOfType(onlySelectedShape, "video"))) {
            const firstToolbarButton = editor.getContainer().querySelector(".tlui-contextual-toolbar button:first-child");
            firstToolbarButton == null ? void 0 : firstToolbarButton.focus();
            return;
          }
          const firstButton = editor.getContainer().querySelector(".tlui-style-panel button");
          firstButton == null ? void 0 : firstButton.focus();
          trackEvent("adjust-shape-styles", { source });
        }
      },
      {
        id: "a11y-open-context-menu",
        kbd: "cmd+shift+Enter,ctrl+shift+Enter",
        isRequiredA11yAction: true,
        readonlyOk: true,
        onSelect: async (source) => {
          var _a6;
          if (!canApplySelectionAction()) return;
          const selectionBounds = editor.getSelectionPageBounds();
          if (!selectionBounds) return;
          const centerX = selectionBounds.x + selectionBounds.width / 2;
          const centerY = selectionBounds.y + selectionBounds.height / 2;
          const screenPoint = editor.pageToScreen(new Vec(centerX, centerY));
          (_a6 = editor.getContainer().querySelector(".tl-canvas")) == null ? void 0 : _a6.dispatchEvent(
            new PointerEvent("contextmenu", {
              clientX: screenPoint.x,
              clientY: screenPoint.y,
              bubbles: true
            })
          );
          trackEvent("open-context-menu", { source });
        }
      },
      {
        id: "enlarge-shapes",
        label: "a11y.enlarge-shape",
        kbd: "cmd+alt+shift+=,ctrl+alt+shift+=",
        onSelect: async (source) => {
          scaleShapes(1.1);
          trackEvent("enlarge-shapes", { source });
        }
      },
      {
        id: "shrink-shapes",
        label: "a11y.shrink-shape",
        kbd: "cmd+alt+shift+-,ctrl+alt+shift+-",
        onSelect: async (source) => {
          scaleShapes(1 / 1.1);
          trackEvent("shrink-shapes", { source });
        }
      },
      {
        id: "a11y-repeat-shape-announce",
        kbd: "alt+r",
        label: "a11y.repeat-shape",
        isRequiredA11yAction: true,
        readonlyOk: true,
        onSelect: async (source) => {
          const selectedShapeIds = editor.getSelectedShapeIds();
          if (!selectedShapeIds.length) return;
          const a11yLive = generateShapeAnnouncementMessage({
            editor,
            selectedShapeIds,
            msg: msg2
          });
          if (a11yLive) {
            a11y.announce({ msg: "" });
            editor.timers.requestAnimationFrame(() => {
              a11y.announce({ msg: a11yLive });
            });
            trackEvent("a11y-repeat-shape-announce", { source });
          }
        }
      },
      {
        id: "image-replace",
        label: "tool.replace-media",
        icon: "arrow-cycle",
        readonlyOk: false,
        onSelect: async (source) => {
          trackEvent("image-replace", { source });
          helpers.replaceImage();
        }
      },
      {
        id: "video-replace",
        label: "tool.replace-media",
        icon: "arrow-cycle",
        readonlyOk: false,
        onSelect: async (source) => {
          trackEvent("video-replace", { source });
          helpers.replaceVideo();
        }
      },
      {
        id: "download-original",
        label: "action.download-original",
        readonlyOk: true,
        onSelect: async (source) => {
          const selectedShapes = editor.getSelectedShapes();
          if (selectedShapes.length === 0) return;
          const mediaShapes = selectedShapes.filter(
            (s) => supportsDownloadingOriginal(s, editor)
          );
          if (mediaShapes.length === 0) return;
          for (const mediaShape of mediaShapes) {
            const asset = editor.getAsset(mediaShape.props.assetId);
            if (!asset || !asset.props.src) continue;
            const url = await editor.resolveAssetUrl(asset.id, { shouldResolveToOriginal: true });
            if (!url) return;
            const link = document.createElement("a");
            link.href = url;
            if ((asset.type === "video" || asset.type === "image") && !asset.props.src.startsWith("asset:")) {
              link.download = asset.props.name;
            } else {
              link.download = "download";
            }
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
          }
          trackEvent("download-original", { source });
        }
      }
    ];
    if (showCollaborationUi) {
      actionItems.push({
        id: "open-cursor-chat",
        label: "action.open-cursor-chat",
        readonlyOk: true,
        kbd: "/",
        onSelect(source) {
          trackEvent("open-cursor-chat", { source });
          if (editor.getInstanceState().isCoarsePointer) {
            return;
          }
          editor.timers.requestAnimationFrame(() => {
            editor.updateInstanceState({ isChatting: true });
          });
        }
      });
    }
    const actions2 = makeActions(actionItems);
    if (overrides) {
      return overrides(editor, actions2, helpers);
    }
    return actions2;
  }, [
    helpers,
    _editor,
    trackEvent,
    overrides,
    defaultDocumentName,
    showCollaborationUi,
    msg2,
    a11y,
    components
  ]);
  return (0, import_jsx_runtime183.jsx)(ActionsContext.Provider, { value: asActions(actions), children });
}
function useActions() {
  const ctx = React97.useContext(ActionsContext);
  if (!ctx) {
    throw new Error("useTools must be used within a ToolProvider");
  }
  return ctx;
}
function asActions(actions) {
  return actions;
}
function unwrapLabel(label, menuType) {
  return label ? typeof label === "string" ? label : menuType ? label[menuType] ?? label["default"] : void 0 : void 0;
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/primitives/menus/TldrawUiMenuActionCheckboxItem.mjs
var import_jsx_runtime184 = __toESM(require_jsx_runtime(), 1);
function TldrawUiMenuActionCheckboxItem({
  actionId = "",
  ...rest
}) {
  const actions = useActions();
  const action = actions[actionId];
  if (!action) return null;
  return (0, import_jsx_runtime184.jsx)(TldrawUiMenuCheckboxItem, { ...action, ...rest });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/menu-items.mjs
function ToggleAutoSizeMenuItem() {
  const shouldDisplay = useShowAutoSizeToggle();
  if (!shouldDisplay) return null;
  return (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "toggle-auto-size" });
}
function EditLinkMenuItem2() {
  const shouldDisplay = useHasLinkShapeSelected();
  if (!shouldDisplay) return null;
  return (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "edit-link" });
}
function DuplicateMenuItem() {
  const shouldDisplay = useUnlockedSelectedShapesCount(1);
  if (!shouldDisplay) return null;
  return (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "duplicate" });
}
function FlattenMenuItem() {
  const editor = useEditor();
  const shouldDisplay = useValue(
    "should display flatten option",
    () => {
      const selectedShapeIds = editor.getSelectedShapeIds();
      if (selectedShapeIds.length === 0) return false;
      const onlySelectedShape = editor.getOnlySelectedShape();
      if (onlySelectedShape && editor.isShapeOfType(onlySelectedShape, "image")) {
        return false;
      }
      return true;
    },
    [editor]
  );
  if (!shouldDisplay) return null;
  return (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "flatten-to-image" });
}
function DownloadOriginalMenuItem() {
  const editor = useEditor();
  const shouldDisplay = useValue(
    "should display download original option",
    () => {
      const selectedShapes = editor.getSelectedShapes();
      if (selectedShapes.length === 0) return false;
      return selectedShapes.some((shape) => supportsDownloadingOriginal(shape, editor));
    },
    [editor]
  );
  if (!shouldDisplay) return null;
  return (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "download-original" });
}
function GroupMenuItem2() {
  const shouldDisplay = useAllowGroup();
  if (!shouldDisplay) return null;
  return (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "group" });
}
function UngroupMenuItem2() {
  const shouldDisplay = useAllowUngroup();
  if (!shouldDisplay) return null;
  return (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "ungroup" });
}
function RemoveFrameMenuItem() {
  const editor = useEditor();
  const shouldDisplay = useValue(
    "allow unframe",
    () => {
      const selectedShapes = editor.getSelectedShapes();
      if (selectedShapes.length === 0) return false;
      return selectedShapes.every((shape) => editor.isShapeOfType(shape, "frame"));
    },
    [editor]
  );
  if (!shouldDisplay) return null;
  return (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "remove-frame" });
}
function FitFrameToContentMenuItem() {
  const editor = useEditor();
  const shouldDisplay = useValue(
    "allow fit frame to content",
    () => {
      const onlySelectedShape = editor.getOnlySelectedShape();
      if (!onlySelectedShape) return false;
      return editor.isShapeOfType(onlySelectedShape, "frame") && editor.getSortedChildIdsForParent(onlySelectedShape).length > 0;
    },
    [editor]
  );
  if (!shouldDisplay) return null;
  return (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "fit-frame-to-content" });
}
function ToggleLockMenuItem() {
  const editor = useEditor();
  const shouldDisplay = useValue("selected shapes", () => editor.getSelectedShapes().length > 0, [
    editor
  ]);
  if (!shouldDisplay) return null;
  return (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "toggle-lock" });
}
function ToggleTransparentBgMenuItem() {
  const editor = useEditor();
  const isTransparentBg = useValue(
    "isTransparentBg",
    () => !editor.getInstanceState().exportBackground,
    [editor]
  );
  return (0, import_jsx_runtime185.jsx)(
    TldrawUiMenuActionCheckboxItem,
    {
      actionId: "toggle-transparent",
      checked: isTransparentBg,
      toggle: true
    }
  );
}
function UnlockAllMenuItem() {
  const editor = useEditor();
  const shouldDisplay = useValue("any shapes", () => editor.getCurrentPageShapeIds().size > 0, [
    editor
  ]);
  return (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "unlock-all", disabled: !shouldDisplay });
}
function ZoomTo100MenuItem() {
  const editor = useEditor();
  const isZoomedTo100 = useValue("zoomed to 100", () => editor.getEfficientZoomLevel() === 1, [
    editor
  ]);
  return (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "zoom-to-100", noClose: true, disabled: isZoomedTo100 });
}
function ZoomToFitMenuItem() {
  const editor = useEditor();
  const hasShapes = useValue("has shapes", () => editor.getCurrentPageShapeIds().size > 0, [editor]);
  return (0, import_jsx_runtime185.jsx)(
    TldrawUiMenuActionItem,
    {
      actionId: "zoom-to-fit",
      disabled: !hasShapes,
      "data-testid": "minimap.zoom-menu.zoom-to-fit",
      noClose: true
    }
  );
}
function ZoomToSelectionMenuItem() {
  const editor = useEditor();
  const hasSelected = useValue("has shapes", () => editor.getSelectedShapeIds().length > 0, [
    editor
  ]);
  return (0, import_jsx_runtime185.jsx)(
    TldrawUiMenuActionItem,
    {
      actionId: "zoom-to-selection",
      disabled: !hasSelected,
      "data-testid": "minimap.zoom-menu.zoom-to-selection",
      noClose: true
    }
  );
}
function ClipboardMenuGroup() {
  return (0, import_jsx_runtime185.jsxs)(TldrawUiMenuGroup, { id: "clipboard", children: [
    (0, import_jsx_runtime185.jsx)(CutMenuItem, {}),
    (0, import_jsx_runtime185.jsx)(CopyMenuItem, {}),
    (0, import_jsx_runtime185.jsx)(PasteMenuItem, {}),
    (0, import_jsx_runtime185.jsx)(DuplicateMenuItem, {}),
    (0, import_jsx_runtime185.jsx)(DeleteMenuItem, {})
  ] });
}
function CopyAsMenuGroup() {
  var _a6;
  const editor = useEditor();
  const atLeastOneShapeOnPage = useValue(
    "atLeastOneShapeOnPage",
    () => editor.getCurrentPageShapeIds().size > 0,
    [editor]
  );
  return (0, import_jsx_runtime185.jsxs)(
    TldrawUiMenuSubmenu,
    {
      id: "copy-as",
      label: "context-menu.copy-as",
      size: "small",
      disabled: !atLeastOneShapeOnPage,
      children: [
        (0, import_jsx_runtime185.jsxs)(TldrawUiMenuGroup, { id: "copy-as-group", children: [
          (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "copy-as-svg" }),
          Boolean((_a6 = window.navigator.clipboard) == null ? void 0 : _a6.write) && (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "copy-as-png" })
        ] }),
        (0, import_jsx_runtime185.jsx)(TldrawUiMenuGroup, { id: "copy-as-bg", children: (0, import_jsx_runtime185.jsx)(ToggleTransparentBgMenuItem, {}) })
      ]
    }
  );
}
function CutMenuItem() {
  const shouldDisplay = useUnlockedSelectedShapesCount(1);
  return (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "cut", disabled: !shouldDisplay });
}
function CopyMenuItem() {
  const shouldDisplay = useAnySelectedShapesCount(1);
  return (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "copy", disabled: !shouldDisplay });
}
function PasteMenuItem() {
  const shouldDisplay = showMenuPaste;
  return (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "paste", disabled: !shouldDisplay });
}
function ConversionsMenuGroup() {
  const editor = useEditor();
  const atLeastOneShapeOnPage = useValue(
    "atLeastOneShapeOnPage",
    () => editor.getCurrentPageShapeIds().size > 0,
    [editor]
  );
  if (!atLeastOneShapeOnPage) return null;
  return (0, import_jsx_runtime185.jsxs)(TldrawUiMenuGroup, { id: "conversions", children: [
    (0, import_jsx_runtime185.jsx)(CopyAsMenuGroup, {}),
    (0, import_jsx_runtime185.jsxs)(TldrawUiMenuSubmenu, { id: "export-as", label: "context-menu.export-as", size: "small", children: [
      (0, import_jsx_runtime185.jsxs)(TldrawUiMenuGroup, { id: "export-as-group", children: [
        (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "export-as-svg" }),
        (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "export-as-png" })
      ] }),
      (0, import_jsx_runtime185.jsx)(TldrawUiMenuGroup, { id: "export-as-bg", children: (0, import_jsx_runtime185.jsx)(ToggleTransparentBgMenuItem, {}) })
    ] }),
    (0, import_jsx_runtime185.jsx)(DownloadOriginalMenuItem, {})
  ] });
}
function SelectAllMenuItem() {
  const editor = useEditor();
  const atLeastOneShapeOnPage = useValue(
    "atLeastOneShapeOnPage",
    () => editor.getCurrentPageShapeIds().size > 0,
    [editor]
  );
  return (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "select-all", disabled: !atLeastOneShapeOnPage });
}
function DeleteMenuItem() {
  const oneSelected = useUnlockedSelectedShapesCount(1);
  return (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "delete", disabled: !oneSelected });
}
function EditMenuSubmenu() {
  const isReadonlyMode = useReadonly();
  if (!useAnySelectedShapesCount(1)) return null;
  if (isReadonlyMode) return null;
  return (0, import_jsx_runtime185.jsxs)(TldrawUiMenuSubmenu, { id: "edit", label: "context-menu.edit", size: "small", children: [
    (0, import_jsx_runtime185.jsx)(GroupMenuItem2, {}),
    (0, import_jsx_runtime185.jsx)(UngroupMenuItem2, {}),
    (0, import_jsx_runtime185.jsx)(FlattenMenuItem, {}),
    (0, import_jsx_runtime185.jsx)(EditLinkMenuItem2, {}),
    (0, import_jsx_runtime185.jsx)(FitFrameToContentMenuItem, {}),
    (0, import_jsx_runtime185.jsx)(RemoveFrameMenuItem, {}),
    (0, import_jsx_runtime185.jsx)(ConvertToEmbedMenuItem, {}),
    (0, import_jsx_runtime185.jsx)(ConvertToBookmarkMenuItem, {}),
    (0, import_jsx_runtime185.jsx)(ToggleAutoSizeMenuItem, {}),
    (0, import_jsx_runtime185.jsx)(ToggleLockMenuItem, {})
  ] });
}
function ArrangeMenuSubmenu() {
  const twoSelected = useUnlockedSelectedShapesCount(2);
  const onlyFlippableShapeSelected = useOnlyFlippableShape();
  const isReadonlyMode = useReadonly();
  if (isReadonlyMode) return null;
  if (!(twoSelected || onlyFlippableShapeSelected)) return null;
  return (0, import_jsx_runtime185.jsxs)(TldrawUiMenuSubmenu, { id: "arrange", label: "context-menu.arrange", size: "small", children: [
    twoSelected && (0, import_jsx_runtime185.jsxs)(TldrawUiMenuGroup, { id: "align", children: [
      (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "align-left" }),
      (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "align-center-horizontal" }),
      (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "align-right" }),
      (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "align-top" }),
      (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "align-center-vertical" }),
      (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "align-bottom" })
    ] }),
    (0, import_jsx_runtime185.jsx)(DistributeMenuGroup, {}),
    twoSelected && (0, import_jsx_runtime185.jsxs)(TldrawUiMenuGroup, { id: "stretch", children: [
      (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "stretch-horizontal" }),
      (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "stretch-vertical" })
    ] }),
    (twoSelected || onlyFlippableShapeSelected) && (0, import_jsx_runtime185.jsxs)(TldrawUiMenuGroup, { id: "flip", children: [
      (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "flip-horizontal" }),
      (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "flip-vertical" })
    ] }),
    (0, import_jsx_runtime185.jsx)(OrderMenuGroup, {})
  ] });
}
function DistributeMenuGroup() {
  const threeSelected = useUnlockedSelectedShapesCount(3);
  if (!threeSelected) return null;
  return (0, import_jsx_runtime185.jsxs)(TldrawUiMenuGroup, { id: "distribute", children: [
    (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "distribute-horizontal" }),
    (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "distribute-vertical" })
  ] });
}
function OrderMenuGroup() {
  const twoSelected = useUnlockedSelectedShapesCount(2);
  const threeStackableItems = useThreeStackableItems();
  if (!twoSelected) return null;
  return (0, import_jsx_runtime185.jsxs)(TldrawUiMenuGroup, { id: "order", children: [
    (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "pack" }),
    threeStackableItems && (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "stack-horizontal" }),
    threeStackableItems && (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "stack-vertical" })
  ] });
}
function ReorderMenuSubmenu() {
  const isReadonlyMode = useReadonly();
  const oneSelected = useUnlockedSelectedShapesCount(1);
  if (isReadonlyMode) return null;
  if (!oneSelected) return null;
  return (0, import_jsx_runtime185.jsx)(TldrawUiMenuSubmenu, { id: "reorder", label: "context-menu.reorder", size: "small", children: (0, import_jsx_runtime185.jsxs)(TldrawUiMenuGroup, { id: "reorder", children: [
    (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "bring-to-front" }),
    (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "bring-forward" }),
    (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "send-backward" }),
    (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "send-to-back" })
  ] }) });
}
function MoveToPageMenu() {
  const editor = useEditor();
  const pages = useValue("pages", () => editor.getPages(), [editor]);
  const currentPageId = useValue("current page id", () => editor.getCurrentPageId(), [editor]);
  const { addToast } = useToasts();
  const trackEvent = useUiEvents();
  const isReadonlyMode = useReadonly();
  const oneSelected = useUnlockedSelectedShapesCount(1);
  if (!oneSelected) return null;
  if (isReadonlyMode) return null;
  return (0, import_jsx_runtime185.jsxs)(TldrawUiMenuSubmenu, { id: "move-to-page", label: "context-menu.move-to-page", size: "small", children: [
    (0, import_jsx_runtime185.jsx)(TldrawUiMenuGroup, { id: "pages", children: pages.map((page) => (0, import_jsx_runtime185.jsx)(
      TldrawUiMenuItem,
      {
        id: page.id,
        disabled: currentPageId === page.id,
        label: page.name.length > 30 ? `${page.name.slice(0, 30)}…` : page.name,
        onSelect: () => {
          editor.markHistoryStoppingPoint("move_shapes_to_page");
          editor.moveShapesToPage(editor.getSelectedShapeIds(), page.id);
          const toPage = editor.getPage(page.id);
          if (toPage) {
            addToast({
              title: "Changed page",
              description: `Moved to ${toPage.name}.`,
              actions: [
                {
                  label: "Go back",
                  type: "primary",
                  onClick: () => {
                    editor.markHistoryStoppingPoint("change-page");
                    editor.setCurrentPage(currentPageId);
                  }
                }
              ]
            });
          }
          trackEvent("move-to-page", { source: "context-menu" });
        }
      },
      page.id
    )) }),
    (0, import_jsx_runtime185.jsx)(TldrawUiMenuGroup, { id: "new-page", children: (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "move-to-new-page" }) })
  ] });
}
function ConvertToBookmarkMenuItem() {
  const editor = useEditor();
  const oneEmbedSelected = useValue(
    "oneEmbedSelected",
    () => {
      const onlySelectedShape = editor.getOnlySelectedShape();
      if (!onlySelectedShape) return false;
      return !!(editor.isShapeOfType(onlySelectedShape, "embed") && onlySelectedShape.props.url && !editor.isShapeOrAncestorLocked(onlySelectedShape));
    },
    [editor]
  );
  if (!oneEmbedSelected) return null;
  return (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "convert-to-bookmark" });
}
function ConvertToEmbedMenuItem() {
  const editor = useEditor();
  const getEmbedDefinition = useGetEmbedDefinition();
  const oneEmbeddableBookmarkSelected = useValue(
    "oneEmbeddableBookmarkSelected",
    () => {
      const onlySelectedShape = editor.getOnlySelectedShape();
      if (!onlySelectedShape) return false;
      return !!(editor.isShapeOfType(onlySelectedShape, "bookmark") && onlySelectedShape.props.url && getEmbedDefinition(onlySelectedShape.props.url) && !editor.isShapeOrAncestorLocked(onlySelectedShape));
    },
    [editor]
  );
  if (!oneEmbeddableBookmarkSelected) return null;
  return (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "convert-to-embed" });
}
function ToggleSnapModeItem() {
  const editor = useEditor();
  const isSnapMode = useValue("isSnapMode", () => editor.user.getIsSnapMode(), [editor]);
  return (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionCheckboxItem, { actionId: "toggle-snap-mode", checked: isSnapMode });
}
function ToggleToolLockItem() {
  const editor = useEditor();
  const isToolLock = useValue("isToolLock", () => editor.getInstanceState().isToolLocked, [editor]);
  return (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionCheckboxItem, { actionId: "toggle-tool-lock", checked: isToolLock });
}
function ToggleGridItem() {
  const editor = useEditor();
  const isGridMode = useValue("isGridMode", () => editor.getInstanceState().isGridMode, [editor]);
  return (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionCheckboxItem, { actionId: "toggle-grid", checked: isGridMode });
}
function ToggleWrapModeItem() {
  const editor = useEditor();
  const isWrapMode = useValue("isWrapMode", () => editor.user.getIsWrapMode(), [editor]);
  return (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionCheckboxItem, { actionId: "toggle-wrap-mode", checked: isWrapMode });
}
function ToggleFocusModeItem() {
  const editor = useEditor();
  const isFocusMode = useValue("isFocusMode", () => editor.getInstanceState().isFocusMode, [editor]);
  return (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionCheckboxItem, { actionId: "toggle-focus-mode", checked: isFocusMode });
}
function ToggleEdgeScrollingItem() {
  const editor = useEditor();
  const edgeScrollSpeed = useValue("edgeScrollSpeed", () => editor.user.getEdgeScrollSpeed(), [
    editor
  ]);
  return (0, import_jsx_runtime185.jsx)(
    TldrawUiMenuActionCheckboxItem,
    {
      actionId: "toggle-edge-scrolling",
      checked: edgeScrollSpeed === 1
    }
  );
}
function ToggleReduceMotionItem() {
  const editor = useEditor();
  const animationSpeed = useValue("animationSpeed", () => editor.user.getAnimationSpeed(), [editor]);
  return (0, import_jsx_runtime185.jsx)(
    TldrawUiMenuActionCheckboxItem,
    {
      actionId: "toggle-reduce-motion",
      checked: animationSpeed === 0
    }
  );
}
function ToggleKeyboardShortcutsItem() {
  const editor = useEditor();
  const keyboardShortcuts = useValue(
    "keyboardShortcuts",
    () => editor.user.getAreKeyboardShortcutsEnabled(),
    [editor]
  );
  return (0, import_jsx_runtime185.jsx)(
    TldrawUiMenuActionCheckboxItem,
    {
      actionId: "toggle-keyboard-shortcuts",
      checked: keyboardShortcuts
    }
  );
}
function ToggleEnhancedA11yModeItem() {
  const editor = useEditor();
  const enhancedA11yMode = useValue("enhancedA11yMode", () => editor.user.getEnhancedA11yMode(), [
    editor
  ]);
  return (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionCheckboxItem, { actionId: "enhanced-a11y-mode", checked: enhancedA11yMode });
}
function ToggleDebugModeItem() {
  const editor = useEditor();
  const isDebugMode = useValue("isDebugMode", () => editor.getInstanceState().isDebugMode, [editor]);
  return (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionCheckboxItem, { actionId: "toggle-debug-mode", checked: isDebugMode });
}
function ToggleDynamicSizeModeItem() {
  const editor = useEditor();
  const isDynamicResizeMode = useValue(
    "dynamic resize",
    () => editor.user.getIsDynamicResizeMode(),
    [editor]
  );
  return (0, import_jsx_runtime185.jsx)(
    TldrawUiMenuActionCheckboxItem,
    {
      actionId: "toggle-dynamic-size-mode",
      checked: isDynamicResizeMode
    }
  );
}
function TogglePasteAtCursorItem() {
  const editor = useEditor();
  const pasteAtCursor = useValue("paste at cursor", () => editor.user.getIsPasteAtCursorMode(), [
    editor
  ]);
  return (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionCheckboxItem, { actionId: "toggle-paste-at-cursor", checked: pasteAtCursor });
}
function PrintItem() {
  const editor = useEditor();
  const emptyPage = useValue("emptyPage", () => editor.getCurrentPageShapeIds().size === 0, [
    editor
  ]);
  return (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "print", disabled: emptyPage });
}
function CursorChatItem() {
  const editor = useEditor();
  const shouldShow = useValue(
    "show cursor chat",
    () => editor.getCurrentToolId() === "select" && !editor.getInstanceState().isCoarsePointer,
    [editor]
  );
  if (!shouldShow) return null;
  return (0, import_jsx_runtime185.jsx)(TldrawUiMenuActionItem, { actionId: "open-cursor-chat" });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/AccessibilityMenu.mjs
function AccessibilityMenu() {
  return (0, import_jsx_runtime186.jsx)(TldrawUiMenuSubmenu, { id: "help menu accessibility", label: "menu.accessibility", children: (0, import_jsx_runtime186.jsxs)(TldrawUiMenuGroup, { id: "accessibility", children: [
    (0, import_jsx_runtime186.jsx)(ToggleReduceMotionItem, {}),
    (0, import_jsx_runtime186.jsx)(ToggleKeyboardShortcutsItem, {}),
    (0, import_jsx_runtime186.jsx)(ToggleEnhancedA11yModeItem, {})
  ] }) });
}

// ../node_modules/tldraw/dist-esm/lib/bindings/arrow/ArrowBindingUtil.mjs
var ArrowBindingUtil = class extends BindingUtil {
  getDefaultProps() {
    return {
      isPrecise: false,
      isExact: false,
      normalizedAnchor: { x: 0.5, y: 0.5 },
      snap: "none"
    };
  }
  // when the binding itself changes
  onAfterCreate({ binding }) {
    const arrow5 = this.editor.getShape(binding.fromId);
    if (!arrow5) return;
    arrowDidUpdate(this.editor, arrow5);
  }
  // when the binding itself changes
  onAfterChange({ bindingAfter }) {
    const arrow5 = this.editor.getShape(bindingAfter.fromId);
    if (!arrow5) return;
    arrowDidUpdate(this.editor, arrow5);
  }
  // when the arrow itself changes
  onAfterChangeFromShape({
    shapeAfter
  }) {
    arrowDidUpdate(this.editor, shapeAfter);
  }
  // when the shape an arrow is bound to changes
  onAfterChangeToShape({
    binding,
    shapeBefore,
    shapeAfter,
    reason
  }) {
    if (reason !== "ancestry" && shapeBefore.parentId === shapeAfter.parentId && shapeBefore.index === shapeAfter.index) {
      return;
    }
    reparentArrow(this.editor, binding.fromId);
  }
  // when the arrow is isolated we need to update it's x,y positions
  onBeforeIsolateFromShape({
    binding
  }) {
    const arrow5 = this.editor.getShape(binding.fromId);
    if (!arrow5) return;
    updateArrowTerminal({
      editor: this.editor,
      arrow: arrow5,
      terminal: binding.props.terminal
    });
  }
};
__publicField(ArrowBindingUtil, "type", "arrow");
__publicField(ArrowBindingUtil, "props", arrowBindingProps);
__publicField(ArrowBindingUtil, "migrations", arrowBindingMigrations);
function reparentArrow(editor, arrowId) {
  var _a6;
  const arrow5 = editor.getShape(arrowId);
  if (!arrow5) return;
  const bindings = getArrowBindings(editor, arrow5);
  const { start, end } = bindings;
  const startShape = start ? editor.getShape(start.toId) : void 0;
  const endShape = end ? editor.getShape(end.toId) : void 0;
  const parentPageId = editor.getAncestorPageId(arrow5);
  if (!parentPageId) return;
  let nextParentId;
  if (startShape && endShape) {
    nextParentId = editor.findCommonAncestor([startShape, endShape]) ?? parentPageId;
  } else if (startShape || endShape) {
    const bindingParentId = (_a6 = startShape || endShape) == null ? void 0 : _a6.parentId;
    if (bindingParentId && bindingParentId === arrow5.parentId) {
      nextParentId = arrow5.parentId;
    } else {
      nextParentId = parentPageId;
    }
  } else {
    return;
  }
  if (nextParentId && nextParentId !== arrow5.parentId) {
    editor.reparentShapes([arrowId], nextParentId);
  }
  const reparentedArrow = editor.getShape(arrowId);
  if (!reparentedArrow) throw Error("no reparented arrow");
  const startSibling = editor.getShapeNearestSibling(reparentedArrow, startShape);
  const endSibling = editor.getShapeNearestSibling(reparentedArrow, endShape);
  let highestSibling;
  if (startSibling && endSibling) {
    highestSibling = startSibling.index > endSibling.index ? startSibling : endSibling;
  } else if (startSibling && !endSibling) {
    highestSibling = startSibling;
  } else if (endSibling && !startSibling) {
    highestSibling = endSibling;
  } else {
    return;
  }
  let finalIndex;
  const higherSiblings = editor.getSortedChildIdsForParent(highestSibling.parentId).map((id) => editor.getShape(id)).filter((sibling) => sibling.index > highestSibling.index);
  if (higherSiblings.length) {
    const nextHighestNonArrowSibling = higherSiblings.find((sibling) => sibling.type !== "arrow");
    if (
      // ...then, if we're above the last shape we want to be above...
      reparentedArrow.index > highestSibling.index && // ...but below the next non-arrow sibling...
      (!nextHighestNonArrowSibling || reparentedArrow.index < nextHighestNonArrowSibling.index)
    ) {
      return;
    }
    finalIndex = getIndexBetween(highestSibling.index, higherSiblings[0].index);
  } else {
    finalIndex = getIndexAbove(highestSibling.index);
  }
  if (finalIndex !== reparentedArrow.index) {
    editor.updateShapes([{ id: arrowId, type: "arrow", index: finalIndex }]);
  }
}
function arrowDidUpdate(editor, arrow5) {
  const bindings = getArrowBindings(editor, arrow5);
  for (const handle of ["start", "end"]) {
    const binding = bindings[handle];
    if (!binding) continue;
    const boundShape = editor.getShape(binding.toId);
    const isShapeInSamePageAsArrow = editor.getAncestorPageId(arrow5) === editor.getAncestorPageId(boundShape);
    if (!boundShape || !isShapeInSamePageAsArrow) {
      updateArrowTerminal({ editor, arrow: arrow5, terminal: handle, unbind: true });
    }
  }
  reparentArrow(editor, arrow5.id);
}
function updateArrowTerminal({
  editor,
  arrow: arrow5,
  terminal,
  unbind: unbind2 = false,
  useHandle = false
}) {
  const info = getArrowInfo(editor, arrow5);
  if (!info) {
    throw new Error("expected arrow info");
  }
  const startPoint = useHandle ? info.start.handle : info.start.point;
  const endPoint = useHandle ? info.end.handle : info.end.point;
  const point = terminal === "start" ? startPoint : endPoint;
  const update = {
    id: arrow5.id,
    type: "arrow",
    props: {
      [terminal]: { x: point.x, y: point.y },
      bend: arrow5.props.bend
    }
  };
  if (info.type === "arc") {
    const newStart = terminal === "start" ? startPoint : info.start.handle;
    const newEnd = terminal === "end" ? endPoint : info.end.handle;
    const newMidPoint = Vec.Med(newStart, newEnd);
    const lineSegment = Vec.Sub(newStart, newEnd).per().uni().mul(info.handleArc.radius * 2 * Math.sign(arrow5.props.bend));
    const intersections = intersectLineSegmentCircle(
      info.handleArc.center,
      Vec.Add(newMidPoint, lineSegment),
      info.handleArc.center,
      info.handleArc.radius
    );
    assert((intersections == null ? void 0 : intersections.length) === 1);
    const bend = Vec.Dist(newMidPoint, intersections[0]) * Math.sign(arrow5.props.bend);
    if (!approximately(bend, update.props.bend)) {
      update.props.bend = bend;
    }
  }
  editor.updateShape(update);
  if (unbind2) {
    removeArrowBinding(editor, arrow5, terminal);
  }
}

// ../node_modules/tldraw/dist-esm/lib/canvas/TldrawCropHandles.mjs
var import_jsx_runtime187 = __toESM(require_jsx_runtime(), 1);
var import_classnames30 = __toESM(require_classnames(), 1);
function TldrawCropHandles({
  size: size4,
  width,
  height,
  hideAlternateHandles
}) {
  const cropStrokeWidth = toDomPrecision(size4 / 3);
  const offset4 = cropStrokeWidth / 2;
  const msg2 = useTranslation();
  return (0, import_jsx_runtime187.jsxs)("svg", { className: "tl-overlays__item", "aria-hidden": "true", children: [
    (0, import_jsx_runtime187.jsx)(
      "polyline",
      {
        className: "tl-corner-crop-handle",
        points: `
						${toDomPrecision(0 - offset4)},${toDomPrecision(size4)} 
						${toDomPrecision(0 - offset4)},${toDomPrecision(0 - offset4)} 
						${toDomPrecision(size4)},${toDomPrecision(0 - offset4)}`,
        strokeWidth: cropStrokeWidth,
        "data-testid": "selection.crop.top_left",
        role: "button",
        "aria-label": msg2("handle.crop.top-left")
      }
    ),
    (0, import_jsx_runtime187.jsx)(
      "line",
      {
        className: (0, import_classnames30.default)("tl-corner-crop-edge-handle", {
          "tl-hidden": hideAlternateHandles
        }),
        x1: toDomPrecision(width / 2 - size4),
        y1: toDomPrecision(0 - offset4),
        x2: toDomPrecision(width / 2 + size4),
        y2: toDomPrecision(0 - offset4),
        strokeWidth: cropStrokeWidth,
        "data-testid": "selection.crop.top",
        role: "button",
        "aria-label": msg2("handle.crop.top")
      }
    ),
    (0, import_jsx_runtime187.jsx)(
      "polyline",
      {
        className: (0, import_classnames30.default)("tl-corner-crop-handle", {
          "tl-hidden": hideAlternateHandles
        }),
        points: `
						${toDomPrecision(width - size4)},${toDomPrecision(0 - offset4)} 
						${toDomPrecision(width + offset4)},${toDomPrecision(0 - offset4)} 
						${toDomPrecision(width + offset4)},${toDomPrecision(size4)}`,
        strokeWidth: cropStrokeWidth,
        "data-testid": "selection.crop.top_right",
        role: "button",
        "aria-label": msg2("handle.crop.top-right")
      }
    ),
    (0, import_jsx_runtime187.jsx)(
      "line",
      {
        className: (0, import_classnames30.default)("tl-corner-crop-edge-handle", {
          "tl-hidden": hideAlternateHandles
        }),
        x1: toDomPrecision(width + offset4),
        y1: toDomPrecision(height / 2 - size4),
        x2: toDomPrecision(width + offset4),
        y2: toDomPrecision(height / 2 + size4),
        strokeWidth: cropStrokeWidth,
        "data-testid": "selection.crop.right",
        role: "button",
        "aria-label": msg2("handle.crop.right")
      }
    ),
    (0, import_jsx_runtime187.jsx)(
      "polyline",
      {
        className: "tl-corner-crop-handle",
        points: `
						${toDomPrecision(width + offset4)},${toDomPrecision(height - size4)} 
						${toDomPrecision(width + offset4)},${toDomPrecision(height + offset4)}
						${toDomPrecision(width - size4)},${toDomPrecision(height + offset4)}`,
        strokeWidth: cropStrokeWidth,
        "data-testid": "selection.crop.bottom_right",
        role: "button",
        "aria-label": msg2("handle.crop.bottom-right")
      }
    ),
    (0, import_jsx_runtime187.jsx)(
      "line",
      {
        className: (0, import_classnames30.default)("tl-corner-crop-edge-handle", {
          "tl-hidden": hideAlternateHandles
        }),
        x1: toDomPrecision(width / 2 - size4),
        y1: toDomPrecision(height + offset4),
        x2: toDomPrecision(width / 2 + size4),
        y2: toDomPrecision(height + offset4),
        strokeWidth: cropStrokeWidth,
        "data-testid": "selection.crop.bottom",
        role: "button",
        "aria-label": msg2("handle.crop.bottom")
      }
    ),
    (0, import_jsx_runtime187.jsx)(
      "polyline",
      {
        className: (0, import_classnames30.default)("tl-corner-crop-handle", {
          "tl-hidden": hideAlternateHandles
        }),
        points: `
						${toDomPrecision(0 + size4)},${toDomPrecision(height + offset4)} 
						${toDomPrecision(0 - offset4)},${toDomPrecision(height + offset4)}
						${toDomPrecision(0 - offset4)},${toDomPrecision(height - size4)}`,
        strokeWidth: cropStrokeWidth,
        "data-testid": "selection.crop.bottom_left",
        role: "button",
        "aria-label": msg2("handle.crop.bottom-left")
      }
    ),
    (0, import_jsx_runtime187.jsx)(
      "line",
      {
        className: (0, import_classnames30.default)("tl-corner-crop-edge-handle", {
          "tl-hidden": hideAlternateHandles
        }),
        x1: toDomPrecision(0 - offset4),
        y1: toDomPrecision(height / 2 - size4),
        x2: toDomPrecision(0 - offset4),
        y2: toDomPrecision(height / 2 + size4),
        strokeWidth: cropStrokeWidth,
        "data-testid": "selection.crop.left",
        role: "button",
        "aria-label": msg2("handle.crop.left")
      }
    )
  ] });
}

// ../node_modules/tldraw/dist-esm/lib/canvas/TldrawHandles.mjs
var import_jsx_runtime188 = __toESM(require_jsx_runtime(), 1);
function TldrawHandles({ children }) {
  const editor = useEditor();
  const shouldDisplayHandles = useValue(
    "shouldDisplayHandles",
    () => {
      if (editor.isInAny("select.idle", "select.pointing_handle", "select.pointing_shape")) {
        return true;
      }
      if (editor.isInAny("select.editing_shape")) {
        const onlySelectedShape = editor.getOnlySelectedShape();
        return onlySelectedShape && editor.isShapeOfType(onlySelectedShape, "note");
      }
      return false;
    },
    [editor]
  );
  if (!shouldDisplayHandles) return null;
  return (0, import_jsx_runtime188.jsx)("svg", { className: "tl-user-handles tl-overlays__item", "aria-hidden": "true", children });
}

// ../node_modules/tldraw/dist-esm/lib/canvas/TldrawOverlays.mjs
var import_jsx_runtime189 = __toESM(require_jsx_runtime(), 1);

// ../node_modules/tldraw/dist-esm/lib/shapes/arrow/arrowTargetState.mjs
var arrowTargetStore = new WeakCache();
function getArrowTargetAtom(editor) {
  return arrowTargetStore.get(editor, () => atom("arrowTarget", null));
}
function getArrowTargetState(editor) {
  return getArrowTargetAtom(editor).get();
}
function clearArrowTargetState(editor) {
  getArrowTargetAtom(editor).set(null);
}
function updateArrowTargetState({
  editor,
  pointInPageSpace,
  arrow: arrow5,
  isPrecise,
  currentBinding,
  oppositeBinding
}) {
  const util = editor.getShapeUtil("arrow");
  if (util.options.shouldIgnoreTargets(editor)) {
    getArrowTargetAtom(editor).set(null);
    return null;
  }
  const arrowKind = arrow5 ? arrow5.props.kind : editor.getStyleForNextShape(ArrowShapeKindStyle);
  const target = editor.getShapeAtPoint(pointInPageSpace, {
    hitInside: true,
    hitFrameInside: true,
    margin: arrowKind === "elbow" ? 8 : [8, 0],
    filter: (targetShape) => {
      return !targetShape.isLocked && editor.canBindShapes({
        fromShape: arrow5 ?? targetFilterFallback,
        toShape: targetShape,
        binding: "arrow"
      });
    }
  });
  if (!target) {
    getArrowTargetAtom(editor).set(null);
    return null;
  }
  const targetGeometryInTargetSpace = editor.getShapeGeometry(target);
  const targetBoundsInTargetSpace = Box.ZeroFix(targetGeometryInTargetSpace.bounds);
  const targetCenterInTargetSpace = targetGeometryInTargetSpace.center;
  const targetTransform = editor.getShapePageTransform(target);
  const pointInTargetSpace = editor.getPointInShapeSpace(target, pointInPageSpace);
  const castDistance = Math.max(
    targetGeometryInTargetSpace.bounds.width,
    targetGeometryInTargetSpace.bounds.height
  );
  const handlesInPageSpace = mapObjectMapValues(ElbowArrowSideDeltas, (side, delta) => {
    const axis = ElbowArrowAxes[ElbowArrowSideAxes[side]];
    const farPoint = Vec.Mul(delta, castDistance).add(targetCenterInTargetSpace);
    let isEnabled = false;
    let handlePointInTargetSpace = axis.v(
      targetBoundsInTargetSpace[side],
      targetBoundsInTargetSpace[axis.crossMid]
    );
    let furthestDistance = 0;
    const intersections = targetGeometryInTargetSpace.intersectLineSegment(
      targetCenterInTargetSpace,
      farPoint,
      Geometry2dFilters.EXCLUDE_NON_STANDARD
    );
    for (const intersection of intersections) {
      const distance = Vec.Dist2(intersection, targetCenterInTargetSpace);
      if (distance > furthestDistance) {
        furthestDistance = distance;
        handlePointInTargetSpace = intersection;
        isEnabled = targetGeometryInTargetSpace.isClosed;
      }
    }
    const handlePointInPageSpace = targetTransform.applyToPoint(handlePointInTargetSpace);
    return { point: handlePointInPageSpace, isEnabled, far: targetTransform.applyToPoint(farPoint) };
  });
  const zoomLevel = editor.getZoomLevel();
  const minDistScaled = util.options.minElbowHandleDistance / zoomLevel;
  const targetCenterInPageSpace = targetTransform.applyToPoint(targetCenterInTargetSpace);
  for (const side of objectMapKeys(handlesInPageSpace)) {
    const handle = handlesInPageSpace[side];
    if (Vec.DistMin(handle.point, targetCenterInPageSpace, minDistScaled)) {
      handle.isEnabled = false;
    }
  }
  let precise2 = isPrecise;
  if (!precise2) {
    if (!currentBinding || currentBinding && target.id !== currentBinding.toId) {
      precise2 = editor.inputs.getPointerVelocity().len() < 0.5;
    }
  }
  if (!isPrecise) {
    if (!targetGeometryInTargetSpace.isClosed) {
      precise2 = true;
    }
    if (oppositeBinding && target.id === oppositeBinding.toId && oppositeBinding.props.isPrecise) {
      precise2 = true;
    }
  }
  const isExact = util.options.shouldBeExact(editor, precise2);
  if (isExact) precise2 = true;
  const shouldSnapCenter = !isExact && precise2 && targetGeometryInTargetSpace.isClosed;
  const shouldSnapEdges = !isExact && (precise2 && arrowKind === "elbow" || !targetGeometryInTargetSpace.isClosed);
  const shouldSnapEdgePoints = !isExact && precise2 && arrowKind === "elbow" && targetGeometryInTargetSpace.isClosed;
  const shouldSnapNone = precise2 && (targetGeometryInTargetSpace.isClosed || isExact);
  const shouldSnapCenterAxis = !isExact && precise2 && arrowKind === "elbow" && targetGeometryInTargetSpace.isClosed;
  let snap = "none";
  let anchorInPageSpace = pointInPageSpace;
  if (!shouldSnapNone) {
    snap = "center";
    anchorInPageSpace = targetCenterInPageSpace;
  }
  if (shouldSnapEdges) {
    const snapDistance = shouldSnapNone ? calculateSnapDistance(
      editor,
      targetBoundsInTargetSpace,
      util.options.elbowArrowEdgeSnapDistance
    ) : Infinity;
    const nearestPointOnEdgeInTargetSpace = targetGeometryInTargetSpace.nearestPoint(
      pointInTargetSpace,
      {
        includeLabels: false,
        includeInternal: false
      }
    );
    const nearestPointOnEdgeInPageSpace = targetTransform.applyToPoint(
      nearestPointOnEdgeInTargetSpace
    );
    const distance = Vec.Dist(nearestPointOnEdgeInPageSpace, pointInPageSpace);
    if (distance < snapDistance) {
      snap = "edge";
      anchorInPageSpace = nearestPointOnEdgeInPageSpace;
    }
  }
  if (shouldSnapCenterAxis) {
    const snapDistance = calculateSnapDistance(
      editor,
      targetBoundsInTargetSpace,
      util.options.elbowArrowAxisSnapDistance
    );
    const distanceFromXAxis = Vec.DistanceToLineSegment(
      handlesInPageSpace.left.far,
      handlesInPageSpace.right.far,
      pointInPageSpace
    );
    const distanceFromYAxis = Vec.DistanceToLineSegment(
      handlesInPageSpace.top.far,
      handlesInPageSpace.bottom.far,
      pointInPageSpace
    );
    const snapAxis = distanceFromXAxis < distanceFromYAxis && distanceFromXAxis < snapDistance ? "x" : distanceFromYAxis < snapDistance ? "y" : null;
    if (snapAxis) {
      const axis = ElbowArrowAxes[snapAxis];
      const loDist2 = Vec.Dist2(handlesInPageSpace[axis.loEdge].far, pointInPageSpace);
      const hiDist2 = Vec.Dist2(handlesInPageSpace[axis.hiEdge].far, pointInPageSpace);
      const side = loDist2 < hiDist2 ? axis.loEdge : axis.hiEdge;
      if (handlesInPageSpace[side].isEnabled) {
        snap = "edge-point";
        anchorInPageSpace = handlesInPageSpace[side].point;
      }
    }
  }
  if (shouldSnapEdgePoints) {
    const snapDistance = calculateSnapDistance(
      editor,
      targetBoundsInTargetSpace,
      util.options.elbowArrowPointSnapDistance
    );
    let closestSide = null;
    let closestDistance = Infinity;
    for (const [side, handle] of objectMapEntries(handlesInPageSpace)) {
      if (!handle.isEnabled) continue;
      const distance = Vec.Dist(handle.point, pointInPageSpace);
      if (distance < snapDistance && distance < closestDistance) {
        closestDistance = distance;
        closestSide = side;
      }
    }
    if (closestSide) {
      snap = "edge-point";
      anchorInPageSpace = handlesInPageSpace[closestSide].point;
    }
  }
  if (shouldSnapCenter) {
    const snapDistance = calculateSnapDistance(
      editor,
      targetBoundsInTargetSpace,
      arrowKind === "elbow" ? util.options.elbowArrowCenterSnapDistance : util.options.arcArrowCenterSnapDistance
    );
    if (Vec.Dist(pointInTargetSpace, targetBoundsInTargetSpace.center) < snapDistance) {
      snap = "center";
      anchorInPageSpace = targetCenterInPageSpace;
    }
  }
  const snapPointInTargetSpace = editor.getPointInShapeSpace(target, anchorInPageSpace);
  const normalizedAnchor = {
    x: invLerp(
      targetBoundsInTargetSpace.minX,
      targetBoundsInTargetSpace.maxX,
      snapPointInTargetSpace.x
    ),
    y: invLerp(
      targetBoundsInTargetSpace.minY,
      targetBoundsInTargetSpace.maxY,
      snapPointInTargetSpace.y
    )
  };
  const result = {
    target,
    arrowKind,
    handlesInPageSpace,
    centerInPageSpace: targetCenterInPageSpace,
    anchorInPageSpace,
    isExact,
    isPrecise: precise2,
    snap,
    normalizedAnchor
  };
  getArrowTargetAtom(editor).set(result);
  return result;
}
var targetFilterFallback = { type: "arrow" };
function calculateSnapDistance(editor, targetBoundsInTargetSpace, idealSnapDistance) {
  return clamp(
    Math.min(targetBoundsInTargetSpace.width, targetBoundsInTargetSpace.height) * 0.15,
    4,
    idealSnapDistance
  ) / editor.getZoomLevel();
}

// ../node_modules/tldraw/dist-esm/lib/canvas/TldrawOverlays.mjs
function TldrawOverlays() {
  const editor = useEditor();
  const shouldShowArrowHints = useValue(
    "should show arrow hints",
    () => {
      if (editor.isInAny("arrow.idle", "arrow.pointing")) return true;
      if (editor.isIn("select.pointing_handle")) {
        const node = editor.getStateDescendant("select.pointing_handle");
        if (node.info.shape.type === "arrow" && (node.info.handle.id === "start" || node.info.handle.id === "end")) {
          return true;
        }
      }
      if (editor.isIn("select.dragging_handle")) {
        const node = editor.getStateDescendant("select.dragging_handle");
        if (node.info.shape.type === "arrow" && (node.info.handle.id === "start" || node.info.handle.id === "end")) {
          return true;
        }
      }
      return false;
    },
    [editor]
  );
  if (!shouldShowArrowHints) return null;
  return (0, import_jsx_runtime189.jsx)(TldrawArrowHints, {});
}
function TldrawArrowHints() {
  const editor = useEditor();
  const { ShapeIndicator } = useEditorComponents();
  const targetInfo = useValue("arrow target info", () => getArrowTargetState(editor), [editor]);
  if (!targetInfo) return null;
  const { handlesInPageSpace, snap, anchorInPageSpace, arrowKind, isExact, isPrecise } = targetInfo;
  const showEdgeHints = !isExact && arrowKind === "elbow";
  return (0, import_jsx_runtime189.jsxs)(import_jsx_runtime189.Fragment, { children: [
    ShapeIndicator && (0, import_jsx_runtime189.jsx)(ShapeIndicator, { shapeId: targetInfo.target.id }),
    showEdgeHints && (0, import_jsx_runtime189.jsxs)("svg", { className: "tl-overlays__item", "aria-hidden": "true", children: [
      (0, import_jsx_runtime189.jsx)(
        "circle",
        {
          cx: anchorInPageSpace.x,
          cy: anchorInPageSpace.y,
          className: `tl-arrow-hint-snap tl-arrow-hint-snap__${isPrecise ? snap ?? "none" : "none"}`
        }
      ),
      Object.entries(handlesInPageSpace).map(([side, handle]) => {
        if (!handle.isEnabled) return null;
        return (0, import_jsx_runtime189.jsx)(
          "circle",
          {
            cx: handle.point.x,
            cy: handle.point.y,
            className: "tl-arrow-hint-handle"
          },
          side
        );
      })
    ] })
  ] });
}

// ../node_modules/tldraw/dist-esm/lib/canvas/TldrawScribble.mjs
var import_jsx_runtime190 = __toESM(require_jsx_runtime(), 1);
var import_classnames31 = __toESM(require_classnames(), 1);

// ../node_modules/tldraw/dist-esm/lib/shapes/shared/freehand/getStrokeOutlinePoints.mjs
var { PI: PI3 } = Math;
var FIXED_PI = PI3 + 1e-4;
function getStrokeOutlineTracks(strokePoints, options2 = {}) {
  const { size: size4 = 16, smoothing = 0.5 } = options2;
  if (strokePoints.length === 0 || size4 <= 0) {
    return { left: [], right: [] };
  }
  const firstStrokePoint = strokePoints[0];
  const lastStrokePoint = strokePoints[strokePoints.length - 1];
  const totalLength = lastStrokePoint.runningLength;
  const minDistance = Math.pow(size4 * smoothing, 2);
  const leftPts = [];
  const rightPts = [];
  let prevVector = strokePoints[0].vector;
  let pl = strokePoints[0].point;
  let pr = pl;
  let tl = pl;
  let tr2 = pr;
  let isPrevPointSharpCorner = false;
  let strokePoint;
  for (let i = 0; i < strokePoints.length; i++) {
    strokePoint = strokePoints[i];
    const { point, vector } = strokePoints[i];
    const prevDpr = strokePoint.vector.dpr(prevVector);
    const nextVector = (i < strokePoints.length - 1 ? strokePoints[i + 1] : strokePoints[i]).vector;
    const nextDpr = i < strokePoints.length - 1 ? nextVector.dpr(strokePoint.vector) : 1;
    const isPointSharpCorner = prevDpr < 0 && !isPrevPointSharpCorner;
    const isNextPointSharpCorner = nextDpr !== null && nextDpr < 0.2;
    if (isPointSharpCorner || isNextPointSharpCorner) {
      if (nextDpr > -0.62 && totalLength - strokePoint.runningLength > strokePoint.radius) {
        const offset22 = prevVector.clone().mul(strokePoint.radius);
        const cpr = prevVector.clone().cpr(nextVector);
        if (cpr < 0) {
          tl = Vec.Add(point, offset22);
          tr2 = Vec.Sub(point, offset22);
        } else {
          tl = Vec.Sub(point, offset22);
          tr2 = Vec.Add(point, offset22);
        }
        leftPts.push(tl);
        rightPts.push(tr2);
      } else {
        const offset22 = prevVector.clone().mul(strokePoint.radius).per();
        const start = Vec.Sub(strokePoint.input, offset22);
        for (let step = 1 / 13, t2 = 0; t2 < 1; t2 += step) {
          tl = Vec.RotWith(start, strokePoint.input, FIXED_PI * t2);
          leftPts.push(tl);
          tr2 = Vec.RotWith(start, strokePoint.input, FIXED_PI + FIXED_PI * -t2);
          rightPts.push(tr2);
        }
      }
      pl = tl;
      pr = tr2;
      if (isNextPointSharpCorner) {
        isPrevPointSharpCorner = true;
      }
      continue;
    }
    isPrevPointSharpCorner = false;
    if (strokePoint === firstStrokePoint || strokePoint === lastStrokePoint) {
      const offset22 = Vec.Per(vector).mul(strokePoint.radius);
      leftPts.push(Vec.Sub(point, offset22));
      rightPts.push(Vec.Add(point, offset22));
      continue;
    }
    const offset4 = Vec.Lrp(nextVector, vector, nextDpr).per().mul(strokePoint.radius);
    tl = Vec.Sub(point, offset4);
    if (i <= 1 || Vec.Dist2(pl, tl) > minDistance) {
      leftPts.push(tl);
      pl = tl;
    }
    tr2 = Vec.Add(point, offset4);
    if (i <= 1 || Vec.Dist2(pr, tr2) > minDistance) {
      rightPts.push(tr2);
      pr = tr2;
    }
    prevVector = vector;
    continue;
  }
  return {
    left: leftPts,
    right: rightPts
  };
}
function getStrokeOutlinePoints(strokePoints, options2 = {}) {
  const { size: size4 = 16, start = {}, end = {}, last: isComplete = false } = options2;
  const { cap: capStart = true } = start;
  const { cap: capEnd = true } = end;
  if (strokePoints.length === 0 || size4 <= 0) {
    return [];
  }
  const firstStrokePoint = strokePoints[0];
  const lastStrokePoint = strokePoints[strokePoints.length - 1];
  const totalLength = lastStrokePoint.runningLength;
  const taperStart = start.taper === false ? 0 : start.taper === true ? Math.max(size4, totalLength) : start.taper;
  const taperEnd = end.taper === false ? 0 : end.taper === true ? Math.max(size4, totalLength) : end.taper;
  const { left: leftPts, right: rightPts } = getStrokeOutlineTracks(strokePoints, options2);
  const firstPoint = firstStrokePoint.point;
  const lastPoint = strokePoints.length > 1 ? strokePoints[strokePoints.length - 1].point : Vec.AddXY(firstStrokePoint.point, 1, 1);
  if (strokePoints.length === 1) {
    if (!(taperStart || taperEnd) || isComplete) {
      const start2 = Vec.Add(
        firstPoint,
        Vec.Sub(firstPoint, lastPoint).uni().per().mul(-firstStrokePoint.radius)
      );
      const dotPts = [];
      for (let step = 1 / 13, t2 = step; t2 <= 1; t2 += step) {
        dotPts.push(Vec.RotWith(start2, firstPoint, FIXED_PI * 2 * t2));
      }
      return dotPts;
    }
  }
  const startCap = [];
  if (taperStart || taperEnd && strokePoints.length === 1) {
  } else if (capStart) {
    for (let step = 1 / 8, t2 = step; t2 <= 1; t2 += step) {
      const pt = Vec.RotWith(rightPts[0], firstPoint, FIXED_PI * t2);
      startCap.push(pt);
    }
  } else {
    const cornersVector = Vec.Sub(leftPts[0], rightPts[0]);
    const offsetA = Vec.Mul(cornersVector, 0.5);
    const offsetB = Vec.Mul(cornersVector, 0.51);
    startCap.push(
      Vec.Sub(firstPoint, offsetA),
      Vec.Sub(firstPoint, offsetB),
      Vec.Add(firstPoint, offsetB),
      Vec.Add(firstPoint, offsetA)
    );
  }
  const endCap = [];
  const direction = lastStrokePoint.vector.clone().per().neg();
  if (taperEnd || taperStart && strokePoints.length === 1) {
    endCap.push(lastPoint);
  } else if (capEnd) {
    const start2 = Vec.Add(lastPoint, Vec.Mul(direction, lastStrokePoint.radius));
    for (let step = 1 / 29, t2 = step; t2 < 1; t2 += step) {
      endCap.push(Vec.RotWith(start2, lastPoint, FIXED_PI * 3 * t2));
    }
  } else {
    endCap.push(
      Vec.Add(lastPoint, Vec.Mul(direction, lastStrokePoint.radius)),
      Vec.Add(lastPoint, Vec.Mul(direction, lastStrokePoint.radius * 0.99)),
      Vec.Sub(lastPoint, Vec.Mul(direction, lastStrokePoint.radius * 0.99)),
      Vec.Sub(lastPoint, Vec.Mul(direction, lastStrokePoint.radius))
    );
  }
  return leftPts.concat(endCap, rightPts.reverse(), startCap);
}

// ../node_modules/tldraw/dist-esm/lib/shapes/shared/freehand/getStrokePoints.mjs
var MIN_START_PRESSURE = 0.025;
var MIN_END_PRESSURE = 0.01;
function getStrokePoints(rawInputPoints, options2 = {}) {
  var _a6;
  const { streamline = 0.5, size: size4 = 16, simulatePressure = false } = options2;
  if (rawInputPoints.length === 0) return [];
  const t2 = 0.15 + (1 - streamline) * 0.85;
  let pts = rawInputPoints.map(Vec.From);
  let pointsRemovedFromNearEnd = 0;
  if (!simulatePressure) {
    let pt2 = pts[0];
    while (pt2) {
      if (pt2.z >= MIN_START_PRESSURE) break;
      pts.shift();
      pt2 = pts[0];
    }
  }
  if (!simulatePressure) {
    let pt2 = pts[pts.length - 1];
    while (pt2) {
      if (pt2.z >= MIN_END_PRESSURE) break;
      pts.pop();
      pt2 = pts[pts.length - 1];
    }
  }
  if (pts.length === 0)
    return [
      {
        point: Vec.From(rawInputPoints[0]),
        input: Vec.From(rawInputPoints[0]),
        pressure: simulatePressure ? 0.5 : 0.15,
        vector: new Vec(1, 1),
        distance: 0,
        runningLength: 0,
        radius: 1
      }
    ];
  let pt = pts[1];
  while (pt) {
    if (Vec.Dist2(pt, pts[0]) > (size4 / 3) ** 2) break;
    pts[0].z = Math.max(pts[0].z, pt.z);
    pts.splice(1, 1);
    pt = pts[1];
  }
  const last2 = pts.pop();
  pt = pts[pts.length - 1];
  while (pt) {
    if (Vec.Dist2(pt, last2) > (size4 / 3) ** 2) break;
    pts.pop();
    pt = pts[pts.length - 1];
    pointsRemovedFromNearEnd++;
  }
  pts.push(last2);
  const isComplete = options2.last || !options2.simulatePressure || pts.length > 1 && Vec.Dist2(pts[pts.length - 1], pts[pts.length - 2]) < size4 ** 2 || pointsRemovedFromNearEnd > 0;
  if (pts.length === 2 && options2.simulatePressure) {
    const last22 = pts[1];
    pts = pts.slice(0, -1);
    for (let i = 1; i < 5; i++) {
      const next = Vec.Lrp(pts[0], last22, i / 4);
      next.z = (pts[0].z + (last22.z - pts[0].z)) * i / 4;
      pts.push(next);
    }
  }
  const strokePoints = [
    {
      point: pts[0],
      input: pts[0],
      pressure: simulatePressure ? 0.5 : pts[0].z,
      vector: new Vec(1, 1),
      distance: 0,
      runningLength: 0,
      radius: 1
    }
  ];
  let totalLength = 0;
  let prev = strokePoints[0];
  let point, distance;
  if (isComplete && streamline > 0) {
    pts.push(pts[pts.length - 1].clone());
  }
  for (let i = 1, n = pts.length; i < n; i++) {
    point = !t2 || options2.last && i === n - 1 ? pts[i].clone() : pts[i].clone().lrp(prev.point, 1 - t2);
    if (prev.point.equals(point)) continue;
    distance = Vec.Dist(point, prev.point);
    totalLength += distance;
    if (i < 4 && totalLength < size4) {
      continue;
    }
    prev = {
      input: pts[i],
      // The adjusted point
      point,
      // The input pressure (or .5 if not specified)
      pressure: simulatePressure ? 0.5 : pts[i].z,
      // The vector from the current point to the previous point
      vector: Vec.Sub(prev.point, point).uni(),
      // The distance between the current point and the previous point
      distance,
      // The total distance so far
      runningLength: totalLength,
      // The stroke point's radius
      radius: 1
    };
    strokePoints.push(prev);
  }
  if ((_a6 = strokePoints[1]) == null ? void 0 : _a6.vector) {
    strokePoints[0].vector = strokePoints[1].vector.clone();
  }
  if (totalLength < 1) {
    const maxPressureAmongPoints = Math.max(0.5, ...strokePoints.map((s) => s.pressure));
    strokePoints.forEach((s) => s.pressure = maxPressureAmongPoints);
  }
  return strokePoints;
}

// ../node_modules/tldraw/dist-esm/lib/shapes/shared/freehand/setStrokePointRadii.mjs
var { min: min2 } = Math;
var RATE_OF_PRESSURE_CHANGE = 0.275;
function setStrokePointRadii(strokePoints, options2) {
  const {
    size: size4 = 16,
    thinning = 0.5,
    simulatePressure = true,
    easing = (t2) => t2,
    start = {},
    end = {}
  } = options2;
  const { easing: taperStartEase = EASINGS.easeOutQuad } = start;
  const { easing: taperEndEase = EASINGS.easeOutCubic } = end;
  const totalLength = strokePoints[strokePoints.length - 1].runningLength;
  let firstRadius;
  let prevPressure = strokePoints[0].pressure;
  let strokePoint;
  if (!simulatePressure && totalLength < size4) {
    const max2 = strokePoints.reduce((max22, curr) => Math.max(max22, curr.pressure), 0.5);
    strokePoints.forEach((sp) => {
      sp.pressure = max2;
      sp.radius = size4 * easing(0.5 - thinning * (0.5 - sp.pressure));
    });
    return strokePoints;
  } else {
    let p;
    for (let i = 0, n = strokePoints.length; i < n; i++) {
      strokePoint = strokePoints[i];
      if (strokePoint.runningLength > size4 * 5) break;
      const sp = min2(1, strokePoint.distance / size4);
      if (simulatePressure) {
        const rp = min2(1, 1 - sp);
        p = min2(1, prevPressure + (rp - prevPressure) * (sp * RATE_OF_PRESSURE_CHANGE));
      } else {
        p = min2(1, prevPressure + (strokePoint.pressure - prevPressure) * 0.5);
      }
      prevPressure = prevPressure + (p - prevPressure) * 0.5;
    }
    for (let i = 0; i < strokePoints.length; i++) {
      strokePoint = strokePoints[i];
      if (thinning) {
        let { pressure } = strokePoint;
        const sp = min2(1, strokePoint.distance / size4);
        if (simulatePressure) {
          const rp = min2(1, 1 - sp);
          pressure = min2(1, prevPressure + (rp - prevPressure) * (sp * RATE_OF_PRESSURE_CHANGE));
        } else {
          pressure = min2(
            1,
            prevPressure + (pressure - prevPressure) * (sp * RATE_OF_PRESSURE_CHANGE)
          );
        }
        strokePoint.radius = size4 * easing(0.5 - thinning * (0.5 - pressure));
        prevPressure = pressure;
      } else {
        strokePoint.radius = size4 / 2;
      }
      if (firstRadius === void 0) {
        firstRadius = strokePoint.radius;
      }
    }
  }
  const taperStart = start.taper === false ? 0 : start.taper === true ? Math.max(size4, totalLength) : start.taper;
  const taperEnd = end.taper === false ? 0 : end.taper === true ? Math.max(size4, totalLength) : end.taper;
  if (taperStart || taperEnd) {
    for (let i = 0; i < strokePoints.length; i++) {
      strokePoint = strokePoints[i];
      const { runningLength } = strokePoint;
      const ts2 = runningLength < taperStart ? taperStartEase(runningLength / taperStart) : 1;
      const te = totalLength - runningLength < taperEnd ? taperEndEase((totalLength - runningLength) / taperEnd) : 1;
      strokePoint.radius = Math.max(0.01, strokePoint.radius * Math.min(ts2, te));
    }
  }
  return strokePoints;
}

// ../node_modules/tldraw/dist-esm/lib/shapes/shared/freehand/getStroke.mjs
function getStroke(points, options2 = {}) {
  return getStrokeOutlinePoints(
    setStrokePointRadii(getStrokePoints(points, options2), options2),
    options2
  );
}

// ../node_modules/tldraw/dist-esm/lib/canvas/TldrawScribble.mjs
function TldrawScribble({ scribble, zoom, color, opacity, className }) {
  if (!scribble.points.length) return null;
  const stroke = getStroke(scribble.points, {
    size: scribble.size / zoom,
    start: { taper: scribble.taper, easing: EASINGS.linear },
    last: scribble.state === "stopping",
    simulatePressure: false,
    streamline: 0.32
  });
  let d;
  if (stroke.length < 4) {
    const r = scribble.size / zoom / 2;
    const { x, y } = scribble.points[scribble.points.length - 1];
    d = `M ${x - r},${y} a ${r},${r} 0 1,0 ${r * 2},0 a ${r},${r} 0 1,0 ${-r * 2},0`;
  } else {
    d = getSvgPathFromPoints(stroke);
  }
  return (0, import_jsx_runtime190.jsx)("svg", { className: className ? (0, import_classnames31.default)("tl-overlays__item", className) : className, children: (0, import_jsx_runtime190.jsx)(
    "path",
    {
      className: "tl-scribble",
      d,
      fill: color ?? `var(--tl-color-${scribble.color})`,
      opacity: opacity ?? scribble.opacity
    }
  ) });
}

// ../node_modules/tldraw/dist-esm/lib/canvas/TldrawSelectionForeground.mjs
var import_jsx_runtime191 = __toESM(require_jsx_runtime(), 1);
var import_classnames32 = __toESM(require_classnames(), 1);
var import_react123 = __toESM(require_react(), 1);
var TldrawSelectionForeground = track(function TldrawSelectionForeground2({
  bounds,
  rotation
}) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const rSvg = (0, import_react123.useRef)(null);
  const isReadonlyMode = useReadonly();
  const topEvents = useSelectionEvents("top");
  const rightEvents = useSelectionEvents("right");
  const bottomEvents = useSelectionEvents("bottom");
  const leftEvents = useSelectionEvents("left");
  const topLeftEvents = useSelectionEvents("top_left");
  const topRightEvents = useSelectionEvents("top_right");
  const bottomRightEvents = useSelectionEvents("bottom_right");
  const bottomLeftEvents = useSelectionEvents("bottom_left");
  const isDefaultCursor = editor.getInstanceState().cursor.type === "default";
  const isCoarsePointer = editor.getInstanceState().isCoarsePointer;
  const onlyShape = editor.getOnlySelectedShape();
  const isLockedShape = onlyShape && editor.isShapeOrAncestorLocked(onlyShape);
  const expandOutlineBy = onlyShape ? editor.getShapeUtil(onlyShape).expandSelectionOutlinePx(onlyShape) : 0;
  const expandedBounds = expandOutlineBy instanceof Box ? bounds.clone().expand(expandOutlineBy).zeroFix() : bounds.clone().expandBy(expandOutlineBy).zeroFix();
  const selectionRotation = editor.getSelectionRotation();
  const isShapeTooCloseToContextualToolbar = selectionRotation / HALF_PI > 1.6 && selectionRotation / HALF_PI < 2.4;
  useTransform(rSvg, bounds == null ? void 0 : bounds.x, bounds == null ? void 0 : bounds.y, 1, selectionRotation, {
    x: expandedBounds.x - bounds.x,
    y: expandedBounds.y - bounds.y
  });
  if (onlyShape && editor.isShapeHidden(onlyShape)) return null;
  const zoom = editor.getEfficientZoomLevel();
  const isChangingStyle = editor.getInstanceState().isChangingStyle;
  const width = expandedBounds.width;
  const height = expandedBounds.height;
  const size4 = 8 / zoom;
  const isTinyX = width < size4 * 2;
  const isTinyY = height < size4 * 2;
  const isSmallX = width < size4 * 4;
  const isSmallY = height < size4 * 4;
  const isSmallCropX = width < size4 * 5;
  const isSmallCropY = height < size4 * 5;
  const mobileHandleMultiplier = isCoarsePointer ? 1.75 : 1;
  const targetSize = 6 / zoom * mobileHandleMultiplier;
  const targetSizeX = (isSmallX ? targetSize / 2 : targetSize) * (mobileHandleMultiplier * 0.75);
  const targetSizeY = (isSmallY ? targetSize / 2 : targetSize) * (mobileHandleMultiplier * 0.75);
  const showSelectionBounds = (onlyShape ? !editor.getShapeUtil(onlyShape).hideSelectionBoundsFg(onlyShape) : true) && !isChangingStyle;
  let shouldDisplayBox = showSelectionBounds && editor.isInAny(
    "select.idle",
    "select.brushing",
    "select.scribble_brushing",
    "select.pointing_canvas",
    "select.pointing_selection",
    "select.pointing_shape",
    "select.crop.idle",
    "select.crop.pointing_crop",
    "select.crop.pointing_crop_handle",
    "select.pointing_resize_handle"
  ) || showSelectionBounds && editor.isIn("select.resizing") && onlyShape && editor.isShapeOfType(onlyShape, "text");
  if (onlyShape && shouldDisplayBox) {
    if (tlenv.isFirefox && editor.isShapeOfType(onlyShape, "embed")) {
      shouldDisplayBox = false;
    }
  }
  const showCropHandles = editor.isInAny(
    "select.crop.idle",
    "select.crop.pointing_crop",
    "select.crop.pointing_crop_handle"
  ) && !isChangingStyle && !isReadonlyMode;
  const shouldDisplayControls = editor.isInAny(
    "select.idle",
    "select.pointing_selection",
    "select.pointing_shape",
    "select.crop.idle"
  ) && !isChangingStyle && !isReadonlyMode;
  const showCornerRotateHandles = !isCoarsePointer && !(isTinyX || isTinyY) && (shouldDisplayControls || showCropHandles) && (onlyShape ? !editor.getShapeUtil(onlyShape).hideRotateHandle(onlyShape) : true) && !isLockedShape;
  const showMobileRotateHandle = isCoarsePointer && (!isSmallX || !isSmallY) && (shouldDisplayControls || showCropHandles) && (onlyShape ? !editor.getShapeUtil(onlyShape).hideRotateHandle(onlyShape) : true) && !isLockedShape;
  const showResizeHandles = shouldDisplayControls && (onlyShape ? editor.getShapeUtil(onlyShape).canResize(onlyShape) && !editor.getShapeUtil(onlyShape).hideResizeHandles(onlyShape) : true) && !showCropHandles && !isLockedShape;
  const hideAlternateCornerHandles = isTinyX || isTinyY;
  const showOnlyOneHandle = isTinyX && isTinyY;
  const hideAlternateCropHandles = isSmallCropX || isSmallCropY;
  const showHandles = showResizeHandles || showCropHandles;
  const hideRotateCornerHandles = !showCornerRotateHandles;
  const hideMobileRotateHandle = !shouldDisplayControls || !showMobileRotateHandle;
  const hideTopLeftCorner = !shouldDisplayControls || !showHandles;
  const hideTopRightCorner = !shouldDisplayControls || !showHandles || hideAlternateCornerHandles;
  const hideBottomLeftCorner = !shouldDisplayControls || !showHandles || hideAlternateCornerHandles;
  const hideBottomRightCorner = !shouldDisplayControls || !showHandles || showOnlyOneHandle && !showCropHandles;
  let hideVerticalEdgeTargets = true;
  let hideHorizontalEdgeTargets = true;
  if (showCropHandles) {
    hideVerticalEdgeTargets = hideAlternateCropHandles;
    hideHorizontalEdgeTargets = hideAlternateCropHandles;
  } else if (showResizeHandles) {
    hideVerticalEdgeTargets = hideAlternateCornerHandles || showOnlyOneHandle || isCoarsePointer;
    const isMobileAndTextShape = isCoarsePointer && onlyShape && onlyShape.type === "text";
    hideHorizontalEdgeTargets = hideVerticalEdgeTargets && !isMobileAndTextShape;
  }
  const textHandleHeight = Math.min(24 / zoom, height - targetSizeY * 3);
  const showTextResizeHandles = shouldDisplayControls && isCoarsePointer && onlyShape && editor.isShapeOfType(onlyShape, "text") && textHandleHeight * zoom >= 4;
  const isMediaShape = onlyShape && (editor.isShapeOfType(onlyShape, "image") || editor.isShapeOfType(onlyShape, "video"));
  return (0, import_jsx_runtime191.jsx)(
    "svg",
    {
      className: "tl-overlays__item tl-selection__fg",
      "data-testid": "selection-foreground",
      "aria-hidden": "true",
      children: (0, import_jsx_runtime191.jsxs)("g", { ref: rSvg, children: [
        shouldDisplayBox && (0, import_jsx_runtime191.jsx)(
          "rect",
          {
            className: "tl-selection__fg__outline",
            width: toDomPrecision(width),
            height: toDomPrecision(height)
          }
        ),
        (0, import_jsx_runtime191.jsx)(
          RotateCornerHandle,
          {
            "data-testid": "selection.rotate.top-left",
            cx: 0,
            cy: 0,
            targetSize,
            corner: "top_left_rotate",
            cursor: isDefaultCursor ? getCursor("nwse-rotate", rotation) : void 0,
            isHidden: hideRotateCornerHandles
          }
        ),
        (0, import_jsx_runtime191.jsx)(
          RotateCornerHandle,
          {
            "data-testid": "selection.rotate.top-right",
            cx: width + targetSize * 3,
            cy: 0,
            targetSize,
            corner: "top_right_rotate",
            cursor: isDefaultCursor ? getCursor("nesw-rotate", rotation) : void 0,
            isHidden: hideRotateCornerHandles
          }
        ),
        (0, import_jsx_runtime191.jsx)(
          RotateCornerHandle,
          {
            "data-testid": "selection.rotate.bottom-left",
            cx: 0,
            cy: height + targetSize * 3,
            targetSize,
            corner: "bottom_left_rotate",
            cursor: isDefaultCursor ? getCursor("swne-rotate", rotation) : void 0,
            isHidden: hideRotateCornerHandles
          }
        ),
        (0, import_jsx_runtime191.jsx)(
          RotateCornerHandle,
          {
            "data-testid": "selection.rotate.bottom-right",
            cx: width + targetSize * 3,
            cy: height + targetSize * 3,
            targetSize,
            corner: "bottom_right_rotate",
            cursor: isDefaultCursor ? getCursor("senw-rotate", rotation) : void 0,
            isHidden: hideRotateCornerHandles
          }
        ),
        (0, import_jsx_runtime191.jsx)(
          MobileRotateHandle,
          {
            "data-testid": "selection.rotate.mobile",
            cx: isSmallX ? -targetSize * 1.5 : width / 2,
            cy: isSmallX ? height / 2 : isMediaShape && !isShapeTooCloseToContextualToolbar ? height + targetSize * 1.5 : -targetSize * 1.5,
            size: size4,
            isHidden: hideMobileRotateHandle
          }
        ),
        (0, import_jsx_runtime191.jsx)(
          ResizeHandle,
          {
            hide: hideVerticalEdgeTargets,
            dataTestId: "selection.resize.top",
            ariaLabel: msg2("handle.resize-top"),
            x: 0,
            y: toDomPrecision(0 - (isSmallY ? targetSizeY * 2 : targetSizeY)),
            width: toDomPrecision(width),
            height: toDomPrecision(Math.max(1, targetSizeY * 2)),
            cursor: isDefaultCursor ? getCursor("ns-resize", rotation) : void 0,
            events: topEvents
          }
        ),
        (0, import_jsx_runtime191.jsx)(
          ResizeHandle,
          {
            hide: hideHorizontalEdgeTargets,
            dataTestId: "selection.resize.right",
            ariaLabel: msg2("handle.resize-right"),
            x: toDomPrecision(width - (isSmallX ? 0 : targetSizeX)),
            y: 0,
            height: toDomPrecision(height),
            width: toDomPrecision(Math.max(1, targetSizeX * 2)),
            cursor: isDefaultCursor ? getCursor("ew-resize", rotation) : void 0,
            events: rightEvents
          }
        ),
        (0, import_jsx_runtime191.jsx)(
          ResizeHandle,
          {
            hide: hideVerticalEdgeTargets,
            dataTestId: "selection.resize.bottom",
            ariaLabel: msg2("handle.resize-bottom"),
            x: 0,
            y: toDomPrecision(height - (isSmallY ? 0 : targetSizeY)),
            width: toDomPrecision(width),
            height: toDomPrecision(Math.max(1, targetSizeY * 2)),
            cursor: isDefaultCursor ? getCursor("ns-resize", rotation) : void 0,
            events: bottomEvents
          }
        ),
        (0, import_jsx_runtime191.jsx)(
          ResizeHandle,
          {
            hide: hideHorizontalEdgeTargets,
            dataTestId: "selection.resize.left",
            ariaLabel: msg2("handle.resize-left"),
            x: toDomPrecision(0 - (isSmallX ? targetSizeX * 2 : targetSizeX)),
            y: 0,
            height: toDomPrecision(height),
            width: toDomPrecision(Math.max(1, targetSizeX * 2)),
            cursor: isDefaultCursor ? getCursor("ew-resize", rotation) : void 0,
            events: leftEvents
          }
        ),
        (0, import_jsx_runtime191.jsx)(
          ResizeHandle,
          {
            hide: hideTopLeftCorner,
            dataTestId: "selection.target.top-left",
            ariaLabel: msg2("handle.resize-top-left"),
            x: toDomPrecision(0 - (isSmallX ? targetSizeX * 2 : targetSizeX * 1.5)),
            y: toDomPrecision(0 - (isSmallY ? targetSizeY * 2 : targetSizeY * 1.5)),
            width: toDomPrecision(targetSizeX * 3),
            height: toDomPrecision(targetSizeY * 3),
            cursor: isDefaultCursor ? getCursor("nwse-resize", rotation) : void 0,
            events: topLeftEvents
          }
        ),
        (0, import_jsx_runtime191.jsx)(
          ResizeHandle,
          {
            hide: hideTopRightCorner,
            dataTestId: "selection.target.top-right",
            ariaLabel: msg2("handle.resize-top-right"),
            x: toDomPrecision(width - (isSmallX ? 0 : targetSizeX * 1.5)),
            y: toDomPrecision(0 - (isSmallY ? targetSizeY * 2 : targetSizeY * 1.5)),
            width: toDomPrecision(targetSizeX * 3),
            height: toDomPrecision(targetSizeY * 3),
            cursor: isDefaultCursor ? getCursor("nesw-resize", rotation) : void 0,
            events: topRightEvents
          }
        ),
        (0, import_jsx_runtime191.jsx)(
          ResizeHandle,
          {
            hide: hideBottomRightCorner,
            dataTestId: "selection.target.bottom-right",
            ariaLabel: msg2("handle.resize-bottom-right"),
            x: toDomPrecision(width - (isSmallX ? targetSizeX : targetSizeX * 1.5)),
            y: toDomPrecision(height - (isSmallY ? targetSizeY : targetSizeY * 1.5)),
            width: toDomPrecision(targetSizeX * 3),
            height: toDomPrecision(targetSizeY * 3),
            cursor: isDefaultCursor ? getCursor("nwse-resize", rotation) : void 0,
            events: bottomRightEvents
          }
        ),
        (0, import_jsx_runtime191.jsx)(
          ResizeHandle,
          {
            hide: hideBottomLeftCorner,
            dataTestId: "selection.target.bottom-left",
            ariaLabel: msg2("handle.resize-bottom-left"),
            x: toDomPrecision(0 - (isSmallX ? targetSizeX * 3 : targetSizeX * 1.5)),
            y: toDomPrecision(height - (isSmallY ? 0 : targetSizeY * 1.5)),
            width: toDomPrecision(targetSizeX * 3),
            height: toDomPrecision(targetSizeY * 3),
            cursor: isDefaultCursor ? getCursor("nesw-resize", rotation) : void 0,
            events: bottomLeftEvents
          }
        ),
        showResizeHandles && (0, import_jsx_runtime191.jsxs)(import_jsx_runtime191.Fragment, { children: [
          (0, import_jsx_runtime191.jsx)(
            "rect",
            {
              "data-testid": "selection.resize.top-left",
              className: (0, import_classnames32.default)("tl-corner-handle", {
                "tl-hidden": hideTopLeftCorner
              }),
              x: toDomPrecision(0 - size4 / 2),
              y: toDomPrecision(0 - size4 / 2),
              width: toDomPrecision(size4),
              height: toDomPrecision(size4)
            }
          ),
          (0, import_jsx_runtime191.jsx)(
            "rect",
            {
              "data-testid": "selection.resize.top-right",
              className: (0, import_classnames32.default)("tl-corner-handle", {
                "tl-hidden": hideTopRightCorner
              }),
              x: toDomPrecision(width - size4 / 2),
              y: toDomPrecision(0 - size4 / 2),
              width: toDomPrecision(size4),
              height: toDomPrecision(size4)
            }
          ),
          (0, import_jsx_runtime191.jsx)(
            "rect",
            {
              "data-testid": "selection.resize.bottom-right",
              className: (0, import_classnames32.default)("tl-corner-handle", {
                "tl-hidden": hideBottomRightCorner
              }),
              x: toDomPrecision(width - size4 / 2),
              y: toDomPrecision(height - size4 / 2),
              width: toDomPrecision(size4),
              height: toDomPrecision(size4)
            }
          ),
          (0, import_jsx_runtime191.jsx)(
            "rect",
            {
              "data-testid": "selection.resize.bottom-left",
              className: (0, import_classnames32.default)("tl-corner-handle", {
                "tl-hidden": hideBottomLeftCorner
              }),
              x: toDomPrecision(0 - size4 / 2),
              y: toDomPrecision(height - size4 / 2),
              width: toDomPrecision(size4),
              height: toDomPrecision(size4)
            }
          )
        ] }),
        showTextResizeHandles && (0, import_jsx_runtime191.jsxs)(import_jsx_runtime191.Fragment, { children: [
          (0, import_jsx_runtime191.jsx)(
            "rect",
            {
              "data-testid": "selection.text-resize.left.handle",
              className: "tl-text-handle",
              x: toDomPrecision(0 - size4 / 4),
              y: toDomPrecision(height / 2 - textHandleHeight / 2),
              rx: size4 / 4,
              width: toDomPrecision(size4 / 2),
              height: toDomPrecision(textHandleHeight)
            }
          ),
          (0, import_jsx_runtime191.jsx)(
            "rect",
            {
              "data-testid": "selection.text-resize.right.handle",
              className: "tl-text-handle",
              rx: size4 / 4,
              x: toDomPrecision(width - size4 / 4),
              y: toDomPrecision(height / 2 - textHandleHeight / 2),
              width: toDomPrecision(size4 / 2),
              height: toDomPrecision(textHandleHeight)
            }
          )
        ] }),
        showCropHandles && (0, import_jsx_runtime191.jsx)(
          TldrawCropHandles,
          {
            ...{
              size: size4,
              width,
              height,
              hideAlternateHandles: hideAlternateCropHandles
            }
          }
        )
      ] })
    }
  );
});
var ResizeHandle = function ResizeHandle2({
  hide: hide4,
  dataTestId,
  ariaLabel,
  x,
  y,
  width,
  height,
  cursor,
  events
}) {
  return (0, import_jsx_runtime191.jsx)(
    "rect",
    {
      className: (0, import_classnames32.default)("tl-resize-handle", "tl-transparent", {
        "tl-hidden": hide4
      }),
      "data-testid": dataTestId,
      role: "button",
      "aria-label": ariaLabel,
      pointerEvents: "all",
      x,
      y,
      width,
      height,
      cursor,
      ...events
    }
  );
};
var RotateCornerHandle = function RotateCornerHandle2({
  cx,
  cy,
  targetSize,
  corner,
  cursor,
  isHidden: isHidden2,
  "data-testid": testId
}) {
  const events = useSelectionEvents(corner);
  const msg2 = useTranslation();
  const label = msg2(`handle.rotate.${corner}`);
  return (0, import_jsx_runtime191.jsx)(
    "rect",
    {
      className: (0, import_classnames32.default)("tl-transparent", "tl-rotate-corner", { "tl-hidden": isHidden2 }),
      "data-testid": testId,
      role: "button",
      "aria-label": label,
      pointerEvents: "all",
      x: toDomPrecision(cx - targetSize * 3),
      y: toDomPrecision(cy - targetSize * 3),
      width: toDomPrecision(Math.max(1, targetSize * 3)),
      height: toDomPrecision(Math.max(1, targetSize * 3)),
      cursor,
      ...events
    }
  );
};
var SQUARE_ROOT_PI = Math.sqrt(Math.PI);
var MobileRotateHandle = function RotateHandle({
  cx,
  cy,
  size: size4,
  isHidden: isHidden2,
  "data-testid": testId
}) {
  const events = useSelectionEvents("mobile_rotate");
  const editor = useEditor();
  const zoom = useValue("zoom level", () => editor.getEfficientZoomLevel(), [editor]);
  const bgRadius = Math.max(14 * (1 / zoom), 20 / Math.max(1, zoom));
  const msg2 = useTranslation();
  return (0, import_jsx_runtime191.jsxs)("g", { role: "button", "aria-label": msg2("handle.rotate.mobile_rotate"), children: [
    (0, import_jsx_runtime191.jsx)(
      "circle",
      {
        "data-testid": testId,
        pointerEvents: "all",
        className: (0, import_classnames32.default)("tl-transparent", "tl-mobile-rotate__bg", { "tl-hidden": isHidden2 }),
        cx,
        cy,
        r: bgRadius,
        ...events
      }
    ),
    (0, import_jsx_runtime191.jsx)(
      "circle",
      {
        className: (0, import_classnames32.default)("tl-mobile-rotate__fg", { "tl-hidden": isHidden2 }),
        cx,
        cy,
        r: size4 / SQUARE_ROOT_PI
      }
    )
  ] });
};

// ../node_modules/tldraw/dist-esm/lib/canvas/TldrawShapeIndicators.mjs
var import_jsx_runtime192 = __toESM(require_jsx_runtime(), 1);
function TldrawShapeIndicators() {
  const editor = useEditor();
  const isInSelectState = useValue(
    "is in a valid select state",
    () => {
      return editor.isInAny(
        "select.idle",
        "select.brushing",
        "select.scribble_brushing",
        "select.editing_shape",
        "select.pointing_shape",
        "select.pointing_selection",
        "select.pointing_handle"
      );
    },
    [editor]
  );
  return (0, import_jsx_runtime192.jsx)(DefaultShapeIndicators, { hideAll: !isInSelectState });
}

// ../node_modules/tldraw/dist-esm/lib/defaultBindingUtils.mjs
var defaultBindingUtils = [ArrowBindingUtil];

// ../node_modules/tldraw/dist-esm/lib/shapes/shared/default-shape-constants.mjs
var TEXT_PROPS = {
  lineHeight: 1.35,
  fontWeight: "normal",
  fontVariant: "normal",
  fontStyle: "normal",
  padding: "0px"
};
var STROKE_SIZES2 = {
  s: 2,
  m: 3.5,
  l: 5,
  xl: 10
};
var FONT_SIZES = {
  s: 18,
  m: 24,
  l: 36,
  xl: 44
};
var LABEL_FONT_SIZES = {
  s: 18,
  m: 22,
  l: 26,
  xl: 32
};
var ARROW_LABEL_FONT_SIZES = {
  s: 18,
  m: 20,
  l: 24,
  xl: 28
};
var FONT_FAMILIES = {
  draw: "var(--tl-font-draw)",
  sans: "var(--tl-font-sans)",
  serif: "var(--tl-font-serif)",
  mono: "var(--tl-font-mono)"
};
var LABEL_TO_ARROW_PADDING = 20;
var ARROW_LABEL_PADDING = 4.25;
var LABEL_PADDING = 16;

// ../node_modules/tldraw/dist-esm/lib/utils/assets/assets.mjs
function containBoxSize(originalSize, containBoxSize2) {
  const overByXScale = originalSize.w / containBoxSize2.w;
  const overByYScale = originalSize.h / containBoxSize2.h;
  if (overByXScale <= 1 && overByYScale <= 1) {
    return originalSize;
  } else if (overByXScale > overByYScale) {
    return {
      w: originalSize.w / overByXScale,
      h: originalSize.h / overByXScale
    };
  } else {
    return {
      w: originalSize.w / overByYScale,
      h: originalSize.h / overByYScale
    };
  }
}
async function downsizeImage(blob, width, height, opts = {}) {
  const { w, h: h2, image } = await MediaHelpers.usingObjectURL(
    blob,
    MediaHelpers.getImageAndDimensions
  );
  const { type = blob.type, quality = 0.85 } = opts;
  const [desiredWidth, desiredHeight] = clampToBrowserMaxCanvasSize(
    Math.min(width * 2, w),
    Math.min(height * 2, h2)
  );
  const canvas = document.createElement("canvas");
  canvas.width = desiredWidth;
  canvas.height = desiredHeight;
  const ctx = assertExists(
    canvas.getContext("2d", { willReadFrequently: true }),
    "Could not get canvas context"
  );
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";
  ctx.drawImage(image, 0, 0, desiredWidth, desiredHeight);
  return new Promise((resolve, reject) => {
    canvas.toBlob(
      (blob2) => {
        if (blob2) {
          resolve(blob2);
        } else {
          reject(new Error("Could not resize image"));
        }
      },
      type,
      quality
    );
  });
}

// ../node_modules/tldraw/dist-esm/lib/utils/excalidraw/putExcalidrawContent.mjs
async function putExcalidrawContent(editor, excalidrawClipboardContent, point) {
  var _a6, _b3, _c;
  const { elements, files } = excalidrawClipboardContent;
  const tldrawContent = {
    shapes: [],
    bindings: [],
    rootShapeIds: [],
    assets: [],
    schema: editor.store.schema.serialize()
  };
  const groupShapeIdToChildren = /* @__PURE__ */ new Map();
  const rotatedElements = /* @__PURE__ */ new Map();
  const currentPageId = editor.getCurrentPageId();
  const excElementIdsToTldrawShapeIds = /* @__PURE__ */ new Map();
  const rootShapeIds = [];
  const skipIds = /* @__PURE__ */ new Set();
  elements.forEach((element) => {
    excElementIdsToTldrawShapeIds.set(element.id, createShapeId());
    if (element.boundElements !== null) {
      for (const boundElement of element.boundElements) {
        if (boundElement.type === "text") {
          skipIds.add(boundElement.id);
        }
      }
    }
  });
  let index2 = ZERO_INDEX_KEY;
  for (const element of elements) {
    if (skipIds.has(element.id)) {
      continue;
    }
    const id = excElementIdsToTldrawShapeIds.get(element.id);
    const base2 = {
      id,
      typeName: "shape",
      parentId: currentPageId,
      index: index2,
      x: element.x,
      y: element.y,
      rotation: 0,
      isLocked: element.locked,
      opacity: getOpacity(element.opacity),
      meta: {}
    };
    if (element.angle !== 0) {
      rotatedElements.set(id, element.angle);
    }
    if (element.groupIds && element.groupIds.length > 0) {
      if (groupShapeIdToChildren.has(element.groupIds[0])) {
        (_a6 = groupShapeIdToChildren.get(element.groupIds[0])) == null ? void 0 : _a6.push(id);
      } else {
        groupShapeIdToChildren.set(element.groupIds[0], [id]);
      }
    } else {
      rootShapeIds.push(id);
    }
    switch (element.type) {
      case "rectangle":
      case "ellipse":
      case "diamond": {
        let text = "";
        let align = "middle";
        if (element.boundElements !== null) {
          for (const boundElement of element.boundElements) {
            if (boundElement.type === "text") {
              const labelElement = elements.find((elm) => elm.id === boundElement.id);
              if (labelElement) {
                text = labelElement.text;
                align = textAlignToAlignTypes[labelElement.textAlign];
              }
            }
          }
        }
        const colorToUse = element.backgroundColor === "transparent" ? element.strokeColor : element.backgroundColor;
        tldrawContent.shapes.push({
          ...base2,
          type: "geo",
          props: {
            ...editor.getShapeUtil("geo").getDefaultProps(),
            geo: element.type,
            url: element.link ?? "",
            w: element.width,
            h: element.height,
            size: strokeWidthsToSizes[element.strokeWidth] ?? "draw",
            color: colorsToColors[colorToUse] ?? "black",
            richText: toRichText(text),
            align,
            dash: getDash(element),
            fill: getFill(element)
          }
        });
        break;
      }
      case "freedraw": {
        const points = element.points.map(([x, y, z = 0.5]) => ({
          x,
          y,
          z
        }));
        const base64Points = b64Vecs.encodePoints(points);
        tldrawContent.shapes.push({
          ...base2,
          type: "draw",
          props: {
            ...editor.getShapeUtil("draw").getDefaultProps(),
            dash: getDash(element),
            size: strokeWidthsToSizes[element.strokeWidth],
            color: colorsToColors[element.strokeColor] ?? "black",
            segments: [
              {
                type: "free",
                path: base64Points
              }
            ]
          }
        });
        break;
      }
      case "line": {
        const points = element.points.slice();
        if (points.length < 2) {
          break;
        }
        const indices = getIndices(element.points.length);
        tldrawContent.shapes.push({
          ...base2,
          type: "line",
          props: {
            ...editor.getShapeUtil("line").getDefaultProps(),
            dash: getDash(element),
            size: strokeWidthsToSizes[element.strokeWidth],
            color: colorsToColors[element.strokeColor] ?? "black",
            spline: element.roundness ? "cubic" : "line",
            points: {
              ...Object.fromEntries(
                element.points.map(([x, y], i) => {
                  const index22 = indices[i];
                  return [index22, { id: index22, index: index22, x, y }];
                })
              )
            }
          }
        });
        break;
      }
      case "arrow": {
        let text = "";
        if (element.boundElements !== null) {
          for (const boundElement of element.boundElements) {
            if (boundElement.type === "text") {
              const labelElement = elements.find((elm) => elm.id === boundElement.id);
              if (labelElement) {
                text = labelElement.text;
              }
            }
          }
        }
        const start = element.points[0];
        const end = element.points[element.points.length - 1];
        const startTargetId = excElementIdsToTldrawShapeIds.get((_b3 = element.startBinding) == null ? void 0 : _b3.elementId);
        const endTargetId = excElementIdsToTldrawShapeIds.get((_c = element.endBinding) == null ? void 0 : _c.elementId);
        tldrawContent.shapes.push({
          ...base2,
          type: "arrow",
          props: {
            ...editor.getShapeUtil("arrow").getDefaultProps(),
            richText: toRichText(text),
            kind: element.elbowed ? "elbow" : "arc",
            bend: getBend(element, start, end),
            dash: getDash(element),
            size: strokeWidthsToSizes[element.strokeWidth] ?? "m",
            color: colorsToColors[element.strokeColor] ?? "black",
            start: { x: start[0], y: start[1] },
            end: { x: end[0], y: end[1] },
            arrowheadEnd: arrowheadsToArrowheadTypes[element.endArrowhead] ?? "none",
            arrowheadStart: arrowheadsToArrowheadTypes[element.startArrowhead] ?? "none"
          }
        });
        if (startTargetId) {
          tldrawContent.bindings.push({
            id: createBindingId(),
            typeName: "binding",
            type: "arrow",
            fromId: id,
            toId: startTargetId,
            props: {
              terminal: "start",
              snap: "none",
              normalizedAnchor: { x: 0.5, y: 0.5 },
              isPrecise: false,
              isExact: false
            },
            meta: {}
          });
        }
        if (endTargetId) {
          tldrawContent.bindings.push({
            id: createBindingId(),
            typeName: "binding",
            type: "arrow",
            fromId: id,
            toId: endTargetId,
            props: {
              terminal: "end",
              snap: "none",
              normalizedAnchor: { x: 0.5, y: 0.5 },
              isPrecise: false,
              isExact: false
            },
            meta: {}
          });
        }
        break;
      }
      case "text": {
        const { size: size4, scale } = getFontSizeAndScale(element.fontSize);
        tldrawContent.shapes.push({
          ...base2,
          type: "text",
          props: {
            ...editor.getShapeUtil("text").getDefaultProps(),
            size: size4,
            scale,
            font: fontFamilyToFontType[element.fontFamily] ?? "draw",
            color: colorsToColors[element.strokeColor] ?? "black",
            richText: toRichText(element.text),
            textAlign: textAlignToTextAlignTypes[element.textAlign]
          }
        });
        break;
      }
      case "image": {
        const file = files[element.fileId];
        if (!file) break;
        const assetId = AssetRecordType.createId();
        tldrawContent.assets.push({
          id: assetId,
          typeName: "asset",
          type: "image",
          props: {
            w: element.width,
            h: element.height,
            fileSize: file.size,
            name: element.id ?? "Untitled",
            isAnimated: false,
            mimeType: file.mimeType,
            src: file.dataURL
          },
          meta: {}
        });
        tldrawContent.shapes.push({
          ...base2,
          type: "image",
          props: {
            ...editor.getShapeUtil("image").getDefaultProps(),
            w: element.width,
            h: element.height,
            assetId
          }
        });
      }
    }
    index2 = getIndexAbove(index2);
  }
  const p = point ?? (editor.inputs.getShiftKey() ? editor.inputs.getCurrentPagePoint() : void 0);
  editor.putContentOntoCurrentPage(tldrawContent, {
    point: p,
    select: false,
    preserveIds: true
  });
  for (const groupedShapeIds of groupShapeIdToChildren.values()) {
    if (groupedShapeIds.length > 1) {
      editor.groupShapes(groupedShapeIds);
      const groupShape = editor.getShape(groupedShapeIds[0]);
      if ((groupShape == null ? void 0 : groupShape.parentId) && isShapeId(groupShape.parentId)) {
        rootShapeIds.push(groupShape.parentId);
      }
    }
  }
  for (const [id, angle] of rotatedElements) {
    editor.select(id);
    editor.rotateShapesBy([id], angle);
  }
  const rootShapes = compact(rootShapeIds.map((id) => editor.getShape(id)));
  const bounds = Box.Common(rootShapes.map((s) => editor.getShapePageBounds(s)));
  const viewPortCenter = editor.getViewportPageBounds().center;
  editor.updateShapes(
    rootShapes.map((s) => {
      const delta = {
        x: (s.x ?? 0) - (bounds.x + bounds.w / 2),
        y: (s.y ?? 0) - (bounds.y + bounds.h / 2)
      };
      return {
        id: s.id,
        type: s.type,
        x: viewPortCenter.x + delta.x,
        y: viewPortCenter.y + delta.y
      };
    })
  );
  editor.setSelectedShapes(rootShapeIds);
}
var getOpacity = (opacity) => {
  const t2 = opacity / 100;
  if (t2 < 0.2) {
    return 0.1;
  } else if (t2 < 0.4) {
    return 0.25;
  } else if (t2 < 0.6) {
    return 0.5;
  } else if (t2 < 0.8) {
    return 0.75;
  }
  return 1;
};
var strokeWidthsToSizes = {
  1: "s",
  2: "m",
  3: "l",
  4: "xl"
};
var fontSizesToSizes = {
  16: "s",
  20: "m",
  28: "l",
  36: "xl"
};
function getFontSizeAndScale(fontSize) {
  const size4 = fontSizesToSizes[fontSize];
  if (size4) {
    return { size: size4, scale: 1 };
  }
  if (fontSize < 16) {
    return { size: "s", scale: fontSize / 16 };
  }
  if (fontSize > 36) {
    return { size: "xl", scale: fontSize / 36 };
  }
  return { size: "m", scale: 1 };
}
var fontFamilyToFontType = {
  1: "draw",
  2: "sans",
  3: "mono"
};
var oc = {
  gray: ["#f8f9fa", "#e9ecef", "#ced4da", "#868e96", "#343a40"],
  red: ["#fff5f5", "#ffc9c9", "#ff8787", "#fa5252", "#e03131"],
  pink: ["#fff0f6", "#fcc2d7", "#f783ac", "#e64980", "#c2255c"],
  grape: ["#f8f0fc", "#eebefa", "#da77f2", "#be4bdb", "#9c36b5"],
  violet: ["#f3f0ff", "#d0bfff", "#9775fa", "#7950f2", "#6741d9"],
  indigo: ["#edf2ff", "#bac8ff", "#748ffc", "#4c6ef5", "#3b5bdb"],
  blue: ["#e7f5ff", "#a5d8ff", "#4dabf7", "#228be6", "#1971c2"],
  cyan: ["#e3fafc", "#99e9f2", "#3bc9db", "#15aabf", "#0c8599"],
  teal: ["#e6fcf5", "#96f2d7", "#38d9a9", "#12b886", "#099268"],
  green: ["#ebfbee", "#b2f2bb", "#69db7c", "#40c057", "#2f9e44"],
  lime: ["#f4fce3", "#d8f5a2", "#a9e34b", "#82c91e", "#66a80f"],
  yellow: ["#fff9db", "#ffec99", "#ffd43b", "#fab005", "#f08c00"],
  orange: ["#fff4e6", "#ffd8a8", "#ffa94d", "#fd7e14", "#e8590c"]
};
function mapExcalidrawColorToTldrawColors(excalidrawColor, light, dark) {
  const colors = [0, 1, 2, 3, 4].map((index2) => oc[excalidrawColor][index2]);
  return Object.fromEntries(colors.map((c, i) => [c, i < 3 ? light : dark]));
}
var colorsToColors = {
  ...mapExcalidrawColorToTldrawColors("gray", "grey", "black"),
  ...mapExcalidrawColorToTldrawColors("red", "light-red", "red"),
  ...mapExcalidrawColorToTldrawColors("pink", "light-red", "red"),
  ...mapExcalidrawColorToTldrawColors("grape", "light-violet", "violet"),
  ...mapExcalidrawColorToTldrawColors("blue", "light-blue", "blue"),
  ...mapExcalidrawColorToTldrawColors("cyan", "light-blue", "blue"),
  ...mapExcalidrawColorToTldrawColors("teal", "light-green", "green"),
  ...mapExcalidrawColorToTldrawColors("green", "light-green", "green"),
  ...mapExcalidrawColorToTldrawColors("yellow", "yellow", "orange"),
  ...mapExcalidrawColorToTldrawColors("orange", "yellow", "orange"),
  "#ffffff": "white",
  "#000000": "black"
};
var strokeStylesToStrokeTypes = {
  solid: "draw",
  dashed: "dashed",
  dotted: "dotted"
};
var fillStylesToFillType = {
  "cross-hatch": "pattern",
  hachure: "pattern",
  solid: "solid"
};
var textAlignToAlignTypes = {
  left: "start",
  center: "middle",
  right: "end"
};
var textAlignToTextAlignTypes = {
  left: "start",
  center: "middle",
  right: "end"
};
var arrowheadsToArrowheadTypes = {
  arrow: "arrow",
  dot: "dot",
  triangle: "triangle",
  bar: "pipe"
};
function getBend(element, startPoint, endPoint) {
  let bend = 0;
  if (element.points.length > 2) {
    const start = new Vec(startPoint[0], startPoint[1]);
    const end = new Vec(endPoint[0], endPoint[1]);
    const handle = new Vec(element.points[1][0], element.points[1][1]);
    const delta = Vec.Sub(end, start);
    const v = Vec.Per(delta);
    const med = Vec.Med(end, start);
    const A = Vec.Sub(med, v);
    const B = Vec.Add(med, v);
    const point = Vec.NearestPointOnLineSegment(A, B, handle, false);
    bend = Vec.Dist(point, med);
    if (Vec.Clockwise(point, end, med)) bend *= -1;
  }
  return bend;
}
var getDash = (element) => {
  let dash = strokeStylesToStrokeTypes[element.strokeStyle] ?? "draw";
  if (dash === "draw" && element.roughness === 0) {
    dash = "solid";
  }
  return dash;
};
var getFill = (element) => {
  if (element.backgroundColor === "transparent") {
    return "none";
  }
  return fillStylesToFillType[element.fillStyle] ?? "solid";
};

// ../node_modules/@tiptap/extension-code/dist/index.js
var inputRegex = /(^|[^`])`([^`]+)`(?!`)$/;
var pasteRegex = /(^|[^`])`([^`]+)`(?!`)/g;
var Code = Mark2.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: true,
  exitable: true,
  parseHTML() {
    return [{ tag: "code" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["code", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  markdownTokenName: "codespan",
  parseMarkdown: (token, helpers) => {
    return helpers.applyMark("code", [{ type: "text", text: token.text || "" }]);
  },
  renderMarkdown: (node, h2) => {
    if (!node.content) {
      return "";
    }
    return `\`${h2.renderChildren(node.content)}\``;
  },
  addCommands() {
    return {
      setCode: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleCode: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetCode: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex,
        type: this.type
      })
    ];
  }
});

// ../node_modules/@tiptap/extension-highlight/dist/index.js
var inputRegex2 = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))$/;
var pasteRegex2 = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))/g;
var Highlight = Mark2.create({
  name: "highlight",
  addOptions() {
    return {
      multicolor: false,
      HTMLAttributes: {}
    };
  },
  addAttributes() {
    if (!this.options.multicolor) {
      return {};
    }
    return {
      color: {
        default: null,
        parseHTML: (element) => element.getAttribute("data-color") || element.style.backgroundColor,
        renderHTML: (attributes) => {
          if (!attributes.color) {
            return {};
          }
          return {
            "data-color": attributes.color,
            style: `background-color: ${attributes.color}; color: inherit`
          };
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "mark"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["mark", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  renderMarkdown: (node, h2) => {
    return `==${h2.renderChildren(node)}==`;
  },
  parseMarkdown: (token, h2) => {
    return h2.applyMark("highlight", h2.parseInline(token.tokens || []));
  },
  markdownTokenizer: {
    name: "highlight",
    level: "inline",
    start: (src) => src.indexOf("=="),
    tokenize(src, _, h2) {
      const rule = /^(==)([^=]+)(==)/;
      const match = rule.exec(src);
      if (match) {
        const innerContent = match[2].trim();
        const children = h2.inlineTokens(innerContent);
        return {
          type: "highlight",
          raw: match[0],
          text: innerContent,
          tokens: children
        };
      }
    }
  },
  addCommands() {
    return {
      setHighlight: (attributes) => ({ commands }) => {
        return commands.setMark(this.name, attributes);
      },
      toggleHighlight: (attributes) => ({ commands }) => {
        return commands.toggleMark(this.name, attributes);
      },
      unsetHighlight: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-h": () => this.editor.commands.toggleHighlight()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex2,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex2,
        type: this.type
      })
    ];
  }
});

// ../node_modules/@tiptap/core/dist/jsx-runtime/jsx-runtime.js
var h = (tag, attributes) => {
  if (tag === "slot") {
    return 0;
  }
  if (tag instanceof Function) {
    return tag(attributes);
  }
  const { children, ...rest } = attributes != null ? attributes : {};
  if (tag === "svg") {
    throw new Error("SVG elements are not supported in the JSX syntax, use the array syntax instead");
  }
  return [tag, rest, children];
};

// ../node_modules/@tiptap/extension-blockquote/dist/index.js
var inputRegex3 = /^\s*>\s$/;
var Blockquote = Node3.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: true,
  parseHTML() {
    return [{ tag: "blockquote" }];
  },
  renderHTML({ HTMLAttributes }) {
    return h("blockquote", { ...mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), children: h("slot", {}) });
  },
  parseMarkdown: (token, helpers) => {
    return helpers.createNode("blockquote", void 0, helpers.parseChildren(token.tokens || []));
  },
  renderMarkdown: (node, h2) => {
    if (!node.content) {
      return "";
    }
    const prefix = ">";
    const result = [];
    node.content.forEach((child) => {
      const childContent = h2.renderChildren([child]);
      const lines = childContent.split("\n");
      const linesWithPrefix = lines.map((line) => {
        if (line.trim() === "") {
          return prefix;
        }
        return `${prefix} ${line}`;
      });
      result.push(linesWithPrefix.join("\n"));
    });
    return result.join(`
${prefix}
`);
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands }) => {
        return commands.wrapIn(this.name);
      },
      toggleBlockquote: () => ({ commands }) => {
        return commands.toggleWrap(this.name);
      },
      unsetBlockquote: () => ({ commands }) => {
        return commands.lift(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      wrappingInputRule({
        find: inputRegex3,
        type: this.type
      })
    ];
  }
});

// ../node_modules/@tiptap/extension-bold/dist/index.js
var starInputRegex = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/;
var starPasteRegex = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g;
var underscoreInputRegex = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/;
var underscorePasteRegex = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g;
var Bold = Mark2.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (node) => node.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight=400",
        clearMark: (mark) => mark.type.name === this.name
      },
      {
        style: "font-weight",
        getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return h("strong", { ...mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), children: h("slot", {}) });
  },
  markdownTokenName: "strong",
  parseMarkdown: (token, helpers) => {
    return helpers.applyMark("bold", helpers.parseInline(token.tokens || []));
  },
  renderMarkdown: (node, h2) => {
    return `**${h2.renderChildren(node)}**`;
  },
  addCommands() {
    return {
      setBold: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleBold: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetBold: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex,
        type: this.type
      })
    ];
  }
});

// ../node_modules/@tiptap/extension-code-block/dist/index.js
var DEFAULT_TAB_SIZE = 4;
var backtickInputRegex = /^```([a-z]+)?[\s\n]$/;
var tildeInputRegex = /^~~~([a-z]+)?[\s\n]$/;
var CodeBlock = Node3.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: true,
      exitOnArrowDown: true,
      defaultLanguage: null,
      enableTabIndentation: false,
      tabSize: DEFAULT_TAB_SIZE,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: true,
  defining: true,
  addAttributes() {
    return {
      language: {
        default: this.options.defaultLanguage,
        parseHTML: (element) => {
          var _a6;
          const { languageClassPrefix } = this.options;
          if (!languageClassPrefix) {
            return null;
          }
          const classNames39 = [...((_a6 = element.firstElementChild) == null ? void 0 : _a6.classList) || []];
          const languages = classNames39.filter((className) => className.startsWith(languageClassPrefix)).map((className) => className.replace(languageClassPrefix, ""));
          const language = languages[0];
          if (!language) {
            return null;
          }
          return language;
        },
        rendered: false
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node, HTMLAttributes }) {
    return [
      "pre",
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),
      [
        "code",
        {
          class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null
        },
        0
      ]
    ];
  },
  markdownTokenName: "code",
  parseMarkdown: (token, helpers) => {
    var _a6;
    if (((_a6 = token.raw) == null ? void 0 : _a6.startsWith("```")) === false && token.codeBlockStyle !== "indented") {
      return [];
    }
    return helpers.createNode(
      "codeBlock",
      { language: token.lang || null },
      token.text ? [helpers.createTextNode(token.text)] : []
    );
  },
  renderMarkdown: (node, h2) => {
    var _a6;
    let output = "";
    const language = ((_a6 = node.attrs) == null ? void 0 : _a6.language) || "";
    if (!node.content) {
      output = `\`\`\`${language}

\`\`\``;
    } else {
      const lines = [`\`\`\`${language}`, h2.renderChildren(node.content), "```"];
      output = lines.join("\n");
    }
    return output;
  },
  addCommands() {
    return {
      setCodeBlock: (attributes) => ({ commands }) => {
        return commands.setNode(this.name, attributes);
      },
      toggleCodeBlock: (attributes) => ({ commands }) => {
        return commands.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      // remove code block when at start of document or code block is empty
      Backspace: () => {
        const { empty: empty2, $anchor } = this.editor.state.selection;
        const isAtStart = $anchor.pos === 1;
        if (!empty2 || $anchor.parent.type.name !== this.name) {
          return false;
        }
        if (isAtStart || !$anchor.parent.textContent.length) {
          return this.editor.commands.clearNodes();
        }
        return false;
      },
      // handle tab indentation
      Tab: ({ editor }) => {
        var _a6;
        if (!this.options.enableTabIndentation) {
          return false;
        }
        const tabSize = (_a6 = this.options.tabSize) != null ? _a6 : DEFAULT_TAB_SIZE;
        const { state } = editor;
        const { selection } = state;
        const { $from, empty: empty2 } = selection;
        if ($from.parent.type !== this.type) {
          return false;
        }
        const indent = " ".repeat(tabSize);
        if (empty2) {
          return editor.commands.insertContent(indent);
        }
        return editor.commands.command(({ tr: tr2 }) => {
          const { from: from2, to } = selection;
          const text = state.doc.textBetween(from2, to, "\n", "\n");
          const lines = text.split("\n");
          const indentedText = lines.map((line) => indent + line).join("\n");
          tr2.replaceWith(from2, to, state.schema.text(indentedText));
          return true;
        });
      },
      // handle shift+tab reverse indentation
      "Shift-Tab": ({ editor }) => {
        var _a6;
        if (!this.options.enableTabIndentation) {
          return false;
        }
        const tabSize = (_a6 = this.options.tabSize) != null ? _a6 : DEFAULT_TAB_SIZE;
        const { state } = editor;
        const { selection } = state;
        const { $from, empty: empty2 } = selection;
        if ($from.parent.type !== this.type) {
          return false;
        }
        if (empty2) {
          return editor.commands.command(({ tr: tr2 }) => {
            var _a22;
            const { pos } = $from;
            const codeBlockStart = $from.start();
            const codeBlockEnd = $from.end();
            const allText = state.doc.textBetween(codeBlockStart, codeBlockEnd, "\n", "\n");
            const lines = allText.split("\n");
            let currentLineIndex = 0;
            let charCount = 0;
            const relativeCursorPos = pos - codeBlockStart;
            for (let i = 0; i < lines.length; i += 1) {
              if (charCount + lines[i].length >= relativeCursorPos) {
                currentLineIndex = i;
                break;
              }
              charCount += lines[i].length + 1;
            }
            const currentLine = lines[currentLineIndex];
            const leadingSpaces = ((_a22 = currentLine.match(/^ */)) == null ? void 0 : _a22[0]) || "";
            const spacesToRemove = Math.min(leadingSpaces.length, tabSize);
            if (spacesToRemove === 0) {
              return true;
            }
            let lineStartPos = codeBlockStart;
            for (let i = 0; i < currentLineIndex; i += 1) {
              lineStartPos += lines[i].length + 1;
            }
            tr2.delete(lineStartPos, lineStartPos + spacesToRemove);
            const cursorPosInLine = pos - lineStartPos;
            if (cursorPosInLine <= spacesToRemove) {
              tr2.setSelection(TextSelection.create(tr2.doc, lineStartPos));
            }
            return true;
          });
        }
        return editor.commands.command(({ tr: tr2 }) => {
          const { from: from2, to } = selection;
          const text = state.doc.textBetween(from2, to, "\n", "\n");
          const lines = text.split("\n");
          const reverseIndentText = lines.map((line) => {
            var _a22;
            const leadingSpaces = ((_a22 = line.match(/^ */)) == null ? void 0 : _a22[0]) || "";
            const spacesToRemove = Math.min(leadingSpaces.length, tabSize);
            return line.slice(spacesToRemove);
          }).join("\n");
          tr2.replaceWith(from2, to, state.schema.text(reverseIndentText));
          return true;
        });
      },
      // exit node on triple enter
      Enter: ({ editor }) => {
        if (!this.options.exitOnTripleEnter) {
          return false;
        }
        const { state } = editor;
        const { selection } = state;
        const { $from, empty: empty2 } = selection;
        if (!empty2 || $from.parent.type !== this.type) {
          return false;
        }
        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
        const endsWithDoubleNewline = $from.parent.textContent.endsWith("\n\n");
        if (!isAtEnd || !endsWithDoubleNewline) {
          return false;
        }
        return editor.chain().command(({ tr: tr2 }) => {
          tr2.delete($from.pos - 2, $from.pos);
          return true;
        }).exitCode().run();
      },
      // exit node on arrow down
      ArrowDown: ({ editor }) => {
        if (!this.options.exitOnArrowDown) {
          return false;
        }
        const { state } = editor;
        const { selection, doc: doc3 } = state;
        const { $from, empty: empty2 } = selection;
        if (!empty2 || $from.parent.type !== this.type) {
          return false;
        }
        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
        if (!isAtEnd) {
          return false;
        }
        const after = $from.after();
        if (after === void 0) {
          return false;
        }
        const nodeAfter = doc3.nodeAt(after);
        if (nodeAfter) {
          return editor.commands.command(({ tr: tr2 }) => {
            tr2.setSelection(Selection.near(doc3.resolve(after)));
            return true;
          });
        }
        return editor.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      textblockTypeInputRule({
        find: backtickInputRegex,
        type: this.type,
        getAttributes: (match) => ({
          language: match[1]
        })
      }),
      textblockTypeInputRule({
        find: tildeInputRegex,
        type: this.type,
        getAttributes: (match) => ({
          language: match[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      // this plugin creates a code block for pasted content from VS Code
      // we can also detect the copied code language
      new Plugin({
        key: new PluginKey("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (view, event) => {
            if (!event.clipboardData) {
              return false;
            }
            if (this.editor.isActive(this.type.name)) {
              return false;
            }
            const text = event.clipboardData.getData("text/plain");
            const vscode = event.clipboardData.getData("vscode-editor-data");
            const vscodeData = vscode ? JSON.parse(vscode) : void 0;
            const language = vscodeData == null ? void 0 : vscodeData.mode;
            if (!text || !language) {
              return false;
            }
            const { tr: tr2, schema } = view.state;
            const textNode = schema.text(text.replace(/\r\n?/g, "\n"));
            tr2.replaceSelectionWith(this.type.create({ language }, textNode));
            if (tr2.selection.$from.parent.type !== this.type) {
              tr2.setSelection(TextSelection.near(tr2.doc.resolve(Math.max(0, tr2.selection.from - 2))));
            }
            tr2.setMeta("paste", true);
            view.dispatch(tr2);
            return true;
          }
        }
      })
    ];
  }
});

// ../node_modules/@tiptap/extension-document/dist/index.js
var Document = Node3.create({
  name: "doc",
  topNode: true,
  content: "block+",
  renderMarkdown: (node, h2) => {
    if (!node.content) {
      return "";
    }
    return h2.renderChildren(node.content, "\n\n");
  }
});

// ../node_modules/@tiptap/extension-hard-break/dist/index.js
var HardBreak = Node3.create({
  name: "hardBreak",
  markdownTokenName: "br",
  addOptions() {
    return {
      keepMarks: true,
      HTMLAttributes: {}
    };
  },
  inline: true,
  group: "inline",
  selectable: false,
  linebreakReplacement: true,
  parseHTML() {
    return [{ tag: "br" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["br", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  renderText() {
    return "\n";
  },
  renderMarkdown: () => `  
`,
  parseMarkdown: () => {
    return {
      type: "hardBreak"
    };
  },
  addCommands() {
    return {
      setHardBreak: () => ({ commands, chain: chain2, state, editor }) => {
        return commands.first([
          () => commands.exitCode(),
          () => commands.command(() => {
            const { selection, storedMarks } = state;
            if (selection.$from.parent.type.spec.isolating) {
              return false;
            }
            const { keepMarks } = this.options;
            const { splittableMarks } = editor.extensionManager;
            const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
            return chain2().insertContent({ type: this.name }).command(({ tr: tr2, dispatch: dispatch2 }) => {
              if (dispatch2 && marks && keepMarks) {
                const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
                tr2.ensureMarks(filteredMarks);
              }
              return true;
            }).run();
          })
        ]);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
});

// ../node_modules/@tiptap/extension-heading/dist/index.js
var Heading = Node3.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: true,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: false
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((level) => ({
      tag: `h${level}`,
      attrs: { level }
    }));
  },
  renderHTML({ node, HTMLAttributes }) {
    const hasLevel = this.options.levels.includes(node.attrs.level);
    const level = hasLevel ? node.attrs.level : this.options.levels[0];
    return [`h${level}`, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  parseMarkdown: (token, helpers) => {
    return helpers.createNode("heading", { level: token.depth || 1 }, helpers.parseInline(token.tokens || []));
  },
  renderMarkdown: (node, h2) => {
    var _a6;
    const level = ((_a6 = node.attrs) == null ? void 0 : _a6.level) ? parseInt(node.attrs.level, 10) : 1;
    const headingChars = "#".repeat(level);
    if (!node.content) {
      return "";
    }
    return `${headingChars} ${h2.renderChildren(node.content)}`;
  },
  addCommands() {
    return {
      setHeading: (attributes) => ({ commands }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands.setNode(this.name, attributes);
      },
      toggleHeading: (attributes) => ({ commands }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce(
      (items, level) => ({
        ...items,
        ...{
          [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level })
        }
      }),
      {}
    );
  },
  addInputRules() {
    return this.options.levels.map((level) => {
      return textblockTypeInputRule({
        find: new RegExp(`^(#{${Math.min(...this.options.levels)},${level}})\\s$`),
        type: this.type,
        getAttributes: {
          level
        }
      });
    });
  }
});

// ../node_modules/@tiptap/extension-horizontal-rule/dist/index.js
var HorizontalRule = Node3.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {},
      nextNodeType: "paragraph"
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["hr", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  markdownTokenName: "hr",
  parseMarkdown: (token, helpers) => {
    return helpers.createNode("horizontalRule");
  },
  renderMarkdown: () => {
    return "---";
  },
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain: chain2, state }) => {
        if (!canInsertNode(state, state.schema.nodes[this.name])) {
          return false;
        }
        const { selection } = state;
        const { $to: $originTo } = selection;
        const currentChain = chain2();
        if (isNodeSelection(selection)) {
          currentChain.insertContentAt($originTo.pos, {
            type: this.name
          });
        } else {
          currentChain.insertContent({ type: this.name });
        }
        return currentChain.command(({ state: chainState, tr: tr2, dispatch: dispatch2 }) => {
          if (dispatch2) {
            const { $to } = tr2.selection;
            const posAfter = $to.end();
            if ($to.nodeAfter) {
              if ($to.nodeAfter.isTextblock) {
                tr2.setSelection(TextSelection.create(tr2.doc, $to.pos + 1));
              } else if ($to.nodeAfter.isBlock) {
                tr2.setSelection(NodeSelection.create(tr2.doc, $to.pos));
              } else {
                tr2.setSelection(TextSelection.create(tr2.doc, $to.pos));
              }
            } else {
              const nodeType = chainState.schema.nodes[this.options.nextNodeType] || $to.parent.type.contentMatch.defaultType;
              const node = nodeType == null ? void 0 : nodeType.create();
              if (node) {
                tr2.insert(posAfter, node);
                tr2.setSelection(TextSelection.create(tr2.doc, posAfter + 1));
              }
            }
            tr2.scrollIntoView();
          }
          return true;
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      nodeInputRule({
        find: /^(?:---|—-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
});

// ../node_modules/@tiptap/extension-italic/dist/index.js
var starInputRegex2 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/;
var starPasteRegex2 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g;
var underscoreInputRegex2 = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/;
var underscorePasteRegex2 = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g;
var Italic = Mark2.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (node) => node.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=normal",
        clearMark: (mark) => mark.type.name === this.name
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["em", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleItalic: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetItalic: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  markdownTokenName: "em",
  parseMarkdown: (token, helpers) => {
    return helpers.applyMark("italic", helpers.parseInline(token.tokens || []));
  },
  renderMarkdown: (node, h2) => {
    return `*${h2.renderChildren(node)}*`;
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex2,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex2,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex2,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex2,
        type: this.type
      })
    ];
  }
});

// ../node_modules/linkifyjs/dist/linkify.mjs
var encodedTlds = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3nd0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0axi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2";
var encodedUtlds = "ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2";
var numeric = "numeric";
var ascii = "ascii";
var alpha = "alpha";
var asciinumeric = "asciinumeric";
var alphanumeric = "alphanumeric";
var domain = "domain";
var emoji = "emoji";
var scheme = "scheme";
var slashscheme = "slashscheme";
var whitespace = "whitespace";
function registerGroup(name, groups) {
  if (!(name in groups)) {
    groups[name] = [];
  }
  return groups[name];
}
function addToGroups(t2, flags, groups) {
  if (flags[numeric]) {
    flags[asciinumeric] = true;
    flags[alphanumeric] = true;
  }
  if (flags[ascii]) {
    flags[asciinumeric] = true;
    flags[alpha] = true;
  }
  if (flags[asciinumeric]) {
    flags[alphanumeric] = true;
  }
  if (flags[alpha]) {
    flags[alphanumeric] = true;
  }
  if (flags[alphanumeric]) {
    flags[domain] = true;
  }
  if (flags[emoji]) {
    flags[domain] = true;
  }
  for (const k in flags) {
    const group = registerGroup(k, groups);
    if (group.indexOf(t2) < 0) {
      group.push(t2);
    }
  }
}
function flagsForToken(t2, groups) {
  const result = {};
  for (const c in groups) {
    if (groups[c].indexOf(t2) >= 0) {
      result[c] = true;
    }
  }
  return result;
}
function State(token = null) {
  this.j = {};
  this.jr = [];
  this.jd = null;
  this.t = token;
}
State.groups = {};
State.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(input) {
    const state = this;
    const nextState = state.j[input];
    if (nextState) {
      return nextState;
    }
    for (let i = 0; i < state.jr.length; i++) {
      const regex = state.jr[i][0];
      const nextState2 = state.jr[i][1];
      if (nextState2 && regex.test(input)) {
        return nextState2;
      }
    }
    return state.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(input, exactOnly = false) {
    return exactOnly ? input in this.j : !!this.go(input);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(inputs, next, flags, groups) {
    for (let i = 0; i < inputs.length; i++) {
      this.tt(inputs[i], next, flags, groups);
    }
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(regexp2, next, flags, groups) {
    groups = groups || State.groups;
    let nextState;
    if (next && next.j) {
      nextState = next;
    } else {
      nextState = new State(next);
      if (flags && groups) {
        addToGroups(next, flags, groups);
      }
    }
    this.jr.push([regexp2, nextState]);
    return nextState;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(input, next, flags, groups) {
    let state = this;
    const len = input.length;
    if (!len) {
      return state;
    }
    for (let i = 0; i < len - 1; i++) {
      state = state.tt(input[i]);
    }
    return state.tt(input[len - 1], next, flags, groups);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(input, next, flags, groups) {
    groups = groups || State.groups;
    const state = this;
    if (next && next.j) {
      state.j[input] = next;
      return next;
    }
    const t2 = next;
    let nextState, templateState = state.go(input);
    if (templateState) {
      nextState = new State();
      Object.assign(nextState.j, templateState.j);
      nextState.jr.push.apply(nextState.jr, templateState.jr);
      nextState.jd = templateState.jd;
      nextState.t = templateState.t;
    } else {
      nextState = new State();
    }
    if (t2) {
      if (groups) {
        if (nextState.t && typeof nextState.t === "string") {
          const allFlags = Object.assign(flagsForToken(nextState.t, groups), flags);
          addToGroups(t2, allFlags, groups);
        } else if (flags) {
          addToGroups(t2, flags, groups);
        }
      }
      nextState.t = t2;
    }
    state.j[input] = nextState;
    return nextState;
  }
};
var ta = (state, input, next, flags, groups) => state.ta(input, next, flags, groups);
var tr = (state, regexp2, next, flags, groups) => state.tr(regexp2, next, flags, groups);
var ts = (state, input, next, flags, groups) => state.ts(input, next, flags, groups);
var tt = (state, input, next, flags, groups) => state.tt(input, next, flags, groups);
var WORD = "WORD";
var UWORD = "UWORD";
var ASCIINUMERICAL = "ASCIINUMERICAL";
var ALPHANUMERICAL = "ALPHANUMERICAL";
var LOCALHOST = "LOCALHOST";
var TLD = "TLD";
var UTLD = "UTLD";
var SCHEME = "SCHEME";
var SLASH_SCHEME = "SLASH_SCHEME";
var NUM = "NUM";
var WS = "WS";
var NL = "NL";
var OPENBRACE = "OPENBRACE";
var CLOSEBRACE = "CLOSEBRACE";
var OPENBRACKET = "OPENBRACKET";
var CLOSEBRACKET = "CLOSEBRACKET";
var OPENPAREN = "OPENPAREN";
var CLOSEPAREN = "CLOSEPAREN";
var OPENANGLEBRACKET = "OPENANGLEBRACKET";
var CLOSEANGLEBRACKET = "CLOSEANGLEBRACKET";
var FULLWIDTHLEFTPAREN = "FULLWIDTHLEFTPAREN";
var FULLWIDTHRIGHTPAREN = "FULLWIDTHRIGHTPAREN";
var LEFTCORNERBRACKET = "LEFTCORNERBRACKET";
var RIGHTCORNERBRACKET = "RIGHTCORNERBRACKET";
var LEFTWHITECORNERBRACKET = "LEFTWHITECORNERBRACKET";
var RIGHTWHITECORNERBRACKET = "RIGHTWHITECORNERBRACKET";
var FULLWIDTHLESSTHAN = "FULLWIDTHLESSTHAN";
var FULLWIDTHGREATERTHAN = "FULLWIDTHGREATERTHAN";
var AMPERSAND = "AMPERSAND";
var APOSTROPHE = "APOSTROPHE";
var ASTERISK = "ASTERISK";
var AT = "AT";
var BACKSLASH = "BACKSLASH";
var BACKTICK = "BACKTICK";
var CARET = "CARET";
var COLON = "COLON";
var COMMA = "COMMA";
var DOLLAR = "DOLLAR";
var DOT = "DOT";
var EQUALS = "EQUALS";
var EXCLAMATION = "EXCLAMATION";
var HYPHEN = "HYPHEN";
var PERCENT = "PERCENT";
var PIPE = "PIPE";
var PLUS = "PLUS";
var POUND = "POUND";
var QUERY = "QUERY";
var QUOTE = "QUOTE";
var FULLWIDTHMIDDLEDOT = "FULLWIDTHMIDDLEDOT";
var SEMI = "SEMI";
var SLASH = "SLASH";
var TILDE = "TILDE";
var UNDERSCORE = "UNDERSCORE";
var EMOJI$1 = "EMOJI";
var SYM = "SYM";
var tk = Object.freeze({
  __proto__: null,
  ALPHANUMERICAL,
  AMPERSAND,
  APOSTROPHE,
  ASCIINUMERICAL,
  ASTERISK,
  AT,
  BACKSLASH,
  BACKTICK,
  CARET,
  CLOSEANGLEBRACKET,
  CLOSEBRACE,
  CLOSEBRACKET,
  CLOSEPAREN,
  COLON,
  COMMA,
  DOLLAR,
  DOT,
  EMOJI: EMOJI$1,
  EQUALS,
  EXCLAMATION,
  FULLWIDTHGREATERTHAN,
  FULLWIDTHLEFTPAREN,
  FULLWIDTHLESSTHAN,
  FULLWIDTHMIDDLEDOT,
  FULLWIDTHRIGHTPAREN,
  HYPHEN,
  LEFTCORNERBRACKET,
  LEFTWHITECORNERBRACKET,
  LOCALHOST,
  NL,
  NUM,
  OPENANGLEBRACKET,
  OPENBRACE,
  OPENBRACKET,
  OPENPAREN,
  PERCENT,
  PIPE,
  PLUS,
  POUND,
  QUERY,
  QUOTE,
  RIGHTCORNERBRACKET,
  RIGHTWHITECORNERBRACKET,
  SCHEME,
  SEMI,
  SLASH,
  SLASH_SCHEME,
  SYM,
  TILDE,
  TLD,
  UNDERSCORE,
  UTLD,
  UWORD,
  WORD,
  WS
});
var ASCII_LETTER = /[a-z]/;
var LETTER = new RegExp("\\p{L}", "u");
var EMOJI = new RegExp("\\p{Emoji}", "u");
var EMOJI_VARIATION$1 = /\ufe0f/;
var DIGIT = /\d/;
var SPACE = /\s/;
var regexp = Object.freeze({
  __proto__: null,
  ASCII_LETTER,
  DIGIT,
  EMOJI,
  EMOJI_VARIATION: EMOJI_VARIATION$1,
  LETTER,
  SPACE
});
var CR = "\r";
var LF = "\n";
var EMOJI_VARIATION = "️";
var EMOJI_JOINER = "‍";
var OBJECT_REPLACEMENT = "￼";
var tlds = null;
var utlds = null;
function init$2(customSchemes = []) {
  const groups = {};
  State.groups = groups;
  const Start = new State();
  if (tlds == null) {
    tlds = decodeTlds(encodedTlds);
  }
  if (utlds == null) {
    utlds = decodeTlds(encodedUtlds);
  }
  tt(Start, "'", APOSTROPHE);
  tt(Start, "{", OPENBRACE);
  tt(Start, "}", CLOSEBRACE);
  tt(Start, "[", OPENBRACKET);
  tt(Start, "]", CLOSEBRACKET);
  tt(Start, "(", OPENPAREN);
  tt(Start, ")", CLOSEPAREN);
  tt(Start, "<", OPENANGLEBRACKET);
  tt(Start, ">", CLOSEANGLEBRACKET);
  tt(Start, "（", FULLWIDTHLEFTPAREN);
  tt(Start, "）", FULLWIDTHRIGHTPAREN);
  tt(Start, "「", LEFTCORNERBRACKET);
  tt(Start, "」", RIGHTCORNERBRACKET);
  tt(Start, "『", LEFTWHITECORNERBRACKET);
  tt(Start, "』", RIGHTWHITECORNERBRACKET);
  tt(Start, "＜", FULLWIDTHLESSTHAN);
  tt(Start, "＞", FULLWIDTHGREATERTHAN);
  tt(Start, "&", AMPERSAND);
  tt(Start, "*", ASTERISK);
  tt(Start, "@", AT);
  tt(Start, "`", BACKTICK);
  tt(Start, "^", CARET);
  tt(Start, ":", COLON);
  tt(Start, ",", COMMA);
  tt(Start, "$", DOLLAR);
  tt(Start, ".", DOT);
  tt(Start, "=", EQUALS);
  tt(Start, "!", EXCLAMATION);
  tt(Start, "-", HYPHEN);
  tt(Start, "%", PERCENT);
  tt(Start, "|", PIPE);
  tt(Start, "+", PLUS);
  tt(Start, "#", POUND);
  tt(Start, "?", QUERY);
  tt(Start, '"', QUOTE);
  tt(Start, "/", SLASH);
  tt(Start, ";", SEMI);
  tt(Start, "~", TILDE);
  tt(Start, "_", UNDERSCORE);
  tt(Start, "\\", BACKSLASH);
  tt(Start, "・", FULLWIDTHMIDDLEDOT);
  const Num = tr(Start, DIGIT, NUM, {
    [numeric]: true
  });
  tr(Num, DIGIT, Num);
  const Asciinumeric = tr(Num, ASCII_LETTER, ASCIINUMERICAL, {
    [asciinumeric]: true
  });
  const Alphanumeric = tr(Num, LETTER, ALPHANUMERICAL, {
    [alphanumeric]: true
  });
  const Word = tr(Start, ASCII_LETTER, WORD, {
    [ascii]: true
  });
  tr(Word, DIGIT, Asciinumeric);
  tr(Word, ASCII_LETTER, Word);
  tr(Asciinumeric, DIGIT, Asciinumeric);
  tr(Asciinumeric, ASCII_LETTER, Asciinumeric);
  const UWord = tr(Start, LETTER, UWORD, {
    [alpha]: true
  });
  tr(UWord, ASCII_LETTER);
  tr(UWord, DIGIT, Alphanumeric);
  tr(UWord, LETTER, UWord);
  tr(Alphanumeric, DIGIT, Alphanumeric);
  tr(Alphanumeric, ASCII_LETTER);
  tr(Alphanumeric, LETTER, Alphanumeric);
  const Nl2 = tt(Start, LF, NL, {
    [whitespace]: true
  });
  const Cr = tt(Start, CR, WS, {
    [whitespace]: true
  });
  const Ws = tr(Start, SPACE, WS, {
    [whitespace]: true
  });
  tt(Start, OBJECT_REPLACEMENT, Ws);
  tt(Cr, LF, Nl2);
  tt(Cr, OBJECT_REPLACEMENT, Ws);
  tr(Cr, SPACE, Ws);
  tt(Ws, CR);
  tt(Ws, LF);
  tr(Ws, SPACE, Ws);
  tt(Ws, OBJECT_REPLACEMENT, Ws);
  const Emoji = tr(Start, EMOJI, EMOJI$1, {
    [emoji]: true
  });
  tt(Emoji, "#");
  tr(Emoji, EMOJI, Emoji);
  tt(Emoji, EMOJI_VARIATION, Emoji);
  const EmojiJoiner = tt(Emoji, EMOJI_JOINER);
  tt(EmojiJoiner, "#");
  tr(EmojiJoiner, EMOJI, Emoji);
  const wordjr = [[ASCII_LETTER, Word], [DIGIT, Asciinumeric]];
  const uwordjr = [[ASCII_LETTER, null], [LETTER, UWord], [DIGIT, Alphanumeric]];
  for (let i = 0; i < tlds.length; i++) {
    fastts(Start, tlds[i], TLD, WORD, wordjr);
  }
  for (let i = 0; i < utlds.length; i++) {
    fastts(Start, utlds[i], UTLD, UWORD, uwordjr);
  }
  addToGroups(TLD, {
    tld: true,
    ascii: true
  }, groups);
  addToGroups(UTLD, {
    utld: true,
    alpha: true
  }, groups);
  fastts(Start, "file", SCHEME, WORD, wordjr);
  fastts(Start, "mailto", SCHEME, WORD, wordjr);
  fastts(Start, "http", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "https", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "ftp", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "ftps", SLASH_SCHEME, WORD, wordjr);
  addToGroups(SCHEME, {
    scheme: true,
    ascii: true
  }, groups);
  addToGroups(SLASH_SCHEME, {
    slashscheme: true,
    ascii: true
  }, groups);
  customSchemes = customSchemes.sort((a, b) => a[0] > b[0] ? 1 : -1);
  for (let i = 0; i < customSchemes.length; i++) {
    const sch = customSchemes[i][0];
    const optionalSlashSlash = customSchemes[i][1];
    const flags = optionalSlashSlash ? {
      [scheme]: true
    } : {
      [slashscheme]: true
    };
    if (sch.indexOf("-") >= 0) {
      flags[domain] = true;
    } else if (!ASCII_LETTER.test(sch)) {
      flags[numeric] = true;
    } else if (DIGIT.test(sch)) {
      flags[asciinumeric] = true;
    } else {
      flags[ascii] = true;
    }
    ts(Start, sch, sch, flags);
  }
  ts(Start, "localhost", LOCALHOST, {
    ascii: true
  });
  Start.jd = new State(SYM);
  return {
    start: Start,
    tokens: Object.assign({
      groups
    }, tk)
  };
}
function run$1(start, str) {
  const iterable = stringToArray(str.replace(/[A-Z]/g, (c) => c.toLowerCase()));
  const charCount = iterable.length;
  const tokens = [];
  let cursor = 0;
  let charCursor = 0;
  while (charCursor < charCount) {
    let state = start;
    let nextState = null;
    let tokenLength = 0;
    let latestAccepting = null;
    let sinceAccepts = -1;
    let charsSinceAccepts = -1;
    while (charCursor < charCount && (nextState = state.go(iterable[charCursor]))) {
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        charsSinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts += iterable[charCursor].length;
        charsSinceAccepts++;
      }
      tokenLength += iterable[charCursor].length;
      cursor += iterable[charCursor].length;
      charCursor++;
    }
    cursor -= sinceAccepts;
    charCursor -= charsSinceAccepts;
    tokenLength -= sinceAccepts;
    tokens.push({
      t: latestAccepting.t,
      // token type/name
      v: str.slice(cursor - tokenLength, cursor),
      // string value
      s: cursor - tokenLength,
      // start index
      e: cursor
      // end index (excluding)
    });
  }
  return tokens;
}
function stringToArray(str) {
  const result = [];
  const len = str.length;
  let index2 = 0;
  while (index2 < len) {
    let first2 = str.charCodeAt(index2);
    let second;
    let char = first2 < 55296 || first2 > 56319 || index2 + 1 === len || (second = str.charCodeAt(index2 + 1)) < 56320 || second > 57343 ? str[index2] : str.slice(index2, index2 + 2);
    result.push(char);
    index2 += char.length;
  }
  return result;
}
function fastts(state, input, t2, defaultt, jr) {
  let next;
  const len = input.length;
  for (let i = 0; i < len - 1; i++) {
    const char = input[i];
    if (state.j[char]) {
      next = state.j[char];
    } else {
      next = new State(defaultt);
      next.jr = jr.slice();
      state.j[char] = next;
    }
    state = next;
  }
  next = new State(t2);
  next.jr = jr.slice();
  state.j[input[len - 1]] = next;
  return next;
}
function decodeTlds(encoded) {
  const words = [];
  const stack2 = [];
  let i = 0;
  let digits = "0123456789";
  while (i < encoded.length) {
    let popDigitCount = 0;
    while (digits.indexOf(encoded[i + popDigitCount]) >= 0) {
      popDigitCount++;
    }
    if (popDigitCount > 0) {
      words.push(stack2.join(""));
      for (let popCount2 = parseInt(encoded.substring(i, i + popDigitCount), 10); popCount2 > 0; popCount2--) {
        stack2.pop();
      }
      i += popDigitCount;
    } else {
      stack2.push(encoded[i]);
      i++;
    }
  }
  return words;
}
var defaults = {
  defaultProtocol: "http",
  events: null,
  format: noop5,
  formatHref: noop5,
  nl2br: false,
  tagName: "a",
  target: null,
  rel: null,
  validate: true,
  truncate: Infinity,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function Options(opts, defaultRender = null) {
  let o = Object.assign({}, defaults);
  if (opts) {
    o = Object.assign(o, opts instanceof Options ? opts.o : opts);
  }
  const ignoredTags = o.ignoreTags;
  const uppercaseIgnoredTags = [];
  for (let i = 0; i < ignoredTags.length; i++) {
    uppercaseIgnoredTags.push(ignoredTags[i].toUpperCase());
  }
  this.o = o;
  if (defaultRender) {
    this.defaultRender = defaultRender;
  }
  this.ignoreTags = uppercaseIgnoredTags;
}
Options.prototype = {
  o: defaults,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(ir) {
    return ir;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(token) {
    return this.get("validate", token.toString(), token);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(key, operator, token) {
    const isCallable = operator != null;
    let option = this.o[key];
    if (!option) {
      return option;
    }
    if (typeof option === "object") {
      option = token.t in option ? option[token.t] : defaults[key];
      if (typeof option === "function" && isCallable) {
        option = option(operator, token);
      }
    } else if (typeof option === "function" && isCallable) {
      option = option(operator, token.t, token);
    }
    return option;
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(key, operator, token) {
    let obj = this.o[key];
    if (typeof obj === "function" && operator != null) {
      obj = obj(operator, token.t, token);
    }
    return obj;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(token) {
    const ir = token.render(this);
    const renderFn = this.get("render", null, token) || this.defaultRender;
    return renderFn(ir, token.t, token);
  }
};
function noop5(val) {
  return val;
}
var options = Object.freeze({
  __proto__: null,
  Options,
  defaults
});
function MultiToken(value, tokens) {
  this.t = "token";
  this.v = value;
  this.tk = tokens;
}
MultiToken.prototype = {
  isLink: false,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
   */
  toHref(scheme2) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(options2) {
    const val = this.toString();
    const truncate = options2.get("truncate", val, this);
    const formatted = options2.get("format", val, this);
    return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + "…" : formatted;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(options2) {
    return options2.get("formatHref", this.toHref(options2.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(protocol = defaults.defaultProtocol) {
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(protocol),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(options2) {
    return {
      type: this.t,
      value: this.toFormattedString(options2),
      isLink: this.isLink,
      href: this.toFormattedHref(options2),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(options2) {
    return options2.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(options2) {
    const token = this;
    const href = this.toHref(options2.get("defaultProtocol"));
    const formattedHref = options2.get("formatHref", href, this);
    const tagName = options2.get("tagName", href, token);
    const content = this.toFormattedString(options2);
    const attributes = {};
    const className = options2.get("className", href, token);
    const target = options2.get("target", href, token);
    const rel = options2.get("rel", href, token);
    const attrs = options2.getObj("attributes", href, token);
    const eventListeners = options2.getObj("events", href, token);
    attributes.href = formattedHref;
    if (className) {
      attributes.class = className;
    }
    if (target) {
      attributes.target = target;
    }
    if (rel) {
      attributes.rel = rel;
    }
    if (attrs) {
      Object.assign(attributes, attrs);
    }
    return {
      tagName,
      attributes,
      content,
      eventListeners
    };
  }
};
function createTokenClass(type, props) {
  class Token extends MultiToken {
    constructor(value, tokens) {
      super(value, tokens);
      this.t = type;
    }
  }
  for (const p in props) {
    Token.prototype[p] = props[p];
  }
  Token.t = type;
  return Token;
}
var Email = createTokenClass("email", {
  isLink: true,
  toHref() {
    return "mailto:" + this.toString();
  }
});
var Text = createTokenClass("text");
var Nl = createTokenClass("nl");
var Url = createTokenClass("url", {
  isLink: true,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(scheme2 = defaults.defaultProtocol) {
    return this.hasProtocol() ? this.v : `${scheme2}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const tokens = this.tk;
    return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;
  }
});
var multi = Object.freeze({
  __proto__: null,
  Base: MultiToken,
  Email,
  MultiToken,
  Nl,
  Text,
  Url,
  createTokenClass
});
var makeState = (arg) => new State(arg);
function init$1({
  groups
}) {
  const qsAccepting = groups.domain.concat([AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, NUM, PERCENT, PIPE, PLUS, POUND, SLASH, SYM, TILDE, UNDERSCORE]);
  const qsNonAccepting = [APOSTROPHE, COLON, COMMA, DOT, EXCLAMATION, PERCENT, QUERY, QUOTE, SEMI, OPENANGLEBRACKET, CLOSEANGLEBRACKET, OPENBRACE, CLOSEBRACE, CLOSEBRACKET, OPENBRACKET, OPENPAREN, CLOSEPAREN, FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN, LEFTCORNERBRACKET, RIGHTCORNERBRACKET, LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET, FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN];
  const localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, OPENBRACE, CLOSEBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, UNDERSCORE];
  const Start = makeState();
  const Localpart = tt(Start, TILDE);
  ta(Localpart, localpartAccepting, Localpart);
  ta(Localpart, groups.domain, Localpart);
  const Domain = makeState(), Scheme = makeState(), SlashScheme = makeState();
  ta(Start, groups.domain, Domain);
  ta(Start, groups.scheme, Scheme);
  ta(Start, groups.slashscheme, SlashScheme);
  ta(Domain, localpartAccepting, Localpart);
  ta(Domain, groups.domain, Domain);
  const LocalpartAt = tt(Domain, AT);
  tt(Localpart, AT, LocalpartAt);
  tt(Scheme, AT, LocalpartAt);
  tt(SlashScheme, AT, LocalpartAt);
  const LocalpartDot = tt(Localpart, DOT);
  ta(LocalpartDot, localpartAccepting, Localpart);
  ta(LocalpartDot, groups.domain, Localpart);
  const EmailDomain = makeState();
  ta(LocalpartAt, groups.domain, EmailDomain);
  ta(EmailDomain, groups.domain, EmailDomain);
  const EmailDomainDot = tt(EmailDomain, DOT);
  ta(EmailDomainDot, groups.domain, EmailDomain);
  const Email$1 = makeState(Email);
  ta(EmailDomainDot, groups.tld, Email$1);
  ta(EmailDomainDot, groups.utld, Email$1);
  tt(LocalpartAt, LOCALHOST, Email$1);
  const EmailDomainHyphen = tt(EmailDomain, HYPHEN);
  tt(EmailDomainHyphen, HYPHEN, EmailDomainHyphen);
  ta(EmailDomainHyphen, groups.domain, EmailDomain);
  ta(Email$1, groups.domain, EmailDomain);
  tt(Email$1, DOT, EmailDomainDot);
  tt(Email$1, HYPHEN, EmailDomainHyphen);
  const EmailColon = tt(Email$1, COLON);
  ta(EmailColon, groups.numeric, Email);
  const DomainHyphen = tt(Domain, HYPHEN);
  const DomainDot = tt(Domain, DOT);
  tt(DomainHyphen, HYPHEN, DomainHyphen);
  ta(DomainHyphen, groups.domain, Domain);
  ta(DomainDot, localpartAccepting, Localpart);
  ta(DomainDot, groups.domain, Domain);
  const DomainDotTld = makeState(Url);
  ta(DomainDot, groups.tld, DomainDotTld);
  ta(DomainDot, groups.utld, DomainDotTld);
  ta(DomainDotTld, groups.domain, Domain);
  ta(DomainDotTld, localpartAccepting, Localpart);
  tt(DomainDotTld, DOT, DomainDot);
  tt(DomainDotTld, HYPHEN, DomainHyphen);
  tt(DomainDotTld, AT, LocalpartAt);
  const DomainDotTldColon = tt(DomainDotTld, COLON);
  const DomainDotTldColonPort = makeState(Url);
  ta(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);
  const Url$1 = makeState(Url);
  const UrlNonaccept = makeState();
  ta(Url$1, qsAccepting, Url$1);
  ta(Url$1, qsNonAccepting, UrlNonaccept);
  ta(UrlNonaccept, qsAccepting, Url$1);
  ta(UrlNonaccept, qsNonAccepting, UrlNonaccept);
  tt(DomainDotTld, SLASH, Url$1);
  tt(DomainDotTldColonPort, SLASH, Url$1);
  const SchemeColon = tt(Scheme, COLON);
  const SlashSchemeColon = tt(SlashScheme, COLON);
  const SlashSchemeColonSlash = tt(SlashSchemeColon, SLASH);
  const UriPrefix = tt(SlashSchemeColonSlash, SLASH);
  ta(Scheme, groups.domain, Domain);
  tt(Scheme, DOT, DomainDot);
  tt(Scheme, HYPHEN, DomainHyphen);
  ta(SlashScheme, groups.domain, Domain);
  tt(SlashScheme, DOT, DomainDot);
  tt(SlashScheme, HYPHEN, DomainHyphen);
  ta(SchemeColon, groups.domain, Url$1);
  tt(SchemeColon, SLASH, Url$1);
  tt(SchemeColon, QUERY, Url$1);
  ta(UriPrefix, groups.domain, Url$1);
  ta(UriPrefix, qsAccepting, Url$1);
  tt(UriPrefix, SLASH, Url$1);
  const bracketPairs = [
    [OPENBRACE, CLOSEBRACE],
    // {}
    [OPENBRACKET, CLOSEBRACKET],
    // []
    [OPENPAREN, CLOSEPAREN],
    // ()
    [OPENANGLEBRACKET, CLOSEANGLEBRACKET],
    // <>
    [FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN],
    // （）
    [LEFTCORNERBRACKET, RIGHTCORNERBRACKET],
    // 「」
    [LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET],
    // 『』
    [FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN]
    // ＜＞
  ];
  for (let i = 0; i < bracketPairs.length; i++) {
    const [OPEN, CLOSE] = bracketPairs[i];
    const UrlOpen = tt(Url$1, OPEN);
    tt(UrlNonaccept, OPEN, UrlOpen);
    tt(UrlOpen, CLOSE, Url$1);
    const UrlOpenQ = makeState(Url);
    ta(UrlOpen, qsAccepting, UrlOpenQ);
    const UrlOpenSyms = makeState();
    ta(UrlOpen, qsNonAccepting);
    ta(UrlOpenQ, qsAccepting, UrlOpenQ);
    ta(UrlOpenQ, qsNonAccepting, UrlOpenSyms);
    ta(UrlOpenSyms, qsAccepting, UrlOpenQ);
    ta(UrlOpenSyms, qsNonAccepting, UrlOpenSyms);
    tt(UrlOpenQ, CLOSE, Url$1);
    tt(UrlOpenSyms, CLOSE, Url$1);
  }
  tt(Start, LOCALHOST, DomainDotTld);
  tt(Start, NL, Nl);
  return {
    start: Start,
    tokens: tk
  };
}
function run3(start, input, tokens) {
  let len = tokens.length;
  let cursor = 0;
  let multis = [];
  let textTokens = [];
  while (cursor < len) {
    let state = start;
    let secondState = null;
    let nextState = null;
    let multiLength = 0;
    let latestAccepting = null;
    let sinceAccepts = -1;
    while (cursor < len && !(secondState = state.go(tokens[cursor].t))) {
      textTokens.push(tokens[cursor++]);
    }
    while (cursor < len && (nextState = secondState || state.go(tokens[cursor].t))) {
      secondState = null;
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts++;
      }
      cursor++;
      multiLength++;
    }
    if (sinceAccepts < 0) {
      cursor -= multiLength;
      if (cursor < len) {
        textTokens.push(tokens[cursor]);
        cursor++;
      }
    } else {
      if (textTokens.length > 0) {
        multis.push(initMultiToken(Text, input, textTokens));
        textTokens = [];
      }
      cursor -= sinceAccepts;
      multiLength -= sinceAccepts;
      const Multi = latestAccepting.t;
      const subtokens = tokens.slice(cursor - multiLength, cursor);
      multis.push(initMultiToken(Multi, input, subtokens));
    }
  }
  if (textTokens.length > 0) {
    multis.push(initMultiToken(Text, input, textTokens));
  }
  return multis;
}
function initMultiToken(Multi, input, tokens) {
  const startIdx = tokens[0].s;
  const endIdx = tokens[tokens.length - 1].e;
  const value = input.slice(startIdx, endIdx);
  return new Multi(value, tokens);
}
var warn = typeof console !== "undefined" && console && console.warn || (() => {
});
var warnAdvice = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.";
var INIT = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: false
};
function reset() {
  State.groups = {};
  INIT.scanner = null;
  INIT.parser = null;
  INIT.tokenQueue = [];
  INIT.pluginQueue = [];
  INIT.customSchemes = [];
  INIT.initialized = false;
  return INIT;
}
function registerCustomProtocol(scheme2, optionalSlashSlash = false) {
  if (INIT.initialized) {
    warn(`linkifyjs: already initialized - will not register custom scheme "${scheme2}" ${warnAdvice}`);
  }
  if (!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme2)) {
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  }
  INIT.customSchemes.push([scheme2, optionalSlashSlash]);
}
function init() {
  INIT.scanner = init$2(INIT.customSchemes);
  for (let i = 0; i < INIT.tokenQueue.length; i++) {
    INIT.tokenQueue[i][1]({
      scanner: INIT.scanner
    });
  }
  INIT.parser = init$1(INIT.scanner.tokens);
  for (let i = 0; i < INIT.pluginQueue.length; i++) {
    INIT.pluginQueue[i][1]({
      scanner: INIT.scanner,
      parser: INIT.parser
    });
  }
  INIT.initialized = true;
  return INIT;
}
function tokenize(str) {
  if (!INIT.initialized) {
    init();
  }
  return run3(INIT.parser.start, str, run$1(INIT.scanner.start, str));
}
tokenize.scan = run$1;
function find(str, type = null, opts = null) {
  if (type && typeof type === "object") {
    if (opts) {
      throw Error(`linkifyjs: Invalid link type ${type}; must be a string`);
    }
    opts = type;
    type = null;
  }
  const options2 = new Options(opts);
  const tokens = tokenize(str);
  const filtered = [];
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    if (token.isLink && (!type || token.t === type) && options2.check(token)) {
      filtered.push(token.toFormattedObject(options2));
    }
  }
  return filtered;
}

// ../node_modules/@tiptap/extension-link/dist/index.js
var UNICODE_WHITESPACE_PATTERN = "[\0-   ᠎ -\u2029 　]";
var UNICODE_WHITESPACE_REGEX = new RegExp(UNICODE_WHITESPACE_PATTERN);
var UNICODE_WHITESPACE_REGEX_END = new RegExp(`${UNICODE_WHITESPACE_PATTERN}$`);
var UNICODE_WHITESPACE_REGEX_GLOBAL = new RegExp(UNICODE_WHITESPACE_PATTERN, "g");
function isValidLinkStructure(tokens) {
  if (tokens.length === 1) {
    return tokens[0].isLink;
  }
  if (tokens.length === 3 && tokens[1].isLink) {
    return ["()", "[]"].includes(tokens[0].value + tokens[2].value);
  }
  return false;
}
function autolink(options2) {
  return new Plugin({
    key: new PluginKey("autolink"),
    appendTransaction: (transactions, oldState, newState) => {
      const docChanges = transactions.some((transaction2) => transaction2.docChanged) && !oldState.doc.eq(newState.doc);
      const preventAutolink = transactions.some((transaction2) => transaction2.getMeta("preventAutolink"));
      if (!docChanges || preventAutolink) {
        return;
      }
      const { tr: tr2 } = newState;
      const transform = combineTransactionSteps(oldState.doc, [...transactions]);
      const changes = getChangedRanges(transform);
      changes.forEach(({ newRange }) => {
        const nodesInChangedRanges = findChildrenInRange(newState.doc, newRange, (node) => node.isTextblock);
        let textBlock;
        let textBeforeWhitespace;
        if (nodesInChangedRanges.length > 1) {
          textBlock = nodesInChangedRanges[0];
          textBeforeWhitespace = newState.doc.textBetween(
            textBlock.pos,
            textBlock.pos + textBlock.node.nodeSize,
            void 0,
            " "
          );
        } else if (nodesInChangedRanges.length) {
          const endText = newState.doc.textBetween(newRange.from, newRange.to, " ", " ");
          if (!UNICODE_WHITESPACE_REGEX_END.test(endText)) {
            return;
          }
          textBlock = nodesInChangedRanges[0];
          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, void 0, " ");
        }
        if (textBlock && textBeforeWhitespace) {
          const wordsBeforeWhitespace = textBeforeWhitespace.split(UNICODE_WHITESPACE_REGEX).filter(Boolean);
          if (wordsBeforeWhitespace.length <= 0) {
            return false;
          }
          const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];
          const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);
          if (!lastWordBeforeSpace) {
            return false;
          }
          const linksBeforeSpace = tokenize(lastWordBeforeSpace).map((t2) => t2.toObject(options2.defaultProtocol));
          if (!isValidLinkStructure(linksBeforeSpace)) {
            return false;
          }
          linksBeforeSpace.filter((link) => link.isLink).map((link) => ({
            ...link,
            from: lastWordAndBlockOffset + link.start + 1,
            to: lastWordAndBlockOffset + link.end + 1
          })).filter((link) => {
            if (!newState.schema.marks.code) {
              return true;
            }
            return !newState.doc.rangeHasMark(link.from, link.to, newState.schema.marks.code);
          }).filter((link) => options2.validate(link.value)).filter((link) => options2.shouldAutoLink(link.value)).forEach((link) => {
            if (getMarksBetween(link.from, link.to, newState.doc).some((item) => item.mark.type === options2.type)) {
              return;
            }
            tr2.addMark(
              link.from,
              link.to,
              options2.type.create({
                href: link.href
              })
            );
          });
        }
      });
      if (!tr2.steps.length) {
        return;
      }
      return tr2;
    }
  });
}
function clickHandler(options2) {
  return new Plugin({
    key: new PluginKey("handleClickLink"),
    props: {
      handleClick: (view, pos, event) => {
        var _a6, _b3;
        if (event.button !== 0) {
          return false;
        }
        if (!view.editable) {
          return false;
        }
        let link = null;
        if (event.target instanceof HTMLAnchorElement) {
          link = event.target;
        } else {
          const target = event.target;
          if (!target) {
            return false;
          }
          const root = options2.editor.view.dom;
          link = target.closest("a");
          if (link && !root.contains(link)) {
            link = null;
          }
        }
        if (!link) {
          return false;
        }
        let handled = false;
        if (options2.enableClickSelection) {
          const commandResult = options2.editor.commands.extendMarkRange(options2.type.name);
          handled = commandResult;
        }
        if (options2.openOnClick) {
          const attrs = getAttributes(view.state, options2.type.name);
          const href = (_a6 = link.href) != null ? _a6 : attrs.href;
          const target = (_b3 = link.target) != null ? _b3 : attrs.target;
          if (href) {
            window.open(href, target);
            handled = true;
          }
        }
        return handled;
      }
    }
  });
}
function pasteHandler(options2) {
  return new Plugin({
    key: new PluginKey("handlePasteLink"),
    props: {
      handlePaste: (view, _event, slice2) => {
        const { shouldAutoLink } = options2;
        const { state } = view;
        const { selection } = state;
        const { empty: empty2 } = selection;
        if (empty2) {
          return false;
        }
        let textContent = "";
        slice2.content.forEach((node) => {
          textContent += node.textContent;
        });
        const link = find(textContent, { defaultProtocol: options2.defaultProtocol }).find(
          (item) => item.isLink && item.value === textContent
        );
        if (!textContent || !link || shouldAutoLink !== void 0 && !shouldAutoLink(link.value)) {
          return false;
        }
        return options2.editor.commands.setMark(options2.type, {
          href: link.href
        });
      }
    }
  });
}
function isAllowedUri(uri, protocols) {
  const allowedProtocols = ["http", "https", "ftp", "ftps", "mailto", "tel", "callto", "sms", "cid", "xmpp"];
  if (protocols) {
    protocols.forEach((protocol) => {
      const nextProtocol = typeof protocol === "string" ? protocol : protocol.scheme;
      if (nextProtocol) {
        allowedProtocols.push(nextProtocol);
      }
    });
  }
  return !uri || uri.replace(UNICODE_WHITESPACE_REGEX_GLOBAL, "").match(
    new RegExp(
      // eslint-disable-next-line no-useless-escape
      `^(?:(?:${allowedProtocols.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
      "i"
    )
  );
}
var Link2 = Mark2.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: false,
  exitable: true,
  onCreate() {
    if (this.options.validate && !this.options.shouldAutoLink) {
      this.options.shouldAutoLink = this.options.validate;
      console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.");
    }
    this.options.protocols.forEach((protocol) => {
      if (typeof protocol === "string") {
        registerCustomProtocol(protocol);
        return;
      }
      registerCustomProtocol(protocol.scheme, protocol.optionalSlashes);
    });
  },
  onDestroy() {
    reset();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: true,
      enableClickSelection: false,
      linkOnPaste: true,
      autolink: true,
      protocols: [],
      defaultProtocol: "http",
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      isAllowedUri: (url, ctx) => !!isAllowedUri(url, ctx.protocols),
      validate: (url) => !!url,
      shouldAutoLink: (url) => {
        const hasProtocol = /^[a-z][a-z0-9+.-]*:\/\//i.test(url);
        const hasMaybeProtocol = /^[a-z][a-z0-9+.-]*:/i.test(url);
        if (hasProtocol || hasMaybeProtocol && !url.includes("@")) {
          return true;
        }
        const urlWithoutUserinfo = url.includes("@") ? url.split("@").pop() : url;
        const hostname = urlWithoutUserinfo.split(/[/?#:]/)[0];
        if (/^\d{1,3}(\.\d{1,3}){3}$/.test(hostname)) {
          return false;
        }
        if (!/\./.test(hostname)) {
          return false;
        }
        return true;
      }
    };
  },
  addAttributes() {
    return {
      href: {
        default: null,
        parseHTML(element) {
          return element.getAttribute("href");
        }
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      },
      title: {
        default: null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "a[href]",
        getAttrs: (dom) => {
          const href = dom.getAttribute("href");
          if (!href || !this.options.isAllowedUri(href, {
            defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),
            protocols: this.options.protocols,
            defaultProtocol: this.options.defaultProtocol
          })) {
            return false;
          }
          return null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    if (!this.options.isAllowedUri(HTMLAttributes.href, {
      defaultValidate: (href) => !!isAllowedUri(href, this.options.protocols),
      protocols: this.options.protocols,
      defaultProtocol: this.options.defaultProtocol
    })) {
      return ["a", mergeAttributes(this.options.HTMLAttributes, { ...HTMLAttributes, href: "" }), 0];
    }
    return ["a", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  markdownTokenName: "link",
  parseMarkdown: (token, helpers) => {
    return helpers.applyMark("link", helpers.parseInline(token.tokens || []), {
      href: token.href,
      title: token.title || null
    });
  },
  renderMarkdown: (node, h2) => {
    var _a6, _b3, _c, _d;
    const href = (_b3 = (_a6 = node.attrs) == null ? void 0 : _a6.href) != null ? _b3 : "";
    const title = (_d = (_c = node.attrs) == null ? void 0 : _c.title) != null ? _d : "";
    const text = h2.renderChildren(node);
    return title ? `[${text}](${href} "${title}")` : `[${text}](${href})`;
  },
  addCommands() {
    return {
      setLink: (attributes) => ({ chain: chain2 }) => {
        const { href } = attributes;
        if (!this.options.isAllowedUri(href, {
          defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        })) {
          return false;
        }
        return chain2().setMark(this.name, attributes).setMeta("preventAutolink", true).run();
      },
      toggleLink: (attributes) => ({ chain: chain2 }) => {
        const { href } = attributes || {};
        if (href && !this.options.isAllowedUri(href, {
          defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        })) {
          return false;
        }
        return chain2().toggleMark(this.name, attributes, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
      },
      unsetLink: () => ({ chain: chain2 }) => {
        return chain2().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
      }
    };
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: (text) => {
          const foundLinks = [];
          if (text) {
            const { protocols, defaultProtocol } = this.options;
            const links = find(text).filter(
              (item) => item.isLink && this.options.isAllowedUri(item.value, {
                defaultValidate: (href) => !!isAllowedUri(href, protocols),
                protocols,
                defaultProtocol
              })
            );
            if (links.length) {
              links.forEach((link) => {
                if (!this.options.shouldAutoLink(link.value)) {
                  return;
                }
                foundLinks.push({
                  text: link.value,
                  data: {
                    href: link.href
                  },
                  index: link.start
                });
              });
            }
          }
          return foundLinks;
        },
        type: this.type,
        getAttributes: (match) => {
          var _a6;
          return {
            href: (_a6 = match.data) == null ? void 0 : _a6.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const plugins = [];
    const { protocols, defaultProtocol } = this.options;
    if (this.options.autolink) {
      plugins.push(
        autolink({
          type: this.type,
          defaultProtocol: this.options.defaultProtocol,
          validate: (url) => this.options.isAllowedUri(url, {
            defaultValidate: (href) => !!isAllowedUri(href, protocols),
            protocols,
            defaultProtocol
          }),
          shouldAutoLink: this.options.shouldAutoLink
        })
      );
    }
    plugins.push(
      clickHandler({
        type: this.type,
        editor: this.editor,
        openOnClick: this.options.openOnClick === "whenNotEditable" ? true : this.options.openOnClick,
        enableClickSelection: this.options.enableClickSelection
      })
    );
    if (this.options.linkOnPaste) {
      plugins.push(
        pasteHandler({
          editor: this.editor,
          defaultProtocol: this.options.defaultProtocol,
          type: this.type,
          shouldAutoLink: this.options.shouldAutoLink
        })
      );
    }
    return plugins;
  }
});

// ../node_modules/@tiptap/extension-list/dist/index.js
var __defProp13 = Object.defineProperty;
var __export3 = (target, all) => {
  for (var name in all)
    __defProp13(target, name, { get: all[name], enumerable: true });
};
var ListItemName = "listItem";
var TextStyleName = "textStyle";
var bulletListInputRegex = /^\s*([-+*])\s$/;
var BulletList = Node3.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: false,
      keepAttributes: false
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [{ tag: "ul" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["ul", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  markdownTokenName: "list",
  parseMarkdown: (token, helpers) => {
    if (token.type !== "list" || token.ordered) {
      return [];
    }
    return {
      type: "bulletList",
      content: token.items ? helpers.parseChildren(token.items) : []
    };
  },
  renderMarkdown: (node, h2) => {
    if (!node.content) {
      return "";
    }
    return h2.renderChildren(node.content, "\n");
  },
  markdownOptions: {
    indentsContent: true
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands, chain: chain2 }) => {
        if (this.options.keepAttributes) {
          return chain2().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName)).run();
        }
        return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let inputRule = wrappingInputRule({
      find: bulletListInputRegex,
      type: this.type
    });
    if (this.options.keepMarks || this.options.keepAttributes) {
      inputRule = wrappingInputRule({
        find: bulletListInputRegex,
        type: this.type,
        keepMarks: this.options.keepMarks,
        keepAttributes: this.options.keepAttributes,
        getAttributes: () => {
          return this.editor.getAttributes(TextStyleName);
        },
        editor: this.editor
      });
    }
    return [inputRule];
  }
});
var ListItem = Node3.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: true,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  markdownTokenName: "list_item",
  parseMarkdown: (token, helpers) => {
    if (token.type !== "list_item") {
      return [];
    }
    let content = [];
    if (token.tokens && token.tokens.length > 0) {
      const hasParagraphTokens = token.tokens.some((t2) => t2.type === "paragraph");
      if (hasParagraphTokens) {
        content = helpers.parseChildren(token.tokens);
      } else {
        const firstToken = token.tokens[0];
        if (firstToken && firstToken.type === "text" && firstToken.tokens && firstToken.tokens.length > 0) {
          const inlineContent = helpers.parseInline(firstToken.tokens);
          content = [
            {
              type: "paragraph",
              content: inlineContent
            }
          ];
          if (token.tokens.length > 1) {
            const remainingTokens = token.tokens.slice(1);
            const additionalContent = helpers.parseChildren(remainingTokens);
            content.push(...additionalContent);
          }
        } else {
          content = helpers.parseChildren(token.tokens);
        }
      }
    }
    if (content.length === 0) {
      content = [
        {
          type: "paragraph",
          content: []
        }
      ];
    }
    return {
      type: "listItem",
      content
    };
  },
  renderMarkdown: (node, h2, ctx) => {
    return renderNestedMarkdownContent(
      node,
      h2,
      (context) => {
        var _a6, _b3;
        if (context.parentType === "bulletList") {
          return "- ";
        }
        if (context.parentType === "orderedList") {
          const start = ((_b3 = (_a6 = context.meta) == null ? void 0 : _a6.parentAttrs) == null ? void 0 : _b3.start) || 1;
          return `${start + context.index}. `;
        }
        return "- ";
      },
      ctx
    );
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
});
var listHelpers_exports = {};
__export3(listHelpers_exports, {
  findListItemPos: () => findListItemPos,
  getNextListDepth: () => getNextListDepth,
  handleBackspace: () => handleBackspace,
  handleDelete: () => handleDelete,
  hasListBefore: () => hasListBefore,
  hasListItemAfter: () => hasListItemAfter,
  hasListItemBefore: () => hasListItemBefore,
  listItemHasSubList: () => listItemHasSubList,
  nextListIsDeeper: () => nextListIsDeeper,
  nextListIsHigher: () => nextListIsHigher
});
var findListItemPos = (typeOrName, state) => {
  const { $from } = state.selection;
  const nodeType = getNodeType(typeOrName, state.schema);
  let currentNode = null;
  let currentDepth = $from.depth;
  let currentPos = $from.pos;
  let targetDepth = null;
  while (currentDepth > 0 && targetDepth === null) {
    currentNode = $from.node(currentDepth);
    if (currentNode.type === nodeType) {
      targetDepth = currentDepth;
    } else {
      currentDepth -= 1;
      currentPos -= 1;
    }
  }
  if (targetDepth === null) {
    return null;
  }
  return { $pos: state.doc.resolve(currentPos), depth: targetDepth };
};
var getNextListDepth = (typeOrName, state) => {
  const listItemPos = findListItemPos(typeOrName, state);
  if (!listItemPos) {
    return false;
  }
  const [, depth] = getNodeAtPosition(state, typeOrName, listItemPos.$pos.pos + 4);
  return depth;
};
var hasListBefore = (editorState, name, parentListTypes) => {
  const { $anchor } = editorState.selection;
  const previousNodePos = Math.max(0, $anchor.pos - 2);
  const previousNode = editorState.doc.resolve(previousNodePos).node();
  if (!previousNode || !parentListTypes.includes(previousNode.type.name)) {
    return false;
  }
  return true;
};
var hasListItemBefore = (typeOrName, state) => {
  var _a6;
  const { $anchor } = state.selection;
  const $targetPos = state.doc.resolve($anchor.pos - 2);
  if ($targetPos.index() === 0) {
    return false;
  }
  if (((_a6 = $targetPos.nodeBefore) == null ? void 0 : _a6.type.name) !== typeOrName) {
    return false;
  }
  return true;
};
var listItemHasSubList = (typeOrName, state, node) => {
  if (!node) {
    return false;
  }
  const nodeType = getNodeType(typeOrName, state.schema);
  let hasSubList = false;
  node.descendants((child) => {
    if (child.type === nodeType) {
      hasSubList = true;
    }
  });
  return hasSubList;
};
var handleBackspace = (editor, name, parentListTypes) => {
  if (editor.commands.undoInputRule()) {
    return true;
  }
  if (editor.state.selection.from !== editor.state.selection.to) {
    return false;
  }
  if (!isNodeActive(editor.state, name) && hasListBefore(editor.state, name, parentListTypes)) {
    const { $anchor } = editor.state.selection;
    const $listPos = editor.state.doc.resolve($anchor.before() - 1);
    const listDescendants = [];
    $listPos.node().descendants((node, pos) => {
      if (node.type.name === name) {
        listDescendants.push({ node, pos });
      }
    });
    const lastItem = listDescendants.at(-1);
    if (!lastItem) {
      return false;
    }
    const $lastItemPos = editor.state.doc.resolve($listPos.start() + lastItem.pos + 1);
    return editor.chain().cut({ from: $anchor.start() - 1, to: $anchor.end() + 1 }, $lastItemPos.end()).joinForward().run();
  }
  if (!isNodeActive(editor.state, name)) {
    return false;
  }
  if (!isAtStartOfNode(editor.state)) {
    return false;
  }
  const listItemPos = findListItemPos(name, editor.state);
  if (!listItemPos) {
    return false;
  }
  const $prev = editor.state.doc.resolve(listItemPos.$pos.pos - 2);
  const prevNode = $prev.node(listItemPos.depth);
  const previousListItemHasSubList = listItemHasSubList(name, editor.state, prevNode);
  if (hasListItemBefore(name, editor.state) && !previousListItemHasSubList) {
    return editor.commands.joinItemBackward();
  }
  return editor.chain().liftListItem(name).run();
};
var nextListIsDeeper = (typeOrName, state) => {
  const listDepth = getNextListDepth(typeOrName, state);
  const listItemPos = findListItemPos(typeOrName, state);
  if (!listItemPos || !listDepth) {
    return false;
  }
  if (listDepth > listItemPos.depth) {
    return true;
  }
  return false;
};
var nextListIsHigher = (typeOrName, state) => {
  const listDepth = getNextListDepth(typeOrName, state);
  const listItemPos = findListItemPos(typeOrName, state);
  if (!listItemPos || !listDepth) {
    return false;
  }
  if (listDepth < listItemPos.depth) {
    return true;
  }
  return false;
};
var handleDelete = (editor, name) => {
  if (!isNodeActive(editor.state, name)) {
    return false;
  }
  if (!isAtEndOfNode(editor.state, name)) {
    return false;
  }
  const { selection } = editor.state;
  const { $from, $to } = selection;
  if (!selection.empty && $from.sameParent($to)) {
    return false;
  }
  if (nextListIsDeeper(name, editor.state)) {
    return editor.chain().focus(editor.state.selection.from + 4).lift(name).joinBackward().run();
  }
  if (nextListIsHigher(name, editor.state)) {
    return editor.chain().joinForward().joinBackward().run();
  }
  return editor.commands.joinItemForward();
};
var hasListItemAfter = (typeOrName, state) => {
  var _a6;
  const { $anchor } = state.selection;
  const $targetPos = state.doc.resolve($anchor.pos - $anchor.parentOffset - 2);
  if ($targetPos.index() === $targetPos.parent.childCount - 1) {
    return false;
  }
  if (((_a6 = $targetPos.nodeAfter) == null ? void 0 : _a6.type.name) !== typeOrName) {
    return false;
  }
  return true;
};
var ListKeymap = Extension.create({
  name: "listKeymap",
  addOptions() {
    return {
      listTypes: [
        {
          itemName: "listItem",
          wrapperNames: ["bulletList", "orderedList"]
        },
        {
          itemName: "taskItem",
          wrapperNames: ["taskList"]
        }
      ]
    };
  },
  addKeyboardShortcuts() {
    return {
      Delete: ({ editor }) => {
        let handled = false;
        this.options.listTypes.forEach(({ itemName }) => {
          if (editor.state.schema.nodes[itemName] === void 0) {
            return;
          }
          if (handleDelete(editor, itemName)) {
            handled = true;
          }
        });
        return handled;
      },
      "Mod-Delete": ({ editor }) => {
        let handled = false;
        this.options.listTypes.forEach(({ itemName }) => {
          if (editor.state.schema.nodes[itemName] === void 0) {
            return;
          }
          if (handleDelete(editor, itemName)) {
            handled = true;
          }
        });
        return handled;
      },
      Backspace: ({ editor }) => {
        let handled = false;
        this.options.listTypes.forEach(({ itemName, wrapperNames }) => {
          if (editor.state.schema.nodes[itemName] === void 0) {
            return;
          }
          if (handleBackspace(editor, itemName, wrapperNames)) {
            handled = true;
          }
        });
        return handled;
      },
      "Mod-Backspace": ({ editor }) => {
        let handled = false;
        this.options.listTypes.forEach(({ itemName, wrapperNames }) => {
          if (editor.state.schema.nodes[itemName] === void 0) {
            return;
          }
          if (handleBackspace(editor, itemName, wrapperNames)) {
            handled = true;
          }
        });
        return handled;
      }
    };
  }
});
var ORDERED_LIST_ITEM_REGEX = /^(\s*)(\d+)\.\s+(.*)$/;
var INDENTED_LINE_REGEX = /^\s/;
function collectOrderedListItems(lines) {
  const listItems = [];
  let currentLineIndex = 0;
  let consumed = 0;
  while (currentLineIndex < lines.length) {
    const line = lines[currentLineIndex];
    const match = line.match(ORDERED_LIST_ITEM_REGEX);
    if (!match) {
      break;
    }
    const [, indent, number, content] = match;
    const indentLevel = indent.length;
    let itemContent = content;
    let nextLineIndex = currentLineIndex + 1;
    const itemLines = [line];
    while (nextLineIndex < lines.length) {
      const nextLine = lines[nextLineIndex];
      const nextMatch = nextLine.match(ORDERED_LIST_ITEM_REGEX);
      if (nextMatch) {
        break;
      }
      if (nextLine.trim() === "") {
        itemLines.push(nextLine);
        itemContent += "\n";
        nextLineIndex += 1;
      } else if (nextLine.match(INDENTED_LINE_REGEX)) {
        itemLines.push(nextLine);
        itemContent += `
${nextLine.slice(indentLevel + 2)}`;
        nextLineIndex += 1;
      } else {
        break;
      }
    }
    listItems.push({
      indent: indentLevel,
      number: parseInt(number, 10),
      content: itemContent.trim(),
      raw: itemLines.join("\n")
    });
    consumed = nextLineIndex;
    currentLineIndex = nextLineIndex;
  }
  return [listItems, consumed];
}
function buildNestedStructure(items, baseIndent, lexer) {
  var _a6;
  const result = [];
  let currentIndex = 0;
  while (currentIndex < items.length) {
    const item = items[currentIndex];
    if (item.indent === baseIndent) {
      const contentLines = item.content.split("\n");
      const mainText = ((_a6 = contentLines[0]) == null ? void 0 : _a6.trim()) || "";
      const tokens = [];
      if (mainText) {
        tokens.push({
          type: "paragraph",
          raw: mainText,
          tokens: lexer.inlineTokens(mainText)
        });
      }
      const additionalContent = contentLines.slice(1).join("\n").trim();
      if (additionalContent) {
        const blockTokens = lexer.blockTokens(additionalContent);
        tokens.push(...blockTokens);
      }
      let lookAheadIndex = currentIndex + 1;
      const nestedItems = [];
      while (lookAheadIndex < items.length && items[lookAheadIndex].indent > baseIndent) {
        nestedItems.push(items[lookAheadIndex]);
        lookAheadIndex += 1;
      }
      if (nestedItems.length > 0) {
        const nextIndent = Math.min(...nestedItems.map((nestedItem) => nestedItem.indent));
        const nestedListItems = buildNestedStructure(nestedItems, nextIndent, lexer);
        tokens.push({
          type: "list",
          ordered: true,
          start: nestedItems[0].number,
          items: nestedListItems,
          raw: nestedItems.map((nestedItem) => nestedItem.raw).join("\n")
        });
      }
      result.push({
        type: "list_item",
        raw: item.raw,
        tokens
      });
      currentIndex = lookAheadIndex;
    } else {
      currentIndex += 1;
    }
  }
  return result;
}
function parseListItems(items, helpers) {
  return items.map((item) => {
    if (item.type !== "list_item") {
      return helpers.parseChildren([item])[0];
    }
    const content = [];
    if (item.tokens && item.tokens.length > 0) {
      item.tokens.forEach((itemToken) => {
        if (itemToken.type === "paragraph" || itemToken.type === "list" || itemToken.type === "blockquote" || itemToken.type === "code") {
          content.push(...helpers.parseChildren([itemToken]));
        } else if (itemToken.type === "text" && itemToken.tokens) {
          const inlineContent = helpers.parseChildren([itemToken]);
          content.push({
            type: "paragraph",
            content: inlineContent
          });
        } else {
          const parsed = helpers.parseChildren([itemToken]);
          if (parsed.length > 0) {
            content.push(...parsed);
          }
        }
      });
    }
    return {
      type: "listItem",
      content
    };
  });
}
var ListItemName2 = "listItem";
var TextStyleName2 = "textStyle";
var orderedListInputRegex = /^(\d+)\.\s$/;
var OrderedList = Node3.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: false,
      keepAttributes: false
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (element) => {
          return element.hasAttribute("start") ? parseInt(element.getAttribute("start") || "", 10) : 1;
        }
      },
      type: {
        default: null,
        parseHTML: (element) => element.getAttribute("type")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    const { start, ...attributesWithoutStart } = HTMLAttributes;
    return start === 1 ? ["ol", mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0] : ["ol", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  markdownTokenName: "list",
  parseMarkdown: (token, helpers) => {
    if (token.type !== "list" || !token.ordered) {
      return [];
    }
    const startValue = token.start || 1;
    const content = token.items ? parseListItems(token.items, helpers) : [];
    if (startValue !== 1) {
      return {
        type: "orderedList",
        attrs: { start: startValue },
        content
      };
    }
    return {
      type: "orderedList",
      content
    };
  },
  renderMarkdown: (node, h2) => {
    if (!node.content) {
      return "";
    }
    return h2.renderChildren(node.content, "\n");
  },
  markdownTokenizer: {
    name: "orderedList",
    level: "block",
    start: (src) => {
      const match = src.match(/^(\s*)(\d+)\.\s+/);
      const index2 = match == null ? void 0 : match.index;
      return index2 !== void 0 ? index2 : -1;
    },
    tokenize: (src, _tokens, lexer) => {
      var _a6;
      const lines = src.split("\n");
      const [listItems, consumed] = collectOrderedListItems(lines);
      if (listItems.length === 0) {
        return void 0;
      }
      const items = buildNestedStructure(listItems, 0, lexer);
      if (items.length === 0) {
        return void 0;
      }
      const startValue = ((_a6 = listItems[0]) == null ? void 0 : _a6.number) || 1;
      return {
        type: "list",
        ordered: true,
        start: startValue,
        items,
        raw: lines.slice(0, consumed).join("\n")
      };
    }
  },
  markdownOptions: {
    indentsContent: true
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands, chain: chain2 }) => {
        if (this.options.keepAttributes) {
          return chain2().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName2, this.editor.getAttributes(TextStyleName2)).run();
        }
        return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let inputRule = wrappingInputRule({
      find: orderedListInputRegex,
      type: this.type,
      getAttributes: (match) => ({ start: +match[1] }),
      joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1]
    });
    if (this.options.keepMarks || this.options.keepAttributes) {
      inputRule = wrappingInputRule({
        find: orderedListInputRegex,
        type: this.type,
        keepMarks: this.options.keepMarks,
        keepAttributes: this.options.keepAttributes,
        getAttributes: (match) => ({ start: +match[1], ...this.editor.getAttributes(TextStyleName2) }),
        joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],
        editor: this.editor
      });
    }
    return [inputRule];
  }
});
var inputRegex4 = /^\s*(\[([( |x])?\])\s$/;
var TaskItem = Node3.create({
  name: "taskItem",
  addOptions() {
    return {
      nested: false,
      HTMLAttributes: {},
      taskListTypeName: "taskList",
      a11y: void 0
    };
  },
  content() {
    return this.options.nested ? "paragraph block*" : "paragraph+";
  },
  defining: true,
  addAttributes() {
    return {
      checked: {
        default: false,
        keepOnSplit: false,
        parseHTML: (element) => {
          const dataChecked = element.getAttribute("data-checked");
          return dataChecked === "" || dataChecked === "true";
        },
        renderHTML: (attributes) => ({
          "data-checked": attributes.checked
        })
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: `li[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ node, HTMLAttributes }) {
    return [
      "li",
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {
        "data-type": this.name
      }),
      [
        "label",
        [
          "input",
          {
            type: "checkbox",
            checked: node.attrs.checked ? "checked" : null
          }
        ],
        ["span"]
      ],
      ["div", 0]
    ];
  },
  parseMarkdown: (token, h2) => {
    const content = [];
    if (token.tokens && token.tokens.length > 0) {
      content.push(h2.createNode("paragraph", {}, h2.parseInline(token.tokens)));
    } else if (token.text) {
      content.push(h2.createNode("paragraph", {}, [h2.createNode("text", { text: token.text })]));
    } else {
      content.push(h2.createNode("paragraph", {}, []));
    }
    if (token.nestedTokens && token.nestedTokens.length > 0) {
      const nestedContent = h2.parseChildren(token.nestedTokens);
      content.push(...nestedContent);
    }
    return h2.createNode("taskItem", { checked: token.checked || false }, content);
  },
  renderMarkdown: (node, h2) => {
    var _a6;
    const checkedChar = ((_a6 = node.attrs) == null ? void 0 : _a6.checked) ? "x" : " ";
    const prefix = `- [${checkedChar}] `;
    return renderNestedMarkdownContent(node, h2, prefix);
  },
  addKeyboardShortcuts() {
    const shortcuts = {
      Enter: () => this.editor.commands.splitListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
    if (!this.options.nested) {
      return shortcuts;
    }
    return {
      ...shortcuts,
      Tab: () => this.editor.commands.sinkListItem(this.name)
    };
  },
  addNodeView() {
    return ({ node, HTMLAttributes, getPos, editor }) => {
      const listItem = document.createElement("li");
      const checkboxWrapper = document.createElement("label");
      const checkboxStyler = document.createElement("span");
      const checkbox = document.createElement("input");
      const content = document.createElement("div");
      const updateA11Y = (currentNode) => {
        var _a6, _b3;
        checkbox.ariaLabel = ((_b3 = (_a6 = this.options.a11y) == null ? void 0 : _a6.checkboxLabel) == null ? void 0 : _b3.call(_a6, currentNode, checkbox.checked)) || `Task item checkbox for ${currentNode.textContent || "empty task item"}`;
      };
      updateA11Y(node);
      checkboxWrapper.contentEditable = "false";
      checkbox.type = "checkbox";
      checkbox.addEventListener("mousedown", (event) => event.preventDefault());
      checkbox.addEventListener("change", (event) => {
        if (!editor.isEditable && !this.options.onReadOnlyChecked) {
          checkbox.checked = !checkbox.checked;
          return;
        }
        const { checked } = event.target;
        if (editor.isEditable && typeof getPos === "function") {
          editor.chain().focus(void 0, { scrollIntoView: false }).command(({ tr: tr2 }) => {
            const position = getPos();
            if (typeof position !== "number") {
              return false;
            }
            const currentNode = tr2.doc.nodeAt(position);
            tr2.setNodeMarkup(position, void 0, {
              ...currentNode == null ? void 0 : currentNode.attrs,
              checked
            });
            return true;
          }).run();
        }
        if (!editor.isEditable && this.options.onReadOnlyChecked) {
          if (!this.options.onReadOnlyChecked(node, checked)) {
            checkbox.checked = !checkbox.checked;
          }
        }
      });
      Object.entries(this.options.HTMLAttributes).forEach(([key, value]) => {
        listItem.setAttribute(key, value);
      });
      listItem.dataset.checked = node.attrs.checked;
      checkbox.checked = node.attrs.checked;
      checkboxWrapper.append(checkbox, checkboxStyler);
      listItem.append(checkboxWrapper, content);
      Object.entries(HTMLAttributes).forEach(([key, value]) => {
        listItem.setAttribute(key, value);
      });
      let prevRenderedAttributeKeys = new Set(Object.keys(HTMLAttributes));
      return {
        dom: listItem,
        contentDOM: content,
        update: (updatedNode) => {
          if (updatedNode.type !== this.type) {
            return false;
          }
          listItem.dataset.checked = updatedNode.attrs.checked;
          checkbox.checked = updatedNode.attrs.checked;
          updateA11Y(updatedNode);
          const extensionAttributes = editor.extensionManager.attributes;
          const newHTMLAttributes = getRenderedAttributes(updatedNode, extensionAttributes);
          const newKeys = new Set(Object.keys(newHTMLAttributes));
          const staticAttrs = this.options.HTMLAttributes;
          prevRenderedAttributeKeys.forEach((key) => {
            if (!newKeys.has(key)) {
              if (key in staticAttrs) {
                listItem.setAttribute(key, staticAttrs[key]);
              } else {
                listItem.removeAttribute(key);
              }
            }
          });
          Object.entries(newHTMLAttributes).forEach(([key, value]) => {
            if (value === null || value === void 0) {
              if (key in staticAttrs) {
                listItem.setAttribute(key, staticAttrs[key]);
              } else {
                listItem.removeAttribute(key);
              }
            } else {
              listItem.setAttribute(key, value);
            }
          });
          prevRenderedAttributeKeys = newKeys;
          return true;
        }
      };
    };
  },
  addInputRules() {
    return [
      wrappingInputRule({
        find: inputRegex4,
        type: this.type,
        getAttributes: (match) => ({
          checked: match[match.length - 1] === "x"
        })
      })
    ];
  }
});
var TaskList = Node3.create({
  name: "taskList",
  addOptions() {
    return {
      itemTypeName: "taskItem",
      HTMLAttributes: {}
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      {
        tag: `ul[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["ul", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, { "data-type": this.name }), 0];
  },
  parseMarkdown: (token, h2) => {
    return h2.createNode("taskList", {}, h2.parseChildren(token.items || []));
  },
  renderMarkdown: (node, h2) => {
    if (!node.content) {
      return "";
    }
    return h2.renderChildren(node.content, "\n");
  },
  markdownTokenizer: {
    name: "taskList",
    level: "block",
    start(src) {
      var _a6;
      const index2 = (_a6 = src.match(/^\s*[-+*]\s+\[([ xX])\]\s+/)) == null ? void 0 : _a6.index;
      return index2 !== void 0 ? index2 : -1;
    },
    tokenize(src, tokens, lexer) {
      const parseTaskListContent = (content) => {
        const nestedResult = parseIndentedBlocks(
          content,
          {
            itemPattern: /^(\s*)([-+*])\s+\[([ xX])\]\s+(.*)$/,
            extractItemData: (match) => ({
              indentLevel: match[1].length,
              mainContent: match[4],
              checked: match[3].toLowerCase() === "x"
            }),
            createToken: (data, nestedTokens) => ({
              type: "taskItem",
              raw: "",
              mainContent: data.mainContent,
              indentLevel: data.indentLevel,
              checked: data.checked,
              text: data.mainContent,
              tokens: lexer.inlineTokens(data.mainContent),
              nestedTokens
            }),
            // Allow recursive nesting
            customNestedParser: parseTaskListContent
          },
          lexer
        );
        if (nestedResult) {
          return [
            {
              type: "taskList",
              raw: nestedResult.raw,
              items: nestedResult.items
            }
          ];
        }
        return lexer.blockTokens(content);
      };
      const result = parseIndentedBlocks(
        src,
        {
          itemPattern: /^(\s*)([-+*])\s+\[([ xX])\]\s+(.*)$/,
          extractItemData: (match) => ({
            indentLevel: match[1].length,
            mainContent: match[4],
            checked: match[3].toLowerCase() === "x"
          }),
          createToken: (data, nestedTokens) => ({
            type: "taskItem",
            raw: "",
            mainContent: data.mainContent,
            indentLevel: data.indentLevel,
            checked: data.checked,
            text: data.mainContent,
            tokens: lexer.inlineTokens(data.mainContent),
            nestedTokens
          }),
          // Use the recursive parser for nested content
          customNestedParser: parseTaskListContent
        },
        lexer
      );
      if (!result) {
        return void 0;
      }
      return {
        type: "taskList",
        raw: result.raw,
        items: result.items
      };
    }
  },
  markdownOptions: {
    indentsContent: true
  },
  addCommands() {
    return {
      toggleTaskList: () => ({ commands }) => {
        return commands.toggleList(this.name, this.options.itemTypeName);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-9": () => this.editor.commands.toggleTaskList()
    };
  }
});
var ListKit = Extension.create({
  name: "listKit",
  addExtensions() {
    const extensions = [];
    if (this.options.bulletList !== false) {
      extensions.push(BulletList.configure(this.options.bulletList));
    }
    if (this.options.listItem !== false) {
      extensions.push(ListItem.configure(this.options.listItem));
    }
    if (this.options.listKeymap !== false) {
      extensions.push(ListKeymap.configure(this.options.listKeymap));
    }
    if (this.options.orderedList !== false) {
      extensions.push(OrderedList.configure(this.options.orderedList));
    }
    if (this.options.taskItem !== false) {
      extensions.push(TaskItem.configure(this.options.taskItem));
    }
    if (this.options.taskList !== false) {
      extensions.push(TaskList.configure(this.options.taskList));
    }
    return extensions;
  }
});

// ../node_modules/@tiptap/extension-paragraph/dist/index.js
var EMPTY_PARAGRAPH_MARKDOWN = "&nbsp;";
var NBSP_CHAR = " ";
var Paragraph = Node3.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [{ tag: "p" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["p", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  parseMarkdown: (token, helpers) => {
    const tokens = token.tokens || [];
    if (tokens.length === 1 && tokens[0].type === "image") {
      return helpers.parseChildren([tokens[0]]);
    }
    const content = helpers.parseInline(tokens);
    if (content.length === 1 && content[0].type === "text" && (content[0].text === EMPTY_PARAGRAPH_MARKDOWN || content[0].text === NBSP_CHAR)) {
      return helpers.createNode("paragraph", void 0, []);
    }
    return helpers.createNode("paragraph", void 0, content);
  },
  renderMarkdown: (node, h2) => {
    if (!node) {
      return "";
    }
    const content = Array.isArray(node.content) ? node.content : [];
    if (content.length === 0) {
      return EMPTY_PARAGRAPH_MARKDOWN;
    }
    return h2.renderChildren(content);
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands }) => {
        return commands.setNode(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
});

// ../node_modules/@tiptap/extension-strike/dist/index.js
var inputRegex5 = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/;
var pasteRegex3 = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g;
var Strike = Mark2.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: false,
        getAttrs: (style2) => style2.includes("line-through") ? {} : false
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["s", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  markdownTokenName: "del",
  parseMarkdown: (token, helpers) => {
    return helpers.applyMark("strike", helpers.parseInline(token.tokens || []));
  },
  renderMarkdown: (node, h2) => {
    return `~~${h2.renderChildren(node)}~~`;
  },
  addCommands() {
    return {
      setStrike: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleStrike: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetStrike: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-s": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex5,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex3,
        type: this.type
      })
    ];
  }
});

// ../node_modules/@tiptap/extension-text/dist/index.js
var Text2 = Node3.create({
  name: "text",
  group: "inline",
  parseMarkdown: (token) => {
    return {
      type: "text",
      text: token.text || ""
    };
  },
  renderMarkdown: (node) => node.text || ""
});

// ../node_modules/@tiptap/extension-underline/dist/index.js
var Underline = Mark2.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: false,
        getAttrs: (style2) => style2.includes("underline") ? {} : false
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["u", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  parseMarkdown(token, helpers) {
    return helpers.applyMark(this.name || "underline", helpers.parseInline(token.tokens || []));
  },
  renderMarkdown(node, helpers) {
    return `++${helpers.renderChildren(node)}++`;
  },
  markdownTokenizer: {
    name: "underline",
    level: "inline",
    start(src) {
      return src.indexOf("++");
    },
    tokenize(src, _tokens, lexer) {
      const rule = /^(\+\+)([\s\S]+?)(\+\+)/;
      const match = rule.exec(src);
      if (!match) {
        return void 0;
      }
      const innerContent = match[2].trim();
      return {
        type: "underline",
        raw: match[0],
        text: innerContent,
        tokens: lexer.inlineTokens(innerContent)
      };
    }
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleUnderline: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetUnderline: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
});

// ../node_modules/prosemirror-dropcursor/dist/index.js
function dropCursor(options2 = {}) {
  return new Plugin({
    view(editorView) {
      return new DropCursorView(editorView, options2);
    }
  });
}
var DropCursorView = class {
  constructor(editorView, options2) {
    var _a6;
    this.editorView = editorView;
    this.cursorPos = null;
    this.element = null;
    this.timeout = -1;
    this.width = (_a6 = options2.width) !== null && _a6 !== void 0 ? _a6 : 1;
    this.color = options2.color === false ? void 0 : options2.color || "black";
    this.class = options2.class;
    this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((name) => {
      let handler = (e) => {
        this[name](e);
      };
      editorView.dom.addEventListener(name, handler);
      return { name, handler };
    });
  }
  destroy() {
    this.handlers.forEach(({ name, handler }) => this.editorView.dom.removeEventListener(name, handler));
  }
  update(editorView, prevState) {
    if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
      if (this.cursorPos > editorView.state.doc.content.size)
        this.setCursor(null);
      else
        this.updateOverlay();
    }
  }
  setCursor(pos) {
    if (pos == this.cursorPos)
      return;
    this.cursorPos = pos;
    if (pos == null) {
      this.element.parentNode.removeChild(this.element);
      this.element = null;
    } else {
      this.updateOverlay();
    }
  }
  updateOverlay() {
    let $pos = this.editorView.state.doc.resolve(this.cursorPos);
    let isBlock = !$pos.parent.inlineContent, rect;
    let editorDOM = this.editorView.dom, editorRect = editorDOM.getBoundingClientRect();
    let scaleX = editorRect.width / editorDOM.offsetWidth, scaleY = editorRect.height / editorDOM.offsetHeight;
    if (isBlock) {
      let before = $pos.nodeBefore, after = $pos.nodeAfter;
      if (before || after) {
        let node = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));
        if (node) {
          let nodeRect = node.getBoundingClientRect();
          let top = before ? nodeRect.bottom : nodeRect.top;
          if (before && after)
            top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
          let halfWidth = this.width / 2 * scaleY;
          rect = { left: nodeRect.left, right: nodeRect.right, top: top - halfWidth, bottom: top + halfWidth };
        }
      }
    }
    if (!rect) {
      let coords = this.editorView.coordsAtPos(this.cursorPos);
      let halfWidth = this.width / 2 * scaleX;
      rect = { left: coords.left - halfWidth, right: coords.left + halfWidth, top: coords.top, bottom: coords.bottom };
    }
    let parent = this.editorView.dom.offsetParent;
    if (!this.element) {
      this.element = parent.appendChild(document.createElement("div"));
      if (this.class)
        this.element.className = this.class;
      this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;";
      if (this.color) {
        this.element.style.backgroundColor = this.color;
      }
    }
    this.element.classList.toggle("prosemirror-dropcursor-block", isBlock);
    this.element.classList.toggle("prosemirror-dropcursor-inline", !isBlock);
    let parentLeft, parentTop;
    if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
      parentLeft = -pageXOffset;
      parentTop = -pageYOffset;
    } else {
      let rect2 = parent.getBoundingClientRect();
      let parentScaleX = rect2.width / parent.offsetWidth, parentScaleY = rect2.height / parent.offsetHeight;
      parentLeft = rect2.left - parent.scrollLeft * parentScaleX;
      parentTop = rect2.top - parent.scrollTop * parentScaleY;
    }
    this.element.style.left = (rect.left - parentLeft) / scaleX + "px";
    this.element.style.top = (rect.top - parentTop) / scaleY + "px";
    this.element.style.width = (rect.right - rect.left) / scaleX + "px";
    this.element.style.height = (rect.bottom - rect.top) / scaleY + "px";
  }
  scheduleRemoval(timeout) {
    clearTimeout(this.timeout);
    this.timeout = setTimeout(() => this.setCursor(null), timeout);
  }
  dragover(event) {
    if (!this.editorView.editable)
      return;
    let pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });
    let node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
    let disableDropCursor = node && node.type.spec.disableDropCursor;
    let disabled = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;
    if (pos && !disabled) {
      let target = pos.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let point = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
        if (point != null)
          target = point;
      }
      this.setCursor(target);
      this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(event) {
    if (!this.editorView.dom.contains(event.relatedTarget))
      this.setCursor(null);
  }
};

// ../node_modules/prosemirror-gapcursor/dist/index.js
var GapCursor = class _GapCursor extends Selection {
  /**
  Create a gap cursor.
  */
  constructor($pos) {
    super($pos, $pos);
  }
  map(doc3, mapping) {
    let $pos = doc3.resolve(mapping.map(this.head));
    return _GapCursor.valid($pos) ? new _GapCursor($pos) : Selection.near($pos);
  }
  content() {
    return Slice.empty;
  }
  eq(other) {
    return other instanceof _GapCursor && other.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(doc3, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new _GapCursor(doc3.resolve(json.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new GapBookmark(this.anchor);
  }
  /**
  @internal
  */
  static valid($pos) {
    let parent = $pos.parent;
    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))
      return false;
    let override = parent.type.spec.allowGapCursor;
    if (override != null)
      return override;
    let deflt = parent.contentMatchAt($pos.index()).defaultType;
    return deflt && deflt.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom($pos, dir, mustMove = false) {
    search: for (; ; ) {
      if (!mustMove && _GapCursor.valid($pos))
        return $pos;
      let pos = $pos.pos, next = null;
      for (let d = $pos.depth; ; d--) {
        let parent = $pos.node(d);
        if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
          next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
          break;
        } else if (d == 0) {
          return null;
        }
        pos += dir;
        let $cur = $pos.doc.resolve(pos);
        if (_GapCursor.valid($cur))
          return $cur;
      }
      for (; ; ) {
        let inside = dir > 0 ? next.firstChild : next.lastChild;
        if (!inside) {
          if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {
            $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
            mustMove = false;
            continue search;
          }
          break;
        }
        next = inside;
        pos += dir;
        let $cur = $pos.doc.resolve(pos);
        if (_GapCursor.valid($cur))
          return $cur;
      }
      return null;
    }
  }
};
GapCursor.prototype.visible = false;
GapCursor.findFrom = GapCursor.findGapCursorFrom;
Selection.jsonID("gapcursor", GapCursor);
var GapBookmark = class _GapBookmark {
  constructor(pos) {
    this.pos = pos;
  }
  map(mapping) {
    return new _GapBookmark(mapping.map(this.pos));
  }
  resolve(doc3) {
    let $pos = doc3.resolve(this.pos);
    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
  }
};
function needsGap(type) {
  return type.isAtom || type.spec.isolating || type.spec.createGapCursor;
}
function closedBefore($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index2 = $pos.index(d), parent = $pos.node(d);
    if (index2 == 0) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let before = parent.child(index2 - 1); ; before = before.lastChild) {
      if (before.childCount == 0 && !before.inlineContent || needsGap(before.type))
        return true;
      if (before.inlineContent)
        return false;
    }
  }
  return true;
}
function closedAfter($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index2 = $pos.indexAfter(d), parent = $pos.node(d);
    if (index2 == parent.childCount) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let after = parent.child(index2); ; after = after.firstChild) {
      if (after.childCount == 0 && !after.inlineContent || needsGap(after.type))
        return true;
      if (after.inlineContent)
        return false;
    }
  }
  return true;
}
function gapCursor() {
  return new Plugin({
    props: {
      decorations: drawGapCursor,
      createSelectionBetween(_view, $anchor, $head) {
        return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;
      },
      handleClick,
      handleKeyDown,
      handleDOMEvents: { beforeinput }
    }
  });
}
var handleKeyDown = keydownHandler({
  "ArrowLeft": arrow4("horiz", -1),
  "ArrowRight": arrow4("horiz", 1),
  "ArrowUp": arrow4("vert", -1),
  "ArrowDown": arrow4("vert", 1)
});
function arrow4(axis, dir) {
  const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
  return function(state, dispatch2, view) {
    let sel = state.selection;
    let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
    if (sel instanceof TextSelection) {
      if (!view.endOfTextblock(dirStr) || $start.depth == 0)
        return false;
      mustMove = false;
      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
    }
    let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);
    if (!$found)
      return false;
    if (dispatch2)
      dispatch2(state.tr.setSelection(new GapCursor($found)));
    return true;
  };
}
function handleClick(view, pos, event) {
  if (!view || !view.editable)
    return false;
  let $pos = view.state.doc.resolve(pos);
  if (!GapCursor.valid($pos))
    return false;
  let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });
  if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))
    return false;
  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
  return true;
}
function beforeinput(view, event) {
  if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor))
    return false;
  let { $from } = view.state.selection;
  let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
  if (!insert)
    return false;
  let frag = Fragment12.empty;
  for (let i = insert.length - 1; i >= 0; i--)
    frag = Fragment12.from(insert[i].createAndFill(null, frag));
  let tr2 = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));
  tr2.setSelection(TextSelection.near(tr2.doc.resolve($from.pos + 1)));
  view.dispatch(tr2);
  return false;
}
function drawGapCursor(state) {
  if (!(state.selection instanceof GapCursor))
    return null;
  let node = document.createElement("div");
  node.className = "ProseMirror-gapcursor";
  return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, { key: "gapcursor" })]);
}

// ../node_modules/rope-sequence/dist/index.js
var GOOD_LEAF_SIZE = 200;
var RopeSequence = function RopeSequence2() {
};
RopeSequence.prototype.append = function append(other) {
  if (!other.length) {
    return this;
  }
  other = RopeSequence.from(other);
  return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
};
RopeSequence.prototype.prepend = function prepend(other) {
  if (!other.length) {
    return this;
  }
  return RopeSequence.from(other).append(this);
};
RopeSequence.prototype.appendInner = function appendInner(other) {
  return new Append(this, other);
};
RopeSequence.prototype.slice = function slice(from2, to) {
  if (from2 === void 0) from2 = 0;
  if (to === void 0) to = this.length;
  if (from2 >= to) {
    return RopeSequence.empty;
  }
  return this.sliceInner(Math.max(0, from2), Math.min(this.length, to));
};
RopeSequence.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) {
    return void 0;
  }
  return this.getInner(i);
};
RopeSequence.prototype.forEach = function forEach2(f, from2, to) {
  if (from2 === void 0) from2 = 0;
  if (to === void 0) to = this.length;
  if (from2 <= to) {
    this.forEachInner(f, from2, to, 0);
  } else {
    this.forEachInvertedInner(f, from2, to, 0);
  }
};
RopeSequence.prototype.map = function map(f, from2, to) {
  if (from2 === void 0) from2 = 0;
  if (to === void 0) to = this.length;
  var result = [];
  this.forEach(function(elt, i) {
    return result.push(f(elt, i));
  }, from2, to);
  return result;
};
RopeSequence.from = function from(values) {
  if (values instanceof RopeSequence) {
    return values;
  }
  return values && values.length ? new Leaf(values) : RopeSequence.empty;
};
var Leaf = (function(RopeSequence3) {
  function Leaf2(values) {
    RopeSequence3.call(this);
    this.values = values;
  }
  if (RopeSequence3) Leaf2.__proto__ = RopeSequence3;
  Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Leaf2.prototype.constructor = Leaf2;
  var prototypeAccessors = { length: { configurable: true }, depth: { configurable: true } };
  Leaf2.prototype.flatten = function flatten() {
    return this.values;
  };
  Leaf2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    return new Leaf2(this.values.slice(from2, to));
  };
  Leaf2.prototype.getInner = function getInner(i) {
    return this.values[i];
  };
  Leaf2.prototype.forEachInner = function forEachInner(f, from2, to, start) {
    for (var i = from2; i < to; i++) {
      if (f(this.values[i], start + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start) {
    for (var i = from2 - 1; i >= to; i--) {
      if (f(this.values[i], start + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.leafAppend = function leafAppend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(this.values.concat(other.flatten()));
    }
  };
  Leaf2.prototype.leafPrepend = function leafPrepend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(other.flatten().concat(this.values));
    }
  };
  prototypeAccessors.length.get = function() {
    return this.values.length;
  };
  prototypeAccessors.depth.get = function() {
    return 0;
  };
  Object.defineProperties(Leaf2.prototype, prototypeAccessors);
  return Leaf2;
})(RopeSequence);
RopeSequence.empty = new Leaf([]);
var Append = (function(RopeSequence3) {
  function Append2(left, right) {
    RopeSequence3.call(this);
    this.left = left;
    this.right = right;
    this.length = left.length + right.length;
    this.depth = Math.max(left.depth, right.depth) + 1;
  }
  if (RopeSequence3) Append2.__proto__ = RopeSequence3;
  Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Append2.prototype.constructor = Append2;
  Append2.prototype.flatten = function flatten() {
    return this.left.flatten().concat(this.right.flatten());
  };
  Append2.prototype.getInner = function getInner(i) {
    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
  };
  Append2.prototype.forEachInner = function forEachInner(f, from2, to, start) {
    var leftLen = this.left.length;
    if (from2 < leftLen && this.left.forEachInner(f, from2, Math.min(to, leftLen), start) === false) {
      return false;
    }
    if (to > leftLen && this.right.forEachInner(f, Math.max(from2 - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false) {
      return false;
    }
  };
  Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start) {
    var leftLen = this.left.length;
    if (from2 > leftLen && this.right.forEachInvertedInner(f, from2 - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false) {
      return false;
    }
    if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from2, leftLen), to, start) === false) {
      return false;
    }
  };
  Append2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    var leftLen = this.left.length;
    if (to <= leftLen) {
      return this.left.slice(from2, to);
    }
    if (from2 >= leftLen) {
      return this.right.slice(from2 - leftLen, to - leftLen);
    }
    return this.left.slice(from2, leftLen).append(this.right.slice(0, to - leftLen));
  };
  Append2.prototype.leafAppend = function leafAppend(other) {
    var inner = this.right.leafAppend(other);
    if (inner) {
      return new Append2(this.left, inner);
    }
  };
  Append2.prototype.leafPrepend = function leafPrepend(other) {
    var inner = this.left.leafPrepend(other);
    if (inner) {
      return new Append2(inner, this.right);
    }
  };
  Append2.prototype.appendInner = function appendInner2(other) {
    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
      return new Append2(this.left, new Append2(this.right, other));
    }
    return new Append2(this, other);
  };
  return Append2;
})(RopeSequence);
var dist_default2 = RopeSequence;

// ../node_modules/prosemirror-history/dist/index.js
var max_empty_items = 500;
var Branch2 = class _Branch {
  constructor(items, eventCount) {
    this.items = items;
    this.eventCount = eventCount;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(state, preserveItems) {
    if (this.eventCount == 0)
      return null;
    let end = this.items.length;
    for (; ; end--) {
      let next = this.items.get(end - 1);
      if (next.selection) {
        --end;
        break;
      }
    }
    let remap, mapFrom;
    if (preserveItems) {
      remap = this.remapping(end, this.items.length);
      mapFrom = remap.maps.length;
    }
    let transform = state.tr;
    let selection, remaining;
    let addAfter = [], addBefore = [];
    this.items.forEach((item, i) => {
      if (!item.step) {
        if (!remap) {
          remap = this.remapping(end, i + 1);
          mapFrom = remap.maps.length;
        }
        mapFrom--;
        addBefore.push(item);
        return;
      }
      if (remap) {
        addBefore.push(new Item3(item.map));
        let step = item.step.map(remap.slice(mapFrom)), map2;
        if (step && transform.maybeStep(step).doc) {
          map2 = transform.mapping.maps[transform.mapping.maps.length - 1];
          addAfter.push(new Item3(map2, void 0, void 0, addAfter.length + addBefore.length));
        }
        mapFrom--;
        if (map2)
          remap.appendMap(map2, mapFrom);
      } else {
        transform.maybeStep(item.step);
      }
      if (item.selection) {
        selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
        remaining = new _Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);
        return false;
      }
    }, this.items.length, 0);
    return { remaining, transform, selection };
  }
  // Create a new branch with the given transform added.
  addTransform(transform, selection, histOptions, preserveItems) {
    let newItems = [], eventCount = this.eventCount;
    let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
    for (let i = 0; i < transform.steps.length; i++) {
      let step = transform.steps[i].invert(transform.docs[i]);
      let item = new Item3(transform.mapping.maps[i], step, selection), merged;
      if (merged = lastItem && lastItem.merge(item)) {
        item = merged;
        if (i)
          newItems.pop();
        else
          oldItems = oldItems.slice(0, oldItems.length - 1);
      }
      newItems.push(item);
      if (selection) {
        eventCount++;
        selection = void 0;
      }
      if (!preserveItems)
        lastItem = item;
    }
    let overflow = eventCount - histOptions.depth;
    if (overflow > DEPTH_OVERFLOW) {
      oldItems = cutOffEvents(oldItems, overflow);
      eventCount -= overflow;
    }
    return new _Branch(oldItems.append(newItems), eventCount);
  }
  remapping(from2, to) {
    let maps = new Mapping();
    this.items.forEach((item, i) => {
      let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from2 ? maps.maps.length - item.mirrorOffset : void 0;
      maps.appendMap(item.map, mirrorPos);
    }, from2, to);
    return maps;
  }
  addMaps(array) {
    if (this.eventCount == 0)
      return this;
    return new _Branch(this.items.append(array.map((map2) => new Item3(map2))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(rebasedTransform, rebasedCount) {
    if (!this.eventCount)
      return this;
    let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);
    let mapping = rebasedTransform.mapping;
    let newUntil = rebasedTransform.steps.length;
    let eventCount = this.eventCount;
    this.items.forEach((item) => {
      if (item.selection)
        eventCount--;
    }, start);
    let iRebased = rebasedCount;
    this.items.forEach((item) => {
      let pos = mapping.getMirror(--iRebased);
      if (pos == null)
        return;
      newUntil = Math.min(newUntil, pos);
      let map2 = mapping.maps[pos];
      if (item.step) {
        let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
        let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
        if (selection)
          eventCount++;
        rebasedItems.push(new Item3(map2, step, selection));
      } else {
        rebasedItems.push(new Item3(map2));
      }
    }, start);
    let newMaps = [];
    for (let i = rebasedCount; i < newUntil; i++)
      newMaps.push(new Item3(mapping.maps[i]));
    let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);
    let branch = new _Branch(items, eventCount);
    if (branch.emptyItemCount() > max_empty_items)
      branch = branch.compress(this.items.length - rebasedItems.length);
    return branch;
  }
  emptyItemCount() {
    let count3 = 0;
    this.items.forEach((item) => {
      if (!item.step)
        count3++;
    });
    return count3;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(upto = this.items.length) {
    let remap = this.remapping(0, upto), mapFrom = remap.maps.length;
    let items = [], events = 0;
    this.items.forEach((item, i) => {
      if (i >= upto) {
        items.push(item);
        if (item.selection)
          events++;
      } else if (item.step) {
        let step = item.step.map(remap.slice(mapFrom)), map2 = step && step.getMap();
        mapFrom--;
        if (map2)
          remap.appendMap(map2, mapFrom);
        if (step) {
          let selection = item.selection && item.selection.map(remap.slice(mapFrom));
          if (selection)
            events++;
          let newItem = new Item3(map2.invert(), step, selection), merged, last2 = items.length - 1;
          if (merged = items.length && items[last2].merge(newItem))
            items[last2] = merged;
          else
            items.push(newItem);
        }
      } else if (item.map) {
        mapFrom--;
      }
    }, this.items.length, 0);
    return new _Branch(dist_default2.from(items.reverse()), events);
  }
};
Branch2.empty = new Branch2(dist_default2.empty, 0);
function cutOffEvents(items, n) {
  let cutPoint;
  items.forEach((item, i) => {
    if (item.selection && n-- == 0) {
      cutPoint = i;
      return false;
    }
  });
  return items.slice(cutPoint);
}
var Item3 = class _Item {
  constructor(map2, step, selection, mirrorOffset) {
    this.map = map2;
    this.step = step;
    this.selection = selection;
    this.mirrorOffset = mirrorOffset;
  }
  merge(other) {
    if (this.step && other.step && !other.selection) {
      let step = other.step.merge(this.step);
      if (step)
        return new _Item(step.getMap().invert(), step, this.selection);
    }
  }
};
var HistoryState = class {
  constructor(done, undone, prevRanges, prevTime, prevComposition) {
    this.done = done;
    this.undone = undone;
    this.prevRanges = prevRanges;
    this.prevTime = prevTime;
    this.prevComposition = prevComposition;
  }
};
var DEPTH_OVERFLOW = 20;
function applyTransaction(history2, state, tr2, options2) {
  let historyTr = tr2.getMeta(historyKey), rebased;
  if (historyTr)
    return historyTr.historyState;
  if (tr2.getMeta(closeHistoryKey))
    history2 = new HistoryState(history2.done, history2.undone, null, 0, -1);
  let appended = tr2.getMeta("appendedTransaction");
  if (tr2.steps.length == 0) {
    return history2;
  } else if (appended && appended.getMeta(historyKey)) {
    if (appended.getMeta(historyKey).redo)
      return new HistoryState(history2.done.addTransform(tr2, void 0, options2, mustPreserveItems(state)), history2.undone, rangesFor(tr2.mapping.maps), history2.prevTime, history2.prevComposition);
    else
      return new HistoryState(history2.done, history2.undone.addTransform(tr2, void 0, options2, mustPreserveItems(state)), null, history2.prevTime, history2.prevComposition);
  } else if (tr2.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
    let composition = tr2.getMeta("composition");
    let newGroup = history2.prevTime == 0 || !appended && history2.prevComposition != composition && (history2.prevTime < (tr2.time || 0) - options2.newGroupDelay || !isAdjacentTo(tr2, history2.prevRanges));
    let prevRanges = appended ? mapRanges(history2.prevRanges, tr2.mapping) : rangesFor(tr2.mapping.maps);
    return new HistoryState(history2.done.addTransform(tr2, newGroup ? state.selection.getBookmark() : void 0, options2, mustPreserveItems(state)), Branch2.empty, prevRanges, tr2.time, composition == null ? history2.prevComposition : composition);
  } else if (rebased = tr2.getMeta("rebased")) {
    return new HistoryState(history2.done.rebased(tr2, rebased), history2.undone.rebased(tr2, rebased), mapRanges(history2.prevRanges, tr2.mapping), history2.prevTime, history2.prevComposition);
  } else {
    return new HistoryState(history2.done.addMaps(tr2.mapping.maps), history2.undone.addMaps(tr2.mapping.maps), mapRanges(history2.prevRanges, tr2.mapping), history2.prevTime, history2.prevComposition);
  }
}
function isAdjacentTo(transform, prevRanges) {
  if (!prevRanges)
    return false;
  if (!transform.docChanged)
    return true;
  let adjacent = false;
  transform.mapping.maps[0].forEach((start, end) => {
    for (let i = 0; i < prevRanges.length; i += 2)
      if (start <= prevRanges[i + 1] && end >= prevRanges[i])
        adjacent = true;
  });
  return adjacent;
}
function rangesFor(maps) {
  let result = [];
  for (let i = maps.length - 1; i >= 0 && result.length == 0; i--)
    maps[i].forEach((_from, _to, from2, to) => result.push(from2, to));
  return result;
}
function mapRanges(ranges, mapping) {
  if (!ranges)
    return null;
  let result = [];
  for (let i = 0; i < ranges.length; i += 2) {
    let from2 = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);
    if (from2 <= to)
      result.push(from2, to);
  }
  return result;
}
function histTransaction(history2, state, redo2) {
  let preserveItems = mustPreserveItems(state);
  let histOptions = historyKey.get(state).spec.config;
  let pop = (redo2 ? history2.undone : history2.done).popEvent(state, preserveItems);
  if (!pop)
    return null;
  let selection = pop.selection.resolve(pop.transform.doc);
  let added = (redo2 ? history2.done : history2.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
  let newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0, -1);
  return pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist });
}
var cachedPreserveItems = false;
var cachedPreserveItemsPlugins = null;
function mustPreserveItems(state) {
  let plugins = state.plugins;
  if (cachedPreserveItemsPlugins != plugins) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins;
    for (let i = 0; i < plugins.length; i++)
      if (plugins[i].spec.historyPreserveItems) {
        cachedPreserveItems = true;
        break;
      }
  }
  return cachedPreserveItems;
}
var historyKey = new PluginKey("history");
var closeHistoryKey = new PluginKey("closeHistory");
function history(config = {}) {
  config = {
    depth: config.depth || 100,
    newGroupDelay: config.newGroupDelay || 500
  };
  return new Plugin({
    key: historyKey,
    state: {
      init() {
        return new HistoryState(Branch2.empty, Branch2.empty, null, 0, -1);
      },
      apply(tr2, hist, state) {
        return applyTransaction(hist, state, tr2, config);
      }
    },
    config,
    props: {
      handleDOMEvents: {
        beforeinput(view, e) {
          let inputType = e.inputType;
          let command2 = inputType == "historyUndo" ? undo : inputType == "historyRedo" ? redo : null;
          if (!command2 || !view.editable)
            return false;
          e.preventDefault();
          return command2(view.state, view.dispatch);
        }
      }
    }
  });
}
function buildCommand(redo2, scroll) {
  return (state, dispatch2) => {
    let hist = historyKey.getState(state);
    if (!hist || (redo2 ? hist.undone : hist.done).eventCount == 0)
      return false;
    if (dispatch2) {
      let tr2 = histTransaction(hist, state, redo2);
      if (tr2)
        dispatch2(scroll ? tr2.scrollIntoView() : tr2);
    }
    return true;
  };
}
var undo = buildCommand(false, true);
var redo = buildCommand(true, true);
var undoNoScroll = buildCommand(false, false);
var redoNoScroll = buildCommand(true, false);

// ../node_modules/@tiptap/extensions/dist/index.js
var CharacterCount = Extension.create({
  name: "characterCount",
  addOptions() {
    return {
      limit: null,
      mode: "textSize",
      textCounter: (text) => text.length,
      wordCounter: (text) => text.split(" ").filter((word) => word !== "").length
    };
  },
  addStorage() {
    return {
      characters: () => 0,
      words: () => 0
    };
  },
  onBeforeCreate() {
    this.storage.characters = (options2) => {
      const node = (options2 == null ? void 0 : options2.node) || this.editor.state.doc;
      const mode = (options2 == null ? void 0 : options2.mode) || this.options.mode;
      if (mode === "textSize") {
        const text = node.textBetween(0, node.content.size, void 0, " ");
        return this.options.textCounter(text);
      }
      return node.nodeSize;
    };
    this.storage.words = (options2) => {
      const node = (options2 == null ? void 0 : options2.node) || this.editor.state.doc;
      const text = node.textBetween(0, node.content.size, " ", " ");
      return this.options.wordCounter(text);
    };
  },
  addProseMirrorPlugins() {
    let initialEvaluationDone = false;
    return [
      new Plugin({
        key: new PluginKey("characterCount"),
        appendTransaction: (transactions, oldState, newState) => {
          if (initialEvaluationDone) {
            return;
          }
          const limit = this.options.limit;
          if (limit === null || limit === void 0 || limit === 0) {
            initialEvaluationDone = true;
            return;
          }
          const initialContentSize = this.storage.characters({ node: newState.doc });
          if (initialContentSize > limit) {
            const over = initialContentSize - limit;
            const from2 = 0;
            const to = over;
            console.warn(
              `[CharacterCount] Initial content exceeded limit of ${limit} characters. Content was automatically trimmed.`
            );
            const tr2 = newState.tr.deleteRange(from2, to);
            initialEvaluationDone = true;
            return tr2;
          }
          initialEvaluationDone = true;
        },
        filterTransaction: (transaction2, state) => {
          const limit = this.options.limit;
          if (!transaction2.docChanged || limit === 0 || limit === null || limit === void 0) {
            return true;
          }
          const oldSize = this.storage.characters({ node: state.doc });
          const newSize = this.storage.characters({ node: transaction2.doc });
          if (newSize <= limit) {
            return true;
          }
          if (oldSize > limit && newSize > limit && newSize <= oldSize) {
            return true;
          }
          if (oldSize > limit && newSize > limit && newSize > oldSize) {
            return false;
          }
          const isPaste = transaction2.getMeta("paste");
          if (!isPaste) {
            return false;
          }
          const pos = transaction2.selection.$head.pos;
          const over = newSize - limit;
          const from2 = pos - over;
          const to = pos;
          transaction2.deleteRange(from2, to);
          const updatedSize = this.storage.characters({ node: transaction2.doc });
          if (updatedSize > limit) {
            return false;
          }
          return true;
        }
      })
    ];
  }
});
var Dropcursor = Extension.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [dropCursor(this.options)];
  }
});
var Focus = Extension.create({
  name: "focus",
  addOptions() {
    return {
      className: "has-focus",
      mode: "all"
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("focus"),
        props: {
          decorations: ({ doc: doc3, selection }) => {
            const { isEditable, isFocused } = this.editor;
            const { anchor } = selection;
            const decorations = [];
            if (!isEditable || !isFocused) {
              return DecorationSet.create(doc3, []);
            }
            let maxLevels = 0;
            if (this.options.mode === "deepest") {
              doc3.descendants((node, pos) => {
                if (node.isText) {
                  return;
                }
                const isCurrent = anchor >= pos && anchor <= pos + node.nodeSize - 1;
                if (!isCurrent) {
                  return false;
                }
                maxLevels += 1;
              });
            }
            let currentLevel = 0;
            doc3.descendants((node, pos) => {
              if (node.isText) {
                return false;
              }
              const isCurrent = anchor >= pos && anchor <= pos + node.nodeSize - 1;
              if (!isCurrent) {
                return false;
              }
              currentLevel += 1;
              const outOfScope = this.options.mode === "deepest" && maxLevels - currentLevel > 0 || this.options.mode === "shallowest" && currentLevel > 1;
              if (outOfScope) {
                return this.options.mode === "deepest";
              }
              decorations.push(
                Decoration.node(pos, pos + node.nodeSize, {
                  class: this.options.className
                })
              );
            });
            return DecorationSet.create(doc3, decorations);
          }
        }
      })
    ];
  }
});
var Gapcursor = Extension.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [gapCursor()];
  },
  extendNodeSchema(extension) {
    var _a6;
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    return {
      allowGapCursor: (_a6 = callOrReturn(getExtensionField(extension, "allowGapCursor", context))) != null ? _a6 : null
    };
  }
});
var DEFAULT_DATA_ATTRIBUTE = "placeholder";
function preparePlaceholderAttribute(attr) {
  return attr.replace(/\s+/g, "-").replace(/[^a-zA-Z0-9-]/g, "").replace(/^[0-9-]+/, "").replace(/^-+/, "").toLowerCase();
}
var Placeholder = Extension.create({
  name: "placeholder",
  addOptions() {
    return {
      emptyEditorClass: "is-editor-empty",
      emptyNodeClass: "is-empty",
      dataAttribute: DEFAULT_DATA_ATTRIBUTE,
      placeholder: "Write something …",
      showOnlyWhenEditable: true,
      showOnlyCurrent: true,
      includeChildren: false
    };
  },
  addProseMirrorPlugins() {
    const dataAttribute = this.options.dataAttribute ? `data-${preparePlaceholderAttribute(this.options.dataAttribute)}` : `data-${DEFAULT_DATA_ATTRIBUTE}`;
    return [
      new Plugin({
        key: new PluginKey("placeholder"),
        props: {
          decorations: ({ doc: doc3, selection }) => {
            const active = this.editor.isEditable || !this.options.showOnlyWhenEditable;
            const { anchor } = selection;
            const decorations = [];
            if (!active) {
              return null;
            }
            const isEmptyDoc = this.editor.isEmpty;
            doc3.descendants((node, pos) => {
              const hasAnchor = anchor >= pos && anchor <= pos + node.nodeSize;
              const isEmpty = !node.isLeaf && isNodeEmpty(node);
              if ((hasAnchor || !this.options.showOnlyCurrent) && isEmpty) {
                const classes = [this.options.emptyNodeClass];
                if (isEmptyDoc) {
                  classes.push(this.options.emptyEditorClass);
                }
                const decoration = Decoration.node(pos, pos + node.nodeSize, {
                  class: classes.join(" "),
                  [dataAttribute]: typeof this.options.placeholder === "function" ? this.options.placeholder({
                    editor: this.editor,
                    node,
                    pos,
                    hasAnchor
                  }) : this.options.placeholder
                });
                decorations.push(decoration);
              }
              return this.options.includeChildren;
            });
            return DecorationSet.create(doc3, decorations);
          }
        }
      })
    ];
  }
});
var Selection2 = Extension.create({
  name: "selection",
  addOptions() {
    return {
      className: "selection"
    };
  },
  addProseMirrorPlugins() {
    const { editor, options: options2 } = this;
    return [
      new Plugin({
        key: new PluginKey("selection"),
        props: {
          decorations(state) {
            if (state.selection.empty || editor.isFocused || !editor.isEditable || isNodeSelection(state.selection) || editor.view.dragging) {
              return null;
            }
            return DecorationSet.create(state.doc, [
              Decoration.inline(state.selection.from, state.selection.to, {
                class: options2.className
              })
            ]);
          }
        }
      })
    ];
  }
});
function nodeEqualsType({ types, node }) {
  return node && Array.isArray(types) && types.includes(node.type) || (node == null ? void 0 : node.type) === types;
}
var TrailingNode = Extension.create({
  name: "trailingNode",
  addOptions() {
    return {
      node: void 0,
      notAfter: []
    };
  },
  addProseMirrorPlugins() {
    var _a6;
    const plugin = new PluginKey(this.name);
    const defaultNode = this.options.node || ((_a6 = this.editor.schema.topNodeType.contentMatch.defaultType) == null ? void 0 : _a6.name) || "paragraph";
    const disabledNodes = Object.entries(this.editor.schema.nodes).map(([, value]) => value).filter((node) => (this.options.notAfter || []).concat(defaultNode).includes(node.name));
    return [
      new Plugin({
        key: plugin,
        appendTransaction: (_, __, state) => {
          const { doc: doc3, tr: tr2, schema } = state;
          const shouldInsertNodeAtEnd = plugin.getState(state);
          const endPosition = doc3.content.size;
          const type = schema.nodes[defaultNode];
          if (!shouldInsertNodeAtEnd) {
            return;
          }
          return tr2.insert(endPosition, type.create());
        },
        state: {
          init: (_, state) => {
            const lastNode = state.tr.doc.lastChild;
            return !nodeEqualsType({ node: lastNode, types: disabledNodes });
          },
          apply: (tr2, value) => {
            if (!tr2.docChanged) {
              return value;
            }
            if (tr2.getMeta("__uniqueIDTransaction")) {
              return value;
            }
            const lastNode = tr2.doc.lastChild;
            return !nodeEqualsType({ node: lastNode, types: disabledNodes });
          }
        }
      })
    ];
  }
});
var UndoRedo = Extension.create({
  name: "undoRedo",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state, dispatch: dispatch2 }) => {
        return undo(state, dispatch2);
      },
      redo: () => ({ state, dispatch: dispatch2 }) => {
        return redo(state, dispatch2);
      }
    };
  },
  addProseMirrorPlugins() {
    return [history(this.options)];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-я": () => this.editor.commands.undo(),
      "Shift-Mod-я": () => this.editor.commands.redo()
    };
  }
});

// ../node_modules/@tiptap/starter-kit/dist/index.js
var StarterKit = Extension.create({
  name: "starterKit",
  addExtensions() {
    var _a6, _b3, _c, _d;
    const extensions = [];
    if (this.options.bold !== false) {
      extensions.push(Bold.configure(this.options.bold));
    }
    if (this.options.blockquote !== false) {
      extensions.push(Blockquote.configure(this.options.blockquote));
    }
    if (this.options.bulletList !== false) {
      extensions.push(BulletList.configure(this.options.bulletList));
    }
    if (this.options.code !== false) {
      extensions.push(Code.configure(this.options.code));
    }
    if (this.options.codeBlock !== false) {
      extensions.push(CodeBlock.configure(this.options.codeBlock));
    }
    if (this.options.document !== false) {
      extensions.push(Document.configure(this.options.document));
    }
    if (this.options.dropcursor !== false) {
      extensions.push(Dropcursor.configure(this.options.dropcursor));
    }
    if (this.options.gapcursor !== false) {
      extensions.push(Gapcursor.configure(this.options.gapcursor));
    }
    if (this.options.hardBreak !== false) {
      extensions.push(HardBreak.configure(this.options.hardBreak));
    }
    if (this.options.heading !== false) {
      extensions.push(Heading.configure(this.options.heading));
    }
    if (this.options.undoRedo !== false) {
      extensions.push(UndoRedo.configure(this.options.undoRedo));
    }
    if (this.options.horizontalRule !== false) {
      extensions.push(HorizontalRule.configure(this.options.horizontalRule));
    }
    if (this.options.italic !== false) {
      extensions.push(Italic.configure(this.options.italic));
    }
    if (this.options.listItem !== false) {
      extensions.push(ListItem.configure(this.options.listItem));
    }
    if (this.options.listKeymap !== false) {
      extensions.push(ListKeymap.configure((_a6 = this.options) == null ? void 0 : _a6.listKeymap));
    }
    if (this.options.link !== false) {
      extensions.push(Link2.configure((_b3 = this.options) == null ? void 0 : _b3.link));
    }
    if (this.options.orderedList !== false) {
      extensions.push(OrderedList.configure(this.options.orderedList));
    }
    if (this.options.paragraph !== false) {
      extensions.push(Paragraph.configure(this.options.paragraph));
    }
    if (this.options.strike !== false) {
      extensions.push(Strike.configure(this.options.strike));
    }
    if (this.options.text !== false) {
      extensions.push(Text2.configure(this.options.text));
    }
    if (this.options.underline !== false) {
      extensions.push(Underline.configure((_c = this.options) == null ? void 0 : _c.underline));
    }
    if (this.options.trailingNode !== false) {
      extensions.push(TrailingNode.configure((_d = this.options) == null ? void 0 : _d.trailingNode));
    }
    return extensions;
  }
});

// ../node_modules/tldraw/dist-esm/lib/shapes/shared/defaultFonts.mjs
var DefaultFontFaces = {
  tldraw_draw: {
    normal: {
      normal: {
        family: "tldraw_draw",
        src: { url: "tldraw_draw", format: "woff2" },
        weight: "normal"
      },
      bold: {
        family: "tldraw_draw",
        src: { url: "tldraw_draw_bold", format: "woff2" },
        weight: "bold"
      }
    },
    italic: {
      normal: {
        family: "tldraw_draw",
        src: { url: "tldraw_draw_italic", format: "woff2" },
        weight: "normal",
        style: "italic"
      },
      bold: {
        family: "tldraw_draw",
        src: { url: "tldraw_draw_italic_bold", format: "woff2" },
        weight: "bold",
        style: "italic"
      }
    }
  },
  tldraw_sans: {
    normal: {
      normal: {
        family: "tldraw_sans",
        src: { url: "tldraw_sans", format: "woff2" },
        weight: "normal",
        style: "normal"
      },
      bold: {
        family: "tldraw_sans",
        src: { url: "tldraw_sans_bold", format: "woff2" },
        weight: "bold",
        style: "normal"
      }
    },
    italic: {
      normal: {
        family: "tldraw_sans",
        src: { url: "tldraw_sans_italic", format: "woff2" },
        weight: "normal",
        style: "italic"
      },
      bold: {
        family: "tldraw_sans",
        src: { url: "tldraw_sans_italic_bold", format: "woff2" },
        weight: "bold",
        style: "italic"
      }
    }
  },
  tldraw_serif: {
    normal: {
      normal: {
        family: "tldraw_serif",
        src: { url: "tldraw_serif", format: "woff2" },
        weight: "normal",
        style: "normal"
      },
      bold: {
        family: "tldraw_serif",
        src: { url: "tldraw_serif_bold", format: "woff2" },
        weight: "bold",
        style: "normal"
      }
    },
    italic: {
      normal: {
        family: "tldraw_serif",
        src: { url: "tldraw_serif_italic", format: "woff2" },
        weight: "normal",
        style: "italic"
      },
      bold: {
        family: "tldraw_serif",
        src: { url: "tldraw_serif_italic_bold", format: "woff2" },
        weight: "bold",
        style: "italic"
      }
    }
  },
  tldraw_mono: {
    normal: {
      normal: {
        family: "tldraw_mono",
        src: { url: "tldraw_mono", format: "woff2" },
        weight: "normal",
        style: "normal"
      },
      bold: {
        family: "tldraw_mono",
        src: { url: "tldraw_mono_bold", format: "woff2" },
        weight: "bold",
        style: "normal"
      }
    },
    italic: {
      normal: {
        family: "tldraw_mono",
        src: { url: "tldraw_mono_italic", format: "woff2" },
        weight: "normal",
        style: "italic"
      },
      bold: {
        family: "tldraw_mono",
        src: { url: "tldraw_mono_italic_bold", format: "woff2" },
        weight: "bold",
        style: "italic"
      }
    }
  }
};
var allDefaultFontFaces = objectMapValues(DefaultFontFaces).flatMap(
  (font) => objectMapValues(font).flatMap((fontFace) => Object.values(fontFace))
);

// ../node_modules/tldraw/dist-esm/lib/utils/text/richText.mjs
var KeyboardShiftEnterTweakExtension = Extension.create({
  name: "keyboardShiftEnterHandler",
  addKeyboardShortcuts() {
    return {
      // We don't support soft breaks, so we just use the default enter command.
      "Shift-Enter": ({ editor }) => editor.commands.enter()
    };
  }
});
Code.config.excludes = void 0;
Highlight.config.priority = 1100;
var tipTapDefaultExtensions = [
  StarterKit.configure({
    blockquote: false,
    codeBlock: false,
    horizontalRule: false,
    link: {
      openOnClick: false,
      autolink: true
    },
    // Prevent trailing paragraph insertion after lists (fixes #7641)
    trailingNode: {
      notAfter: ["paragraph", "bulletList", "orderedList", "listItem"]
    }
  }),
  Highlight,
  KeyboardShiftEnterTweakExtension,
  // N.B. We disable the text direction core extension in RichTextArea,
  // but we add it back in again here in our own extensions list so that
  // people can omit/override it if they want to.
  extensions_exports.TextDirection.configure({ direction: "auto" })
];
var htmlCache = new WeakCache();
function renderHtmlFromRichText(editor, richText) {
  return htmlCache.get(richText, () => {
    var _a6;
    const tipTapExtensions = ((_a6 = editor.getTextOptions().tipTapConfig) == null ? void 0 : _a6.extensions) ?? tipTapDefaultExtensions;
    const html = generateHTML(richText, tipTapExtensions);
    return html.replaceAll('<p dir="auto"></p>', "<p><br /></p>") ?? "";
  });
}
function renderHtmlFromRichTextForMeasurement(editor, richText) {
  const html = renderHtmlFromRichText(editor, richText);
  return `<div class="tl-rich-text">${html}</div>`;
}
var plainTextFromRichTextCache = new WeakCache();
function isEmptyRichText(richText) {
  if (richText.content.length === 1) {
    if (!richText.content[0].content) return true;
  }
  return false;
}
function renderPlaintextFromRichText(editor, richText) {
  if (isEmptyRichText(richText)) return "";
  return plainTextFromRichTextCache.get(richText, () => {
    var _a6;
    const tipTapExtensions = ((_a6 = editor.getTextOptions().tipTapConfig) == null ? void 0 : _a6.extensions) ?? tipTapDefaultExtensions;
    return generateText(richText, tipTapExtensions, {
      blockSeparator: "\n"
    });
  });
}
function renderRichTextFromHTML(editor, html) {
  var _a6;
  const tipTapExtensions = ((_a6 = editor.getTextOptions().tipTapConfig) == null ? void 0 : _a6.extensions) ?? tipTapDefaultExtensions;
  return generateJSON(html, tipTapExtensions);
}
function defaultAddFontsFromNode(node, state, addFont) {
  for (const mark of node.marks) {
    if (mark.type.name === "bold" && state.weight !== "bold") {
      state = { ...state, weight: "bold" };
    }
    if (mark.type.name === "italic" && state.style !== "italic") {
      state = { ...state, style: "italic" };
    }
    if (mark.type.name === "code" && state.family !== "tldraw_mono") {
      state = { ...state, family: "tldraw_mono" };
    }
  }
  const fontsForFamily = getOwnProperty(DefaultFontFaces, state.family);
  if (!fontsForFamily) return state;
  const fontsForStyle = getOwnProperty(fontsForFamily, state.style);
  if (!fontsForStyle) return state;
  const fontsForWeight = getOwnProperty(fontsForStyle, state.weight);
  if (!fontsForWeight) return state;
  addFont(fontsForWeight);
  return state;
}

// ../node_modules/tldraw/dist-esm/lib/shapes/shared/TextHelpers.mjs
var INDENT = "  ";
var _TextHelpers = class _TextHelpers {
  static normalizeText(text) {
    return text.replace(_TextHelpers.fixNewLines, "\n");
  }
  static normalizeTextForDom(text) {
    return text.replace(_TextHelpers.fixNewLines, "\n").split("\n").map((x) => x || " ").join("\n");
  }
};
__publicField(_TextHelpers, "fixNewLines", /\r?\n|\r/g);
var TextHelpers = _TextHelpers;

// ../node_modules/tldraw/dist-esm/lib/utils/text/text.mjs
var rtlRegex = /[\u0590-\u05FF\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/;
function isRightToLeftLanguage(text) {
  return rtlRegex.test(text);
}
function replaceTabsWithSpaces(text) {
  return text.replace(/\t/g, INDENT);
}
function stripCommonMinimumIndentation(text) {
  const lines = text.split("\n");
  while (lines[0] && lines[0].trim().length === 0) {
    lines.shift();
  }
  let minIndentation = Infinity;
  for (const line of lines) {
    if (line.trim().length > 0) {
      const indentation = line.length - line.trimStart().length;
      minIndentation = Math.min(minIndentation, indentation);
    }
  }
  return lines.map((line) => line.slice(minIndentation)).join("\n");
}
var COMMON_ENTITY_MAP = {
  "&amp;": "&",
  "&quot;": '"',
  "&apos;": "'",
  "&#27;": "'",
  "&#34;": '"',
  "&#38;": "&",
  "&#39;": "'",
  "&#8211;": "–",
  "&#8212;": "—",
  "&#8216;": "‘",
  "&#8217;": "’",
  "&#8220;": "“",
  "&#8221;": "”",
  "&#8230;": "…"
};
var entityRegex = new RegExp(Object.keys(COMMON_ENTITY_MAP).join("|"), "g");
function convertCommonTitleHTMLEntities(text) {
  return text.replace(entityRegex, (m) => COMMON_ENTITY_MAP[m]);
}
function stripTrailingWhitespace(text) {
  return text.replace(/[ \t]+$/gm, "").replace(/\n+$/, "");
}
function cleanupText(text) {
  return stripTrailingWhitespace(stripCommonMinimumIndentation(replaceTabsWithSpaces(text)));
}
var truncateStringWithEllipsis = (str, maxLength) => {
  return str.length <= maxLength ? str : str.substring(0, maxLength - 3) + "...";
};

// ../node_modules/tldraw/dist-esm/lib/defaultExternalContentHandlers.mjs
var DEFAULT_MAX_IMAGE_DIMENSION = 5e3;
var DEFAULT_MAX_ASSET_SIZE = 10 * 1024 * 1024;
function registerDefaultExternalContentHandlers(editor, options2) {
  editor.registerExternalAssetHandler("file", async (externalAsset) => {
    return defaultHandleExternalFileAsset(editor, externalAsset, options2);
  });
  editor.registerExternalAssetHandler("url", async (externalAsset) => {
    return defaultHandleExternalUrlAsset(editor, externalAsset, options2);
  });
  editor.registerExternalContentHandler("svg-text", async (externalContent) => {
    return defaultHandleExternalSvgTextContent(editor, externalContent);
  });
  editor.registerExternalContentHandler("embed", (externalContent) => {
    return defaultHandleExternalEmbedContent(editor, externalContent);
  });
  editor.registerExternalContentHandler("files", async (externalContent) => {
    return defaultHandleExternalFileContent(editor, externalContent, options2);
  });
  editor.registerExternalContentHandler("file-replace", async (externalContent) => {
    return defaultHandleExternalFileReplaceContent(editor, externalContent, options2);
  });
  editor.registerExternalContentHandler("text", async (externalContent) => {
    return defaultHandleExternalTextContent(editor, externalContent);
  });
  editor.registerExternalContentHandler("url", async (externalContent) => {
    return defaultHandleExternalUrlContent(editor, externalContent, options2);
  });
  editor.registerExternalContentHandler("tldraw", async (externalContent) => {
    return defaultHandleExternalTldrawContent(editor, externalContent);
  });
  editor.registerExternalContentHandler("excalidraw", async (externalContent) => {
    return defaultHandleExternalExcalidrawContent(editor, externalContent);
  });
}
async function defaultHandleExternalFileAsset(editor, { file, assetId }, options2) {
  const isSuccess = notifyIfFileNotAllowed(file, options2);
  if (!isSuccess) assert(false, "File checks failed");
  const assetInfo = await getAssetInfo(file, options2, assetId);
  const result = await editor.uploadAsset(assetInfo, file);
  assetInfo.props.src = result.src;
  if (result.meta) assetInfo.meta = { ...assetInfo.meta, ...result.meta };
  return AssetRecordType.create(assetInfo);
}
async function defaultHandleExternalFileReplaceContent(editor, { file, shapeId, isImage }, options2) {
  const isSuccess = notifyIfFileNotAllowed(file, options2);
  if (!isSuccess) assert(false, "File checks failed");
  const shape = editor.getShape(shapeId);
  if (!shape) assert(false, "Shape not found");
  const hash2 = getHashForBuffer(await file.arrayBuffer());
  const assetId = AssetRecordType.createId(hash2);
  editor.createTemporaryAssetPreview(assetId, file);
  const assetInfoPartial = await getMediaAssetInfoPartial(
    file,
    assetId,
    isImage,
    !isImage
    /* isVideo */
  );
  editor.createAssets([assetInfoPartial]);
  if (shape.type === "image") {
    const imageShape = shape;
    const currentCrop = imageShape.props.crop;
    let newWidth = assetInfoPartial.props.w;
    let newHeight = assetInfoPartial.props.h;
    let newX = imageShape.x;
    let newY = imageShape.y;
    let finalCrop = currentCrop;
    if (currentCrop) {
      const result = getCroppedImageDataForReplacedImage(
        imageShape,
        assetInfoPartial.props.w,
        assetInfoPartial.props.h
      );
      finalCrop = result.crop;
      newWidth = result.w;
      newHeight = result.h;
      newX = result.x;
      newY = result.y;
    }
    editor.updateShapes([
      {
        id: imageShape.id,
        type: imageShape.type,
        props: {
          assetId,
          crop: finalCrop,
          w: newWidth,
          h: newHeight
        },
        x: newX,
        y: newY
      }
    ]);
  } else if (shape.type === "video") {
    editor.updateShapes([
      {
        id: shape.id,
        type: shape.type,
        props: {
          assetId,
          w: assetInfoPartial.props.w,
          h: assetInfoPartial.props.h
        }
      }
    ]);
  }
  const asset = await editor.getAssetForExternalContent({
    type: "file",
    file,
    assetId
  });
  editor.updateAssets([{ ...asset, id: assetId }]);
  return asset;
}
async function defaultHandleExternalUrlAsset(editor, { url }, { toasts, msg: msg2 }) {
  var _a6, _b3, _c, _d, _e;
  let meta;
  try {
    const resp = await fetch2(url, {
      method: "GET",
      mode: "no-cors"
    });
    const html = await resp.text();
    const doc3 = new DOMParser().parseFromString(html, "text/html");
    meta = {
      image: ((_a6 = doc3.head.querySelector('meta[property="og:image"]')) == null ? void 0 : _a6.getAttribute("content")) ?? "",
      favicon: ((_b3 = doc3.head.querySelector('link[rel="apple-touch-icon"]')) == null ? void 0 : _b3.getAttribute("href")) ?? ((_c = doc3.head.querySelector('link[rel="icon"]')) == null ? void 0 : _c.getAttribute("href")) ?? "",
      title: ((_d = doc3.head.querySelector('meta[property="og:title"]')) == null ? void 0 : _d.getAttribute("content")) ?? url,
      description: ((_e = doc3.head.querySelector('meta[property="og:description"]')) == null ? void 0 : _e.getAttribute("content")) ?? ""
    };
    if (!meta.image.startsWith("http")) {
      meta.image = new URL(meta.image, url).href;
    }
    if (!meta.favicon.startsWith("http")) {
      meta.favicon = new URL(meta.favicon, url).href;
    }
  } catch (error) {
    console.error(error);
    toasts.addToast({
      title: msg2("assets.url.failed"),
      severity: "error"
    });
    meta = { image: "", favicon: "", title: "", description: "" };
  }
  return {
    id: AssetRecordType.createId(getHashForString(url)),
    typeName: "asset",
    type: "bookmark",
    props: {
      src: url,
      description: meta.description,
      image: meta.image,
      favicon: meta.favicon,
      title: meta.title
    },
    meta: {}
  };
}
async function defaultHandleExternalSvgTextContent(editor, { point, text }) {
  const position = point ?? (editor.inputs.getShiftKey() ? editor.inputs.getCurrentPagePoint() : editor.getViewportPageBounds().center);
  const svg = new DOMParser().parseFromString(text, "image/svg+xml").querySelector("svg");
  if (!svg) {
    throw new Error("No <svg/> element present");
  }
  let width = parseFloat(svg.getAttribute("width") || "0");
  let height = parseFloat(svg.getAttribute("height") || "0");
  if (!(width && height)) {
    document.body.appendChild(svg);
    const box = svg.getBoundingClientRect();
    document.body.removeChild(svg);
    width = box.width;
    height = box.height;
  }
  const asset = await editor.getAssetForExternalContent({
    type: "file",
    file: new File([text], "asset.svg", { type: "image/svg+xml" })
  });
  if (!asset) throw Error("Could not create an asset");
  createShapesForAssets(editor, [asset], position);
}
function defaultHandleExternalEmbedContent(editor, { point, url, embed }) {
  const position = point ?? (editor.inputs.getShiftKey() ? editor.inputs.getCurrentPagePoint() : editor.getViewportPageBounds().center);
  const { width, height } = embed;
  const id = createShapeId();
  const newPoint = maybeSnapToGrid(
    new Vec(position.x - (width || 450) / 2, position.y - (height || 450) / 2),
    editor
  );
  const shapePartial = {
    id,
    type: "embed",
    x: newPoint.x,
    y: newPoint.y,
    props: {
      w: width,
      h: height,
      url
    }
  };
  if (editor.canCreateShape(shapePartial)) {
    editor.createShape(shapePartial).select(id);
  }
}
async function defaultHandleExternalFileContent(editor, { point, files }, options2) {
  const { acceptedImageMimeTypes = DEFAULT_SUPPORTED_IMAGE_TYPES, toasts, msg: msg2 } = options2;
  if (files.length > editor.options.maxFilesAtOnce) {
    toasts.addToast({ title: msg2("assets.files.amount-too-many"), severity: "error" });
    return;
  }
  const position = point ?? (editor.inputs.getShiftKey() ? editor.inputs.getCurrentPagePoint() : editor.getViewportPageBounds().center);
  const pagePoint = new Vec(position.x, position.y);
  const assetPartials = [];
  const assetsToUpdate = [];
  for (const file of files) {
    const isSuccess = notifyIfFileNotAllowed(file, options2);
    if (!isSuccess) continue;
    const assetInfo = await getAssetInfo(file, options2);
    if (acceptedImageMimeTypes.includes(file.type)) {
      editor.createTemporaryAssetPreview(assetInfo.id, file);
    }
    assetPartials.push(assetInfo);
    assetsToUpdate.push({ asset: assetInfo, file });
  }
  Promise.allSettled(
    assetsToUpdate.map(async (assetAndFile) => {
      try {
        const newAsset = await editor.getAssetForExternalContent({
          type: "file",
          file: assetAndFile.file
        });
        if (!newAsset) {
          throw Error("Could not create an asset");
        }
        editor.updateAssets([{ ...newAsset, id: assetAndFile.asset.id }]);
      } catch (error) {
        toasts.addToast({
          title: msg2("assets.files.upload-failed"),
          severity: "error"
        });
        console.error(error);
        editor.deleteAssets([assetAndFile.asset.id]);
        return;
      }
    })
  );
  createShapesForAssets(editor, assetPartials, pagePoint);
}
async function defaultHandleExternalTextContent(editor, { point, text, html }) {
  const p = point ?? (editor.inputs.getShiftKey() ? editor.inputs.getCurrentPagePoint() : editor.getViewportPageBounds().center);
  const defaultProps = editor.getShapeUtil("text").getDefaultProps();
  const cleanedUpPlaintext = cleanupText(text);
  const richTextToPaste = html ? renderRichTextFromHTML(editor, html) : toRichText(cleanedUpPlaintext);
  let w;
  let h2;
  let autoSize;
  let align = "middle";
  const htmlToMeasure = html ?? cleanedUpPlaintext.replace(/\n/g, "<br>");
  const isMultiLine = html ? richTextToPaste.content.length > 1 : cleanedUpPlaintext.split("\n").length > 1;
  const isRtl = isRightToLeftLanguage(cleanedUpPlaintext);
  if (isMultiLine) {
    align = isMultiLine ? isRtl ? "end" : "start" : "middle";
  }
  const rawSize = editor.textMeasure.measureHtml(htmlToMeasure, {
    ...TEXT_PROPS,
    fontFamily: FONT_FAMILIES[defaultProps.font],
    fontSize: FONT_SIZES[defaultProps.size],
    maxWidth: null
  });
  const minWidth = Math.min(
    isMultiLine ? editor.getViewportPageBounds().width * 0.9 : 920,
    Math.max(200, editor.getViewportPageBounds().width * 0.9)
  );
  if (rawSize.w > minWidth) {
    const shrunkSize = editor.textMeasure.measureHtml(htmlToMeasure, {
      ...TEXT_PROPS,
      fontFamily: FONT_FAMILIES[defaultProps.font],
      fontSize: FONT_SIZES[defaultProps.size],
      maxWidth: minWidth
    });
    w = shrunkSize.w;
    h2 = shrunkSize.h;
    autoSize = false;
    align = isRtl ? "end" : "start";
  } else {
    w = Math.max(rawSize.w, 10);
    h2 = Math.max(rawSize.h, 10);
    autoSize = true;
  }
  if (p.y - h2 / 2 < editor.getViewportPageBounds().minY + 40) {
    p.y = editor.getViewportPageBounds().minY + 40 + h2 / 2;
  }
  const newPoint = maybeSnapToGrid(new Vec(p.x - w / 2, p.y - h2 / 2), editor);
  const shapeId = createShapeId();
  editor.createShapes([
    {
      id: shapeId,
      type: "text",
      x: newPoint.x,
      y: newPoint.y,
      props: {
        richText: richTextToPaste,
        // if the text has more than one line, align it to the left
        textAlign: align,
        autoSize,
        w
      }
    }
  ]);
}
async function defaultHandleExternalUrlContent(editor, { point, url }, { toasts, msg: msg2 }) {
  const embedUtil = editor.getShapeUtil("embed");
  const embedInfo = embedUtil == null ? void 0 : embedUtil.getEmbedDefinition(url);
  if (embedInfo && embedInfo.definition.embedOnPaste !== false) {
    return editor.putExternalContent({
      type: "embed",
      url: embedInfo.url,
      point,
      embed: embedInfo.definition
    });
  }
  const position = point ?? (editor.inputs.getShiftKey() ? editor.inputs.getCurrentPagePoint() : editor.getViewportPageBounds().center);
  const result = await createBookmarkFromUrl(editor, { url, center: position });
  if (!result.ok) {
    toasts.addToast({
      title: msg2("assets.url.failed"),
      severity: "error"
    });
    return;
  }
}
async function defaultHandleExternalTldrawContent(editor, { point, content }) {
  editor.run(() => {
    const selectionBoundsBefore = editor.getSelectionPageBounds();
    editor.markHistoryStoppingPoint("paste");
    for (const shape of content.shapes) {
      if (content.rootShapeIds.includes(shape.id)) {
        shape.isLocked = false;
      }
    }
    editor.putContentOntoCurrentPage(content, {
      point,
      select: true
    });
    const selectedBoundsAfter = editor.getSelectionPageBounds();
    if (selectionBoundsBefore && selectedBoundsAfter && (selectionBoundsBefore == null ? void 0 : selectionBoundsBefore.collides(selectedBoundsAfter))) {
      editor.updateInstanceState({ isChangingStyle: true });
      editor.timers.setTimeout(() => {
        editor.updateInstanceState({ isChangingStyle: false });
      }, 150);
    }
  });
}
async function defaultHandleExternalExcalidrawContent(editor, { point, content }) {
  editor.run(() => {
    putExcalidrawContent(editor, content, point);
  });
}
async function getMediaAssetInfoPartial(file, assetId, isImageType, isVideoType, maxImageDimension) {
  let fileType = file.type;
  if (file.type === "video/quicktime") {
    fileType = "video/mp4";
  }
  const size4 = isImageType ? await MediaHelpers.getImageSize(file) : await MediaHelpers.getVideoSize(file);
  const isAnimated = await MediaHelpers.isAnimated(file) || isVideoType;
  const assetInfo = {
    id: assetId,
    type: isImageType ? "image" : "video",
    typeName: "asset",
    props: {
      name: file.name,
      src: "",
      w: size4.w,
      h: size4.h,
      fileSize: file.size,
      mimeType: fileType,
      isAnimated
    },
    meta: {}
  };
  if (maxImageDimension && isFinite(maxImageDimension)) {
    const size22 = { w: assetInfo.props.w, h: assetInfo.props.h };
    const resizedSize = containBoxSize(size22, { w: maxImageDimension, h: maxImageDimension });
    if (size22 !== resizedSize && MediaHelpers.isStaticImageType(file.type)) {
      assetInfo.props.w = resizedSize.w;
      assetInfo.props.h = resizedSize.h;
    }
  }
  return assetInfo;
}
async function createShapesForAssets(editor, assets, position) {
  if (!assets.length) return [];
  const currentPoint = Vec.From(position);
  const partials = [];
  for (let i = 0; i < assets.length; i++) {
    const asset = assets[i];
    switch (asset.type) {
      case "image": {
        partials.push({
          id: createShapeId(),
          type: "image",
          x: currentPoint.x,
          y: currentPoint.y,
          opacity: 1,
          props: {
            assetId: asset.id,
            w: asset.props.w,
            h: asset.props.h
          }
        });
        currentPoint.x += asset.props.w;
        break;
      }
      case "video": {
        partials.push({
          id: createShapeId(),
          type: "video",
          x: currentPoint.x,
          y: currentPoint.y,
          opacity: 1,
          props: {
            assetId: asset.id,
            w: asset.props.w,
            h: asset.props.h
          }
        });
        currentPoint.x += asset.props.w;
      }
    }
  }
  editor.run(() => {
    const assetsToCreate = assets.filter((asset) => !editor.getAsset(asset.id));
    editor.store.atomic(() => {
      if (editor.canCreateShapes(partials)) {
        if (assetsToCreate.length) {
          editor.createAssets(assetsToCreate);
        }
        editor.createShapes(partials).select(...partials.map((p) => p.id));
        centerSelectionAroundPoint(editor, position);
      }
    });
  });
  return partials.map((p) => p.id);
}
function centerSelectionAroundPoint(editor, position) {
  const viewportPageBounds = editor.getViewportPageBounds();
  let selectionPageBounds = editor.getSelectionPageBounds();
  if (selectionPageBounds) {
    const offset4 = selectionPageBounds.center.sub(position);
    editor.updateShapes(
      editor.getSelectedShapes().map((shape) => {
        const localRotation = editor.getShapeParentTransform(shape).decompose().rotation;
        const localDelta = Vec.Rot(offset4, -localRotation);
        return {
          id: shape.id,
          type: shape.type,
          x: shape.x - localDelta.x,
          y: shape.y - localDelta.y
        };
      })
    );
  }
  selectionPageBounds = editor.getSelectionPageBounds();
  if (selectionPageBounds && editor.getInstanceState().isGridMode) {
    const gridSize = editor.getDocumentSettings().gridSize;
    const topLeft = new Vec(selectionPageBounds.minX, selectionPageBounds.minY);
    const gridSnappedPoint = topLeft.clone().snapToGrid(gridSize);
    const delta = Vec.Sub(topLeft, gridSnappedPoint);
    editor.updateShapes(
      editor.getSelectedShapes().map((shape) => {
        const newPoint = { x: shape.x - delta.x, y: shape.y - delta.y };
        return {
          id: shape.id,
          type: shape.type,
          x: newPoint.x,
          y: newPoint.y
        };
      })
    );
  }
  selectionPageBounds = editor.getSelectionPageBounds();
  if (selectionPageBounds && !viewportPageBounds.contains(selectionPageBounds)) {
    editor.zoomToSelection({ animation: { duration: editor.options.animationMediumMs } });
  }
}
function createEmptyBookmarkShape(editor, url, position) {
  const partial = {
    id: createShapeId(),
    type: "bookmark",
    x: position.x - 150,
    y: position.y - 160,
    opacity: 1,
    props: {
      assetId: null,
      url
    }
  };
  editor.run(() => {
    editor.createShape(partial);
    if (!editor.getShape(partial.id)) return;
    editor.select(partial.id);
    centerSelectionAroundPoint(editor, position);
  });
  return editor.getShape(partial.id);
}
function notifyIfFileNotAllowed(file, options2) {
  const {
    acceptedImageMimeTypes = DEFAULT_SUPPORTED_IMAGE_TYPES,
    acceptedVideoMimeTypes = DEFAULT_SUPPORT_VIDEO_TYPES,
    maxAssetSize = DEFAULT_MAX_ASSET_SIZE,
    toasts,
    msg: msg2
  } = options2;
  const isImageType = acceptedImageMimeTypes.includes(file.type);
  const isVideoType = acceptedVideoMimeTypes.includes(file.type);
  if (!isImageType && !isVideoType) {
    toasts.addToast({
      title: msg2("assets.files.type-not-allowed"),
      severity: "error"
    });
    return false;
  }
  if (file.size > maxAssetSize) {
    const formatBytes = (bytes) => {
      if (bytes === 0) return "0 bytes";
      const units = ["bytes", "KB", "MB", "GB", "TB", "PB"];
      const base2 = 1024;
      const unitIndex = Math.floor(Math.log(bytes) / Math.log(base2));
      const value = bytes / Math.pow(base2, unitIndex);
      const formatted = value % 1 === 0 ? value.toString() : value.toFixed(1);
      return `${formatted} ${units[unitIndex]}`;
    };
    toasts.addToast({
      title: msg2("assets.files.size-too-big"),
      description: msg2("assets.files.maximum-size").replace("{size}", formatBytes(maxAssetSize)),
      severity: "error"
    });
    return false;
  }
  if (!file.type) {
    toasts.addToast({
      title: msg2("assets.files.upload-failed"),
      severity: "error"
    });
    console.error("No mime type");
    return false;
  }
  return true;
}
async function getAssetInfo(file, options2, assetId) {
  const {
    acceptedImageMimeTypes = DEFAULT_SUPPORTED_IMAGE_TYPES,
    acceptedVideoMimeTypes = DEFAULT_SUPPORT_VIDEO_TYPES,
    maxImageDimension = DEFAULT_MAX_IMAGE_DIMENSION
  } = options2;
  const isImageType = acceptedImageMimeTypes.includes(file.type);
  const isVideoType = acceptedVideoMimeTypes.includes(file.type);
  const hash2 = getHashForBuffer(await file.arrayBuffer());
  assetId ?? (assetId = AssetRecordType.createId(hash2));
  const assetInfo = await getMediaAssetInfoPartial(
    file,
    assetId,
    isImageType,
    isVideoType,
    maxImageDimension
  );
  return assetInfo;
}

// ../node_modules/tldraw/dist-esm/lib/shapes/arrow/toolStates/Idle.mjs
var Idle2 = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "isPrecise", false);
    __publicField(this, "isPreciseTimerId", null);
    __publicField(this, "preciseTargetId", null);
  }
  onPointerMove() {
    this.update();
  }
  onPointerDown(info) {
    this.parent.transition("pointing", { ...info, isPrecise: this.isPrecise });
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
    this.update();
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
  onExit() {
    clearArrowTargetState(this.editor);
    if (this.isPreciseTimerId !== null) {
      clearTimeout(this.isPreciseTimerId);
    }
  }
  onKeyDown() {
    this.update();
  }
  onKeyUp(info) {
    this.update();
    if (info.key === "Enter") {
      const onlySelectedShape = this.editor.getOnlySelectedShape();
      if (this.editor.canEditShape(onlySelectedShape)) {
        startEditingShapeWithRichText(this.editor, onlySelectedShape, { selectAll: true });
      }
    }
  }
  update() {
    const arrowUtil = this.editor.getShapeUtil("arrow");
    const targetState = updateArrowTargetState({
      editor: this.editor,
      pointInPageSpace: this.editor.inputs.getCurrentPagePoint(),
      arrow: void 0,
      isPrecise: this.isPrecise,
      currentBinding: void 0,
      oppositeBinding: void 0
    });
    if (targetState && targetState.target.id !== this.preciseTargetId) {
      if (this.isPreciseTimerId !== null) {
        clearTimeout(this.isPreciseTimerId);
      }
      this.preciseTargetId = targetState.target.id;
      this.isPreciseTimerId = this.editor.timers.setTimeout(() => {
        this.isPrecise = true;
        this.update();
      }, arrowUtil.options.hoverPreciseTimeout);
    } else if (!targetState && this.preciseTargetId) {
      this.isPrecise = false;
      this.preciseTargetId = null;
      if (this.isPreciseTimerId !== null) {
        clearTimeout(this.isPreciseTimerId);
      }
    }
  }
};
__publicField(Idle2, "id", "idle");

// ../node_modules/tldraw/dist-esm/lib/shapes/arrow/toolStates/Pointing.mjs
var Pointing2 = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "shape");
    __publicField(this, "isPrecise", false);
    __publicField(this, "isPreciseTimerId", null);
    __publicField(this, "markId", "");
  }
  onEnter(info) {
    this.markId = "";
    this.isPrecise = !!info.isPrecise;
    const targetState = updateArrowTargetState({
      editor: this.editor,
      pointInPageSpace: this.editor.inputs.getCurrentPagePoint(),
      arrow: void 0,
      isPrecise: this.isPrecise,
      currentBinding: void 0,
      oppositeBinding: void 0
    });
    if (!targetState) {
      this.createArrowShape();
      if (!this.shape) {
        this.cancel();
        return;
      }
    }
    this.startPreciseTimeout();
  }
  onExit() {
    this.shape = void 0;
    clearArrowTargetState(this.editor);
    this.clearPreciseTimeout();
  }
  onPointerMove() {
    if (this.editor.inputs.getIsDragging()) {
      if (!this.shape) {
        this.createArrowShape();
      }
      if (!this.shape) {
        this.cancel();
        return;
      }
      this.updateArrowShapeEndHandle();
      this.editor.setCurrentTool("select.dragging_handle", {
        shape: this.shape,
        handle: { id: "end", type: "vertex", index: "a3", x: 0, y: 0 },
        isCreating: true,
        creatingMarkId: this.markId || void 0,
        onInteractionEnd: "arrow"
      });
    }
  }
  onPointerUp() {
    this.cancel();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  cancel() {
    if (this.shape) {
      this.editor.bailToMark(this.markId);
    }
    this.parent.transition("idle");
  }
  createArrowShape() {
    var _a6;
    const originPagePoint = this.editor.inputs.getOriginPagePoint();
    const id = createShapeId();
    this.markId = this.editor.markHistoryStoppingPoint(`creating_arrow:${id}`);
    const newPoint = maybeSnapToGrid(originPagePoint, this.editor);
    this.editor.createShape({
      id,
      type: "arrow",
      x: newPoint.x,
      y: newPoint.y,
      props: {
        scale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1
      }
    });
    const shape = this.editor.getShape(id);
    if (!shape) return;
    const handles = this.editor.getShapeHandles(shape);
    if (!handles) throw Error(`expected handles for arrow`);
    const util = this.editor.getShapeUtil("arrow");
    const initial = this.shape;
    const startHandle = handles.find((h2) => h2.id === "start");
    const change = (_a6 = util.onHandleDrag) == null ? void 0 : _a6.call(util, shape, {
      handle: { ...startHandle, x: 0, y: 0 },
      isPrecise: true,
      isCreatingShape: true,
      initial
    });
    if (change) {
      this.editor.updateShapes([change]);
    }
    this.shape = this.editor.getShape(id);
    this.editor.select(id);
  }
  updateArrowShapeEndHandle() {
    var _a6, _b3;
    const shape = this.shape;
    if (!shape) throw Error(`expected shape`);
    const handles = this.editor.getShapeHandles(shape);
    if (!handles) throw Error(`expected handles for arrow`);
    {
      const util = this.editor.getShapeUtil("arrow");
      const initial = this.shape;
      const startHandle = handles.find((h2) => h2.id === "start");
      const change = (_a6 = util.onHandleDrag) == null ? void 0 : _a6.call(util, shape, {
        handle: { ...startHandle, x: 0, y: 0 },
        isPrecise: this.isPrecise,
        isCreatingShape: true,
        initial
      });
      if (change) {
        this.editor.updateShapes([change]);
      }
    }
    {
      const util = this.editor.getShapeUtil("arrow");
      const initial = this.shape;
      const point = this.editor.getPointInShapeSpace(
        shape,
        this.editor.inputs.getCurrentPagePoint()
      );
      const endHandle = handles.find((h2) => h2.id === "end");
      const change = (_b3 = util.onHandleDrag) == null ? void 0 : _b3.call(util, this.editor.getShape(shape), {
        handle: { ...endHandle, x: point.x, y: point.y },
        isPrecise: this.isPrecise,
        isCreatingShape: true,
        initial
      });
      if (change) {
        this.editor.updateShapes([change]);
      }
    }
    this.shape = this.editor.getShape(shape.id);
  }
  startPreciseTimeout() {
    const arrowUtil = this.editor.getShapeUtil("arrow");
    this.isPreciseTimerId = this.editor.timers.setTimeout(() => {
      if (!this.getIsActive()) return;
      this.isPrecise = true;
    }, arrowUtil.options.pointingPreciseTimeout);
  }
  clearPreciseTimeout() {
    if (this.isPreciseTimerId !== null) {
      clearTimeout(this.isPreciseTimerId);
    }
  }
};
__publicField(Pointing2, "id", "pointing");

// ../node_modules/tldraw/dist-esm/lib/shapes/arrow/ArrowShapeTool.mjs
var ArrowShapeTool = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "shapeType", "arrow");
  }
  static children() {
    return [Idle2, Pointing2];
  }
};
__publicField(ArrowShapeTool, "id", "arrow");
__publicField(ArrowShapeTool, "initial", "idle");

// ../node_modules/tldraw/dist-esm/lib/shapes/draw/toolStates/Drawing.mjs
var Drawing = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "info", {});
    __publicField(this, "initialShape");
    __publicField(this, "shapeType", this.parent.id === "highlight" ? "highlight" : "draw");
    __publicField(this, "util", this.editor.getShapeUtil(this.shapeType));
    __publicField(this, "isPen", false);
    __publicField(this, "isPenOrStylus", false);
    __publicField(this, "segmentMode", "free");
    __publicField(this, "didJustShiftClickToExtendPreviousShapeLine", false);
    __publicField(this, "pagePointWhereCurrentSegmentChanged", {});
    __publicField(this, "pagePointWhereNextSegmentChanged", null);
    __publicField(this, "lastRecordedPoint", {});
    __publicField(this, "mergeNextPoint", false);
    __publicField(this, "currentLineLength", 0);
    // Cache for current segment's points to avoid repeated b64 decode/encode
    __publicField(this, "currentSegmentPoints", []);
    __publicField(this, "markId", null);
  }
  onEnter(info) {
    this.markId = null;
    this.info = info;
    this.lastRecordedPoint = this.editor.inputs.getCurrentPagePoint().clone();
    this.startShape();
  }
  onPointerMove() {
    const { inputs } = this.editor;
    const isPen = inputs.getIsPen();
    if (this.isPen && !isPen) {
      if (this.markId) {
        this.editor.bailToMark(this.markId);
        this.startShape();
        return;
      }
    }
    if (this.isPenOrStylus) {
      const currentPagePoint = inputs.getCurrentPagePoint();
      if (Vec.Dist(currentPagePoint, this.lastRecordedPoint) >= 1 / this.editor.getZoomLevel()) {
        this.lastRecordedPoint = currentPagePoint.clone();
        this.mergeNextPoint = false;
      } else {
        this.mergeNextPoint = true;
      }
    } else {
      this.mergeNextPoint = false;
    }
    this.updateDrawingShape();
  }
  onKeyDown(info) {
    if (info.key === "Shift") {
      switch (this.segmentMode) {
        case "free": {
          this.segmentMode = "starting_straight";
          this.pagePointWhereNextSegmentChanged = this.editor.inputs.getCurrentPagePoint().clone();
          break;
        }
        case "starting_free": {
          this.segmentMode = "starting_straight";
        }
      }
    }
    this.updateDrawingShape();
  }
  onKeyUp(info) {
    if (info.key === "Shift") {
      this.editor.snaps.clearIndicators();
      switch (this.segmentMode) {
        case "straight": {
          this.segmentMode = "starting_free";
          this.pagePointWhereNextSegmentChanged = this.editor.inputs.getCurrentPagePoint().clone();
          break;
        }
        case "starting_straight": {
          this.pagePointWhereNextSegmentChanged = null;
          this.segmentMode = "free";
          break;
        }
      }
    }
    this.updateDrawingShape();
  }
  onExit() {
    this.editor.snaps.clearIndicators();
    this.pagePointWhereCurrentSegmentChanged = this.editor.inputs.getCurrentPagePoint().clone();
  }
  canClose() {
    return this.shapeType !== "highlight";
  }
  getIsClosed(segments, size4, scale) {
    if (!this.canClose()) return false;
    const strokeWidth = STROKE_SIZES2[size4];
    const firstPoint = b64Vecs.decodeFirstPoint(segments[0].path);
    const lastSegment = segments[segments.length - 1];
    const lastPoint = b64Vecs.decodeLastPoint(lastSegment.path);
    return firstPoint !== null && lastPoint !== null && firstPoint !== lastPoint && this.currentLineLength > strokeWidth * 4 * scale && Vec.DistMin(firstPoint, lastPoint, strokeWidth * 2 * scale);
  }
  startShape() {
    const inputs = this.editor.inputs;
    const originPagePoint = inputs.getOriginPagePoint();
    const isPen = inputs.getIsPen();
    this.markId = this.editor.markHistoryStoppingPoint("draw start");
    const { z = 0.5 } = this.info.point;
    this.isPen = isPen;
    this.isPenOrStylus = isPen || z > 0 && z < 0.5 || z > 0.5 && z < 1;
    const pressure = this.isPenOrStylus ? z * 1.25 : 0.5;
    this.segmentMode = this.editor.inputs.getShiftKey() ? "straight" : "free";
    this.didJustShiftClickToExtendPreviousShapeLine = false;
    this.lastRecordedPoint = originPagePoint.clone();
    if (this.initialShape) {
      const shape2 = this.editor.getShape(this.initialShape.id);
      if (shape2 && this.segmentMode === "straight") {
        this.didJustShiftClickToExtendPreviousShapeLine = true;
        const prevSegment = last(shape2.props.segments);
        if (!prevSegment) throw Error("Expected a previous segment!");
        const prevPoint = b64Vecs.decodeLastPoint(prevSegment.path);
        if (!prevPoint) throw Error("Expected a previous point!");
        const { x, y } = this.editor.getPointInShapeSpace(shape2, originPagePoint).toFixed();
        const newSegment = {
          type: this.segmentMode,
          path: b64Vecs.encodePoints([
            { x: prevPoint.x, y: prevPoint.y, z: +pressure.toFixed(2) },
            { x, y, z: +pressure.toFixed(2) }
          ])
        };
        const prevPointPageSpace = Mat.applyToPoint(
          this.editor.getShapePageTransform(shape2.id),
          prevPoint
        );
        this.pagePointWhereCurrentSegmentChanged = prevPointPageSpace;
        this.pagePointWhereNextSegmentChanged = null;
        const segments = [...shape2.props.segments, newSegment];
        if (this.currentLineLength < STROKE_SIZES2[shape2.props.size] * 4) {
          this.currentLineLength = this.getLineLength(segments);
        }
        const shapePartial = {
          id: shape2.id,
          type: this.shapeType,
          props: {
            segments
          }
        };
        if (this.canClose()) {
          ;
          shapePartial.props.isClosed = this.getIsClosed(
            segments,
            shape2.props.size,
            shape2.props.scale
          );
        }
        this.editor.updateShapes([shapePartial]);
        return;
      }
    }
    this.pagePointWhereCurrentSegmentChanged = originPagePoint.clone();
    const id = createShapeId();
    const initialPoint = new Vec(0, 0, +pressure.toFixed(2));
    this.currentSegmentPoints = [initialPoint];
    this.editor.createShape({
      id,
      type: this.shapeType,
      x: originPagePoint.x,
      y: originPagePoint.y,
      props: {
        isPen: this.isPenOrStylus,
        scale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1,
        segments: [
          {
            type: this.segmentMode,
            path: b64Vecs.encodePoints([initialPoint])
          }
        ]
      }
    });
    const shape = this.editor.getShape(id);
    if (!shape) {
      this.cancel();
      return;
    }
    this.currentLineLength = 0;
    this.initialShape = this.editor.getShape(id);
  }
  updateDrawingShape() {
    const { initialShape } = this;
    const { inputs } = this.editor;
    if (!initialShape) return;
    const {
      id,
      props: { size: size4, scale }
    } = initialShape;
    const shape = this.editor.getShape(id);
    if (!shape) return;
    const { segments } = shape.props;
    const currentPagePoint = inputs.getCurrentPagePoint();
    const { x, y, z } = this.editor.getPointInShapeSpace(shape, currentPagePoint).toFixed();
    const pressure = this.isPenOrStylus ? +(currentPagePoint.z * 1.25).toFixed(2) : 0.5;
    const newPoint = { x, y, z: pressure };
    switch (this.segmentMode) {
      case "starting_straight": {
        const { pagePointWhereNextSegmentChanged } = this;
        if (pagePointWhereNextSegmentChanged === null) {
          throw Error("We should have a point where the segment changed");
        }
        const hasMovedFarEnough = Vec.Dist2(pagePointWhereNextSegmentChanged, inputs.getCurrentPagePoint()) > this.editor.options.dragDistanceSquared;
        if (hasMovedFarEnough) {
          this.pagePointWhereCurrentSegmentChanged = this.pagePointWhereNextSegmentChanged.clone();
          this.pagePointWhereNextSegmentChanged = null;
          this.segmentMode = "straight";
          const prevSegment = last(segments);
          if (!prevSegment) throw Error("Expected a previous segment!");
          const prevLastPoint = b64Vecs.decodeLastPoint(prevSegment.path);
          if (!prevLastPoint) throw Error("Expected a previous last point!");
          let newSegment;
          const newLastPoint = this.editor.getPointInShapeSpace(shape, this.pagePointWhereCurrentSegmentChanged).toFixed().toJson();
          if (prevSegment.type === "straight") {
            this.currentLineLength += Vec.Dist(prevLastPoint, newLastPoint);
            newSegment = {
              type: "straight",
              path: b64Vecs.encodePoints([prevLastPoint, newLastPoint])
            };
            const transform = this.editor.getShapePageTransform(shape);
            this.pagePointWhereCurrentSegmentChanged = Mat.applyToPoint(transform, prevLastPoint);
          } else {
            newSegment = {
              type: "straight",
              path: b64Vecs.encodePoints([newLastPoint, newPoint])
            };
          }
          const shapePartial = {
            id,
            type: this.shapeType,
            props: {
              segments: [...segments, newSegment]
            }
          };
          if (this.canClose()) {
            ;
            shapePartial.props.isClosed = this.getIsClosed(
              segments,
              size4,
              scale
            );
          }
          this.editor.updateShapes([shapePartial]);
        }
        break;
      }
      case "starting_free": {
        const { pagePointWhereNextSegmentChanged } = this;
        if (pagePointWhereNextSegmentChanged === null) {
          throw Error("We should have a point where the segment changed");
        }
        const hasMovedFarEnough = Vec.Dist2(pagePointWhereNextSegmentChanged, inputs.getCurrentPagePoint()) > this.editor.options.dragDistanceSquared;
        if (hasMovedFarEnough) {
          this.pagePointWhereCurrentSegmentChanged = this.pagePointWhereNextSegmentChanged.clone();
          this.pagePointWhereNextSegmentChanged = null;
          this.segmentMode = "free";
          const newSegments = segments.slice();
          const prevStraightSegment = newSegments[newSegments.length - 1];
          const prevPoint = b64Vecs.decodeLastPoint(prevStraightSegment.path);
          if (!prevPoint) {
            throw Error("No previous point!");
          }
          const interpolatedPoints = Vec.PointsBetween(prevPoint, newPoint, 6).map(
            (p) => new Vec(toFixed(p.x), toFixed(p.y), toFixed(p.z))
          );
          this.currentSegmentPoints = interpolatedPoints;
          const newFreeSegment = {
            type: "free",
            path: b64Vecs.encodePoints(interpolatedPoints)
          };
          const finalSegments = [...newSegments, newFreeSegment];
          if (this.currentLineLength < STROKE_SIZES2[shape.props.size] * 4) {
            this.currentLineLength = this.getLineLength(finalSegments);
          }
          const shapePartial = {
            id,
            type: this.shapeType,
            props: {
              segments: finalSegments
            }
          };
          if (this.canClose()) {
            ;
            shapePartial.props.isClosed = this.getIsClosed(
              finalSegments,
              size4,
              scale
            );
          }
          this.editor.updateShapes([shapePartial]);
        }
        break;
      }
      case "straight": {
        const newSegments = segments.slice();
        const newSegment = newSegments[newSegments.length - 1];
        const { pagePointWhereCurrentSegmentChanged } = this;
        const inputs2 = this.editor.inputs;
        const ctrlKey2 = inputs2.getCtrlKey();
        const currentPagePoint2 = inputs2.getCurrentPagePoint();
        if (!pagePointWhereCurrentSegmentChanged)
          throw Error("We should have a point where the segment changed");
        let pagePoint;
        let shouldSnapToAngle = false;
        if (this.didJustShiftClickToExtendPreviousShapeLine) {
          if (this.editor.inputs.getIsDragging()) {
            shouldSnapToAngle = !ctrlKey2;
            this.didJustShiftClickToExtendPreviousShapeLine = false;
          } else {
          }
        } else {
          shouldSnapToAngle = !ctrlKey2;
        }
        let newPoint2 = this.editor.getPointInShapeSpace(shape, currentPagePoint2).toFixed().toJson();
        let didSnap = false;
        let snapSegment = void 0;
        const shouldSnap = this.editor.user.getIsSnapMode() ? !ctrlKey2 : ctrlKey2;
        if (shouldSnap) {
          if (newSegments.length > 2) {
            let nearestPoint = void 0;
            let minDistance = 8 / this.editor.getZoomLevel();
            for (let i = 0, n = segments.length - 2; i < n; i++) {
              const segment = segments[i];
              if (!segment) break;
              if (segment.type === "free") continue;
              const first2 = b64Vecs.decodeFirstPoint(segment.path);
              const lastPoint = b64Vecs.decodeLastPoint(segment.path);
              if (!(first2 && lastPoint)) continue;
              const nearestPointOnSegment = Vec.NearestPointOnLineSegment(
                first2,
                lastPoint,
                newPoint2
              );
              if (Vec.DistMin(nearestPointOnSegment, newPoint2, minDistance)) {
                nearestPoint = nearestPointOnSegment.toFixed().toJson();
                minDistance = Vec.Dist(nearestPointOnSegment, newPoint2);
                snapSegment = segment;
                break;
              }
            }
            if (nearestPoint) {
              didSnap = true;
              newPoint2 = nearestPoint;
            }
          }
        }
        if (didSnap && snapSegment) {
          const transform = this.editor.getShapePageTransform(shape);
          const first2 = b64Vecs.decodeFirstPoint(snapSegment.path);
          const lastPoint = b64Vecs.decodeLastPoint(snapSegment.path);
          if (!first2 || !lastPoint) throw Error("Expected a last point!");
          const A = Mat.applyToPoint(transform, first2);
          const B = Mat.applyToPoint(transform, lastPoint);
          const snappedPoint = Mat.applyToPoint(transform, newPoint2);
          this.editor.snaps.setIndicators([
            {
              id: uniqueId(),
              type: "points",
              points: [A, snappedPoint, B]
            }
          ]);
        } else {
          this.editor.snaps.clearIndicators();
          if (shouldSnapToAngle) {
            const currentAngle = Vec.Angle(pagePointWhereCurrentSegmentChanged, currentPagePoint2);
            const snappedAngle = snapAngle(currentAngle, 24);
            const angleDiff = snappedAngle - currentAngle;
            pagePoint = Vec.RotWith(
              currentPagePoint2,
              pagePointWhereCurrentSegmentChanged,
              angleDiff
            );
          } else {
            pagePoint = currentPagePoint2.clone();
          }
          newPoint2 = this.editor.getPointInShapeSpace(shape, pagePoint).toFixed().toJson();
        }
        this.currentLineLength += newSegments.length && b64Vecs.decodeFirstPoint(newSegment.path) ? Vec.Dist(b64Vecs.decodeFirstPoint(newSegment.path), Vec.From(newPoint2)) : 0;
        newSegments[newSegments.length - 1] = {
          ...newSegment,
          type: "straight",
          path: b64Vecs.encodePoints([
            b64Vecs.decodeFirstPoint(newSegment.path),
            Vec.From(newPoint2)
          ])
        };
        const shapePartial = {
          id,
          type: this.shapeType,
          props: {
            segments: newSegments
          }
        };
        if (this.canClose()) {
          ;
          shapePartial.props.isClosed = this.getIsClosed(
            segments,
            size4,
            scale
          );
        }
        this.editor.updateShapes([shapePartial]);
        break;
      }
      case "free": {
        const cachedPoints = this.currentSegmentPoints;
        if (cachedPoints.length && this.mergeNextPoint) {
          const lastPoint = cachedPoints[cachedPoints.length - 1];
          lastPoint.x = newPoint.x;
          lastPoint.y = newPoint.y;
          lastPoint.z = lastPoint.z ? Math.max(lastPoint.z, newPoint.z) : newPoint.z;
        } else {
          this.currentLineLength += cachedPoints.length ? Vec.Dist(cachedPoints[cachedPoints.length - 1], newPoint) : 0;
          cachedPoints.push(new Vec(newPoint.x, newPoint.y, newPoint.z));
        }
        const newSegments = segments.slice();
        const newSegment = newSegments[newSegments.length - 1];
        newSegments[newSegments.length - 1] = {
          ...newSegment,
          path: b64Vecs.encodePoints(cachedPoints)
        };
        if (this.currentLineLength < STROKE_SIZES2[shape.props.size] * 4) {
          this.currentLineLength = this.getLineLength(newSegments);
        }
        const shapePartial = {
          id,
          type: this.shapeType,
          props: {
            segments: newSegments
          }
        };
        if (this.canClose()) {
          ;
          shapePartial.props.isClosed = this.getIsClosed(
            newSegments,
            size4,
            scale
          );
        }
        this.editor.updateShapes([shapePartial]);
        if (cachedPoints.length > this.util.options.maxPointsPerShape) {
          this.editor.updateShapes([{ id, type: this.shapeType, props: { isComplete: true } }]);
          const newShapeId = createShapeId();
          const props = this.editor.getShape(id).props;
          if (!this.editor.canCreateShapes([newShapeId])) return this.cancel();
          const currentPagePoint2 = inputs.getCurrentPagePoint();
          const initialPoint = new Vec(0, 0, this.isPenOrStylus ? +(z * 1.25).toFixed() : 0.5);
          this.currentSegmentPoints = [initialPoint];
          this.editor.createShape({
            id: newShapeId,
            type: this.shapeType,
            x: toFixed(currentPagePoint2.x),
            y: toFixed(currentPagePoint2.y),
            props: {
              isPen: this.isPenOrStylus,
              scale: props.scale,
              segments: [
                {
                  type: "free",
                  path: b64Vecs.encodePoints([initialPoint])
                }
              ]
            }
          });
          const shape2 = this.editor.getShape(newShapeId);
          if (!shape2) {
            return this.cancel();
          }
          this.initialShape = structuredClone(shape2);
          this.mergeNextPoint = false;
          this.lastRecordedPoint = currentPagePoint2.clone();
          this.currentLineLength = 0;
        }
        break;
      }
    }
  }
  getLineLength(segments) {
    let length = 0;
    for (let j = 0; j < segments.length; j++) {
      const points = b64Vecs.decodePoints(segments[j].path);
      for (let i = 0; i < points.length - 1; i++) {
        length += Vec.Dist2(points[i], points[i + 1]);
      }
    }
    return Math.sqrt(length);
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    if (this.editor.inputs.getIsDragging()) {
      return;
    }
    if (this.markId) {
      this.editor.bailToMark(this.markId);
    }
    this.cancel();
  }
  complete() {
    const { initialShape } = this;
    if (!initialShape) return;
    this.editor.updateShapes([
      { id: initialShape.id, type: initialShape.type, props: { isComplete: true } }
    ]);
    this.parent.transition("idle");
  }
  cancel() {
    this.parent.transition("idle", this.info);
  }
};
__publicField(Drawing, "id", "drawing");

// ../node_modules/tldraw/dist-esm/lib/shapes/draw/toolStates/Idle.mjs
var Idle3 = class extends StateNode {
  onPointerDown(info) {
    this.parent.transition("drawing", info);
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
};
__publicField(Idle3, "id", "idle");

// ../node_modules/tldraw/dist-esm/lib/shapes/draw/DrawShapeTool.mjs
var DrawShapeTool = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "shapeType", "draw");
  }
  static children() {
    return [Idle3, Drawing];
  }
  onExit() {
    const drawingState = this.children["drawing"];
    drawingState.initialShape = void 0;
  }
};
__publicField(DrawShapeTool, "id", "draw");
__publicField(DrawShapeTool, "initial", "idle");
__publicField(DrawShapeTool, "isLockable", false);
__publicField(DrawShapeTool, "useCoalescedEvents", true);

// ../node_modules/tldraw/dist-esm/lib/shapes/frame/FrameShapeTool.mjs
var FrameShapeTool = class extends BaseBoxShapeTool {
  constructor() {
    super(...arguments);
    __publicField(this, "shapeType", "frame");
  }
  onCreate(shape) {
    if (!shape) return;
    const bounds = this.editor.getShapePageBounds(shape);
    const shapesToAddToFrame = [];
    const ancestorIds = this.editor.getShapeAncestors(shape).map((shape2) => shape2.id);
    this.editor.getSortedChildIdsForParent(shape.parentId).map((siblingShapeId) => {
      const siblingShape = this.editor.getShape(siblingShapeId);
      if (!siblingShape) return;
      if (siblingShape.id === shape.id) return;
      if (siblingShape.isLocked) return;
      const pageShapeBounds = this.editor.getShapePageBounds(siblingShape);
      if (!pageShapeBounds) return;
      if (bounds.contains(pageShapeBounds)) {
        if (canEnclose(siblingShape, ancestorIds, shape)) {
          shapesToAddToFrame.push(siblingShape.id);
        }
      }
    });
    this.editor.reparentShapes(shapesToAddToFrame, shape.id);
    if (this.editor.getInstanceState().isToolLocked) {
      this.editor.setCurrentTool("frame");
    } else {
      this.editor.setCurrentTool("select.idle");
    }
  }
};
__publicField(FrameShapeTool, "id", "frame");
__publicField(FrameShapeTool, "initial", "idle");
function canEnclose(shape, ancestorIds, frame) {
  if (ancestorIds.includes(shape.id)) {
    return false;
  }
  if (shape.parentId === frame.parentId) {
    return true;
  }
  return false;
}

// ../node_modules/tldraw/dist-esm/lib/shapes/geo/toolStates/Idle.mjs
var Idle4 = class extends StateNode {
  onPointerDown(info) {
    this.parent.transition("pointing", info);
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
  onKeyUp(info) {
    const { editor } = this;
    if (info.key === "Enter") {
      const onlySelectedShape = editor.getOnlySelectedShape();
      if (editor.canEditShape(onlySelectedShape)) {
        startEditingShapeWithRichText(editor, onlySelectedShape, { selectAll: true });
      }
    }
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
};
__publicField(Idle4, "id", "idle");

// ../node_modules/tldraw/dist-esm/lib/shapes/geo/toolStates/Pointing.mjs
var Pointing3 = class extends StateNode {
  onPointerUp() {
    this.complete();
  }
  onPointerMove(info) {
    if (this.editor.inputs.getIsDragging()) {
      const originPagePoint = this.editor.inputs.getOriginPagePoint();
      const id = createShapeId();
      const creatingMarkId = this.editor.markHistoryStoppingPoint(`creating_geo:${id}`);
      const newPoint = maybeSnapToGrid(originPagePoint, this.editor);
      this.editor.createShapes([
        {
          id,
          type: "geo",
          x: newPoint.x,
          y: newPoint.y,
          props: {
            w: 1,
            h: 1,
            geo: this.editor.getStyleForNextShape(GeoShapeGeoStyle),
            scale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1
          }
        }
      ]).select(id);
      const shape = this.editor.getShape(id);
      if (!shape) {
        this.cancel();
        return;
      }
      this.editor.setCurrentTool("select.resizing", {
        ...info,
        target: "selection",
        handle: "bottom_right",
        isCreating: true,
        creatingMarkId,
        creationCursorOffset: { x: 1, y: 1 },
        onInteractionEnd: "geo"
      });
    }
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    this.cancel();
  }
  complete() {
    const originPagePoint = this.editor.inputs.getOriginPagePoint();
    const id = createShapeId();
    this.editor.markHistoryStoppingPoint(`creating_geo:${id}`);
    const scale = this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1;
    const geo = this.editor.getStyleForNextShape(GeoShapeGeoStyle);
    const size4 = geo === "star" ? { w: 200, h: 190 } : geo === "cloud" ? { w: 300, h: 180 } : { w: 200, h: 200 };
    this.editor.createShapes([
      {
        id,
        type: "geo",
        x: originPagePoint.x,
        y: originPagePoint.y,
        props: {
          geo: this.editor.getStyleForNextShape(GeoShapeGeoStyle),
          scale,
          ...size4
        }
      }
    ]);
    const shape = this.editor.getShape(id);
    if (!shape) {
      this.cancel();
      return;
    }
    const { w, h: h2 } = shape.props;
    const delta = new Vec(w / 2, h2 / 2).mul(scale);
    const parentTransform = this.editor.getShapeParentTransform(shape);
    if (parentTransform) delta.rot(-parentTransform.rotation());
    const newPoint = maybeSnapToGrid(new Vec(shape.x - delta.x, shape.y - delta.y), this.editor);
    this.editor.select(id);
    this.editor.updateShape({
      id: shape.id,
      type: "geo",
      x: newPoint.x,
      y: newPoint.y,
      props: {
        geo: this.editor.getStyleForNextShape(GeoShapeGeoStyle),
        w: w * scale,
        h: h2 * scale
      }
    });
    if (this.editor.getInstanceState().isToolLocked) {
      this.parent.transition("idle");
    } else {
      this.editor.setCurrentTool("select", {});
    }
  }
  cancel() {
    this.parent.transition("idle");
  }
};
__publicField(Pointing3, "id", "pointing");

// ../node_modules/tldraw/dist-esm/lib/shapes/geo/GeoShapeTool.mjs
var GeoShapeTool = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "shapeType", "geo");
  }
  static children() {
    return [Idle4, Pointing3];
  }
};
__publicField(GeoShapeTool, "id", "geo");
__publicField(GeoShapeTool, "initial", "idle");

// ../node_modules/tldraw/dist-esm/lib/shapes/highlight/HighlightShapeTool.mjs
var HighlightShapeTool = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "shapeType", "highlight");
  }
  static children() {
    return [Idle3, Drawing];
  }
  onExit() {
    const drawingState = this.children["drawing"];
    drawingState.initialShape = void 0;
  }
};
__publicField(HighlightShapeTool, "id", "highlight");
__publicField(HighlightShapeTool, "initial", "idle");
__publicField(HighlightShapeTool, "useCoalescedEvents", true);
__publicField(HighlightShapeTool, "isLockable", false);

// ../node_modules/tldraw/dist-esm/lib/shapes/line/toolStates/Idle.mjs
var Idle5 = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "shapeId", "");
  }
  onEnter(info) {
    this.shapeId = info.shapeId;
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
  onPointerDown() {
    this.parent.transition("pointing", { shapeId: this.shapeId });
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
};
__publicField(Idle5, "id", "idle");

// ../node_modules/tldraw/dist-esm/lib/shapes/line/toolStates/Pointing.mjs
var MINIMUM_DISTANCE_BETWEEN_SHIFT_CLICKED_HANDLES = 2;
var Pointing4 = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "shape", {});
    __publicField(this, "markId");
  }
  onEnter(info) {
    const { inputs } = this.editor;
    const currentPagePoint = inputs.getCurrentPagePoint();
    this.markId = void 0;
    const shape = info.shapeId && this.editor.getShape(info.shapeId);
    if (shape && inputs.getShiftKey()) {
      this.markId = this.editor.markHistoryStoppingPoint(`creating_line:${shape.id}`);
      this.shape = shape;
      const handles = this.editor.getShapeHandles(this.shape);
      if (!handles) return;
      const vertexHandles = handles.filter((h2) => h2.type === "vertex").sort(sortByIndex);
      const endHandle = vertexHandles[vertexHandles.length - 1];
      const prevEndHandle = vertexHandles[vertexHandles.length - 2];
      const shapePagePoint = Mat.applyToPoint(
        this.editor.getShapeParentTransform(this.shape),
        new Vec(this.shape.x, this.shape.y)
      );
      const nudgedPoint = Vec.Sub(currentPagePoint, shapePagePoint).addXY(0.1, 0.1);
      const nextPoint = maybeSnapToGrid(nudgedPoint, this.editor);
      const points = structuredClone(this.shape.props.points);
      if (Vec.DistMin(endHandle, prevEndHandle, MINIMUM_DISTANCE_BETWEEN_SHIFT_CLICKED_HANDLES) || Vec.DistMin(nextPoint, endHandle, MINIMUM_DISTANCE_BETWEEN_SHIFT_CLICKED_HANDLES)) {
        points[endHandle.id] = {
          id: endHandle.id,
          index: endHandle.index,
          x: nextPoint.x,
          y: nextPoint.y
        };
      } else {
        const nextIndex = getIndexAbove(endHandle.index);
        points[nextIndex] = {
          id: nextIndex,
          index: nextIndex,
          x: nextPoint.x,
          y: nextPoint.y
        };
      }
      this.editor.updateShapes([
        {
          id: this.shape.id,
          type: this.shape.type,
          props: {
            points
          }
        }
      ]);
    } else {
      const id = createShapeId();
      this.markId = this.editor.markHistoryStoppingPoint(`creating_line:${id}`);
      const newPoint = maybeSnapToGrid(currentPagePoint, this.editor);
      this.editor.createShapes([
        {
          id,
          type: "line",
          x: newPoint.x,
          y: newPoint.y,
          props: {
            scale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1
          }
        }
      ]);
      if (!this.editor.getShape(id)) {
        this.cancel();
        return;
      }
      this.editor.select(id);
      this.shape = this.editor.getShape(id);
    }
  }
  onPointerMove() {
    if (!this.shape) return;
    if (this.editor.inputs.getIsDragging()) {
      const handles = this.editor.getShapeHandles(this.shape);
      if (!handles) {
        if (this.markId) this.editor.bailToMark(this.markId);
        throw Error("No handles found");
      }
      const lastHandle = last(handles);
      this.editor.setCurrentTool("select.dragging_handle", {
        shape: this.shape,
        isCreating: true,
        creatingMarkId: this.markId,
        // remove the offset that we added to the handle when we created it
        handle: { ...lastHandle, x: lastHandle.x - 0.1, y: lastHandle.y - 0.1 },
        onInteractionEnd: "line"
      });
    }
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    this.parent.transition("idle");
    if (this.markId) this.editor.bailToMark(this.markId);
    this.editor.snaps.clearIndicators();
  }
  complete() {
    this.parent.transition("idle", { shapeId: this.shape.id });
    this.editor.snaps.clearIndicators();
  }
  cancel() {
    if (this.markId) this.editor.bailToMark(this.markId);
    this.parent.transition("idle", { shapeId: this.shape.id });
    this.editor.snaps.clearIndicators();
  }
};
__publicField(Pointing4, "id", "pointing");

// ../node_modules/tldraw/dist-esm/lib/shapes/line/LineShapeTool.mjs
var LineShapeTool = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "shapeType", "line");
  }
  static children() {
    return [Idle5, Pointing4];
  }
};
__publicField(LineShapeTool, "id", "line");
__publicField(LineShapeTool, "initial", "idle");

// ../node_modules/tldraw/dist-esm/lib/shapes/note/toolStates/Idle.mjs
var Idle6 = class extends StateNode {
  onPointerDown(info) {
    this.parent.transition("pointing", info);
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
};
__publicField(Idle6, "id", "idle");

// ../node_modules/tldraw/dist-esm/lib/shapes/note/noteHelpers.mjs
var CLONE_HANDLE_MARGIN = 0;
var NOTE_SIZE = 200;
var NOTE_CENTER_OFFSET = new Vec(NOTE_SIZE / 2, NOTE_SIZE / 2);
var NOTE_ADJACENT_POSITION_SNAP_RADIUS = 10;
var BASE_NOTE_POSITIONS = (editor) => [
  [
    ["a1"],
    new Vec(NOTE_SIZE * 0.5, NOTE_SIZE * -0.5 - editor.options.adjacentShapeMargin)
  ],
  // t
  [
    ["a2"],
    new Vec(NOTE_SIZE * 1.5 + editor.options.adjacentShapeMargin, NOTE_SIZE * 0.5)
  ],
  // r
  [
    ["a3"],
    new Vec(NOTE_SIZE * 0.5, NOTE_SIZE * 1.5 + editor.options.adjacentShapeMargin)
  ],
  // b
  [
    ["a4"],
    new Vec(NOTE_SIZE * -0.5 - editor.options.adjacentShapeMargin, NOTE_SIZE * 0.5)
  ]
  // l
];
function getBaseAdjacentNotePositions(editor, scale) {
  if (scale === 1) return BASE_NOTE_POSITIONS(editor);
  const s = NOTE_SIZE * scale;
  const m = editor.options.adjacentShapeMargin * scale;
  return [
    [["a1"], new Vec(s * 0.5, s * -0.5 - m)],
    // t
    [["a2"], new Vec(s * 1.5 + m, s * 0.5)],
    // r
    [["a3"], new Vec(s * 0.5, s * 1.5 + m)],
    // b
    [["a4"], new Vec(s * -0.5 - m, s * 0.5)]
    // l
  ];
}
function getNoteAdjacentPositions(editor, pagePoint, pageRotation, growY, extraHeight, scale) {
  return Object.fromEntries(
    getBaseAdjacentNotePositions(editor, scale).map(([id, v], i) => {
      const point = v.clone();
      if (i === 0 && extraHeight) {
        point.y -= extraHeight;
      } else if (i === 2 && growY) {
        point.y += growY;
      }
      return [id, point.rot(pageRotation).add(pagePoint)];
    })
  );
}
function getAvailableNoteAdjacentPositions(editor, rotation, scale, extraHeight) {
  const selectedShapeIds = new Set(editor.getSelectedShapeIds());
  const minSize = (NOTE_SIZE + editor.options.adjacentShapeMargin + extraHeight) ** 2;
  const allCenters = /* @__PURE__ */ new Map();
  const positions = [];
  for (const shape of editor.getCurrentPageShapes()) {
    if (!editor.isShapeOfType(shape, "note") || scale !== shape.props.scale || selectedShapeIds.has(shape.id)) {
      continue;
    }
    const transform = editor.getShapePageTransform(shape.id);
    if (rotation !== transform.rotation()) continue;
    allCenters.set(shape, editor.getShapePageBounds(shape).center);
    positions.push(
      ...Object.values(
        getNoteAdjacentPositions(
          editor,
          transform.point(),
          rotation,
          shape.props.growY,
          extraHeight,
          scale
        )
      )
    );
  }
  const len = positions.length;
  let position;
  for (const [shape, center] of allCenters) {
    for (let i = 0; i < len; i++) {
      position = positions[i];
      if (!position) continue;
      if (Vec.Dist2(center, position) > minSize) continue;
      if (editor.isPointInShape(shape, position)) {
        positions[i] = void 0;
      }
    }
  }
  return compact(positions);
}
function getNoteShapeForAdjacentPosition(editor, shape, center, pageRotation, forceNew = false) {
  let nextNote;
  const allShapesOnPage = editor.getCurrentPageShapesSorted();
  const minDistance = (NOTE_SIZE + editor.options.adjacentShapeMargin ** 2) ** shape.props.scale;
  for (let i = allShapesOnPage.length - 1; i >= 0; i--) {
    const otherNote = allShapesOnPage[i];
    if (otherNote.type === "note" && otherNote.id !== shape.id) {
      const otherBounds = editor.getShapePageBounds(otherNote);
      if (otherBounds && Vec.Dist2(otherBounds.center, center) < minDistance && editor.isPointInShape(otherNote, center)) {
        nextNote = otherNote;
        break;
      }
    }
  }
  editor.complete();
  if (!nextNote || forceNew) {
    editor.markHistoryStoppingPoint("creating note shape");
    const id = createShapeId();
    editor.createShape({
      id,
      type: "note",
      x: center.x,
      y: center.y,
      rotation: pageRotation,
      opacity: shape.opacity,
      props: {
        // Use the props of the shape we're cloning
        ...shape.props,
        richText: toRichText(""),
        growY: 0,
        fontSizeAdjustment: 0,
        url: ""
      }
    });
    const createdShape = editor.getShape(id);
    if (!createdShape) return;
    const topLeft = editor.getPointInParentSpace(
      createdShape,
      Vec.Sub(
        center,
        Vec.Rot(NOTE_CENTER_OFFSET.clone().mul(createdShape.props.scale), pageRotation)
      )
    );
    editor.updateShape({
      id,
      type: "note",
      x: topLeft.x,
      y: topLeft.y
    });
    nextNote = editor.getShape(id);
  }
  editor.zoomToSelectionIfOffscreen(16, {
    animation: {
      duration: editor.options.animationMediumMs
    },
    inset: 0
  });
  return nextNote;
}

// ../node_modules/tldraw/dist-esm/lib/shapes/note/toolStates/Pointing.mjs
var Pointing5 = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "dragged", false);
    __publicField(this, "info", {});
    __publicField(this, "markId", "");
    __publicField(this, "shape", {});
  }
  onEnter() {
    const { editor } = this;
    const id = createShapeId();
    this.markId = editor.markHistoryStoppingPoint(`creating_note:${id}`);
    const center = this.editor.inputs.getOriginPagePoint().clone();
    const offset4 = getNoteShapeAdjacentPositionOffset(
      this.editor,
      center,
      this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1
    );
    if (offset4) {
      center.sub(offset4);
    }
    const shape = createNoteShape(this.editor, id, center);
    if (shape) {
      this.shape = shape;
    } else {
      this.cancel();
    }
  }
  onPointerMove(info) {
    if (this.editor.inputs.getIsDragging()) {
      this.editor.setCurrentTool("select.translating", {
        ...info,
        target: "shape",
        shape: this.shape,
        onInteractionEnd: "note",
        isCreating: true,
        creatingMarkId: this.markId,
        onCreate: () => {
          startEditingShapeWithRichText(this.editor, this.shape.id);
        }
      });
    }
  }
  onPointerUp() {
    this.complete();
  }
  onInterrupt() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  complete() {
    if (this.editor.getInstanceState().isToolLocked) {
      this.parent.transition("idle");
    } else {
      startEditingShapeWithRichText(this.editor, this.shape.id, { info: this.info });
    }
  }
  cancel() {
    this.editor.bailToMark(this.markId);
    this.parent.transition("idle", this.info);
  }
};
__publicField(Pointing5, "id", "pointing");
function getNoteShapeAdjacentPositionOffset(editor, center, scale) {
  let min3 = NOTE_ADJACENT_POSITION_SNAP_RADIUS / editor.getZoomLevel();
  let offset4;
  for (const pit of getAvailableNoteAdjacentPositions(editor, 0, scale, 0)) {
    const deltaToPit = Vec.Sub(center, pit);
    const dist = deltaToPit.len();
    if (dist < min3) {
      min3 = dist;
      offset4 = deltaToPit;
    }
  }
  return offset4;
}
function createNoteShape(editor, id, center) {
  editor.createShape({
    id,
    type: "note",
    x: center.x,
    y: center.y,
    props: {
      scale: editor.user.getIsDynamicResizeMode() ? 1 / editor.getZoomLevel() : 1
    }
  });
  const shape = editor.getShape(id);
  if (!shape) return;
  editor.select(id);
  const bounds = editor.getShapeGeometry(shape).bounds;
  const newPoint = maybeSnapToGrid(
    new Vec(shape.x - bounds.width / 2, shape.y - bounds.height / 2),
    editor
  );
  editor.updateShapes([
    {
      id,
      type: "note",
      x: newPoint.x,
      y: newPoint.y
    }
  ]);
  return editor.getShape(id);
}

// ../node_modules/tldraw/dist-esm/lib/shapes/note/NoteShapeTool.mjs
var NoteShapeTool = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "shapeType", "note");
  }
  static children() {
    return [Idle6, Pointing5];
  }
};
__publicField(NoteShapeTool, "id", "note");
__publicField(NoteShapeTool, "initial", "idle");

// ../node_modules/tldraw/dist-esm/lib/tools/selection-logic/updateHoveredShapeId.mjs
function _updateHoveredShapeId(editor) {
  const hitShape = editor.getShapeAtPoint(editor.inputs.getCurrentPagePoint(), {
    hitInside: false,
    hitLabels: false,
    margin: editor.options.hitTestMargin / editor.getZoomLevel(),
    renderingOnly: true
  });
  if (!hitShape) return editor.setHoveredShape(null);
  let shapeToHover = void 0;
  const outermostShape = editor.getOutermostSelectableShape(hitShape);
  if (outermostShape === hitShape) {
    shapeToHover = hitShape;
  } else {
    if (outermostShape.id === editor.getFocusedGroupId() || editor.getSelectedShapeIds().includes(outermostShape.id)) {
      shapeToHover = hitShape;
    } else {
      shapeToHover = outermostShape;
    }
  }
  return editor.setHoveredShape(shapeToHover.id);
}
var updateHoveredShapeId = (0, import_lodash3.default)(
  _updateHoveredShapeId,
  false ? 0 : 32
);

// ../node_modules/tldraw/dist-esm/lib/shapes/text/toolStates/Idle.mjs
var Idle7 = class extends StateNode {
  onPointerMove(info) {
    switch (info.target) {
      case "shape":
      case "canvas": {
        updateHoveredShapeId(this.editor);
      }
    }
  }
  onPointerDown(info) {
    this.parent.transition("pointing", info);
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
  onExit() {
    updateHoveredShapeId.cancel();
  }
  onKeyDown(info) {
    if (info.key === "Enter") {
      const onlySelectedShape = this.editor.getOnlySelectedShape();
      if (!this.editor.canEditShape(onlySelectedShape)) return;
      this.editor.setCurrentTool("select");
      startEditingShapeWithRichText(this.editor, onlySelectedShape.id, { info });
    }
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
};
__publicField(Idle7, "id", "idle");

// ../node_modules/tldraw/dist-esm/lib/shapes/text/toolStates/Pointing.mjs
var Pointing6 = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "shape");
    __publicField(this, "markId", "");
    __publicField(this, "enterTime", 0);
  }
  onEnter() {
    this.enterTime = Date.now();
  }
  onExit() {
    this.editor.setHintingShapes([]);
  }
  onPointerMove(info) {
    if (Date.now() - this.enterTime < 150) return;
    const { editor } = this;
    const isPointing = editor.inputs.getIsPointing();
    if (!isPointing) return;
    const originPagePoint = editor.inputs.getOriginPagePoint();
    const currentPagePoint = editor.inputs.getCurrentPagePoint();
    const currentDragDist = Math.abs(originPagePoint.x - currentPagePoint.x);
    const baseMinDragDistForFixedWidth = Math.sqrt(
      editor.getInstanceState().isCoarsePointer ? editor.options.coarseDragDistanceSquared : editor.options.dragDistanceSquared
    );
    const minSquaredDragDist = baseMinDragDistForFixedWidth * 6 / editor.getZoomLevel();
    if (currentDragDist > minSquaredDragDist) {
      const id = createShapeId();
      this.markId = editor.markHistoryStoppingPoint(`creating_text:${id}`);
      const shape = this.createTextShape(id, originPagePoint, false, currentDragDist);
      if (!shape) {
        this.cancel();
        return;
      }
      this.shape = editor.getShape(shape);
      editor.select(id);
      const scale = this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1;
      editor.setCurrentTool("select.resizing", {
        ...info,
        target: "selection",
        handle: "right",
        isCreating: true,
        creatingMarkId: this.markId,
        // Make sure the cursor offset takes into account how far we've already dragged
        creationCursorOffset: { x: currentDragDist * scale, y: 1 },
        onInteractionEnd: "text",
        onCreate: () => {
          startEditingShapeWithRichText(editor, shape.id);
        }
      });
    }
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.cancel();
  }
  onCancel() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  complete() {
    this.editor.markHistoryStoppingPoint("creating text shape");
    const id = createShapeId();
    const originPagePoint = this.editor.inputs.getOriginPagePoint();
    const shape = this.createTextShape(id, originPagePoint, true, 20);
    if (!shape) return;
    this.editor.select(id);
    startEditingShapeWithRichText(this.editor, id);
  }
  cancel() {
    this.parent.transition("idle");
    this.editor.bailToMark(this.markId);
  }
  createTextShape(id, point, autoSize, width) {
    this.editor.createShape({
      id,
      type: "text",
      x: point.x,
      y: point.y,
      props: {
        richText: toRichText(""),
        autoSize,
        w: width,
        scale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1
      }
    });
    const shape = this.editor.getShape(id);
    if (!shape) {
      this.cancel();
      return;
    }
    const bounds = this.editor.getShapePageBounds(shape);
    const delta = new Vec();
    if (autoSize) {
      switch (shape.props.textAlign) {
        case "start": {
          delta.x = 0;
          break;
        }
        case "middle": {
          delta.x = -bounds.width / 2;
          break;
        }
        case "end": {
          delta.x = -bounds.width;
          break;
        }
      }
    } else {
      delta.x = 0;
    }
    delta.y = -bounds.height / 2;
    if (isShapeId(shape.parentId)) {
      const transform = this.editor.getShapeParentTransform(shape);
      delta.rot(-transform.rotation());
    }
    const shapeX = shape.x + delta.x;
    const shapeY = shape.y + delta.y;
    if (this.editor.getInstanceState().isGridMode) {
      const topLeft = new Vec(shapeX, shapeY);
      const gridSnappedPoint = maybeSnapToGrid(topLeft, this.editor);
      const gridDelta = Vec.Sub(topLeft, gridSnappedPoint);
      this.editor.updateShape({
        ...shape,
        x: shapeX - gridDelta.x,
        y: shapeY - gridDelta.y
      });
    } else {
      this.editor.updateShape({
        ...shape,
        x: shapeX,
        y: shapeY
      });
    }
    return shape;
  }
};
__publicField(Pointing6, "id", "pointing");

// ../node_modules/tldraw/dist-esm/lib/shapes/text/TextShapeTool.mjs
var TextShapeTool = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "shapeType", "text");
  }
  static children() {
    return [Idle7, Pointing6];
  }
};
__publicField(TextShapeTool, "id", "text");
__publicField(TextShapeTool, "initial", "idle");

// ../node_modules/tldraw/dist-esm/lib/defaultShapeTools.mjs
var defaultShapeTools = [
  TextShapeTool,
  DrawShapeTool,
  GeoShapeTool,
  NoteShapeTool,
  LineShapeTool,
  FrameShapeTool,
  ArrowShapeTool,
  HighlightShapeTool
];

// ../node_modules/tldraw/dist-esm/lib/shapes/arrow/ArrowShapeUtil.mjs
var import_jsx_runtime208 = __toESM(require_jsx_runtime(), 1);
var import_react141 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/shapes/shared/RichTextLabel.mjs
var import_jsx_runtime204 = __toESM(require_jsx_runtime(), 1);
var import_classnames33 = __toESM(require_classnames(), 1);
var import_react138 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/shapes/text/RichTextArea.mjs
var import_jsx_runtime203 = __toESM(require_jsx_runtime(), 1);

// ../node_modules/@tiptap/react/dist/index.js
var import_react124 = __toESM(require_react());
var import_react125 = __toESM(require_react());
var import_react_dom9 = __toESM(require_react_dom());
var import_shim2 = __toESM(require_shim());
var import_jsx_runtime195 = __toESM(require_jsx_runtime());
var import_react126 = __toESM(require_react());
var import_shim3 = __toESM(require_shim());

// ../node_modules/fast-equals/dist/es/index.mjs
var { getOwnPropertyNames, getOwnPropertySymbols } = Object;
var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
function combineComparators(comparatorA, comparatorB) {
  return function isEqual(a, b, state) {
    return comparatorA(a, b, state) && comparatorB(a, b, state);
  };
}
function createIsCircular(areItemsEqual) {
  return function isCircular(a, b, state) {
    if (!a || !b || typeof a !== "object" || typeof b !== "object") {
      return areItemsEqual(a, b, state);
    }
    const { cache } = state;
    const cachedA = cache.get(a);
    const cachedB = cache.get(b);
    if (cachedA && cachedB) {
      return cachedA === b && cachedB === a;
    }
    cache.set(a, b);
    cache.set(b, a);
    const result = areItemsEqual(a, b, state);
    cache.delete(a);
    cache.delete(b);
    return result;
  };
}
function getShortTag(value) {
  return value != null ? value[Symbol.toStringTag] : void 0;
}
function getStrictProperties(object) {
  return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));
}
var hasOwn = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  Object.hasOwn || ((object, property) => hasOwnProperty2.call(object, property))
);
function sameValueZeroEqual(a, b) {
  return a === b || !a && !b && a !== a && b !== b;
}
var PREACT_VNODE = "__v";
var PREACT_OWNER = "__o";
var REACT_OWNER = "_owner";
var { getOwnPropertyDescriptor, keys: keys2 } = Object;
function areArrayBuffersEqual(a, b) {
  return a.byteLength === b.byteLength && areTypedArraysEqual(new Uint8Array(a), new Uint8Array(b));
}
function areArraysEqual(a, b, state) {
  let index2 = a.length;
  if (b.length !== index2) {
    return false;
  }
  while (index2-- > 0) {
    if (!state.equals(a[index2], b[index2], index2, index2, a, b, state)) {
      return false;
    }
  }
  return true;
}
function areDataViewsEqual(a, b) {
  return a.byteLength === b.byteLength && areTypedArraysEqual(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength));
}
function areDatesEqual(a, b) {
  return sameValueZeroEqual(a.getTime(), b.getTime());
}
function areErrorsEqual(a, b) {
  return a.name === b.name && a.message === b.message && a.cause === b.cause && a.stack === b.stack;
}
function areFunctionsEqual(a, b) {
  return a === b;
}
function areMapsEqual(a, b, state) {
  const size4 = a.size;
  if (size4 !== b.size) {
    return false;
  }
  if (!size4) {
    return true;
  }
  const matchedIndices = new Array(size4);
  const aIterable = a.entries();
  let aResult;
  let bResult;
  let index2 = 0;
  while (aResult = aIterable.next()) {
    if (aResult.done) {
      break;
    }
    const bIterable = b.entries();
    let hasMatch = false;
    let matchIndex = 0;
    while (bResult = bIterable.next()) {
      if (bResult.done) {
        break;
      }
      if (matchedIndices[matchIndex]) {
        matchIndex++;
        continue;
      }
      const aEntry = aResult.value;
      const bEntry = bResult.value;
      if (state.equals(aEntry[0], bEntry[0], index2, matchIndex, a, b, state) && state.equals(aEntry[1], bEntry[1], aEntry[0], bEntry[0], a, b, state)) {
        hasMatch = matchedIndices[matchIndex] = true;
        break;
      }
      matchIndex++;
    }
    if (!hasMatch) {
      return false;
    }
    index2++;
  }
  return true;
}
var areNumbersEqual = sameValueZeroEqual;
function areObjectsEqual(a, b, state) {
  const properties = keys2(a);
  let index2 = properties.length;
  if (keys2(b).length !== index2) {
    return false;
  }
  while (index2-- > 0) {
    if (!isPropertyEqual(a, b, state, properties[index2])) {
      return false;
    }
  }
  return true;
}
function areObjectsEqualStrict(a, b, state) {
  const properties = getStrictProperties(a);
  let index2 = properties.length;
  if (getStrictProperties(b).length !== index2) {
    return false;
  }
  let property;
  let descriptorA;
  let descriptorB;
  while (index2-- > 0) {
    property = properties[index2];
    if (!isPropertyEqual(a, b, state, property)) {
      return false;
    }
    descriptorA = getOwnPropertyDescriptor(a, property);
    descriptorB = getOwnPropertyDescriptor(b, property);
    if ((descriptorA || descriptorB) && (!descriptorA || !descriptorB || descriptorA.configurable !== descriptorB.configurable || descriptorA.enumerable !== descriptorB.enumerable || descriptorA.writable !== descriptorB.writable)) {
      return false;
    }
  }
  return true;
}
function arePrimitiveWrappersEqual(a, b) {
  return sameValueZeroEqual(a.valueOf(), b.valueOf());
}
function areRegExpsEqual(a, b) {
  return a.source === b.source && a.flags === b.flags;
}
function areSetsEqual(a, b, state) {
  const size4 = a.size;
  if (size4 !== b.size) {
    return false;
  }
  if (!size4) {
    return true;
  }
  const matchedIndices = new Array(size4);
  const aIterable = a.values();
  let aResult;
  let bResult;
  while (aResult = aIterable.next()) {
    if (aResult.done) {
      break;
    }
    const bIterable = b.values();
    let hasMatch = false;
    let matchIndex = 0;
    while (bResult = bIterable.next()) {
      if (bResult.done) {
        break;
      }
      if (!matchedIndices[matchIndex] && state.equals(aResult.value, bResult.value, aResult.value, bResult.value, a, b, state)) {
        hasMatch = matchedIndices[matchIndex] = true;
        break;
      }
      matchIndex++;
    }
    if (!hasMatch) {
      return false;
    }
  }
  return true;
}
function areTypedArraysEqual(a, b) {
  let index2 = a.byteLength;
  if (b.byteLength !== index2 || a.byteOffset !== b.byteOffset) {
    return false;
  }
  while (index2-- > 0) {
    if (a[index2] !== b[index2]) {
      return false;
    }
  }
  return true;
}
function areUrlsEqual(a, b) {
  return a.hostname === b.hostname && a.pathname === b.pathname && a.protocol === b.protocol && a.port === b.port && a.hash === b.hash && a.username === b.username && a.password === b.password;
}
function isPropertyEqual(a, b, state, property) {
  if ((property === REACT_OWNER || property === PREACT_OWNER || property === PREACT_VNODE) && (a.$$typeof || b.$$typeof)) {
    return true;
  }
  return hasOwn(b, property) && state.equals(a[property], b[property], property, property, a, b, state);
}
var ARRAY_BUFFER_TAG = "[object ArrayBuffer]";
var ARGUMENTS_TAG = "[object Arguments]";
var BOOLEAN_TAG = "[object Boolean]";
var DATA_VIEW_TAG = "[object DataView]";
var DATE_TAG = "[object Date]";
var ERROR_TAG = "[object Error]";
var MAP_TAG = "[object Map]";
var NUMBER_TAG = "[object Number]";
var OBJECT_TAG = "[object Object]";
var REG_EXP_TAG = "[object RegExp]";
var SET_TAG = "[object Set]";
var STRING_TAG = "[object String]";
var TYPED_ARRAY_TAGS = {
  "[object Int8Array]": true,
  "[object Uint8Array]": true,
  "[object Uint8ClampedArray]": true,
  "[object Int16Array]": true,
  "[object Uint16Array]": true,
  "[object Int32Array]": true,
  "[object Uint32Array]": true,
  "[object Float16Array]": true,
  "[object Float32Array]": true,
  "[object Float64Array]": true,
  "[object BigInt64Array]": true,
  "[object BigUint64Array]": true
};
var URL_TAG = "[object URL]";
var toString = Object.prototype.toString;
function createEqualityComparator({ areArrayBuffersEqual: areArrayBuffersEqual2, areArraysEqual: areArraysEqual2, areDataViewsEqual: areDataViewsEqual2, areDatesEqual: areDatesEqual2, areErrorsEqual: areErrorsEqual2, areFunctionsEqual: areFunctionsEqual2, areMapsEqual: areMapsEqual2, areNumbersEqual: areNumbersEqual2, areObjectsEqual: areObjectsEqual2, arePrimitiveWrappersEqual: arePrimitiveWrappersEqual2, areRegExpsEqual: areRegExpsEqual2, areSetsEqual: areSetsEqual2, areTypedArraysEqual: areTypedArraysEqual2, areUrlsEqual: areUrlsEqual2, unknownTagComparators }) {
  return function comparator(a, b, state) {
    if (a === b) {
      return true;
    }
    if (a == null || b == null) {
      return false;
    }
    const type = typeof a;
    if (type !== typeof b) {
      return false;
    }
    if (type !== "object") {
      if (type === "number") {
        return areNumbersEqual2(a, b, state);
      }
      if (type === "function") {
        return areFunctionsEqual2(a, b, state);
      }
      return false;
    }
    const constructor = a.constructor;
    if (constructor !== b.constructor) {
      return false;
    }
    if (constructor === Object) {
      return areObjectsEqual2(a, b, state);
    }
    if (Array.isArray(a)) {
      return areArraysEqual2(a, b, state);
    }
    if (constructor === Date) {
      return areDatesEqual2(a, b, state);
    }
    if (constructor === RegExp) {
      return areRegExpsEqual2(a, b, state);
    }
    if (constructor === Map) {
      return areMapsEqual2(a, b, state);
    }
    if (constructor === Set) {
      return areSetsEqual2(a, b, state);
    }
    const tag = toString.call(a);
    if (tag === DATE_TAG) {
      return areDatesEqual2(a, b, state);
    }
    if (tag === REG_EXP_TAG) {
      return areRegExpsEqual2(a, b, state);
    }
    if (tag === MAP_TAG) {
      return areMapsEqual2(a, b, state);
    }
    if (tag === SET_TAG) {
      return areSetsEqual2(a, b, state);
    }
    if (tag === OBJECT_TAG) {
      return typeof a.then !== "function" && typeof b.then !== "function" && areObjectsEqual2(a, b, state);
    }
    if (tag === URL_TAG) {
      return areUrlsEqual2(a, b, state);
    }
    if (tag === ERROR_TAG) {
      return areErrorsEqual2(a, b, state);
    }
    if (tag === ARGUMENTS_TAG) {
      return areObjectsEqual2(a, b, state);
    }
    if (TYPED_ARRAY_TAGS[tag]) {
      return areTypedArraysEqual2(a, b, state);
    }
    if (tag === ARRAY_BUFFER_TAG) {
      return areArrayBuffersEqual2(a, b, state);
    }
    if (tag === DATA_VIEW_TAG) {
      return areDataViewsEqual2(a, b, state);
    }
    if (tag === BOOLEAN_TAG || tag === NUMBER_TAG || tag === STRING_TAG) {
      return arePrimitiveWrappersEqual2(a, b, state);
    }
    if (unknownTagComparators) {
      let unknownTagComparator = unknownTagComparators[tag];
      if (!unknownTagComparator) {
        const shortTag = getShortTag(a);
        if (shortTag) {
          unknownTagComparator = unknownTagComparators[shortTag];
        }
      }
      if (unknownTagComparator) {
        return unknownTagComparator(a, b, state);
      }
    }
    return false;
  };
}
function createEqualityComparatorConfig({ circular, createCustomConfig, strict }) {
  let config = {
    areArrayBuffersEqual,
    areArraysEqual: strict ? areObjectsEqualStrict : areArraysEqual,
    areDataViewsEqual,
    areDatesEqual,
    areErrorsEqual,
    areFunctionsEqual,
    areMapsEqual: strict ? combineComparators(areMapsEqual, areObjectsEqualStrict) : areMapsEqual,
    areNumbersEqual,
    areObjectsEqual: strict ? areObjectsEqualStrict : areObjectsEqual,
    arePrimitiveWrappersEqual,
    areRegExpsEqual,
    areSetsEqual: strict ? combineComparators(areSetsEqual, areObjectsEqualStrict) : areSetsEqual,
    areTypedArraysEqual: strict ? combineComparators(areTypedArraysEqual, areObjectsEqualStrict) : areTypedArraysEqual,
    areUrlsEqual,
    unknownTagComparators: void 0
  };
  if (createCustomConfig) {
    config = Object.assign({}, config, createCustomConfig(config));
  }
  if (circular) {
    const areArraysEqual2 = createIsCircular(config.areArraysEqual);
    const areMapsEqual2 = createIsCircular(config.areMapsEqual);
    const areObjectsEqual2 = createIsCircular(config.areObjectsEqual);
    const areSetsEqual2 = createIsCircular(config.areSetsEqual);
    config = Object.assign({}, config, {
      areArraysEqual: areArraysEqual2,
      areMapsEqual: areMapsEqual2,
      areObjectsEqual: areObjectsEqual2,
      areSetsEqual: areSetsEqual2
    });
  }
  return config;
}
function createInternalEqualityComparator(compare) {
  return function(a, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, state) {
    return compare(a, b, state);
  };
}
function createIsEqual({ circular, comparator, createState, equals: equals2, strict }) {
  if (createState) {
    return function isEqual(a, b) {
      const { cache = circular ? /* @__PURE__ */ new WeakMap() : void 0, meta } = createState();
      return comparator(a, b, {
        cache,
        equals: equals2,
        meta,
        strict
      });
    };
  }
  if (circular) {
    return function isEqual(a, b) {
      return comparator(a, b, {
        cache: /* @__PURE__ */ new WeakMap(),
        equals: equals2,
        meta: void 0,
        strict
      });
    };
  }
  const state = {
    cache: void 0,
    equals: equals2,
    meta: void 0,
    strict
  };
  return function isEqual(a, b) {
    return comparator(a, b, state);
  };
}
var deepEqual2 = createCustomEqual();
var strictDeepEqual = createCustomEqual({ strict: true });
var circularDeepEqual = createCustomEqual({ circular: true });
var strictCircularDeepEqual = createCustomEqual({
  circular: true,
  strict: true
});
var shallowEqual2 = createCustomEqual({
  createInternalComparator: () => sameValueZeroEqual
});
var strictShallowEqual = createCustomEqual({
  strict: true,
  createInternalComparator: () => sameValueZeroEqual
});
var circularShallowEqual = createCustomEqual({
  circular: true,
  createInternalComparator: () => sameValueZeroEqual
});
var strictCircularShallowEqual = createCustomEqual({
  circular: true,
  createInternalComparator: () => sameValueZeroEqual,
  strict: true
});
function createCustomEqual(options2 = {}) {
  const { circular = false, createInternalComparator: createCustomInternalComparator, createState, strict = false } = options2;
  const config = createEqualityComparatorConfig(options2);
  const comparator = createEqualityComparator(config);
  const equals2 = createCustomInternalComparator ? createCustomInternalComparator(comparator) : createInternalEqualityComparator(comparator);
  return createIsEqual({ circular, comparator, createState, equals: equals2, strict });
}

// ../node_modules/@tiptap/react/dist/index.js
var import_react127 = __toESM(require_react());
var import_with_selector = __toESM(require_with_selector());
var import_jsx_runtime196 = __toESM(require_jsx_runtime());
var import_react128 = __toESM(require_react());
var import_jsx_runtime197 = __toESM(require_jsx_runtime());
var import_react129 = __toESM(require_react());
var import_jsx_runtime198 = __toESM(require_jsx_runtime());
var import_react130 = __toESM(require_react());
var import_react131 = __toESM(require_react());
var import_react_dom10 = __toESM(require_react_dom());
var import_jsx_runtime199 = __toESM(require_jsx_runtime());
var import_jsx_runtime200 = __toESM(require_jsx_runtime());
var import_react132 = __toESM(require_react());
var import_jsx_runtime201 = __toESM(require_jsx_runtime());
var import_react133 = __toESM(require_react());
var import_jsx_runtime202 = __toESM(require_jsx_runtime());
var mergeRefs2 = (...refs) => {
  return (node) => {
    refs.forEach((ref) => {
      if (typeof ref === "function") {
        ref(node);
      } else if (ref) {
        ;
        ref.current = node;
      }
    });
  };
};
var Portals = ({ contentComponent }) => {
  const renderers = (0, import_shim2.useSyncExternalStore)(
    contentComponent.subscribe,
    contentComponent.getSnapshot,
    contentComponent.getServerSnapshot
  );
  return (0, import_jsx_runtime195.jsx)(import_jsx_runtime195.Fragment, { children: Object.values(renderers) });
};
function getInstance() {
  const subscribers = /* @__PURE__ */ new Set();
  let renderers = {};
  return {
    /**
     * Subscribe to the editor instance's changes.
     */
    subscribe(callback) {
      subscribers.add(callback);
      return () => {
        subscribers.delete(callback);
      };
    },
    getSnapshot() {
      return renderers;
    },
    getServerSnapshot() {
      return renderers;
    },
    /**
     * Adds a new NodeView Renderer to the editor.
     */
    setRenderer(id, renderer) {
      renderers = {
        ...renderers,
        [id]: import_react_dom9.default.createPortal(renderer.reactElement, renderer.element, id)
      };
      subscribers.forEach((subscriber) => subscriber());
    },
    /**
     * Removes a NodeView Renderer from the editor.
     */
    removeRenderer(id) {
      const nextRenderers = { ...renderers };
      delete nextRenderers[id];
      renderers = nextRenderers;
      subscribers.forEach((subscriber) => subscriber());
    }
  };
}
var PureEditorContent = class extends import_react125.default.Component {
  constructor(props) {
    var _a6;
    super(props);
    this.editorContentRef = import_react125.default.createRef();
    this.initialized = false;
    this.state = {
      hasContentComponentInitialized: Boolean((_a6 = props.editor) == null ? void 0 : _a6.contentComponent)
    };
  }
  componentDidMount() {
    this.init();
  }
  componentDidUpdate() {
    this.init();
  }
  init() {
    var _a6;
    const editor = this.props.editor;
    if (editor && !editor.isDestroyed && ((_a6 = editor.view.dom) == null ? void 0 : _a6.parentNode)) {
      if (editor.contentComponent) {
        return;
      }
      const element = this.editorContentRef.current;
      element.append(...editor.view.dom.parentNode.childNodes);
      editor.setOptions({
        element
      });
      editor.contentComponent = getInstance();
      if (!this.state.hasContentComponentInitialized) {
        this.unsubscribeToContentComponent = editor.contentComponent.subscribe(() => {
          this.setState((prevState) => {
            if (!prevState.hasContentComponentInitialized) {
              return {
                hasContentComponentInitialized: true
              };
            }
            return prevState;
          });
          if (this.unsubscribeToContentComponent) {
            this.unsubscribeToContentComponent();
          }
        });
      }
      editor.createNodeViews();
      this.initialized = true;
    }
  }
  componentWillUnmount() {
    var _a6;
    const editor = this.props.editor;
    if (!editor) {
      return;
    }
    this.initialized = false;
    if (!editor.isDestroyed) {
      editor.view.setProps({
        nodeViews: {}
      });
    }
    if (this.unsubscribeToContentComponent) {
      this.unsubscribeToContentComponent();
    }
    editor.contentComponent = null;
    try {
      if (!((_a6 = editor.view.dom) == null ? void 0 : _a6.parentNode)) {
        return;
      }
      const newElement = document.createElement("div");
      newElement.append(...editor.view.dom.parentNode.childNodes);
      editor.setOptions({
        element: newElement
      });
    } catch {
    }
  }
  render() {
    const { editor, innerRef, ...rest } = this.props;
    return (0, import_jsx_runtime195.jsxs)(import_jsx_runtime195.Fragment, { children: [
      (0, import_jsx_runtime195.jsx)("div", { ref: mergeRefs2(innerRef, this.editorContentRef), ...rest }),
      (editor == null ? void 0 : editor.contentComponent) && (0, import_jsx_runtime195.jsx)(Portals, { contentComponent: editor.contentComponent })
    ] });
  }
};
var EditorContentWithKey = (0, import_react125.forwardRef)(
  (props, ref) => {
    const key = import_react125.default.useMemo(() => {
      return Math.floor(Math.random() * 4294967295).toString();
    }, [props.editor]);
    return import_react125.default.createElement(PureEditorContent, {
      key,
      innerRef: ref,
      ...props
    });
  }
);
var EditorContent = import_react125.default.memo(EditorContentWithKey);
var isSSR = typeof window === "undefined";
var isNext = isSSR || Boolean(typeof window !== "undefined" && window.next);
var EditorContext2 = (0, import_react124.createContext)({
  editor: null
});
var EditorConsumer = EditorContext2.Consumer;
var ReactNodeViewContext = (0, import_react128.createContext)({
  onDragStart: () => {
  },
  nodeViewContentChildren: void 0,
  nodeViewContentRef: () => {
  }
});
var useReactNodeView = () => (0, import_react128.useContext)(ReactNodeViewContext);
var NodeViewWrapper = import_react129.default.forwardRef((props, ref) => {
  const { onDragStart } = useReactNodeView();
  const Tag = props.as || "div";
  return (
    // @ts-ignore
    (0, import_jsx_runtime198.jsx)(
      Tag,
      {
        ...props,
        ref,
        "data-node-view-wrapper": "",
        onDragStart,
        style: {
          whiteSpace: "normal",
          ...props.style
        }
      }
    )
  );
});
var ReactMarkViewContext = import_react130.default.createContext({
  markViewContentRef: () => {
  }
});
var TiptapContext = (0, import_react133.createContext)({
  get editor() {
    throw new Error("useTiptap must be used within a <Tiptap> provider");
  }
});
TiptapContext.displayName = "TiptapContext";
var useTiptap = () => (0, import_react133.useContext)(TiptapContext);
function TiptapWrapper({ editor, instance, children }) {
  const resolvedEditor = editor != null ? editor : instance;
  if (!resolvedEditor) {
    throw new Error("Tiptap: An editor instance is required. Pass a non-null `editor` prop.");
  }
  const tiptapContextValue = (0, import_react133.useMemo)(() => ({ editor: resolvedEditor }), [resolvedEditor]);
  const legacyContextValue = (0, import_react133.useMemo)(() => ({ editor: resolvedEditor }), [resolvedEditor]);
  return (0, import_jsx_runtime202.jsx)(EditorContext2.Provider, { value: legacyContextValue, children: (0, import_jsx_runtime202.jsx)(TiptapContext.Provider, { value: tiptapContextValue, children }) });
}
TiptapWrapper.displayName = "Tiptap";
function TiptapContent({ ...rest }) {
  const { editor } = useTiptap();
  return (0, import_jsx_runtime202.jsx)(EditorContent, { editor, ...rest });
}
TiptapContent.displayName = "Tiptap.Content";
var Tiptap = Object.assign(TiptapWrapper, {
  /**
   * The Tiptap Content component that renders the EditorContent with the editor instance from the context.
   * @see TiptapContent
   */
  Content: TiptapContent
});

// ../node_modules/tldraw/dist-esm/lib/shapes/text/RichTextArea.mjs
var import_react135 = __toESM(require_react(), 1);
var RichTextArea = import_react135.default.forwardRef(function RichTextArea2({
  shapeId,
  isEditing,
  richText,
  handleFocus,
  handleChange,
  handleBlur,
  handleKeyDown: handleKeyDown2,
  handleDoubleClick: handleDoubleClick2,
  hasCustomTabBehavior,
  handlePaste
}, ref) {
  const editor = useEditor();
  const tipTapId = useUniqueSafeId("tip-tap-editor");
  const tipTapConfig = editor.getTextOptions().tipTapConfig;
  const rInitialRichText = (0, import_react135.useRef)(richText);
  const rTextEditor = (0, import_react135.useRef)(null);
  const rTextEditorEl = (0, import_react135.useRef)(null);
  (0, import_react135.useLayoutEffect)(() => {
    if (!rTextEditor.current) {
      rInitialRichText.current = richText;
    } else if (rInitialRichText.current !== richText) {
      rTextEditor.current.commands.setContent(richText);
    }
  }, [richText]);
  const rCreateInfo = (0, import_react135.useRef)({
    selectAll: false,
    caretPosition: null
  });
  (0, import_react135.useLayoutEffect)(() => {
    function selectAllIfEditing(event) {
      if (event.shapeId === editor.getEditingShapeId()) {
        rCreateInfo.current.selectAll = true;
      }
    }
    function placeCaret(event) {
      if (event.shapeId === editor.getEditingShapeId()) {
        rCreateInfo.current.caretPosition = event.point;
      }
    }
    editor.on("select-all-text", selectAllIfEditing);
    editor.on("place-caret", placeCaret);
    return () => {
      editor.off("select-all-text", selectAllIfEditing);
      editor.off("place-caret", placeCaret);
    };
  }, [editor, isEditing]);
  const onChange = useEvent(handleChange);
  const onKeyDown = useEvent(handleKeyDown2);
  const onFocus = useEvent(handleFocus);
  const onBlur = useEvent(handleBlur);
  const onDoubleClick = useEvent(handleDoubleClick2);
  const onPaste = useEvent(handlePaste);
  (0, import_react135.useLayoutEffect)(() => {
    if (!isEditing || !tipTapConfig || !rTextEditorEl.current) return;
    const { editorProps, ...restOfTipTapConfig } = tipTapConfig;
    const textEditorInstance = new Editor2({
      element: rTextEditorEl.current,
      autofocus: true,
      editable: isEditing,
      onUpdate: (props) => {
        const content = props.editor.state.doc.toJSON();
        rInitialRichText.current = content;
        onChange({ richText: content });
      },
      onFocus,
      onBlur,
      // onCreate is called after a `setTimeout(0)`
      onCreate: (props) => {
        var _a6;
        if (editor.getEditingShapeId() !== shapeId) return;
        const textEditor = props.editor;
        editor.setRichTextEditor(textEditor);
        const { selectAll: selectAll3, caretPosition } = rCreateInfo.current;
        if (selectAll3) {
          textEditor.chain().focus().selectAll().run();
        } else if (caretPosition) {
          const pos = (_a6 = textEditor.view.posAtCoords({
            left: caretPosition.x,
            top: caretPosition.y
          })) == null ? void 0 : _a6.pos;
          if (pos) {
            textEditor.chain().focus().setTextSelection(pos).run();
          } else {
            textEditor.chain().focus().selectAll().run();
          }
        }
      },
      editorProps: {
        handleKeyDown: (view, event) => {
          if (!hasCustomTabBehavior && event.key === "Tab") {
            handleTab(editor, view, event);
          }
          onKeyDown(event);
        },
        handlePaste: (view, event) => {
          onPaste(event);
          if (event.defaultPrevented) return true;
        },
        handleDoubleClick: (_view, _pos, event) => onDoubleClick(event),
        ...editorProps
      },
      coreExtensionOptions: {
        clipboardTextSerializer: {
          blockSeparator: "\n"
        }
      },
      // N.B. We disable the text direction in the core list here,
      // but we add it back in again in our own extensions list so that
      // people can omit/override it if they want to.
      enableCoreExtensions: { textDirection: false },
      textDirection: "auto",
      ...restOfTipTapConfig,
      content: rInitialRichText.current
    });
    const timeout = editor.timers.setTimeout(() => {
      if (rCreateInfo.current.caretPosition || rCreateInfo.current.selectAll) {
        textEditorInstance.commands.focus();
      } else {
        textEditorInstance.commands.focus("end");
      }
      rCreateInfo.current.selectAll = false;
      rCreateInfo.current.caretPosition = null;
    }, 100);
    rTextEditor.current = textEditorInstance;
    return () => {
      rTextEditor.current = null;
      clearTimeout(timeout);
      textEditorInstance.destroy();
    };
  }, [
    isEditing,
    tipTapConfig,
    onFocus,
    onBlur,
    onDoubleClick,
    onChange,
    onPaste,
    onKeyDown,
    editor,
    shapeId,
    hasCustomTabBehavior
  ]);
  if (!isEditing || !tipTapConfig) {
    return null;
  }
  return (0, import_jsx_runtime203.jsx)(
    "div",
    {
      id: tipTapId,
      ref,
      tabIndex: -1,
      "data-testid": "rich-text-area",
      className: "tl-rich-text tl-text tl-text-input",
      onContextMenu: isEditing ? (e) => e.stopPropagation() : void 0,
      onPointerDownCapture: (e) => e.stopPropagation(),
      onTouchEnd: (e) => e.stopPropagation(),
      onDragStart: preventDefault,
      children: (0, import_jsx_runtime203.jsx)("div", { className: "tl-rich-text", ref: rTextEditorEl })
    }
  );
});
function handleTab(editor, view, event) {
  event.preventDefault();
  const textEditor = editor.getRichTextEditor();
  if ((textEditor == null ? void 0 : textEditor.isActive("bulletList")) || (textEditor == null ? void 0 : textEditor.isActive("orderedList"))) return;
  const { state, dispatch: dispatch2 } = view;
  const { $from, $to } = state.selection;
  const isShift = event.shiftKey;
  let tr2 = state.tr;
  let pos = $to.end();
  while (pos >= $from.start()) {
    const line = state.doc.resolve(pos).blockRange();
    if (!line) break;
    const lineStart = line.start;
    const lineEnd = line.end;
    const lineText = state.doc.textBetween(lineStart, lineEnd, "\n");
    let isInList = false;
    state.doc.nodesBetween(lineStart, lineEnd, (node) => {
      if (node.type.name === "bulletList" || node.type.name === "orderedList") {
        isInList = true;
        return false;
      }
    });
    if (!isInList) {
      if (!isShift) {
        tr2 = tr2.insertText("	", lineStart + 1);
      } else {
        if (lineText.startsWith("	")) {
          tr2 = tr2.delete(lineStart + 1, lineStart + 2);
        }
      }
    }
    pos = lineStart - 1;
  }
  const mappedSelection = state.selection.map(tr2.doc, tr2.mapping);
  tr2.setSelection(mappedSelection);
  if (tr2.docChanged) {
    dispatch2(tr2);
  }
}

// ../node_modules/tldraw/dist-esm/lib/shapes/shared/legacyProps.mjs
function isLegacyAlign(align) {
  return align === "start-legacy" || align === "middle-legacy" || align === "end-legacy";
}

// ../node_modules/tldraw/dist-esm/lib/shapes/shared/useEditableRichText.mjs
var import_react137 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/shapes/shared/useEditablePlainText.mjs
var import_react136 = __toESM(require_react(), 1);
function useEditablePlainText(shapeId, type, text) {
  const commonUseEditableTextHandlers = useEditableTextCommon(shapeId);
  const isEditing = commonUseEditableTextHandlers.isEditing;
  const editor = useEditor();
  const rInput = (0, import_react136.useRef)(null);
  const isEmpty = (text || "").trim().length === 0;
  (0, import_react136.useEffect)(() => {
    function selectAllIfEditing(event) {
      var _a6, _b3;
      if (event.shapeId === shapeId) {
        (_b3 = (_a6 = rInput.current) == null ? void 0 : _a6.select) == null ? void 0 : _b3.call(_a6);
      }
    }
    editor.on("select-all-text", selectAllIfEditing);
    return () => {
      editor.off("select-all-text", selectAllIfEditing);
    };
  }, [editor, shapeId, isEditing]);
  (0, import_react136.useEffect)(() => {
    var _a6, _b3, _c, _d;
    if (!isEditing) return;
    if (document.activeElement !== rInput.current) {
      (_a6 = rInput.current) == null ? void 0 : _a6.focus();
    }
    if (editor.getInstanceState().isCoarsePointer) {
      (_b3 = rInput.current) == null ? void 0 : _b3.select();
    }
    if (tlenv.isSafari) {
      (_c = rInput.current) == null ? void 0 : _c.blur();
      (_d = rInput.current) == null ? void 0 : _d.focus();
    }
  }, [editor, isEditing]);
  const handleKeyDown2 = (0, import_react136.useCallback)(
    (e) => {
      if (editor.getEditingShapeId() !== shapeId) return;
      switch (e.key) {
        case "Enter": {
          if (e.ctrlKey || e.metaKey) {
            editor.complete();
          }
          break;
        }
      }
    },
    [editor, shapeId]
  );
  const handleChange = (0, import_react136.useCallback)(
    ({ plaintext }) => {
      if (editor.getEditingShapeId() !== shapeId) return;
      const normalizedPlaintext = TextHelpers.normalizeText(plaintext || "");
      editor.updateShape({
        id: shapeId,
        type,
        props: { text: normalizedPlaintext }
      });
    },
    [editor, shapeId, type]
  );
  return {
    rInput,
    handleKeyDown: handleKeyDown2,
    handleChange,
    isEmpty,
    ...commonUseEditableTextHandlers
  };
}
function useIsReadyForEditing(editor, shapeId) {
  return useValue(
    "isReadyForEditing",
    () => {
      const editingShapeId = editor.getEditingShapeId();
      return (
        // something's being editing... and either it's this shape OR this shape is hovered
        editingShapeId !== null && (editingShapeId === shapeId || editor.getHoveredShapeId() === shapeId)
      );
    },
    [editor, shapeId]
  );
}
function useEditableTextCommon(shapeId) {
  const editor = useEditor();
  const isEditing = useValue("isEditing", () => editor.getEditingShapeId() === shapeId, [editor]);
  const isReadyForEditing = useIsReadyForEditing(editor, shapeId);
  const handleInputPointerDown = (0, import_react136.useCallback)(
    (e) => {
      editor.dispatch({
        ...getPointerInfo(editor, e),
        type: "pointer",
        name: "pointer_down",
        target: "shape",
        shape: editor.getShape(shapeId)
      });
      e.stopPropagation();
    },
    [editor, shapeId]
  );
  const handlePaste = (0, import_react136.useCallback)(
    (e) => {
      if (editor.getEditingShapeId() !== shapeId) return;
      if (e.clipboardData) {
        const html = e.clipboardData.getData("text/html");
        if (html) {
          if (html.includes("<div data-tldraw")) {
            preventDefault(e);
          }
        }
      }
    },
    [editor, shapeId]
  );
  return {
    handleFocus: noop,
    handleBlur: noop,
    handleInputPointerDown,
    handleDoubleClick: editor.markEventAsHandled,
    handlePaste,
    isEditing,
    isReadyForEditing
  };
}

// ../node_modules/tldraw/dist-esm/lib/shapes/shared/useEditableRichText.mjs
function useEditableRichText(shapeId, type, richText) {
  const commonUseEditableTextHandlers = useEditableTextCommon(shapeId);
  const isEditing = commonUseEditableTextHandlers.isEditing;
  const editor = useEditor();
  const rInput = (0, import_react137.useRef)(null);
  const isEmpty = richText && isEmptyRichText(richText);
  (0, import_react137.useEffect)(() => {
    var _a6;
    if (!isEditing) return;
    const contentEditable = (_a6 = rInput.current) == null ? void 0 : _a6.querySelector("[contenteditable]");
    if (contentEditable && document.activeElement !== rInput.current) {
      ;
      contentEditable.focus();
    }
  }, [editor, isEditing]);
  const handleKeyDown2 = (0, import_react137.useCallback)(
    (e) => {
      if (editor.getEditingShapeId() !== shapeId) return;
      if (e.key === "Enter" && isAccelKey(e)) editor.complete();
    },
    [editor, shapeId]
  );
  const handleChange = (0, import_react137.useCallback)(
    ({ richText: richText2 }) => {
      if (editor.getEditingShapeId() !== shapeId) return;
      editor.updateShape({
        id: shapeId,
        type,
        props: { richText: richText2 }
      });
    },
    [editor, shapeId, type]
  );
  return {
    rInput,
    handleKeyDown: handleKeyDown2,
    handleChange,
    isEmpty,
    ...commonUseEditableTextHandlers
  };
}

// ../node_modules/tldraw/dist-esm/lib/shapes/shared/RichTextLabel.mjs
var RichTextLabel = import_react138.default.memo(function RichTextLabel2({
  shapeId,
  type,
  richText,
  labelColor,
  font,
  fontSize,
  lineHeight,
  align,
  verticalAlign,
  wrap: wrap3,
  isSelected,
  padding = 0,
  onKeyDown: handleKeyDownCustom,
  classNamePrefix,
  style: style2,
  textWidth,
  textHeight,
  hasCustomTabBehavior,
  showTextOutline = true
}) {
  const editor = useEditor();
  const isDragging = import_react138.default.useRef(false);
  const { rInput, isEmpty, isEditing, isReadyForEditing, ...editableTextRest } = useEditableRichText(shapeId, type, richText);
  const html = (0, import_react138.useMemo)(() => {
    if (richText) {
      return renderHtmlFromRichText(editor, richText);
    }
  }, [editor, richText]);
  const selectToolActive = useValue(
    "isSelectToolActive",
    () => editor.getCurrentToolId() === "select",
    [editor]
  );
  useReactor(
    "isDragging",
    () => {
      editor.getInstanceState();
      isDragging.current = editor.inputs.getIsDragging();
    },
    [editor]
  );
  const legacyAlign = isLegacyAlign(align);
  const handlePointerDown = (e) => {
    var _a6;
    if (e.target instanceof HTMLElement && (e.target.tagName === "A" || e.target.closest("a"))) {
      preventDefault(e);
      if (!selectToolActive) return;
      const link = ((_a6 = e.target.closest("a")) == null ? void 0 : _a6.getAttribute("href")) ?? "";
      const handlePointerUp = (e2) => {
        if (e2.name !== "pointer_up" || !link) return;
        if (!isDragging.current) {
          openWindow(link, "_blank", false);
        }
        editor.off("event", handlePointerUp);
      };
      editor.on("event", handlePointerUp);
    }
  };
  if (!isEditing && isEmpty) return null;
  const cssPrefix = classNamePrefix || "tl-text";
  return (0, import_jsx_runtime204.jsx)(
    "div",
    {
      className: (0, import_classnames33.default)(
        `${cssPrefix}-label tl-text-wrapper tl-rich-text-wrapper`,
        showTextOutline ? "tl-text__outline" : "tl-text__no-outline"
      ),
      "aria-hidden": !isEditing,
      "data-font": font,
      "data-align": align,
      "data-hastext": !isEmpty,
      "data-isediting": isEditing,
      "data-textwrap": !!wrap3,
      "data-isselected": isSelected,
      style: {
        justifyContent: align === "middle" || legacyAlign ? "center" : align,
        alignItems: verticalAlign === "middle" ? "center" : verticalAlign,
        padding,
        ...style2
      },
      children: (0, import_jsx_runtime204.jsxs)(
        "div",
        {
          className: `${cssPrefix}-label__inner tl-text-content__wrapper`,
          style: {
            fontSize,
            lineHeight: lineHeight.toString(),
            minHeight: Math.floor(fontSize * lineHeight) + "px",
            minWidth: Math.ceil(textWidth || 0),
            color: labelColor,
            width: textWidth ? Math.ceil(textWidth) : void 0,
            height: textHeight ? Math.ceil(textHeight) : void 0
          },
          children: [
            (0, import_jsx_runtime204.jsx)("div", { className: `${cssPrefix} tl-text tl-text-content`, dir: "auto", children: richText && (0, import_jsx_runtime204.jsx)(
              "div",
              {
                className: "tl-rich-text",
                "data-is-select-tool-active": selectToolActive,
                dangerouslySetInnerHTML: { __html: html || "" },
                onPointerDown: handlePointerDown,
                "data-is-ready-for-editing": isReadyForEditing
              }
            ) }),
            (isReadyForEditing || isSelected) && (0, import_jsx_runtime204.jsx)(
              RichTextArea,
              {
                ref: rInput,
                richText,
                isEditing,
                shapeId,
                ...editableTextRest,
                hasCustomTabBehavior,
                handleKeyDown: handleKeyDownCustom ?? editableTextRest.handleKeyDown
              }
            )
          ]
        }
      )
    }
  );
});
function RichTextSVG({
  bounds,
  richText,
  fontSize,
  font,
  align,
  verticalAlign,
  wrap: wrap3,
  labelColor,
  padding,
  showTextOutline = true
}) {
  const editor = useEditor();
  const html = renderHtmlFromRichText(editor, richText);
  const textAlign = align === "middle" ? "center" : align === "start" ? "start" : "end";
  const justifyContent = align === "middle" ? "center" : align === "start" ? "flex-start" : "flex-end";
  const alignItems = verticalAlign === "middle" ? "center" : verticalAlign === "start" ? "flex-start" : "flex-end";
  const wrapperStyle = {
    display: "flex",
    fontFamily: DefaultFontFamilies[font],
    height: `100%`,
    justifyContent,
    alignItems,
    padding: `${padding}px`
  };
  const style2 = {
    fontSize: `${fontSize}px`,
    wrap: wrap3 ? "wrap" : "nowrap",
    color: labelColor,
    lineHeight: TEXT_PROPS.lineHeight,
    textAlign,
    width: "100%",
    wordWrap: "break-word",
    overflowWrap: "break-word",
    whiteSpace: "pre-wrap",
    textShadow: showTextOutline ? "var(--tl-text-outline)" : "none"
  };
  return (0, import_jsx_runtime204.jsx)(
    "foreignObject",
    {
      x: bounds.minX,
      y: bounds.minY,
      width: bounds.w,
      height: bounds.h,
      className: (0, import_classnames33.default)(
        "tl-export-embed-styles tl-rich-text tl-rich-text-svg",
        showTextOutline ? "tl-text__outline" : "tl-text__no-outline"
      ),
      children: (0, import_jsx_runtime204.jsx)("div", { style: wrapperStyle, children: (0, import_jsx_runtime204.jsx)("div", { dangerouslySetInnerHTML: { __html: html }, style: style2 }) })
    }
  );
}

// ../node_modules/tldraw/dist-esm/lib/shapes/shared/ShapeFill.mjs
var import_jsx_runtime206 = __toESM(require_jsx_runtime(), 1);
var import_react140 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/shapes/shared/defaultStyleDefs.mjs
var import_jsx_runtime205 = __toESM(require_jsx_runtime(), 1);
var import_react139 = __toESM(require_react(), 1);
function getFillDefForExport(fill) {
  return {
    key: `${DefaultFontStyle.id}:${fill}`,
    async getElement() {
      if (fill !== "pattern") return null;
      return (0, import_jsx_runtime205.jsx)(HashPatternForExport, {});
    }
  };
}
function HashPatternForExport() {
  const getHashPatternZoomName = useGetHashPatternZoomName();
  const maskId = useUniqueSafeId();
  const theme = useDefaultColorTheme();
  const t2 = 8 / 12;
  return (0, import_jsx_runtime205.jsxs)(import_jsx_runtime205.Fragment, { children: [
    (0, import_jsx_runtime205.jsxs)("mask", { id: maskId, children: [
      (0, import_jsx_runtime205.jsx)("rect", { x: "0", y: "0", width: "8", height: "8", fill: "white" }),
      (0, import_jsx_runtime205.jsxs)("g", { strokeLinecap: "round", stroke: "black", children: [
        (0, import_jsx_runtime205.jsx)("line", { x1: t2 * 1, y1: t2 * 3, x2: t2 * 3, y2: t2 * 1 }),
        (0, import_jsx_runtime205.jsx)("line", { x1: t2 * 5, y1: t2 * 7, x2: t2 * 7, y2: t2 * 5 }),
        (0, import_jsx_runtime205.jsx)("line", { x1: t2 * 9, y1: t2 * 11, x2: t2 * 11, y2: t2 * 9 })
      ] })
    ] }),
    (0, import_jsx_runtime205.jsx)(
      "pattern",
      {
        id: getHashPatternZoomName(1, theme.id),
        width: "8",
        height: "8",
        patternUnits: "userSpaceOnUse",
        children: (0, import_jsx_runtime205.jsx)("rect", { x: "0", y: "0", width: "8", height: "8", fill: theme.solid, mask: `url(#${maskId})` })
      }
    )
  ] });
}
function getFillDefForCanvas() {
  return {
    key: `${DefaultFontStyle.id}:pattern`,
    component: PatternFillDefForCanvas
  };
}
var TILE_PATTERN_SIZE = 8;
var generateImage = (dpr, currentZoom, darkMode) => {
  return new Promise((resolve, reject) => {
    const size4 = TILE_PATTERN_SIZE * currentZoom * dpr;
    const canvasEl = document.createElement("canvas");
    canvasEl.width = size4;
    canvasEl.height = size4;
    const ctx = canvasEl.getContext("2d");
    if (!ctx) return;
    ctx.fillStyle = darkMode ? DefaultColorThemePalette.darkMode.solid : DefaultColorThemePalette.lightMode.solid;
    ctx.fillRect(0, 0, size4, size4);
    ctx.globalCompositeOperation = "destination-out";
    ctx.lineCap = "round";
    ctx.lineWidth = 1.25 * currentZoom * dpr;
    const t2 = 8 / 12;
    const s = (v) => v * currentZoom * dpr;
    ctx.beginPath();
    ctx.moveTo(s(t2 * 1), s(t2 * 3));
    ctx.lineTo(s(t2 * 3), s(t2 * 1));
    ctx.moveTo(s(t2 * 5), s(t2 * 7));
    ctx.lineTo(s(t2 * 7), s(t2 * 5));
    ctx.moveTo(s(t2 * 9), s(t2 * 11));
    ctx.lineTo(s(t2 * 11), s(t2 * 9));
    ctx.stroke();
    canvasEl.toBlob((blob) => {
      if (!blob || debugFlags.throwToBlob.get()) {
        reject();
      } else {
        resolve(blob);
      }
    });
  });
};
var canvasBlob = (size4, fn) => {
  const canvas = document.createElement("canvas");
  canvas.width = size4[0];
  canvas.height = size4[1];
  const ctx = canvas.getContext("2d");
  if (!ctx) return "";
  fn(ctx);
  return canvas.toDataURL();
};
var defaultPixels = null;
function getDefaultPixels() {
  if (!defaultPixels) {
    defaultPixels = {
      white: canvasBlob([1, 1], (ctx) => {
        ctx.fillStyle = "#f8f9fa";
        ctx.fillRect(0, 0, 1, 1);
      }),
      black: canvasBlob([1, 1], (ctx) => {
        ctx.fillStyle = "#212529";
        ctx.fillRect(0, 0, 1, 1);
      })
    };
  }
  return defaultPixels;
}
function getPatternLodForZoomLevel(zoom) {
  return Math.ceil(Math.log2(Math.max(1, zoom)));
}
function useGetHashPatternZoomName() {
  const id = useSharedSafeId("hash_pattern");
  return (0, import_react139.useCallback)(
    (zoom, theme) => {
      const lod = getPatternLodForZoomLevel(zoom);
      return suffixSafeId(id, `${theme}_${lod}`);
    },
    [id]
  );
}
function getPatternLodsToGenerate(maxZoom) {
  const levels = [];
  const minLod = 0;
  const maxLod = getPatternLodForZoomLevel(maxZoom);
  for (let i = minLod; i <= maxLod; i++) {
    levels.push(Math.pow(2, i));
  }
  return levels;
}
function getDefaultPatterns(maxZoom) {
  const defaultPixels2 = getDefaultPixels();
  return getPatternLodsToGenerate(maxZoom).flatMap((zoom) => [
    { zoom, url: defaultPixels2.white, theme: "light" },
    { zoom, url: defaultPixels2.black, theme: "dark" }
  ]);
}
function usePattern() {
  const editor = useEditor();
  const dpr = useValue("devicePixelRatio", () => editor.getInstanceState().devicePixelRatio, [
    editor
  ]);
  const maxZoom = useValue("maxZoom", () => Math.ceil(last(editor.getCameraOptions().zoomSteps)), [
    editor
  ]);
  const [isReady, setIsReady] = (0, import_react139.useState)(false);
  const [backgroundUrls, setBackgroundUrls] = (0, import_react139.useState)(
    () => getDefaultPatterns(maxZoom)
  );
  const getHashPatternZoomName = useGetHashPatternZoomName();
  (0, import_react139.useEffect)(() => {
    if (false) {
      setIsReady(true);
      return;
    }
    const promise = Promise.all(
      getPatternLodsToGenerate(maxZoom).flatMap((zoom) => [
        generateImage(dpr, zoom, false).then((blob) => ({
          zoom,
          theme: "light",
          url: URL.createObjectURL(blob)
        })),
        generateImage(dpr, zoom, true).then((blob) => ({
          zoom,
          theme: "dark",
          url: URL.createObjectURL(blob)
        }))
      ])
    );
    let isCancelled = false;
    promise.then((urls) => {
      if (isCancelled) return;
      setBackgroundUrls(urls);
      setIsReady(true);
    });
    return () => {
      isCancelled = true;
      setIsReady(false);
      promise.then((patterns) => {
        for (const { url } of patterns) {
          URL.revokeObjectURL(url);
        }
      });
    };
  }, [dpr, maxZoom]);
  const defs = (0, import_jsx_runtime205.jsx)(import_jsx_runtime205.Fragment, { children: backgroundUrls.map((item) => {
    const id = getHashPatternZoomName(item.zoom, item.theme);
    return (0, import_jsx_runtime205.jsx)(
      "pattern",
      {
        id,
        width: TILE_PATTERN_SIZE,
        height: TILE_PATTERN_SIZE,
        patternUnits: "userSpaceOnUse",
        children: (0, import_jsx_runtime205.jsx)("image", { href: item.url, width: TILE_PATTERN_SIZE, height: TILE_PATTERN_SIZE })
      },
      id
    );
  }) });
  return { defs, isReady };
}
function PatternFillDefForCanvas() {
  const editor = useEditor();
  const containerRef = (0, import_react139.useRef)(null);
  const { defs, isReady } = usePattern();
  (0, import_react139.useEffect)(() => {
    if (isReady && tlenv.isSafari) {
      const htmlLayer = findHtmlLayerParent(containerRef.current);
      if (htmlLayer) {
        editor.timers.requestAnimationFrame(() => {
          htmlLayer.style.display = "none";
          editor.timers.requestAnimationFrame(() => {
            htmlLayer.style.display = "";
          });
        });
      }
    }
  }, [editor, isReady]);
  return (0, import_jsx_runtime205.jsx)("g", { ref: containerRef, "data-testid": isReady ? "ready-pattern-fill-defs" : void 0, children: defs });
}
function findHtmlLayerParent(element) {
  if (element.classList.contains("tl-html-layer")) return element;
  if (element.parentElement) return findHtmlLayerParent(element.parentElement);
  return null;
}

// ../node_modules/tldraw/dist-esm/lib/shapes/shared/ShapeFill.mjs
var ShapeFill = import_react140.default.memo(function ShapeFill2({
  theme,
  d,
  color,
  fill,
  scale
}) {
  switch (fill) {
    case "none": {
      return null;
    }
    case "solid": {
      return (0, import_jsx_runtime206.jsx)("path", { fill: getColorValue(theme, color, "semi"), d });
    }
    case "semi": {
      return (0, import_jsx_runtime206.jsx)("path", { fill: theme.solid, d });
    }
    case "fill": {
      return (0, import_jsx_runtime206.jsx)("path", { fill: getColorValue(theme, color, "fill"), d });
    }
    case "pattern": {
      return (0, import_jsx_runtime206.jsx)(PatternFill, { theme, color, fill, d, scale });
    }
    case "lined-fill": {
      return (0, import_jsx_runtime206.jsx)("path", { fill: getColorValue(theme, color, "linedFill"), d });
    }
  }
});
function PatternFill({ d, color, theme }) {
  const editor = useEditor();
  const svgExport = useSvgExportContext();
  const zoomLevel = useValue("zoomLevel", () => editor.getEfficientZoomLevel(), [editor]);
  const getHashPatternZoomName = useGetHashPatternZoomName();
  const teenyTiny = zoomLevel <= 0.18;
  return (0, import_jsx_runtime206.jsxs)(import_jsx_runtime206.Fragment, { children: [
    (0, import_jsx_runtime206.jsx)("path", { fill: getColorValue(theme, color, "pattern"), d }),
    (0, import_jsx_runtime206.jsx)(
      "path",
      {
        fill: svgExport ? `url(#${getHashPatternZoomName(1, theme.id)})` : teenyTiny ? getColorValue(theme, color, "semi") : `url(#${getHashPatternZoomName(zoomLevel, theme.id)})`,
        d
      }
    )
  ] });
}

// ../node_modules/tldraw/dist-esm/lib/shapes/shared/useEfficientZoomThreshold.mjs
function useEfficientZoomThreshold(threshold = 0.25) {
  const editor = useEditor();
  return useValue("efficient zoom threshold", () => editor.getEfficientZoomLevel() < threshold, [
    editor,
    threshold
  ]);
}

// ../node_modules/tldraw/dist-esm/lib/shapes/arrow/ArrowPath.mjs
function getArrowBodyPath(shape, info, opts) {
  switch (info.type) {
    case "straight":
      return new PathBuilder().moveTo(info.start.point.x, info.start.point.y, { offset: 0, roundness: 0 }).lineTo(info.end.point.x, info.end.point.y, { offset: 0, roundness: 0 }).toSvg(opts);
    case "arc":
      return new PathBuilder().moveTo(info.start.point.x, info.start.point.y, { offset: 0, roundness: 0 }).circularArcTo(
        info.bodyArc.radius,
        !!info.bodyArc.largeArcFlag,
        !!info.bodyArc.sweepFlag,
        info.end.point.x,
        info.end.point.y,
        { offset: 0, roundness: 0 }
      ).toSvg(opts);
    case "elbow": {
      const path = new PathBuilder();
      path.moveTo(info.start.point.x, info.start.point.y, {
        offset: 0
      });
      for (let i = 1; i < info.route.points.length; i++) {
        const point = info.route.points[i];
        if (info.route.skipPointsWhenDrawing.has(point)) {
          continue;
        }
        path.lineTo(point.x, point.y, {
          offset: i === info.route.points.length - 1 ? 0 : void 0
        });
      }
      return path.toSvg(opts);
    }
    default:
      exhaustiveSwitchError(info, "type");
  }
}
function getArrowHandlePath(info, opts) {
  switch (info.type) {
    case "straight":
      return new PathBuilder().moveTo(info.start.handle.x, info.start.handle.y).lineTo(info.end.handle.x, info.end.handle.y).toSvg(opts);
    case "arc":
      return new PathBuilder().moveTo(info.start.handle.x, info.start.handle.y).circularArcTo(
        info.handleArc.radius,
        !!info.handleArc.largeArcFlag,
        !!info.handleArc.sweepFlag,
        info.end.handle.x,
        info.end.handle.y
      ).toSvg(opts);
    case "elbow": {
      const handleRoute = getRouteHandlePath(info.elbow, info.route);
      return PathBuilder.lineThroughPoints(handleRoute.points).toSvg(opts);
    }
    default:
      exhaustiveSwitchError(info, "type");
  }
}

// ../node_modules/tldraw/dist-esm/lib/shapes/arrow/arrowLabel.mjs
function getArrowBodyGeometry(editor, shape) {
  const info = getArrowInfo(editor, shape);
  switch (info.type) {
    case "straight":
      return new Edge2d({
        start: Vec.From(info.start.point),
        end: Vec.From(info.end.point)
      });
    case "arc":
      return new Arc2d({
        center: Vec.Cast(info.handleArc.center),
        start: Vec.Cast(info.start.point),
        end: Vec.Cast(info.end.point),
        sweepFlag: info.bodyArc.sweepFlag,
        largeArcFlag: info.bodyArc.largeArcFlag
      });
    case "elbow":
      return new Polyline2d({ points: info.route.points });
    default:
      exhaustiveSwitchError(info, "type");
  }
}
var labelSizeCache = createComputedCache(
  "arrow label size",
  (editor, shape) => {
    editor.fonts.trackFontsForShape(shape);
    let width = 0;
    let height = 0;
    const bodyGeom = getArrowBodyGeometry(editor, shape);
    const isEmpty = isEmptyRichText(shape.props.richText);
    const html = renderHtmlFromRichTextForMeasurement(
      editor,
      isEmpty ? toRichText("i") : shape.props.richText
    );
    const bodyBounds = bodyGeom.bounds;
    const fontSize = getArrowLabelFontSize(shape);
    const { w, h: h2 } = editor.textMeasure.measureHtml(html, {
      ...TEXT_PROPS,
      fontFamily: FONT_FAMILIES[shape.props.font],
      fontSize,
      maxWidth: null
    });
    width = w;
    height = h2;
    let shouldSquish = false;
    const info = getArrowInfo(editor, shape);
    const labelToArrowPadding = getLabelToArrowPadding(shape);
    const margin = info.type === "elbow" ? Math.max(info.elbow.A.arrowheadOffset + labelToArrowPadding, 32) + Math.max(info.elbow.B.arrowheadOffset + labelToArrowPadding, 32) : 64;
    if (bodyBounds.width > bodyBounds.height) {
      width = Math.max(Math.min(w, margin), Math.min(bodyBounds.width - margin, w));
      shouldSquish = true;
    } else if (width > 16 * fontSize) {
      width = 16 * fontSize;
      shouldSquish = true;
    }
    if (shouldSquish) {
      const { w: squishedWidth, h: squishedHeight } = editor.textMeasure.measureHtml(html, {
        ...TEXT_PROPS,
        fontFamily: FONT_FAMILIES[shape.props.font],
        fontSize,
        maxWidth: width
      });
      width = squishedWidth;
      height = squishedHeight;
    }
    return new Vec(width, height).addScalar(ARROW_LABEL_PADDING * 2 * shape.props.scale);
  },
  {
    areRecordsEqual: (a, b) => {
      if (a.props === b.props) return true;
      const changedKeys = getChangedKeys(a.props, b.props);
      return changedKeys.length === 1 && changedKeys[0] === "labelPosition";
    }
  }
);
function getArrowLabelSize(editor, shape) {
  return labelSizeCache.get(editor, shape.id) ?? new Vec(0, 0);
}
function getLabelToArrowPadding(shape) {
  const strokeWidth = STROKE_SIZES2[shape.props.size];
  const labelToArrowPadding = (LABEL_TO_ARROW_PADDING + (strokeWidth - STROKE_SIZES2.s) * 2 + (strokeWidth === STROKE_SIZES2.xl ? 20 : 0)) * shape.props.scale;
  return labelToArrowPadding;
}
function getArrowLabelRange(editor, shape, info) {
  const bodyGeom = getArrowBodyGeometry(editor, shape);
  const dbgPoints = [];
  const dbg = [new Group2d({ children: [bodyGeom], debugColor: "lime" })];
  const labelSize = getArrowLabelSize(editor, shape);
  const labelToArrowPadding = getLabelToArrowPadding(shape);
  const paddingRelative = labelToArrowPadding / bodyGeom.length;
  let startBox, endBox;
  if (info.type === "elbow") {
    dbgPoints.push(info.start.point, info.end.point);
    startBox = Box.FromCenter(info.start.point, labelSize).expandBy(labelToArrowPadding);
    endBox = Box.FromCenter(info.end.point, labelSize).expandBy(labelToArrowPadding);
  } else {
    const startPoint = bodyGeom.interpolateAlongEdge(paddingRelative);
    const endPoint = bodyGeom.interpolateAlongEdge(1 - paddingRelative);
    dbgPoints.push(startPoint, endPoint);
    startBox = Box.FromCenter(startPoint, labelSize);
    endBox = Box.FromCenter(endPoint, labelSize);
  }
  const startIntersections = bodyGeom.intersectPolygon(startBox.corners);
  const endIntersections = bodyGeom.intersectPolygon(endBox.corners);
  const startConstrained = furthest(info.start.point, startIntersections);
  const endConstrained = furthest(info.end.point, endIntersections);
  let startRelative = startConstrained ? bodyGeom.uninterpolateAlongEdge(startConstrained) : 0.5;
  let endRelative = endConstrained ? bodyGeom.uninterpolateAlongEdge(endConstrained) : 0.5;
  if (startRelative > endRelative) {
    startRelative = 0.5;
    endRelative = 0.5;
  }
  for (const pt of [...startIntersections, ...endIntersections, ...dbgPoints]) {
    dbg.push(
      new Circle2d({
        x: pt.x - 3,
        y: pt.y - 3,
        radius: 3,
        isFilled: false,
        debugColor: "magenta",
        ignore: true
      })
    );
  }
  dbg.push(
    new Polygon2d({
      points: startBox.corners,
      debugColor: "lime",
      isFilled: false,
      ignore: true
    }),
    new Polygon2d({
      points: endBox.corners,
      debugColor: "lime",
      isFilled: false,
      ignore: true
    })
  );
  return { start: startRelative, end: endRelative, dbg };
}
function getArrowLabelPosition(editor, shape) {
  const isEditing = editor.getEditingShapeId() === shape.id;
  if (!isEditing && isEmptyRichText(shape.props.richText)) {
    const bodyGeom2 = getArrowBodyGeometry(editor, shape);
    const labelCenter2 = bodyGeom2.interpolateAlongEdge(0.5);
    return { box: Box.FromCenter(labelCenter2, new Vec(0, 0)), debugGeom: [] };
  }
  const debugGeom = [];
  const info = getArrowInfo(editor, shape);
  const arrowheadInfo = {
    hasStartBinding: !!info.bindings.start,
    hasEndBinding: !!info.bindings.end,
    hasStartArrowhead: info.start.arrowhead !== "none",
    hasEndArrowhead: info.end.arrowhead !== "none"
  };
  const range = getArrowLabelRange(editor, shape, info);
  if (range.dbg) debugGeom.push(...range.dbg);
  const clampedPosition = getClampedPosition(shape, range, arrowheadInfo);
  const bodyGeom = getArrowBodyGeometry(editor, shape);
  const labelCenter = bodyGeom.interpolateAlongEdge(clampedPosition);
  const labelSize = getArrowLabelSize(editor, shape);
  return { box: Box.FromCenter(labelCenter, labelSize), debugGeom };
}
function getClampedPosition(shape, range, arrowheadInfo) {
  const { hasEndArrowhead, hasEndBinding, hasStartBinding, hasStartArrowhead } = arrowheadInfo;
  const clampedPosition = clamp(
    shape.props.labelPosition,
    hasStartArrowhead || hasStartBinding ? range.start : 0,
    hasEndArrowhead || hasEndBinding ? range.end : 1
  );
  return clampedPosition;
}
function furthest(from2, candidates) {
  let furthest2 = null;
  let furthestDist = -Infinity;
  for (const candidate of candidates) {
    const dist = Vec.Dist2(from2, candidate);
    if (dist > furthestDist) {
      furthest2 = candidate;
      furthestDist = dist;
    }
  }
  return furthest2;
}
function getArrowLabelFontSize(shape) {
  return ARROW_LABEL_FONT_SIZES[shape.props.size] * shape.props.scale;
}
function getArrowLabelDefaultPosition(editor, shape) {
  const info = getArrowInfo(editor, shape);
  switch (info.type) {
    case "straight":
    case "arc":
      return 0.5;
    case "elbow": {
      const midpointHandle = info.route.midpointHandle;
      const bodyGeom = getArrowBodyGeometry(editor, shape);
      if (midpointHandle && bodyGeom) {
        return bodyGeom.uninterpolateAlongEdge(midpointHandle.point);
      }
      return 0.5;
    }
    default:
      exhaustiveSwitchError(info, "type");
  }
}
function isOverArrowLabel(editor, shape) {
  if (!editor.isShapeOfType(shape, "arrow")) return false;
  const pointInShapeSpace = editor.getPointInShapeSpace(shape, editor.inputs.getCurrentPagePoint());
  const labelGeometry = editor.getShapeGeometry(shape).children[1];
  return labelGeometry && pointInPolygon(pointInShapeSpace, labelGeometry.vertices);
}

// ../node_modules/tldraw/dist-esm/lib/shapes/arrow/arrowheads.mjs
function getArrowPoints(info, side, strokeWidth) {
  const point = side === "end" ? info.end.point : info.start.point;
  let int;
  switch (info.type) {
    case "straight": {
      const opposite = side === "end" ? info.start.point : info.end.point;
      const compareLength = Vec.Dist(opposite, point);
      const length = clamp(compareLength / 5, strokeWidth, strokeWidth * 3);
      int = Vec.Nudge(point, opposite, length);
      break;
    }
    case "arc": {
      const compareLength = Math.abs(info.bodyArc.length);
      const length = clamp(compareLength / 5, strokeWidth, strokeWidth * 3);
      const intersections = intersectCircleCircle(
        point,
        length,
        info.handleArc.center,
        info.handleArc.radius
      );
      int = side === "end" ? info.handleArc.sweepFlag ? intersections[0] : intersections[1] : info.handleArc.sweepFlag ? intersections[1] : intersections[0];
      break;
    }
    case "elbow": {
      const previousPoint = side === "end" ? info.route.points[info.route.points.length - 2] : info.route.points[1];
      const previousSegmentLength = Vec.ManhattanDist(previousPoint, point);
      const length = clamp(previousSegmentLength / 2, strokeWidth, strokeWidth * 3);
      int = previousPoint ? Vec.Nudge(point, previousPoint, length) : point;
      break;
    }
    default:
      exhaustiveSwitchError(info, "type");
  }
  if (Vec.IsNaN(int)) {
    int = point;
  }
  return { point, int };
}
function getArrowhead({ point, int }) {
  const PL = Vec.RotWith(int, point, PI / 6);
  const PR = Vec.RotWith(int, point, -PI / 6);
  return `M ${PL.x} ${PL.y} L ${point.x} ${point.y} L ${PR.x} ${PR.y}`;
}
function getTriangleHead({ point, int }) {
  const PL = Vec.RotWith(int, point, PI / 6);
  const PR = Vec.RotWith(int, point, -PI / 6);
  return `M ${PL.x} ${PL.y} L ${PR.x} ${PR.y} L ${point.x} ${point.y} Z`;
}
function getInvertedTriangleHead({ point, int }) {
  const d = Vec.Sub(int, point).div(2);
  const PL = Vec.Add(point, Vec.Rot(d, HALF_PI));
  const PR = Vec.Sub(point, Vec.Rot(d, HALF_PI));
  return `M ${PL.x} ${PL.y} L ${int.x} ${int.y} L ${PR.x} ${PR.y} Z`;
}
function getDotHead({ point, int }) {
  const A = Vec.Lrp(point, int, 0.45);
  const r = Vec.Dist(A, point);
  return `M ${A.x - r},${A.y}
  a ${r},${r} 0 1,0 ${r * 2},0
  a ${r},${r} 0 1,0 -${r * 2},0 `;
}
function getDiamondHead({ point, int }) {
  const PB = Vec.Lrp(point, int, 0.75);
  const PL = Vec.RotWith(PB, point, PI / 4);
  const PR = Vec.RotWith(PB, point, -PI / 4);
  const PQ = Vec.Lrp(PL, PR, 0.5);
  PQ.add(Vec.Sub(PQ, point));
  return `M ${PQ.x} ${PQ.y} L ${PR.x} ${PR.y} ${point.x} ${point.y} L ${PL.x} ${PL.y} Z`;
}
function getSquareHead({ int, point }) {
  const PB = Vec.Lrp(point, int, 0.85);
  const d = Vec.Sub(PB, point).div(2);
  const PL1 = Vec.Add(point, Vec.Rot(d, HALF_PI));
  const PR1 = Vec.Sub(point, Vec.Rot(d, HALF_PI));
  const PL2 = Vec.Add(PB, Vec.Rot(d, HALF_PI));
  const PR2 = Vec.Sub(PB, Vec.Rot(d, HALF_PI));
  return `M ${PL1.x} ${PL1.y} L ${PL2.x} ${PL2.y} L ${PR2.x} ${PR2.y} L ${PR1.x} ${PR1.y} Z`;
}
function getBarHead({ int, point }) {
  const d = Vec.Sub(int, point).div(2);
  const PL = Vec.Add(point, Vec.Rot(d, HALF_PI));
  const PR = Vec.Sub(point, Vec.Rot(d, HALF_PI));
  return `M ${PL.x} ${PL.y} L ${PR.x} ${PR.y}`;
}
function getArrowheadPathForType(info, side, strokeWidth) {
  const type = side === "end" ? info.end.arrowhead : info.start.arrowhead;
  if (type === "none") return;
  const points = getArrowPoints(info, side, strokeWidth);
  if (!points) return;
  switch (type) {
    case "bar":
      return getBarHead(points);
    case "square":
      return getSquareHead(points);
    case "diamond":
      return getDiamondHead(points);
    case "dot":
      return getDotHead(points);
    case "inverted":
      return getInvertedTriangleHead(points);
    case "arrow":
      return getArrowhead(points);
    case "triangle":
      return getTriangleHead(points);
  }
  return "";
}

// ../node_modules/tldraw/dist-esm/lib/shapes/arrow/elbow/ElbowArrowDebug.mjs
var import_jsx_runtime207 = __toESM(require_jsx_runtime(), 1);
function ElbowArrowDebug({ arrow: arrow5 }) {
  var _a6, _b3;
  const editor = useEditor();
  const info = useValue(
    "elbow arrow grid",
    () => {
      try {
        const info2 = getElbowArrowInfo(
          editor,
          editor.getShape(arrow5.id),
          getArrowBindings(editor, arrow5)
        );
        return info2;
      } catch (err) {
        console.error(err);
        return void 0;
      }
    },
    [editor, arrow5.id]
  );
  if (!info) return null;
  const fullBox = Box.Common([info.A.original, info.B.original]).expandBy(50);
  const label = ((_a6 = info.route) == null ? void 0 : _a6.name) ?? "";
  const midPoint = (_b3 = info.route) == null ? void 0 : _b3.midpointHandle;
  return (0, import_jsx_runtime207.jsxs)(import_jsx_runtime207.Fragment, { children: [
    info.midX !== null && (0, import_jsx_runtime207.jsx)(
      DebugLine,
      {
        a: { x: info.midX, y: fullBox.minY },
        b: { x: info.midX, y: fullBox.maxY },
        stroke: "red"
      }
    ),
    info.midY !== null && (0, import_jsx_runtime207.jsx)(
      DebugLine,
      {
        a: { x: fullBox.minX, y: info.midY },
        b: { x: fullBox.maxX, y: info.midY },
        stroke: "blue"
      }
    ),
    (midPoint == null ? void 0 : midPoint.axis) === "x" && info.midXRange && (0, import_jsx_runtime207.jsx)(
      DebugLine,
      {
        a: { x: info.midXRange.lo, y: midPoint.point.y },
        b: { x: info.midXRange.hi, y: midPoint.point.y },
        stroke: "red",
        strokeDasharray: "0 2"
      }
    ),
    (midPoint == null ? void 0 : midPoint.axis) === "y" && info.midYRange && (0, import_jsx_runtime207.jsx)(
      DebugLine,
      {
        a: { x: midPoint.point.x, y: info.midYRange.lo },
        b: { x: midPoint.point.x, y: info.midYRange.hi },
        stroke: "blue",
        strokeDasharray: "0 2"
      }
    ),
    (0, import_jsx_runtime207.jsx)(DebugBox, { box: info.A.original, stroke: "orange" }),
    (0, import_jsx_runtime207.jsx)(DebugBox, { box: info.A.expanded, stroke: "orange", strokeWidth: 0.5 }),
    (0, import_jsx_runtime207.jsx)(
      DebugBox,
      {
        box: info.A.original.clone().expandBy(info.options.minElbowLegLength),
        stroke: "orange",
        strokeWidth: 0.5
      }
    ),
    (0, import_jsx_runtime207.jsx)(DebugBox, { box: info.B.original, stroke: "lightskyblue" }),
    (0, import_jsx_runtime207.jsx)(DebugBox, { box: info.B.expanded, stroke: "lightskyblue", strokeWidth: 0.5 }),
    (0, import_jsx_runtime207.jsx)(
      DebugBox,
      {
        box: info.B.original.clone().expandBy(info.options.minElbowLegLength),
        stroke: "lightskyblue",
        strokeWidth: 0.5
      }
    ),
    (0, import_jsx_runtime207.jsx)(DebugEdge, { edge: info.A.edges.top, axis: "x", stroke: "orange" }),
    (0, import_jsx_runtime207.jsx)(DebugEdge, { edge: info.B.edges.top, axis: "x", stroke: "lightskyblue" }),
    (0, import_jsx_runtime207.jsx)(DebugEdge, { edge: info.A.edges.right, axis: "y", stroke: "orange" }),
    (0, import_jsx_runtime207.jsx)(DebugEdge, { edge: info.B.edges.right, axis: "y", stroke: "lightskyblue" }),
    (0, import_jsx_runtime207.jsx)(DebugEdge, { edge: info.A.edges.bottom, axis: "x", stroke: "orange" }),
    (0, import_jsx_runtime207.jsx)(DebugEdge, { edge: info.B.edges.bottom, axis: "x", stroke: "lightskyblue" }),
    (0, import_jsx_runtime207.jsx)(DebugEdge, { edge: info.A.edges.left, axis: "y", stroke: "orange" }),
    (0, import_jsx_runtime207.jsx)(DebugEdge, { edge: info.B.edges.left, axis: "y", stroke: "lightskyblue" }),
    info.route && (0, import_jsx_runtime207.jsx)(DebugRoute, { route: info.route.points, strokeWidth: 10 }),
    (0, import_jsx_runtime207.jsx)(
      "text",
      {
        x: fullBox.minX + 5,
        y: fullBox.minY - 3,
        fontSize: 10,
        fill: "black",
        stroke: "var(--tl-color-background)",
        strokeWidth: 2,
        paintOrder: "stroke",
        children: label
      }
    ),
    (0, import_jsx_runtime207.jsxs)(
      "text",
      {
        x: info.A.expanded.x,
        y: info.A.expanded.y,
        fontSize: 10,
        fill: "black",
        stroke: "var(--tl-color-background)",
        strokeWidth: 2,
        paintOrder: "stroke",
        children: [
          "A",
          info.route && `, ${info.route.aEdgePicking}`,
          info.A.isPoint && `, point`
        ]
      }
    ),
    (0, import_jsx_runtime207.jsxs)(
      "text",
      {
        x: info.B.expanded.x,
        y: info.B.expanded.y,
        fontSize: 10,
        fill: "black",
        stroke: "var(--tl-color-background)",
        strokeWidth: 2,
        paintOrder: "stroke",
        children: [
          "B",
          info.route && `, ${info.route.bEdgePicking}`,
          info.B.isPoint && `, point`
        ]
      }
    )
  ] });
}
function DebugLine({ a, b, ...props }) {
  return (0, import_jsx_runtime207.jsx)(
    "line",
    {
      fill: "none",
      strokeWidth: 1,
      strokeDasharray: "4,4",
      stroke: "green",
      x1: a.x,
      y1: a.y,
      x2: b.x,
      y2: b.y,
      ...props
    }
  );
}
function DebugRoute({ route, ...props }) {
  return (0, import_jsx_runtime207.jsx)(
    "polyline",
    {
      fill: "none",
      stroke: "darkorchid",
      strokeWidth: 3,
      opacity: 0.5,
      points: route.map((r) => `${r.x},${r.y}`).join(" "),
      ...props
    }
  );
}
function DebugEdge({
  edge,
  axis,
  ...props
}) {
  if (!edge || edge.expanded === null) return null;
  const vec = (vec2) => axis === "x" ? { x: vec2.y, y: vec2.x } : vec2;
  return (0, import_jsx_runtime207.jsxs)("g", { children: [
    (0, import_jsx_runtime207.jsx)(
      DebugLine,
      {
        a: vec({ x: edge.expanded, y: edge.cross.min }),
        b: vec({ x: edge.expanded, y: edge.cross.max }),
        strokeDasharray: "0",
        strokeWidth: 1.5,
        ...props
      }
    ),
    (0, import_jsx_runtime207.jsx)(
      DebugLine,
      {
        a: vec({ x: edge.expanded - 4, y: edge.cross.min }),
        b: vec({ x: edge.expanded + 4, y: edge.cross.min }),
        strokeDasharray: "0",
        strokeWidth: 1.5,
        ...props
      }
    ),
    (0, import_jsx_runtime207.jsx)(
      DebugLine,
      {
        a: vec({ x: edge.expanded - 4, y: edge.cross.max }),
        b: vec({ x: edge.expanded + 4, y: edge.cross.max }),
        strokeDasharray: "0",
        strokeWidth: 1.5,
        ...props
      }
    )
  ] });
}
function DebugBox({ box, ...props }) {
  return (0, import_jsx_runtime207.jsx)(
    "rect",
    {
      x: box.minX,
      y: box.minY,
      width: box.width,
      height: box.height,
      strokeDasharray: "4,4",
      strokeWidth: 1,
      fill: "none",
      ...props
    }
  );
}

// ../node_modules/tldraw/dist-esm/lib/shapes/arrow/elbow/elbowArrowSnapLines.mjs
var snapLinesStore = new WeakCache();
function getElbowArrowSnapLines(editor) {
  return snapLinesStore.get(editor, (editor2) => {
    const currentSelectedArrowShape = computed("current selected arrow shape", () => {
      const shape = editor2.getOnlySelectedShape();
      if (!shape || !editor2.isShapeOfType(shape, "arrow")) return null;
      return shape.id;
    });
    const unselectedArrowShapeIds = editor2.store.query.ids("shape", () => {
      const activeArrowShapeId = currentSelectedArrowShape.get();
      if (!activeArrowShapeId) return { type: { eq: "arrow" } };
      return {
        type: { eq: "arrow" },
        id: { neq: activeArrowShapeId }
      };
    });
    return computed("elbow arrow snap lines", () => {
      var _a6, _b3;
      const result = /* @__PURE__ */ new Map();
      const currentPageShapeIds = editor2.getCurrentPageShapeIds();
      const viewportBounds = editor2.getViewportPageBounds();
      for (const id of unselectedArrowShapeIds.get()) {
        if (!currentPageShapeIds.has(id)) continue;
        const shape = editor2.getShape(id);
        if ((shape == null ? void 0 : shape.type) !== "arrow") continue;
        const shapeBounds = editor2.getShapePageBounds(id);
        if (!shapeBounds || !viewportBounds.includes(shapeBounds)) continue;
        const bindings = getArrowBindings(editor2, shape);
        const pageTransform = editor2.getShapePageTransform(id);
        if (!pageTransform) continue;
        const geometry = editor2.getShapeGeometry(id);
        const pageVertices = pageTransform.applyToPoints(geometry.vertices);
        for (let i = 1; i < pageVertices.length; i++) {
          const prev = pageVertices[i - 1];
          const curr = pageVertices[i];
          let angle = Vec.Angle(prev, curr);
          if (angle < 0) angle += Math.PI;
          let set = result.get(angle);
          if (!set) {
            set = /* @__PURE__ */ new Set();
            result.set(angle, set);
          }
          const perpDistance = perpDistanceToLineAngle(prev, angle);
          set.add({
            perpDistance,
            startBoundShapeId: (_a6 = bindings.start) == null ? void 0 : _a6.toId,
            endBoundShapeId: (_b3 = bindings.end) == null ? void 0 : _b3.toId
          });
        }
      }
      return result;
    });
  }).get();
}
function perpDistanceToLineAngle(pointOnLine, lineAngle) {
  const perpDir = Vec.FromAngle(lineAngle).per();
  return Vec.Dpr(pointOnLine, perpDir);
}

// ../node_modules/tldraw/dist-esm/lib/shapes/arrow/ArrowShapeUtil.mjs
var ArrowHandles = ((ArrowHandles2) => {
  ArrowHandles2["Start"] = "start";
  ArrowHandles2["Middle"] = "middle";
  ArrowHandles2["End"] = "end";
  return ArrowHandles2;
})(ArrowHandles || {});
var ArrowShapeUtil = class extends ShapeUtil {
  constructor() {
    super(...arguments);
    __publicField(this, "options", {
      expandElbowLegLength: {
        s: 28,
        m: 36,
        l: 44,
        xl: 66
      },
      minElbowLegLength: {
        s: STROKE_SIZES2.s * 3,
        m: STROKE_SIZES2.m * 3,
        l: STROKE_SIZES2.l * 3,
        xl: STROKE_SIZES2.xl * 3
      },
      minElbowHandleDistance: 16,
      arcArrowCenterSnapDistance: 16,
      elbowArrowCenterSnapDistance: 24,
      elbowArrowEdgeSnapDistance: 20,
      elbowArrowPointSnapDistance: 24,
      elbowArrowAxisSnapDistance: 16,
      labelCenterSnapDistance: 10,
      elbowMidpointSnapDistance: 10,
      elbowMinSegmentLengthToShowMidpointHandle: 20,
      hoverPreciseTimeout: 600,
      pointingPreciseTimeout: 320,
      shouldBeExact(editor) {
        return editor.inputs.getAltKey();
      },
      shouldIgnoreTargets(editor) {
        return editor.inputs.getCtrlKey();
      },
      showTextOutline: true
    });
    __publicField(this, "_resizeInitialBindings", new WeakCache());
  }
  canEdit() {
    return true;
  }
  canBind({ toShapeType }) {
    return toShapeType !== "arrow";
  }
  canSnap() {
    return false;
  }
  hideResizeHandles() {
    return true;
  }
  hideRotateHandle() {
    return true;
  }
  hideSelectionBoundsBg() {
    return true;
  }
  hideSelectionBoundsFg() {
    return true;
  }
  hideInMinimap() {
    return true;
  }
  canBeLaidOut(shape, info) {
    if (info.type === "flip") {
      const bindings = getArrowBindings(this.editor, shape);
      const { start, end } = bindings;
      const { shapes = [] } = info;
      if (start && !shapes.find((s) => s.id === start.toId)) return false;
      if (end && !shapes.find((s) => s.id === end.toId)) return false;
    }
    return true;
  }
  getFontFaces(shape) {
    if (isEmptyRichText(shape.props.richText)) return EMPTY_ARRAY;
    return getFontsFromRichText(this.editor, shape.props.richText, {
      family: `tldraw_${shape.props.font}`,
      weight: "normal",
      style: "normal"
    });
  }
  getDefaultProps() {
    return {
      kind: "arc",
      elbowMidPoint: 0.5,
      dash: "draw",
      size: "m",
      fill: "none",
      color: "black",
      labelColor: "black",
      bend: 0,
      start: { x: 0, y: 0 },
      end: { x: 2, y: 0 },
      arrowheadStart: "none",
      arrowheadEnd: "arrow",
      richText: toRichText(""),
      labelPosition: 0.5,
      font: "draw",
      scale: 1
    };
  }
  getGeometry(shape) {
    const isEditing = this.editor.getEditingShapeId() === shape.id;
    const info = getArrowInfo(this.editor, shape);
    const debugGeom = [];
    const bodyGeom = info.type === "straight" ? new Edge2d({
      start: Vec.From(info.start.point),
      end: Vec.From(info.end.point)
    }) : info.type === "arc" ? new Arc2d({
      center: Vec.Cast(info.handleArc.center),
      start: Vec.Cast(info.start.point),
      end: Vec.Cast(info.end.point),
      sweepFlag: info.bodyArc.sweepFlag,
      largeArcFlag: info.bodyArc.largeArcFlag
    }) : new Polyline2d({ points: info.route.points });
    let labelGeom;
    if (isEditing || !isEmptyRichText(shape.props.richText)) {
      const labelPosition = getArrowLabelPosition(this.editor, shape);
      if (debugFlags.debugGeometry.get()) {
        debugGeom.push(...labelPosition.debugGeom);
      }
      labelGeom = new Rectangle2d({
        x: labelPosition.box.x,
        y: labelPosition.box.y,
        width: labelPosition.box.w,
        height: labelPosition.box.h,
        isFilled: true,
        isLabel: true
      });
    }
    return new Group2d({
      children: [...labelGeom ? [bodyGeom, labelGeom] : [bodyGeom], ...debugGeom]
    });
  }
  getHandles(shape) {
    const info = getArrowInfo(this.editor, shape);
    const handles = [
      {
        id: "start",
        type: "vertex",
        index: "a1",
        x: info.start.handle.x,
        y: info.start.handle.y
      },
      {
        id: "end",
        type: "vertex",
        index: "a3",
        x: info.end.handle.x,
        y: info.end.handle.y
      }
    ];
    if (shape.props.kind === "arc" && (info.type === "straight" || info.type === "arc")) {
      handles.push({
        id: "middle",
        type: "virtual",
        index: "a2",
        x: info.middle.x,
        y: info.middle.y
      });
    }
    if (shape.props.kind === "elbow" && info.type === "elbow" && info.route.midpointHandle) {
      const shapePageTransform = this.editor.getShapePageTransform(shape.id);
      const segmentStart = shapePageTransform.applyToPoint(info.route.midpointHandle.segmentStart);
      const segmentEnd = shapePageTransform.applyToPoint(info.route.midpointHandle.segmentEnd);
      const segmentLength = Vec.Dist(segmentStart, segmentEnd) * this.editor.getEfficientZoomLevel();
      if (segmentLength > this.options.elbowMinSegmentLengthToShowMidpointHandle) {
        handles.push({
          id: "middle",
          type: "vertex",
          index: "a2",
          x: info.route.midpointHandle.point.x,
          y: info.route.midpointHandle.point.y
        });
      }
    }
    return handles;
  }
  getText(shape) {
    return renderPlaintextFromRichText(this.editor, shape.props.richText);
  }
  onHandleDrag(shape, info) {
    const handleId = info.handle.id;
    switch (handleId) {
      case "middle":
        switch (shape.props.kind) {
          case "arc":
            return this.onArcMidpointHandleDrag(shape, info);
          case "elbow":
            return this.onElbowMidpointHandleDrag(shape, info);
          default:
            exhaustiveSwitchError(shape.props.kind);
        }
      case "start":
      case "end":
        return this.onTerminalHandleDrag(shape, info, handleId);
      default:
        exhaustiveSwitchError(handleId);
    }
  }
  onArcMidpointHandleDrag(shape, { handle }) {
    const bindings = getArrowBindings(this.editor, shape);
    const { start, end } = getArrowTerminalsInArrowSpace(this.editor, shape, bindings);
    const delta = Vec.Sub(end, start);
    const v = Vec.Per(delta);
    const med = Vec.Med(end, start);
    const A = Vec.Sub(med, v);
    const B = Vec.Add(med, v);
    const point = Vec.NearestPointOnLineSegment(A, B, handle, false);
    let bend = Vec.Dist(point, med);
    if (Vec.Clockwise(point, end, med)) bend *= -1;
    return { id: shape.id, type: shape.type, props: { bend } };
  }
  onElbowMidpointHandleDrag(shape, { handle }) {
    var _a6, _b3, _c, _d, _e;
    const info = getArrowInfo(this.editor, shape);
    if ((info == null ? void 0 : info.type) !== "elbow") return;
    const shapeToPageTransform = this.editor.getShapePageTransform(shape.id);
    const handlePagePoint = shapeToPageTransform.applyToPoint(handle);
    const axisName = (_a6 = info.route.midpointHandle) == null ? void 0 : _a6.axis;
    if (!axisName) return;
    const axis = ElbowArrowAxes[axisName];
    const midRange = info.elbow[axis.midRange];
    if (!midRange) return;
    let angle = Vec.Angle(
      shapeToPageTransform.applyToPoint(axis.v(0, 0)),
      shapeToPageTransform.applyToPoint(axis.v(0, 1))
    );
    if (angle < 0) angle += Math.PI;
    const handlePoint = perpDistanceToLineAngle(handlePagePoint, angle);
    const loPoint = perpDistanceToLineAngle(
      shapeToPageTransform.applyToPoint(axis.v(midRange.lo, 0)),
      angle
    );
    const hiPoint = perpDistanceToLineAngle(
      shapeToPageTransform.applyToPoint(axis.v(midRange.hi, 0)),
      angle
    );
    const maxSnapDistance = this.options.elbowMidpointSnapDistance / this.editor.getEfficientZoomLevel();
    const midPoint = perpDistanceToLineAngle(
      shapeToPageTransform.applyToPoint(axis.v(lerp(midRange.lo, midRange.hi, 0.5), 0)),
      angle
    );
    let snapPoint = midPoint;
    let snapDistance = Math.abs(midPoint - handlePoint);
    for (const [snapAngle2, snapLines] of getElbowArrowSnapLines(this.editor)) {
      const { isParallel, isFlippedParallel } = anglesAreApproximatelyParallel(angle, snapAngle2);
      if (isParallel || isFlippedParallel) {
        for (const snapLine of snapLines) {
          const doesShareStartIntersection = snapLine.startBoundShapeId && (snapLine.startBoundShapeId === ((_b3 = info.bindings.start) == null ? void 0 : _b3.toId) || snapLine.startBoundShapeId === ((_c = info.bindings.end) == null ? void 0 : _c.toId));
          const doesShareEndIntersection = snapLine.endBoundShapeId && (snapLine.endBoundShapeId === ((_d = info.bindings.start) == null ? void 0 : _d.toId) || snapLine.endBoundShapeId === ((_e = info.bindings.end) == null ? void 0 : _e.toId));
          if (!doesShareStartIntersection && !doesShareEndIntersection) continue;
          const point = isFlippedParallel ? -snapLine.perpDistance : snapLine.perpDistance;
          const distance = Math.abs(point - handlePoint);
          if (distance < snapDistance) {
            snapPoint = point;
            snapDistance = distance;
          }
        }
      }
    }
    if (snapDistance > maxSnapDistance) {
      snapPoint = handlePoint;
    }
    const newMid = clamp(invLerp(loPoint, hiPoint, snapPoint), 0, 1);
    return {
      id: shape.id,
      type: shape.type,
      props: {
        elbowMidPoint: newMid
      }
    };
  }
  onTerminalHandleDrag(shape, { handle, isPrecise }, handleId) {
    const bindings = getArrowBindings(this.editor, shape);
    const update = { id: shape.id, type: "arrow", props: {} };
    const currentBinding = bindings[handleId];
    const oppositeHandleId = handleId === "start" ? "end" : "start";
    const oppositeBinding = bindings[oppositeHandleId];
    const targetInfo = updateArrowTargetState({
      editor: this.editor,
      pointInPageSpace: this.editor.getShapePageTransform(shape.id).applyToPoint(handle),
      arrow: shape,
      isPrecise,
      currentBinding,
      oppositeBinding
    });
    if (!targetInfo) {
      removeArrowBinding(this.editor, shape, handleId);
      const newPoint = maybeSnapToGrid(new Vec(handle.x, handle.y), this.editor);
      update.props[handleId] = {
        x: newPoint.x,
        y: newPoint.y
      };
      return update;
    }
    const bindingProps = {
      terminal: handleId,
      normalizedAnchor: targetInfo.normalizedAnchor,
      isPrecise: targetInfo.isPrecise,
      isExact: targetInfo.isExact,
      snap: targetInfo.snap
    };
    createOrUpdateArrowBinding(this.editor, shape, targetInfo.target.id, bindingProps);
    const newBindings = getArrowBindings(this.editor, shape);
    if (newBindings.start && newBindings.end && newBindings.start.toId === newBindings.end.toId) {
      if (Vec.Equals(newBindings.start.props.normalizedAnchor, newBindings.end.props.normalizedAnchor)) {
        createOrUpdateArrowBinding(this.editor, shape, newBindings.end.toId, {
          ...newBindings.end.props,
          normalizedAnchor: {
            x: newBindings.end.props.normalizedAnchor.x + 0.05,
            y: newBindings.end.props.normalizedAnchor.y
          }
        });
      }
    }
    return update;
  }
  onTranslateStart(shape) {
    const bindings = getArrowBindings(this.editor, shape);
    if (shape.props.kind === "elbow" && this.editor.getOnlySelectedShapeId() === shape.id) {
      const info = getArrowInfo(this.editor, shape);
      if (!info) return;
      const update = { id: shape.id, type: "arrow", props: {} };
      if (bindings.start) {
        update.props.start = { x: info.start.point.x, y: info.start.point.y };
        removeArrowBinding(this.editor, shape, "start");
      }
      if (bindings.end) {
        update.props.end = { x: info.end.point.x, y: info.end.point.y };
        removeArrowBinding(this.editor, shape, "end");
      }
      return update;
    }
    const terminalsInArrowSpace = getArrowTerminalsInArrowSpace(this.editor, shape, bindings);
    const shapePageTransform = this.editor.getShapePageTransform(shape.id);
    const selectedShapeIds = this.editor.getSelectedShapeIds();
    if (bindings.start && (selectedShapeIds.includes(bindings.start.toId) || this.editor.isAncestorSelected(bindings.start.toId)) || bindings.end && (selectedShapeIds.includes(bindings.end.toId) || this.editor.isAncestorSelected(bindings.end.toId))) {
      return;
    }
    shapeAtTranslationStart.set(shape, {
      pagePosition: shapePageTransform.applyToPoint(shape),
      terminalBindings: mapObjectMapValues(terminalsInArrowSpace, (terminalName, point) => {
        const binding = bindings[terminalName];
        if (!binding) return null;
        return {
          binding,
          shapePosition: point,
          pagePosition: shapePageTransform.applyToPoint(point)
        };
      })
    });
    if (bindings.start) {
      updateArrowTerminal({
        editor: this.editor,
        arrow: shape,
        terminal: "start",
        useHandle: true
      });
      shape = this.editor.getShape(shape.id);
    }
    if (bindings.end) {
      updateArrowTerminal({
        editor: this.editor,
        arrow: shape,
        terminal: "end",
        useHandle: true
      });
    }
    for (const handleName of [
      "start",
      "end"
      /* End */
    ]) {
      const binding = bindings[handleName];
      if (!binding) continue;
      this.editor.updateBinding({
        ...binding,
        props: { ...binding.props, isPrecise: true }
      });
    }
    return;
  }
  onTranslate(initialShape, shape) {
    const atTranslationStart = shapeAtTranslationStart.get(initialShape);
    if (!atTranslationStart) return;
    const shapePageTransform = this.editor.getShapePageTransform(shape.id);
    const pageDelta = Vec.Sub(
      shapePageTransform.applyToPoint(shape),
      atTranslationStart.pagePosition
    );
    for (const terminalBinding of Object.values(atTranslationStart.terminalBindings)) {
      if (!terminalBinding) continue;
      const newPagePoint = Vec.Add(terminalBinding.pagePosition, Vec.Mul(pageDelta, 0.5));
      const newTarget = this.editor.getShapeAtPoint(newPagePoint, {
        hitInside: true,
        hitFrameInside: true,
        margin: 0,
        filter: (targetShape) => {
          return !targetShape.isLocked && this.editor.canBindShapes({ fromShape: shape, toShape: targetShape, binding: "arrow" });
        }
      });
      if ((newTarget == null ? void 0 : newTarget.id) === terminalBinding.binding.toId) {
        const targetBounds = Box.ZeroFix(this.editor.getShapeGeometry(newTarget).bounds);
        const pointInTargetSpace = this.editor.getPointInShapeSpace(newTarget, newPagePoint);
        const normalizedAnchor = {
          x: (pointInTargetSpace.x - targetBounds.minX) / targetBounds.width,
          y: (pointInTargetSpace.y - targetBounds.minY) / targetBounds.height
        };
        createOrUpdateArrowBinding(this.editor, shape, newTarget.id, {
          ...terminalBinding.binding.props,
          normalizedAnchor,
          isPrecise: true
        });
      } else {
        removeArrowBinding(this.editor, shape, terminalBinding.binding.props.terminal);
      }
    }
  }
  onResize(shape, info) {
    const { scaleX, scaleY } = info;
    const bindings = this._resizeInitialBindings.get(
      shape,
      () => getArrowBindings(this.editor, shape)
    );
    const terminals = getArrowTerminalsInArrowSpace(this.editor, shape, bindings);
    const { start, end } = structuredClone(shape.props);
    let { bend } = shape.props;
    if (!bindings.start) {
      start.x = terminals.start.x * scaleX;
      start.y = terminals.start.y * scaleY;
    }
    if (!bindings.end) {
      end.x = terminals.end.x * scaleX;
      end.y = terminals.end.y * scaleY;
    }
    const mx = Math.abs(scaleX);
    const my = Math.abs(scaleY);
    const startNormalizedAnchor = (bindings == null ? void 0 : bindings.start) ? Vec.From(bindings.start.props.normalizedAnchor) : null;
    const endNormalizedAnchor = (bindings == null ? void 0 : bindings.end) ? Vec.From(bindings.end.props.normalizedAnchor) : null;
    if (scaleX < 0 && scaleY >= 0) {
      if (bend !== 0) {
        bend *= -1;
        bend *= Math.max(mx, my);
      }
      if (startNormalizedAnchor) {
        startNormalizedAnchor.x = 1 - startNormalizedAnchor.x;
      }
      if (endNormalizedAnchor) {
        endNormalizedAnchor.x = 1 - endNormalizedAnchor.x;
      }
    } else if (scaleX >= 0 && scaleY < 0) {
      if (bend !== 0) {
        bend *= -1;
        bend *= Math.max(mx, my);
      }
      if (startNormalizedAnchor) {
        startNormalizedAnchor.y = 1 - startNormalizedAnchor.y;
      }
      if (endNormalizedAnchor) {
        endNormalizedAnchor.y = 1 - endNormalizedAnchor.y;
      }
    } else if (scaleX >= 0 && scaleY >= 0) {
      if (bend !== 0) {
        bend *= Math.max(mx, my);
      }
    } else if (scaleX < 0 && scaleY < 0) {
      if (bend !== 0) {
        bend *= Math.max(mx, my);
      }
      if (startNormalizedAnchor) {
        startNormalizedAnchor.x = 1 - startNormalizedAnchor.x;
        startNormalizedAnchor.y = 1 - startNormalizedAnchor.y;
      }
      if (endNormalizedAnchor) {
        endNormalizedAnchor.x = 1 - endNormalizedAnchor.x;
        endNormalizedAnchor.y = 1 - endNormalizedAnchor.y;
      }
    }
    if (bindings.start && startNormalizedAnchor) {
      createOrUpdateArrowBinding(this.editor, shape, bindings.start.toId, {
        ...bindings.start.props,
        normalizedAnchor: startNormalizedAnchor.toJson()
      });
    }
    if (bindings.end && endNormalizedAnchor) {
      createOrUpdateArrowBinding(this.editor, shape, bindings.end.toId, {
        ...bindings.end.props,
        normalizedAnchor: endNormalizedAnchor.toJson()
      });
    }
    const next = {
      props: {
        start,
        end,
        bend
      }
    };
    return next;
  }
  onDoubleClickHandle(shape, handle) {
    switch (handle.id) {
      case "start": {
        return {
          id: shape.id,
          type: shape.type,
          props: {
            ...shape.props,
            arrowheadStart: shape.props.arrowheadStart === "none" ? "arrow" : "none"
          }
        };
      }
      case "end": {
        return {
          id: shape.id,
          type: shape.type,
          props: {
            ...shape.props,
            arrowheadEnd: shape.props.arrowheadEnd === "none" ? "arrow" : "none"
          }
        };
      }
    }
  }
  component(shape) {
    const theme = useDefaultColorTheme();
    const onlySelectedShape = this.editor.getOnlySelectedShape();
    const shouldDisplayHandles = this.editor.isInAny(
      "select.idle",
      "select.pointing_handle",
      "select.dragging_handle",
      "select.translating",
      "arrow.dragging"
    ) && !this.editor.getIsReadonly();
    const info = getArrowInfo(this.editor, shape);
    if (!(info == null ? void 0 : info.isValid)) return null;
    const labelPosition = getArrowLabelPosition(this.editor, shape);
    const isSelected = shape.id === this.editor.getOnlySelectedShapeId();
    const isEditing = this.editor.getEditingShapeId() === shape.id;
    const showArrowLabel = isEditing || !isEmptyRichText(shape.props.richText);
    return (0, import_jsx_runtime208.jsxs)(import_jsx_runtime208.Fragment, { children: [
      (0, import_jsx_runtime208.jsxs)(SVGContainer, { style: { minWidth: 50, minHeight: 50 }, children: [
        (0, import_jsx_runtime208.jsx)(
          ArrowSvg,
          {
            shape,
            shouldDisplayHandles: shouldDisplayHandles && (onlySelectedShape == null ? void 0 : onlySelectedShape.id) === shape.id
          }
        ),
        shape.props.kind === "elbow" && debugFlags.debugElbowArrows.get() && (0, import_jsx_runtime208.jsx)(ElbowArrowDebug, { arrow: shape })
      ] }),
      showArrowLabel && (0, import_jsx_runtime208.jsx)(
        RichTextLabel,
        {
          shapeId: shape.id,
          type: "arrow",
          font: shape.props.font,
          fontSize: getArrowLabelFontSize(shape),
          lineHeight: TEXT_PROPS.lineHeight,
          align: "middle",
          verticalAlign: "middle",
          labelColor: getColorValue(theme, shape.props.labelColor, "solid"),
          richText: shape.props.richText,
          textWidth: labelPosition.box.w - ARROW_LABEL_PADDING * 2 * shape.props.scale,
          isSelected,
          padding: 0,
          showTextOutline: this.options.showTextOutline,
          style: {
            transform: `translate(${labelPosition.box.center.x}px, ${labelPosition.box.center.y}px)`
          }
        }
      )
    ] });
  }
  indicator(shape) {
    const isEditing = useIsEditing(shape.id);
    const clipPathId = useSharedSafeId(shape.id + "_clip");
    const info = getArrowInfo(this.editor, shape);
    if (!info) return null;
    const { start, end } = getArrowTerminalsInArrowSpace(this.editor, shape, info == null ? void 0 : info.bindings);
    const geometry = this.editor.getShapeGeometry(shape);
    const bounds = geometry.bounds;
    const isEmpty = isEmptyRichText(shape.props.richText);
    const labelGeometry = isEditing || !isEmpty ? geometry.children[1] : null;
    if (Vec.Equals(start, end)) return null;
    const strokeWidth = STROKE_SIZES2[shape.props.size] * shape.props.scale;
    const as = info.start.arrowhead && getArrowheadPathForType(info, "start", strokeWidth);
    const ae = info.end.arrowhead && getArrowheadPathForType(info, "end", strokeWidth);
    const includeClipPath = as && info.start.arrowhead !== "arrow" || ae && info.end.arrowhead !== "arrow" || !!labelGeometry;
    const labelBounds = labelGeometry ? labelGeometry.getBounds() : new Box(0, 0, 0, 0);
    if (isEditing && labelGeometry) {
      return (0, import_jsx_runtime208.jsx)(
        "rect",
        {
          x: toDomPrecision(labelBounds.x),
          y: toDomPrecision(labelBounds.y),
          width: labelBounds.w,
          height: labelBounds.h,
          rx: 3.5 * shape.props.scale,
          ry: 3.5 * shape.props.scale
        }
      );
    }
    const clipStartArrowhead = !(info.start.arrowhead === "none" || info.start.arrowhead === "arrow");
    const clipEndArrowhead = !(info.end.arrowhead === "none" || info.end.arrowhead === "arrow");
    return (0, import_jsx_runtime208.jsxs)("g", { children: [
      includeClipPath && (0, import_jsx_runtime208.jsx)("defs", { children: (0, import_jsx_runtime208.jsx)(
        ArrowClipPath,
        {
          radius: 3.5 * shape.props.scale,
          hasText: !isEmpty,
          bounds,
          labelBounds,
          as: clipStartArrowhead && as ? as : "",
          ae: clipEndArrowhead && ae ? ae : ""
        }
      ) }),
      (0, import_jsx_runtime208.jsxs)(
        "g",
        {
          style: {
            clipPath: includeClipPath ? `url(#${clipPathId})` : void 0,
            WebkitClipPath: includeClipPath ? `url(#${clipPathId})` : void 0
          },
          children: [
            includeClipPath && (0, import_jsx_runtime208.jsx)(
              "rect",
              {
                x: bounds.minX - 100,
                y: bounds.minY - 100,
                width: bounds.width + 200,
                height: bounds.height + 200,
                opacity: 0
              }
            ),
            getArrowBodyPath(
              shape,
              info,
              shape.props.dash === "draw" ? {
                style: "draw",
                randomSeed: shape.id,
                strokeWidth: 1,
                passes: 1,
                offset: 0,
                roundness: strokeWidth * 2,
                props: { strokeWidth: void 0 }
              } : { style: "solid", strokeWidth: 1, props: { strokeWidth: void 0 } }
            )
          ]
        }
      ),
      as && (0, import_jsx_runtime208.jsx)("path", { d: as }),
      ae && (0, import_jsx_runtime208.jsx)("path", { d: ae }),
      labelGeometry && (0, import_jsx_runtime208.jsx)(
        "rect",
        {
          x: toDomPrecision(labelBounds.x),
          y: toDomPrecision(labelBounds.y),
          width: labelBounds.w,
          height: labelBounds.h,
          rx: 3.5,
          ry: 3.5
        }
      )
    ] });
  }
  onEditStart(shape) {
    if (isEmptyRichText(shape.props.richText)) {
      const labelPosition = getArrowLabelDefaultPosition(this.editor, shape);
      this.editor.updateShape({
        id: shape.id,
        type: shape.type,
        props: { labelPosition }
      });
    }
  }
  toSvg(shape, ctx) {
    ctx.addExportDef(getFillDefForExport(shape.props.fill));
    const theme = getDefaultColorTheme(ctx);
    const scaleFactor = 1 / shape.props.scale;
    return (0, import_jsx_runtime208.jsxs)("g", { transform: `scale(${scaleFactor})`, children: [
      (0, import_jsx_runtime208.jsx)(ArrowSvg, { shape, shouldDisplayHandles: false }),
      (0, import_jsx_runtime208.jsx)(
        RichTextSVG,
        {
          fontSize: getArrowLabelFontSize(shape),
          font: shape.props.font,
          align: "middle",
          verticalAlign: "middle",
          labelColor: getColorValue(theme, shape.props.labelColor, "solid"),
          richText: shape.props.richText,
          bounds: getArrowLabelPosition(this.editor, shape).box.clone().expandBy(-ARROW_LABEL_PADDING * shape.props.scale),
          padding: 0,
          showTextOutline: this.options.showTextOutline
        }
      )
    ] });
  }
  getCanvasSvgDefs() {
    return [
      getFillDefForCanvas(),
      {
        key: `arrow:dot`,
        component: ArrowheadDotDef
      },
      {
        key: `arrow:cross`,
        component: ArrowheadCrossDef
      }
    ];
  }
  getInterpolatedProps(startShape, endShape, progress) {
    return {
      ...progress > 0.5 ? endShape.props : startShape.props,
      scale: lerp(startShape.props.scale, endShape.props.scale, progress),
      start: {
        x: lerp(startShape.props.start.x, endShape.props.start.x, progress),
        y: lerp(startShape.props.start.y, endShape.props.start.y, progress)
      },
      end: {
        x: lerp(startShape.props.end.x, endShape.props.end.x, progress),
        y: lerp(startShape.props.end.y, endShape.props.end.y, progress)
      },
      bend: lerp(startShape.props.bend, endShape.props.bend, progress),
      labelPosition: lerp(startShape.props.labelPosition, endShape.props.labelPosition, progress)
    };
  }
};
__publicField(ArrowShapeUtil, "type", "arrow");
__publicField(ArrowShapeUtil, "props", arrowShapeProps);
__publicField(ArrowShapeUtil, "migrations", arrowShapeMigrations);
var ArrowSvg = track(function ArrowSvg2({
  shape,
  shouldDisplayHandles
}) {
  const editor = useEditor();
  const theme = useDefaultColorTheme();
  const info = getArrowInfo(editor, shape);
  const isForceSolid = useEfficientZoomThreshold(shape.props.scale * 0.25);
  const clipPathId = useSharedSafeId(shape.id + "_clip");
  const arrowheadDotId = useSharedSafeId("arrowhead-dot");
  const arrowheadCrossId = useSharedSafeId("arrowhead-cross");
  const isEditing = useIsEditing(shape.id);
  const geometry = editor.getShapeGeometry(shape);
  if (!geometry) return null;
  const bounds = Box.ZeroFix(geometry.bounds);
  const bindings = getArrowBindings(editor, shape);
  const isEmpty = isEmptyRichText(shape.props.richText);
  if (!(info == null ? void 0 : info.isValid)) return null;
  const strokeWidth = STROKE_SIZES2[shape.props.size] * shape.props.scale;
  const as = info.start.arrowhead && getArrowheadPathForType(info, "start", strokeWidth);
  const ae = info.end.arrowhead && getArrowheadPathForType(info, "end", strokeWidth);
  let handlePath = null;
  if (shouldDisplayHandles && (bindings.start || bindings.end)) {
    handlePath = getArrowHandlePath(info, {
      style: "dashed",
      start: "skip",
      end: "skip",
      lengthRatio: 2.5,
      strokeWidth: 2 / editor.getEfficientZoomLevel(),
      props: {
        className: "tl-arrow-hint",
        markerStart: bindings.start ? bindings.start.props.isExact ? "" : bindings.start.props.isPrecise ? `url(#${arrowheadCrossId})` : `url(#${arrowheadDotId})` : "",
        markerEnd: bindings.end ? bindings.end.props.isExact ? "" : bindings.end.props.isPrecise ? `url(#${arrowheadCrossId})` : `url(#${arrowheadDotId})` : "",
        opacity: 0.16
      }
    });
  }
  const labelPosition = getArrowLabelPosition(editor, shape);
  const clipStartArrowhead = !(info.start.arrowhead === "none" || info.start.arrowhead === "arrow");
  const clipEndArrowhead = !(info.end.arrowhead === "none" || info.end.arrowhead === "arrow");
  return (0, import_jsx_runtime208.jsxs)(import_jsx_runtime208.Fragment, { children: [
    (0, import_jsx_runtime208.jsx)("defs", { children: (0, import_jsx_runtime208.jsx)("clipPath", { id: clipPathId, children: (0, import_jsx_runtime208.jsx)(
      ArrowClipPath,
      {
        radius: 3.5 * shape.props.scale,
        hasText: isEditing || !isEmpty,
        bounds,
        labelBounds: labelPosition.box,
        as: clipStartArrowhead && as ? as : "",
        ae: clipEndArrowhead && ae ? ae : ""
      }
    ) }) }),
    (0, import_jsx_runtime208.jsxs)(
      "g",
      {
        fill: "none",
        stroke: getColorValue(theme, shape.props.color, "solid"),
        strokeWidth,
        strokeLinejoin: "round",
        strokeLinecap: "round",
        pointerEvents: "none",
        children: [
          handlePath,
          (0, import_jsx_runtime208.jsxs)(
            "g",
            {
              style: {
                clipPath: `url(#${clipPathId})`,
                WebkitClipPath: `url(#${clipPathId})`
              },
              children: [
                (0, import_jsx_runtime208.jsx)(
                  "rect",
                  {
                    x: toDomPrecision(bounds.minX - 100),
                    y: toDomPrecision(bounds.minY - 100),
                    width: toDomPrecision(bounds.width + 200),
                    height: toDomPrecision(bounds.height + 200),
                    opacity: 0
                  }
                ),
                getArrowBodyPath(shape, info, {
                  style: shape.props.dash,
                  strokeWidth,
                  forceSolid: isForceSolid,
                  randomSeed: shape.id
                })
              ]
            }
          ),
          as && clipStartArrowhead && shape.props.fill !== "none" && (0, import_jsx_runtime208.jsx)(
            ShapeFill,
            {
              theme,
              d: as,
              color: shape.props.color,
              fill: shape.props.fill,
              scale: shape.props.scale
            }
          ),
          ae && clipEndArrowhead && shape.props.fill !== "none" && (0, import_jsx_runtime208.jsx)(
            ShapeFill,
            {
              theme,
              d: ae,
              color: shape.props.color,
              fill: shape.props.fill,
              scale: shape.props.scale
            }
          ),
          as && (0, import_jsx_runtime208.jsx)("path", { d: as }),
          ae && (0, import_jsx_runtime208.jsx)("path", { d: ae })
        ]
      }
    )
  ] });
});
function ArrowClipPath({
  radius,
  hasText,
  bounds,
  labelBounds,
  as,
  ae
}) {
  const path = (0, import_react141.useMemo)(() => {
    const path2 = new PathBuilder();
    path2.moveTo(bounds.left - 100, bounds.top - 100).lineTo(bounds.right + 100, bounds.top - 100).lineTo(bounds.right + 100, bounds.bottom + 100).lineTo(bounds.left - 100, bounds.bottom + 100).close();
    if (hasText) {
      path2.moveTo(labelBounds.left, labelBounds.top + radius).lineTo(labelBounds.left, labelBounds.bottom - radius).circularArcTo(radius, false, false, labelBounds.left + radius, labelBounds.bottom).lineTo(labelBounds.right - radius, labelBounds.bottom).circularArcTo(radius, false, false, labelBounds.right, labelBounds.bottom - radius).lineTo(labelBounds.right, labelBounds.top + radius).circularArcTo(radius, false, false, labelBounds.right - radius, labelBounds.top).lineTo(labelBounds.left + radius, labelBounds.top).circularArcTo(radius, false, false, labelBounds.left, labelBounds.top + radius).close();
    }
    return path2.toD();
  }, [
    radius,
    hasText,
    bounds.bottom,
    bounds.left,
    bounds.right,
    bounds.top,
    labelBounds.bottom,
    labelBounds.left,
    labelBounds.right,
    labelBounds.top
  ]);
  return (0, import_jsx_runtime208.jsx)("path", { d: `${path}${as}${ae}` });
}
var shapeAtTranslationStart = /* @__PURE__ */ new WeakMap();
function ArrowheadDotDef() {
  const id = useSharedSafeId("arrowhead-dot");
  return (0, import_jsx_runtime208.jsx)("marker", { id, className: "tl-arrow-hint", refX: "3.0", refY: "3.0", orient: "0", children: (0, import_jsx_runtime208.jsx)("circle", { cx: "3", cy: "3", r: "2", strokeDasharray: "100%" }) });
}
function ArrowheadCrossDef() {
  const id = useSharedSafeId("arrowhead-cross");
  return (0, import_jsx_runtime208.jsxs)("marker", { id, className: "tl-arrow-hint", refX: "3.0", refY: "3.0", orient: "auto", children: [
    (0, import_jsx_runtime208.jsx)("line", { x1: "1.5", y1: "1.5", x2: "4.5", y2: "4.5", strokeDasharray: "100%" }),
    (0, import_jsx_runtime208.jsx)("line", { x1: "1.5", y1: "4.5", x2: "4.5", y2: "1.5", strokeDasharray: "100%" })
  ] });
}
function anglesAreApproximatelyParallel(a, b, tolerance = 1e-4) {
  const diff = Math.abs(a - b);
  const isParallel = diff < tolerance;
  const isFlippedParallel = Math.abs(diff - Math.PI) < tolerance;
  const is360Parallel = Math.abs(diff - PI2) < tolerance;
  return { isParallel: isParallel || is360Parallel, isFlippedParallel };
}

// ../node_modules/tldraw/dist-esm/lib/shapes/bookmark/BookmarkShapeUtil.mjs
var import_jsx_runtime210 = __toESM(require_jsx_runtime(), 1);
var import_classnames35 = __toESM(require_classnames(), 1);
var import_react143 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/shapes/shared/HyperlinkButton.mjs
var import_jsx_runtime209 = __toESM(require_jsx_runtime(), 1);
var import_classnames34 = __toESM(require_classnames(), 1);
var import_react142 = __toESM(require_react(), 1);
var LINK_ICON = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' fill='none'%3E%3Cpath stroke='%23000' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M13 5H7a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6M19 5h6m0 0v6m0-6L13 17'/%3E%3C/svg%3E";
function HyperlinkButton({ url }) {
  const editor = useEditor();
  const hideButton = useEfficientZoomThreshold();
  const markAsHandledOnShiftKey = (0, import_react142.useCallback)(
    (e) => {
      if (!editor.inputs.getShiftKey()) editor.markEventAsHandled(e);
    },
    [editor]
  );
  return (0, import_jsx_runtime209.jsx)(
    "a",
    {
      className: (0, import_classnames34.default)("tl-hyperlink-button", {
        "tl-hyperlink-button__hidden": hideButton
      }),
      href: url,
      target: "_blank",
      rel: "noopener noreferrer",
      onPointerDown: markAsHandledOnShiftKey,
      onPointerUp: markAsHandledOnShiftKey,
      title: url,
      draggable: false,
      children: (0, import_jsx_runtime209.jsx)(
        "div",
        {
          className: "tl-hyperlink__icon",
          style: {
            mask: `url("${LINK_ICON}") center 100% / 100% no-repeat`,
            WebkitMask: `url("${LINK_ICON}") center 100% / 100% no-repeat`
          }
        }
      )
    }
  );
}

// ../node_modules/tldraw/dist-esm/lib/shapes/shared/icons-editor.mjs
var LINK_ICON2 = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' fill='none'%3E%3Cpath stroke='%23000' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M13 5H7a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6M19 5h6m0 0v6m0-6L13 17'/%3E%3C/svg%3E";

// ../node_modules/tldraw/dist-esm/lib/shapes/shared/rotated-box-shadow.mjs
var ROTATING_BOX_SHADOWS = [
  {
    offsetX: 0,
    offsetY: 2,
    blur: 4,
    spread: 0,
    color: "#00000029"
  },
  {
    offsetX: 0,
    offsetY: 3,
    blur: 6,
    spread: 0,
    color: "#0000001f"
  }
];
function getRotatedBoxShadow(rotation) {
  const cssStrings = ROTATING_BOX_SHADOWS.map((shadow) => {
    const { offsetX, offsetY, blur: blur2, spread, color } = shadow;
    const vec = new Vec(offsetX, offsetY);
    const { x, y } = vec.rot(-rotation);
    return `${x}px ${y}px ${blur2}px ${spread}px ${color}`;
  });
  return cssStrings.join(", ");
}

// ../node_modules/tldraw/dist-esm/lib/shapes/bookmark/BookmarkShapeUtil.mjs
var BookmarkShapeUtil = class extends BaseBoxShapeUtil {
  canResize() {
    return false;
  }
  hideSelectionBoundsFg() {
    return true;
  }
  getText(shape) {
    return shape.props.url;
  }
  getAriaDescriptor(shape) {
    const asset = shape.props.assetId ? this.editor.getAsset(shape.props.assetId) : null;
    if (!(asset == null ? void 0 : asset.props.title)) return void 0;
    return convertCommonTitleHTMLEntities(asset.props.title) + (asset.props.description ? ", " + asset.props.description : "");
  }
  getDefaultProps() {
    return {
      url: "",
      w: BOOKMARK_WIDTH,
      h: BOOKMARK_HEIGHT,
      assetId: null
    };
  }
  component(shape) {
    const { assetId, url, h: h2 } = shape.props;
    const rotation = this.editor.getShapePageTransform(shape).rotation();
    return (0, import_jsx_runtime210.jsx)(BookmarkShapeComponent, { assetId, url, h: h2, rotation });
  }
  indicator(shape) {
    return (0, import_jsx_runtime210.jsx)(BookmarkIndicatorComponent, { w: shape.props.w, h: shape.props.h });
  }
  onBeforeCreate(next) {
    return setBookmarkHeight(this.editor, next);
  }
  onBeforeUpdate(prev, shape) {
    if (prev.props.url !== shape.props.url) {
      if (!validation_exports.linkUrl.isValid(shape.props.url)) {
        return { ...shape, props: { ...shape.props, url: prev.props.url } };
      } else {
        updateBookmarkAssetOnUrlChange(this.editor, shape);
      }
    }
    if (prev.props.assetId !== shape.props.assetId) {
      return setBookmarkHeight(this.editor, shape);
    }
  }
  getInterpolatedProps(startShape, endShape, t2) {
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      w: lerp(startShape.props.w, endShape.props.w, t2),
      h: lerp(startShape.props.h, endShape.props.h, t2)
    };
  }
};
__publicField(BookmarkShapeUtil, "type", "bookmark");
__publicField(BookmarkShapeUtil, "props", bookmarkShapeProps);
__publicField(BookmarkShapeUtil, "migrations", bookmarkShapeMigrations);
function BookmarkIndicatorComponent({ w, h: h2 }) {
  return (0, import_jsx_runtime210.jsx)("rect", { width: toDomPrecision(w), height: toDomPrecision(h2), rx: "6", ry: "6" });
}
function BookmarkShapeComponent({
  assetId,
  rotation,
  url,
  h: h2,
  showImageContainer = true
}) {
  const editor = useEditor();
  const asset = assetId ? editor.getAsset(assetId) : null;
  const isSafariExport = !!useSvgExportContext() && tlenv.isSafari;
  const address = getHumanReadableAddress(url);
  const [isFaviconValid, setIsFaviconValid] = (0, import_react143.useState)(true);
  const onFaviconError = () => setIsFaviconValid(false);
  const markAsHandledOnShiftKey = (0, import_react143.useCallback)(
    (e) => {
      if (!editor.inputs.getShiftKey()) editor.markEventAsHandled(e);
    },
    [editor]
  );
  return (0, import_jsx_runtime210.jsx)(HTMLContainer, { children: (0, import_jsx_runtime210.jsxs)(
    "div",
    {
      className: (0, import_classnames35.default)(
        "tl-bookmark__container",
        isSafariExport && "tl-bookmark__container--safariExport"
      ),
      style: {
        boxShadow: isSafariExport ? void 0 : getRotatedBoxShadow(rotation),
        maxHeight: h2
      },
      children: [
        showImageContainer && (!asset || asset.props.image) && (0, import_jsx_runtime210.jsxs)("div", { className: "tl-bookmark__image_container", children: [
          asset ? (0, import_jsx_runtime210.jsx)(
            "img",
            {
              className: "tl-bookmark__image",
              draggable: false,
              referrerPolicy: "strict-origin-when-cross-origin",
              src: asset == null ? void 0 : asset.props.image,
              alt: (asset == null ? void 0 : asset.props.title) || ""
            }
          ) : (0, import_jsx_runtime210.jsx)("div", { className: "tl-bookmark__placeholder" }),
          (asset == null ? void 0 : asset.props.image) && (0, import_jsx_runtime210.jsx)(HyperlinkButton, { url })
        ] }),
        (0, import_jsx_runtime210.jsxs)("div", { className: "tl-bookmark__copy_container", children: [
          (asset == null ? void 0 : asset.props.title) ? (0, import_jsx_runtime210.jsx)(
            "a",
            {
              className: "tl-bookmark__link",
              href: url || "",
              target: "_blank",
              rel: "noopener noreferrer",
              draggable: false,
              onPointerDown: markAsHandledOnShiftKey,
              onPointerUp: markAsHandledOnShiftKey,
              children: (0, import_jsx_runtime210.jsx)("h2", { className: "tl-bookmark__heading", children: convertCommonTitleHTMLEntities(asset.props.title) })
            }
          ) : null,
          (asset == null ? void 0 : asset.props.description) && (asset == null ? void 0 : asset.props.image) ? (0, import_jsx_runtime210.jsx)("p", { className: "tl-bookmark__description", children: asset.props.description }) : null,
          (0, import_jsx_runtime210.jsxs)(
            "a",
            {
              className: "tl-bookmark__link",
              href: url || "",
              target: "_blank",
              rel: "noopener noreferrer",
              draggable: false,
              onPointerDown: markAsHandledOnShiftKey,
              onPointerUp: markAsHandledOnShiftKey,
              children: [
                isFaviconValid && (asset == null ? void 0 : asset.props.favicon) ? (0, import_jsx_runtime210.jsx)(
                  "img",
                  {
                    className: "tl-bookmark__favicon",
                    src: asset == null ? void 0 : asset.props.favicon,
                    referrerPolicy: "strict-origin-when-cross-origin",
                    onError: onFaviconError,
                    alt: `favicon of ${address}`
                  }
                ) : (0, import_jsx_runtime210.jsx)(
                  "div",
                  {
                    className: "tl-hyperlink__icon",
                    style: {
                      mask: `url("${LINK_ICON2}") center 100% / 100% no-repeat`,
                      WebkitMask: `url("${LINK_ICON2}") center 100% / 100% no-repeat`
                    }
                  }
                ),
                (0, import_jsx_runtime210.jsx)("span", { children: address })
              ]
            }
          )
        ] })
      ]
    }
  ) });
}

// ../node_modules/tldraw/dist-esm/lib/shapes/draw/DrawShapeUtil.mjs
var import_jsx_runtime211 = __toESM(require_jsx_runtime(), 1);

// ../node_modules/tldraw/dist-esm/lib/shapes/shared/freehand/svg.mjs
function getSvgPathFromStrokePoints(points, closed = false) {
  const len = points.length;
  if (len < 2) {
    return "";
  }
  let a = points[0].point;
  let b = points[1].point;
  if (len === 2) {
    return `M${precise(a)}L${precise(b)}`;
  }
  let result = "";
  for (let i = 2, max2 = len - 1; i < max2; i++) {
    a = points[i].point;
    b = points[i + 1].point;
    result += average(a, b);
  }
  if (closed) {
    return `M${average(points[0].point, points[1].point)}Q${precise(points[1].point)}${average(
      points[1].point,
      points[2].point
    )}T${result}${average(points[len - 1].point, points[0].point)}${average(
      points[0].point,
      points[1].point
    )}Z`;
  } else {
    return `M${precise(points[0].point)}Q${precise(points[1].point)}${average(
      points[1].point,
      points[2].point
    )}${points.length > 3 ? "T" : ""}${result}L${precise(points[len - 1].point)}`;
  }
}

// ../node_modules/tldraw/dist-esm/lib/shapes/shared/freehand/svgInk.mjs
function svgInk(rawInputPoints, options2 = {}) {
  const { start = {}, end = {} } = options2;
  const { cap: capStart = true } = start;
  const { cap: capEnd = true } = end;
  assert(!start.taper && !end.taper, "cap taper not supported here");
  assert(!start.easing && !end.easing, "cap easing not supported here");
  assert(capStart && capEnd, "cap must be true");
  const points = getStrokePoints(rawInputPoints, options2);
  setStrokePointRadii(points, options2);
  const partitions = partitionAtElbows(points);
  let svg = "";
  for (const partition2 of partitions) {
    svg += renderPartition(partition2, options2);
  }
  return svg;
}
function partitionAtElbows(points) {
  if (points.length <= 2) return [points];
  const result = [];
  let currentPartition = [points[0]];
  let prevV = Vec.Sub(points[1].point, points[0].point).uni();
  let nextV;
  let dpr;
  let prevPoint, thisPoint, nextPoint;
  for (let i = 1, n = points.length; i < n - 1; i++) {
    prevPoint = points[i - 1];
    thisPoint = points[i];
    nextPoint = points[i + 1];
    nextV = Vec.Sub(nextPoint.point, thisPoint.point).uni();
    dpr = Vec.Dpr(prevV, nextV);
    prevV = nextV;
    if (dpr < -0.8) {
      const elbowPoint = {
        ...thisPoint,
        point: thisPoint.input
      };
      currentPartition.push(elbowPoint);
      result.push(cleanUpPartition(currentPartition));
      currentPartition = [elbowPoint];
      continue;
    }
    currentPartition.push(thisPoint);
    if (dpr > 0.7) {
      continue;
    }
    if ((Vec.Dist2(prevPoint.point, thisPoint.point) + Vec.Dist2(thisPoint.point, nextPoint.point)) / ((prevPoint.radius + thisPoint.radius + nextPoint.radius) / 3) ** 2 < 1.5) {
      currentPartition.push(thisPoint);
      result.push(cleanUpPartition(currentPartition));
      currentPartition = [thisPoint];
      continue;
    }
  }
  currentPartition.push(points[points.length - 1]);
  result.push(cleanUpPartition(currentPartition));
  return result;
}
function cleanUpPartition(partition2) {
  const startPoint = partition2[0];
  let nextPoint;
  while (partition2.length > 2) {
    nextPoint = partition2[1];
    if (Vec.Dist2(startPoint.point, nextPoint.point) < ((startPoint.radius + nextPoint.radius) / 2 * 0.5) ** 2) {
      partition2.splice(1, 1);
    } else {
      break;
    }
  }
  const endPoint = partition2[partition2.length - 1];
  let prevPoint;
  while (partition2.length > 2) {
    prevPoint = partition2[partition2.length - 2];
    if (Vec.Dist2(endPoint.point, prevPoint.point) < ((endPoint.radius + prevPoint.radius) / 2 * 0.5) ** 2) {
      partition2.splice(partition2.length - 2, 1);
    } else {
      break;
    }
  }
  if (partition2.length > 1) {
    partition2[0] = {
      ...partition2[0],
      vector: Vec.Sub(partition2[0].point, partition2[1].point).uni()
    };
    partition2[partition2.length - 1] = {
      ...partition2[partition2.length - 1],
      vector: Vec.Sub(
        partition2[partition2.length - 2].point,
        partition2[partition2.length - 1].point
      ).uni()
    };
  }
  return partition2;
}
function circlePath(cx, cy, r) {
  return "M " + cx + " " + cy + " m -" + r + ", 0 a " + r + "," + r + " 0 1,1 " + r * 2 + ",0 a " + r + "," + r + " 0 1,1 -" + r * 2 + ",0";
}
function renderPartition(strokePoints, options2 = {}) {
  if (strokePoints.length === 0) return "";
  if (strokePoints.length === 1) {
    return circlePath(strokePoints[0].point.x, strokePoints[0].point.y, strokePoints[0].radius);
  }
  const { left, right } = getStrokeOutlineTracks(strokePoints, options2);
  right.reverse();
  let svg = `M${precise(left[0])}T`;
  for (let i = 1; i < left.length; i++) {
    svg += average(left[i - 1], left[i]);
  }
  {
    const point = strokePoints[strokePoints.length - 1];
    const radius = point.radius;
    const direction = point.vector.clone().per().neg();
    const arcStart = Vec.Add(point.point, Vec.Mul(direction, radius));
    const arcEnd = Vec.Add(point.point, Vec.Mul(direction, -radius));
    svg += `${precise(arcStart)}A${toDomPrecision(radius)},${toDomPrecision(
      radius
    )} 0 0 1 ${precise(arcEnd)}T`;
  }
  for (let i = 1; i < right.length; i++) {
    svg += average(right[i - 1], right[i]);
  }
  {
    const point = strokePoints[0];
    const radius = point.radius;
    const direction = point.vector.clone().per();
    const arcStart = Vec.Add(point.point, Vec.Mul(direction, radius));
    const arcEnd = Vec.Add(point.point, Vec.Mul(direction, -radius));
    svg += `${precise(arcStart)}A${toDomPrecision(radius)},${toDomPrecision(
      radius
    )} 0 0 1 ${precise(arcEnd)}Z`;
  }
  return svg;
}

// ../node_modules/tldraw/dist-esm/lib/shapes/shared/interpolate-props.mjs
var interpolateSegments = (startSegments, endSegments, progress) => {
  const startPoints = [];
  const endPoints = [];
  startSegments.forEach((segment) => startPoints.push(...b64Vecs.decodePoints(segment.path)));
  endSegments.forEach((segment) => endPoints.push(...b64Vecs.decodePoints(segment.path)));
  const maxLength = Math.max(startPoints.length, endPoints.length);
  const pointsToUseStart = [];
  const pointsToUseEnd = [];
  for (let i = 0; i < maxLength; i++) {
    pointsToUseStart.push(startPoints[i] || startPoints[startPoints.length - 1]);
    pointsToUseEnd.push(endPoints[i] || endPoints[endPoints.length - 1]);
  }
  const interpolatedPoints = pointsToUseStart.map((point, k) => {
    let z = 0.5;
    if (pointsToUseEnd[k].z !== void 0 && point.z !== void 0) {
      z = lerp(point.z, pointsToUseEnd[k].z, progress);
    }
    return {
      x: lerp(point.x, pointsToUseEnd[k].x, progress),
      y: lerp(point.y, pointsToUseEnd[k].y, progress),
      z
    };
  });
  return [
    {
      type: "free",
      path: b64Vecs.encodePoints(interpolatedPoints)
    }
  ];
};

// ../node_modules/tldraw/dist-esm/lib/shapes/draw/DrawShapeUtil.mjs
var DrawShapeUtil = class extends ShapeUtil {
  constructor() {
    super(...arguments);
    __publicField(this, "options", {
      maxPointsPerShape: 600
    });
  }
  hideResizeHandles(shape) {
    return getIsDot(shape);
  }
  hideRotateHandle(shape) {
    return getIsDot(shape);
  }
  hideSelectionBoundsFg(shape) {
    return getIsDot(shape);
  }
  getDefaultProps() {
    return {
      segments: [],
      color: "black",
      fill: "none",
      dash: "draw",
      size: "m",
      isComplete: false,
      isClosed: false,
      isPen: false,
      scale: 1,
      scaleX: 1,
      scaleY: 1
    };
  }
  getGeometry(shape) {
    const points = getPointsFromDrawSegments(
      shape.props.segments,
      shape.props.scaleX,
      shape.props.scaleY
    );
    const sw = (STROKE_SIZES2[shape.props.size] + 1) * shape.props.scale;
    if (shape.props.segments.length === 1) {
      const box = Box.FromPoints(points);
      if (box.width < sw * 2 && box.height < sw * 2) {
        return new Circle2d({
          x: -sw,
          y: -sw,
          radius: sw,
          isFilled: true
        });
      }
    }
    const strokePoints = getStrokePoints(
      points,
      getFreehandOptions(shape.props, sw, shape.props.isPen, true)
    ).map((p) => p.point);
    if (shape.props.isClosed && strokePoints.length > 2) {
      return new Polygon2d({
        points: strokePoints,
        isFilled: shape.props.fill !== "none"
      });
    }
    if (strokePoints.length === 1) {
      return new Circle2d({
        x: -sw,
        y: -sw,
        radius: sw,
        isFilled: true
      });
    }
    return new Polyline2d({
      points: strokePoints
    });
  }
  component(shape) {
    return (0, import_jsx_runtime211.jsx)(SVGContainer, { children: (0, import_jsx_runtime211.jsx)(DrawShapeSvg, { shape }) });
  }
  indicator(shape) {
    var _a6;
    const allPointsFromSegments = getPointsFromDrawSegments(
      shape.props.segments,
      shape.props.scaleX,
      shape.props.scaleY
    );
    let sw = (STROKE_SIZES2[shape.props.size] + 1) * shape.props.scale;
    const forceSolid = useValue(
      "force solid",
      () => {
        const zoomLevel = this.editor.getEfficientZoomLevel();
        return zoomLevel < 0.5 && zoomLevel < 1.5 / sw;
      },
      [this.editor, sw]
    );
    if (!forceSolid && !shape.props.isPen && shape.props.dash === "draw" && allPointsFromSegments.length === 1) {
      sw += rng(shape.id)() * (sw / 6);
    }
    const showAsComplete = shape.props.isComplete || ((_a6 = last(shape.props.segments)) == null ? void 0 : _a6.type) === "straight";
    const options2 = getFreehandOptions(shape.props, sw, showAsComplete, true);
    const strokePoints = getStrokePoints(allPointsFromSegments, options2);
    const solidStrokePath = strokePoints.length > 1 ? getSvgPathFromStrokePoints(strokePoints, shape.props.isClosed) : getDot(allPointsFromSegments[0], sw);
    return (0, import_jsx_runtime211.jsx)("path", { d: solidStrokePath });
  }
  toSvg(shape, ctx) {
    ctx.addExportDef(getFillDefForExport(shape.props.fill));
    const scaleFactor = 1 / shape.props.scale;
    return (0, import_jsx_runtime211.jsx)("g", { transform: `scale(${scaleFactor})`, children: (0, import_jsx_runtime211.jsx)(DrawShapeSvg, { shape, zoomOverride: 1 }) });
  }
  getCanvasSvgDefs() {
    return [getFillDefForCanvas()];
  }
  onResize(shape, info) {
    const { scaleX, scaleY } = info;
    return {
      props: {
        scaleX: scaleX * shape.props.scaleX,
        scaleY: scaleY * shape.props.scaleY
      }
    };
  }
  expandSelectionOutlinePx(shape) {
    const multiplier = shape.props.dash === "draw" ? 1.6 : 1;
    return STROKE_SIZES2[shape.props.size] * multiplier / 2 * shape.props.scale;
  }
  getInterpolatedProps(startShape, endShape, t2) {
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      segments: interpolateSegments(startShape.props.segments, endShape.props.segments, t2),
      scale: lerp(startShape.props.scale, endShape.props.scale, t2)
    };
  }
};
__publicField(DrawShapeUtil, "type", "draw");
__publicField(DrawShapeUtil, "props", drawShapeProps);
__publicField(DrawShapeUtil, "migrations", drawShapeMigrations);
function getDot(point, sw) {
  const r = (sw + 1) * 0.5;
  return `M ${point.x} ${point.y} m -${r}, 0 a ${r},${r} 0 1,0 ${r * 2},0 a ${r},${r} 0 1,0 -${r * 2},0`;
}
function getIsDot(shape) {
  return shape.props.segments.length === 1 && shape.props.segments[0].path.length < 24;
}
function DrawShapeSvg({ shape, zoomOverride }) {
  var _a6;
  const theme = useDefaultColorTheme();
  const editor = useEditor();
  const allPointsFromSegments = getPointsFromDrawSegments(
    shape.props.segments,
    shape.props.scaleX,
    shape.props.scaleY
  );
  const showAsComplete = shape.props.isComplete || ((_a6 = last(shape.props.segments)) == null ? void 0 : _a6.type) === "straight";
  let sw = (STROKE_SIZES2[shape.props.size] + 1) * shape.props.scale;
  const forceSolid = useValue(
    "force solid",
    () => {
      const zoomLevel = zoomOverride ?? editor.getEfficientZoomLevel();
      return zoomLevel < 0.5 && zoomLevel < 1.5 / sw;
    },
    [editor, sw, zoomOverride]
  );
  const dotAdjustment = useValue(
    "dot adjustment",
    () => {
      const zoomLevel = zoomOverride ?? editor.getEfficientZoomLevel();
      return zoomLevel < 0.2 ? 9 : 0.1;
    },
    [editor, zoomOverride]
  );
  if (!forceSolid && !shape.props.isPen && shape.props.dash === "draw" && allPointsFromSegments.length === 1) {
    sw += rng(shape.id)() * (sw / 6);
  }
  const options2 = getFreehandOptions(shape.props, sw, showAsComplete, forceSolid);
  if (!forceSolid && shape.props.dash === "draw") {
    return (0, import_jsx_runtime211.jsxs)(import_jsx_runtime211.Fragment, { children: [
      shape.props.isClosed && shape.props.fill && allPointsFromSegments.length > 1 ? (0, import_jsx_runtime211.jsx)(
        ShapeFill,
        {
          d: getSvgPathFromStrokePoints(
            getStrokePoints(allPointsFromSegments, options2),
            shape.props.isClosed
          ),
          theme,
          color: shape.props.color,
          fill: shape.props.isClosed ? shape.props.fill : "none",
          scale: shape.props.scale
        }
      ) : null,
      (0, import_jsx_runtime211.jsx)(
        "path",
        {
          d: svgInk(allPointsFromSegments, options2),
          strokeLinecap: "round",
          fill: getColorValue(theme, shape.props.color, "solid")
        }
      )
    ] });
  }
  const strokePoints = getStrokePoints(allPointsFromSegments, options2);
  const isDot = strokePoints.length < 2;
  const solidStrokePath = isDot ? getDot(allPointsFromSegments[0], 0) : getSvgPathFromStrokePoints(strokePoints, shape.props.isClosed);
  return (0, import_jsx_runtime211.jsxs)(import_jsx_runtime211.Fragment, { children: [
    (0, import_jsx_runtime211.jsx)(
      ShapeFill,
      {
        d: solidStrokePath,
        theme,
        color: shape.props.color,
        fill: isDot || shape.props.isClosed ? shape.props.fill : "none",
        scale: shape.props.scale
      }
    ),
    (0, import_jsx_runtime211.jsx)(
      "path",
      {
        d: solidStrokePath,
        strokeLinecap: "round",
        fill: isDot ? getColorValue(theme, shape.props.color, "solid") : "none",
        stroke: getColorValue(theme, shape.props.color, "solid"),
        strokeWidth: sw,
        strokeDasharray: isDot ? "none" : getDrawShapeStrokeDashArray(shape, sw, dotAdjustment),
        strokeDashoffset: "0"
      }
    )
  ] });
}

// ../node_modules/tldraw/dist-esm/lib/shapes/embed/EmbedShapeUtil.mjs
var import_jsx_runtime212 = __toESM(require_jsx_runtime(), 1);

// ../node_modules/tldraw/dist-esm/lib/utils/embeds/embeds.mjs
function escapeStringRegexp(string) {
  if (typeof string !== "string") {
    throw new TypeError("Expected a string");
  }
  return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function matchEmbedUrl(definitions, url) {
  const parsed = safeParseUrl(url);
  if (!parsed) return;
  const host = parsed.host.replace("www.", "");
  for (const localEmbedDef of definitions) {
    if (checkHostnames(localEmbedDef.hostnames, host)) {
      const originalUrl = localEmbedDef.fromEmbedUrl(url);
      if (originalUrl) {
        return {
          definition: localEmbedDef,
          url: originalUrl,
          embedUrl: url
        };
      }
    }
  }
}
var globlikeRegExp = (input) => {
  return input.split("*").map((str) => escapeStringRegexp(str)).join(".+");
};
var checkHostnames = (hostnames, targetHostname) => {
  return !!hostnames.find((hostname) => {
    const re = new RegExp(globlikeRegExp(hostname));
    return targetHostname.match(re);
  });
};
function matchUrl(definitions, url) {
  const parsed = safeParseUrl(url);
  if (!parsed) return;
  const host = parsed.host.replace("www.", "");
  for (const localEmbedDef of definitions) {
    if (checkHostnames(localEmbedDef.hostnames, host)) {
      const embedUrl = localEmbedDef.toEmbedUrl(url);
      if (embedUrl) {
        return {
          definition: localEmbedDef,
          embedUrl,
          url
        };
      }
    }
  }
}
function getEmbedInfo(definitions, inputUrl) {
  try {
    return matchUrl(definitions, inputUrl) ?? matchEmbedUrl(definitions, inputUrl);
  } catch {
    return void 0;
  }
}

// ../node_modules/tldraw/dist-esm/lib/shapes/embed/EmbedShapeUtil.mjs
var getSandboxPermissions = (permissions) => {
  return Object.entries(permissions).filter(([_perm, isEnabled]) => isEnabled).map(([perm]) => perm).join(" ");
};
var _EmbedShapeUtil = class _EmbedShapeUtil extends BaseBoxShapeUtil {
  canEditWhileLocked(shape) {
    const result = this.getEmbedDefinition(shape.props.url);
    if (!result) return true;
    return result.definition.canEditWhileLocked ?? true;
  }
  static setEmbedDefinitions(embedDefinitions) {
    _EmbedShapeUtil.embedDefinitions = embedDefinitions;
  }
  getEmbedDefinitions() {
    return _EmbedShapeUtil.embedDefinitions;
  }
  getEmbedDefinition(url) {
    return getEmbedInfo(_EmbedShapeUtil.embedDefinitions, url);
  }
  getText(shape) {
    return shape.props.url;
  }
  getAriaDescriptor(shape) {
    const embedInfo = this.getEmbedDefinition(shape.props.url);
    return embedInfo == null ? void 0 : embedInfo.definition.title;
  }
  hideSelectionBoundsFg(shape) {
    return !this.canResize(shape);
  }
  canEdit() {
    return true;
  }
  canResize(shape) {
    var _a6, _b3;
    return !!((_b3 = (_a6 = this.getEmbedDefinition(shape.props.url)) == null ? void 0 : _a6.definition) == null ? void 0 : _b3.doesResize);
  }
  canEditInReadonly() {
    return true;
  }
  getDefaultProps() {
    return {
      w: 300,
      h: 300,
      url: ""
    };
  }
  getGeometry(shape) {
    const embedInfo = this.getEmbedDefinition(shape.props.url);
    if (!(embedInfo == null ? void 0 : embedInfo.definition)) {
      return new Rectangle2d({
        width: BOOKMARK_WIDTH,
        height: BOOKMARK_JUST_URL_HEIGHT,
        isFilled: true
      });
    }
    return super.getGeometry(shape);
  }
  isAspectRatioLocked(shape) {
    const embedInfo = this.getEmbedDefinition(shape.props.url);
    return (embedInfo == null ? void 0 : embedInfo.definition.isAspectRatioLocked) ?? false;
  }
  onResize(shape, info) {
    const isAspectRatioLocked = this.isAspectRatioLocked(shape);
    const embedInfo = this.getEmbedDefinition(shape.props.url);
    let minWidth = (embedInfo == null ? void 0 : embedInfo.definition.minWidth) ?? 200;
    let minHeight = (embedInfo == null ? void 0 : embedInfo.definition.minHeight) ?? 200;
    if (isAspectRatioLocked) {
      const aspectRatio = shape.props.w / shape.props.h;
      if (aspectRatio > 1) {
        minWidth *= aspectRatio;
      } else {
        minHeight /= aspectRatio;
      }
    }
    return resizeBox(shape, info, { minWidth, minHeight });
  }
  component(shape) {
    const svgExport = useSvgExportContext();
    const { w, h: h2, url } = shape.props;
    const isEditing = useIsEditing(shape.id);
    const embedInfo = this.getEmbedDefinition(url);
    const isHoveringWhileEditingSameShape = useValue(
      "is hovering",
      () => {
        const { editingShapeId, hoveredShapeId } = this.editor.getCurrentPageState();
        if (editingShapeId && hoveredShapeId !== editingShapeId) {
          const editingShape = this.editor.getShape(editingShapeId);
          if (editingShape && this.editor.isShapeOfType(editingShape, "embed")) {
            return true;
          }
        }
        return false;
      },
      []
    );
    const pageRotation = this.editor.getShapePageTransform(shape).rotation();
    if (svgExport) {
      return (0, import_jsx_runtime212.jsx)(HTMLContainer, { className: "tl-embed-container", id: shape.id, children: (0, import_jsx_runtime212.jsx)(
        "div",
        {
          className: "tl-embed",
          style: {
            border: 0,
            boxShadow: getRotatedBoxShadow(pageRotation),
            borderRadius: (embedInfo == null ? void 0 : embedInfo.definition.overrideOutlineRadius) ?? 8,
            background: (embedInfo == null ? void 0 : embedInfo.definition.backgroundColor) ?? "var(--tl-color-background)",
            width: w,
            height: h2
          }
        }
      ) });
    }
    const isInteractive = isEditing || isHoveringWhileEditingSameShape;
    const isIframe = typeof window !== "undefined" && (window !== window.top || window.self !== window.parent);
    if (isIframe && (embedInfo == null ? void 0 : embedInfo.definition.type) === "tldraw") return null;
    if ((embedInfo == null ? void 0 : embedInfo.definition.type) === "github_gist") {
      const idFromGistUrl = embedInfo.url.split("/").pop();
      if (!idFromGistUrl) throw Error("No gist id!");
      return (0, import_jsx_runtime212.jsx)(HTMLContainer, { className: "tl-embed-container", id: shape.id, children: (0, import_jsx_runtime212.jsx)(
        Gist,
        {
          id: idFromGistUrl,
          width: toDomPrecision(w),
          height: toDomPrecision(h2),
          isInteractive,
          pageRotation
        }
      ) });
    }
    const sandbox = getSandboxPermissions({
      ...embedShapePermissionDefaults,
      ...(embedInfo == null ? void 0 : embedInfo.definition.overridePermissions) ?? {}
    });
    return (0, import_jsx_runtime212.jsx)(HTMLContainer, { className: "tl-embed-container", id: shape.id, children: (embedInfo == null ? void 0 : embedInfo.definition) ? (0, import_jsx_runtime212.jsx)(
      "iframe",
      {
        className: "tl-embed",
        sandbox,
        src: embedInfo.embedUrl,
        width: toDomPrecision(w),
        height: toDomPrecision(h2),
        draggable: false,
        frameBorder: "0",
        referrerPolicy: "no-referrer-when-downgrade",
        tabIndex: isEditing ? 0 : -1,
        allowFullScreen: true,
        style: {
          border: 0,
          pointerEvents: isInteractive ? "auto" : "none",
          // Fix for safari <https://stackoverflow.com/a/49150908>
          zIndex: isInteractive ? "" : "-1",
          boxShadow: getRotatedBoxShadow(pageRotation),
          borderRadius: (embedInfo == null ? void 0 : embedInfo.definition.overrideOutlineRadius) ?? 8,
          background: embedInfo == null ? void 0 : embedInfo.definition.backgroundColor
        }
      }
    ) : (0, import_jsx_runtime212.jsx)(
      BookmarkShapeComponent,
      {
        url,
        h: h2,
        rotation: pageRotation,
        assetId: null,
        showImageContainer: false
      }
    ) });
  }
  indicator(shape) {
    const embedInfo = this.getEmbedDefinition(shape.props.url);
    return (embedInfo == null ? void 0 : embedInfo.definition) ? (0, import_jsx_runtime212.jsx)(
      "rect",
      {
        width: toDomPrecision(shape.props.w),
        height: toDomPrecision(shape.props.h),
        rx: (embedInfo == null ? void 0 : embedInfo.definition.overrideOutlineRadius) ?? 8,
        ry: (embedInfo == null ? void 0 : embedInfo.definition.overrideOutlineRadius) ?? 8
      }
    ) : (0, import_jsx_runtime212.jsx)(BookmarkIndicatorComponent, { w: BOOKMARK_WIDTH, h: BOOKMARK_JUST_URL_HEIGHT });
  }
  getInterpolatedProps(startShape, endShape, t2) {
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      w: lerp(startShape.props.w, endShape.props.w, t2),
      h: lerp(startShape.props.h, endShape.props.h, t2)
    };
  }
};
__publicField(_EmbedShapeUtil, "type", "embed");
__publicField(_EmbedShapeUtil, "props", embedShapeProps);
__publicField(_EmbedShapeUtil, "migrations", embedShapeMigrations);
__publicField(_EmbedShapeUtil, "embedDefinitions", DEFAULT_EMBED_DEFINITIONS);
var EmbedShapeUtil = _EmbedShapeUtil;
function Gist({
  id,
  isInteractive,
  width,
  height,
  style: style2,
  pageRotation
}) {
  if (!id.match(/^[0-9a-f]+$/)) throw Error("No gist id!");
  return (0, import_jsx_runtime212.jsx)(
    "iframe",
    {
      className: "tl-embed",
      draggable: false,
      width: toDomPrecision(width),
      height: toDomPrecision(height),
      frameBorder: "0",
      scrolling: "no",
      referrerPolicy: "no-referrer-when-downgrade",
      tabIndex: isInteractive ? 0 : -1,
      style: {
        ...style2,
        pointerEvents: isInteractive ? "all" : "none",
        // Fix for safari <https://stackoverflow.com/a/49150908>
        zIndex: isInteractive ? "" : "-1",
        boxShadow: getRotatedBoxShadow(pageRotation)
      },
      srcDoc: `
			<html>
				<head>
					<base target="_blank">
				</head>
				<body>
					<script src=${`https://gist.github.com/${id}.js`}><\/script>
					<style type="text/css">
						* { margin: 0px; }
						table { height: 100%; background-color: red; }
						.gist { background-color: none; height: 100%;  }
						.gist .gist-file { height: calc(100vh - 2px); padding: 0px; display: grid; grid-template-rows: 1fr auto; }
					</style>
				</body>
			</html>`
    }
  );
}

// ../node_modules/tldraw/dist-esm/lib/shapes/frame/FrameShapeUtil.mjs
var import_jsx_runtime216 = __toESM(require_jsx_runtime(), 1);
var import_classnames36 = __toESM(require_classnames(), 1);

// ../node_modules/tldraw/dist-esm/lib/shapes/shared/createTextJsxFromSpans.mjs
var import_jsx_runtime213 = __toESM(require_jsx_runtime(), 1);
function correctSpacesToNbsp(input) {
  return input.replace(/\s/g, " ");
}
function createTextJsxFromSpans(editor, spans, opts) {
  const { padding = 0 } = opts;
  if (spans.length === 0) return null;
  const bounds = Box.From(spans[0].box);
  for (const { box } of spans) {
    bounds.union(box);
  }
  const offsetX = padding + (opts.offsetX ?? 0);
  const offsetY = (opts.offsetY ?? 0) + opts.fontSize / 2 + (opts.verticalTextAlign === "start" ? padding : opts.verticalTextAlign === "end" ? opts.height - padding - bounds.height : (Math.ceil(opts.height) - bounds.height) / 2);
  let currentLineTop = null;
  const children = [];
  for (const { text, box } of spans) {
    const didBreakLine = currentLineTop !== null && box.y > currentLineTop;
    if (didBreakLine) {
      children.push(
        (0, import_jsx_runtime213.jsx)(
          "tspan",
          {
            alignmentBaseline: "mathematical",
            x: offsetX,
            y: box.y + offsetY,
            children: "\n"
          },
          children.length
        )
      );
    }
    children.push(
      (0, import_jsx_runtime213.jsx)(
        "tspan",
        {
          alignmentBaseline: "mathematical",
          x: box.x + offsetX,
          y: box.y + offsetY,
          unicodeBidi: "plaintext",
          children: correctSpacesToNbsp(text)
        },
        children.length
      )
    );
    currentLineTop = box.y;
  }
  return (0, import_jsx_runtime213.jsx)(
    "text",
    {
      fontSize: opts.fontSize,
      fontFamily: opts.fontFamily,
      fontStyle: opts.fontStyle,
      fontWeight: opts.fontWeight,
      dominantBaseline: "mathematical",
      alignmentBaseline: "mathematical",
      stroke: opts.stroke,
      strokeWidth: opts.strokeWidth,
      fill: opts.fill,
      children
    }
  );
}

// ../node_modules/tldraw/dist-esm/lib/shapes/frame/components/FrameHeading.mjs
var import_jsx_runtime215 = __toESM(require_jsx_runtime(), 1);
var import_react145 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/shapes/frame/frameHelpers.mjs
function getFrameHeadingSide(editor, shape) {
  const pageRotation = canonicalizeRotation(editor.getShapePageTransform(shape.id).rotation());
  const offsetRotation = pageRotation + Math.PI / 4;
  const scaledRotation = (offsetRotation * (2 / Math.PI) + 4) % 4;
  return Math.floor(scaledRotation);
}
var measurementWeakmap = /* @__PURE__ */ new WeakMap();
function getFrameHeadingSize(editor, shape, opts) {
  if (false) {
    return new Box(0, -opts.height, shape.props.w, opts.height);
  }
  let width = measurementWeakmap.get(shape.props);
  if (!width) {
    const frameTitle = defaultEmptyAs(shape.props.name, "Frame") + String.fromCharCode(8203);
    const spans = editor.textMeasure.measureTextSpans(frameTitle, opts);
    const firstSpan = spans[0];
    const lastSpan = last(spans);
    width = lastSpan.box.w + lastSpan.box.x - firstSpan.box.x;
    measurementWeakmap.set(shape.props, width);
  }
  return new Box(0, -opts.height, width, opts.height);
}
function getFrameHeadingOpts(width, isSvg) {
  return {
    fontSize: 12,
    fontFamily: isSvg ? "Arial" : "Inter, sans-serif",
    textAlign: "start",
    width,
    height: 24,
    // --frame-height
    padding: 0,
    lineHeight: 1,
    fontStyle: "normal",
    fontWeight: "normal",
    overflow: "truncate-ellipsis",
    verticalTextAlign: "middle",
    offsetY: -(32 + 2),
    // --frame-minimum-height + (border width * 2)
    offsetX: 0
  };
}
function getFrameHeadingTranslation(shape, side, isSvg) {
  const u = isSvg ? "" : "px";
  const r = isSvg ? "" : "deg";
  let labelTranslate;
  switch (side) {
    case 0:
      labelTranslate = ``;
      break;
    case 3:
      labelTranslate = `translate(${toDomPrecision(shape.props.w)}${u}, 0${u}) rotate(90${r})`;
      break;
    case 2:
      labelTranslate = `translate(${toDomPrecision(shape.props.w)}${u}, ${toDomPrecision(
        shape.props.h
      )}${u}) rotate(180${r})`;
      break;
    case 1:
      labelTranslate = `translate(0${u}, ${toDomPrecision(shape.props.h)}${u}) rotate(270${r})`;
      break;
    default:
      throw Error("labelSide out of bounds");
  }
  return labelTranslate;
}

// ../node_modules/tldraw/dist-esm/lib/shapes/frame/components/FrameLabelInput.mjs
var import_jsx_runtime214 = __toESM(require_jsx_runtime(), 1);
var import_react144 = __toESM(require_react(), 1);
var FrameLabelInput = (0, import_react144.forwardRef)(({ id, name, isEditing }, ref) => {
  const editor = useEditor();
  const breakpoint = useBreakpoint();
  const isCoarsePointer = useValue(
    "isCoarsePointer",
    () => editor.getInstanceState().isCoarsePointer,
    [editor]
  );
  const shouldUseWindowPrompt = breakpoint < PORTRAIT_BREAKPOINT.TABLET_SM && isCoarsePointer;
  const promptOpen = (0, import_react144.useRef)(false);
  const msg2 = useTranslation();
  const handlePointerDown = (0, import_react144.useCallback)(
    (e) => {
      if (isEditing) editor.markEventAsHandled(e);
    },
    [editor, isEditing]
  );
  const handleKeyDown2 = (0, import_react144.useCallback)(
    (e) => {
      if (e.key === "Enter" && !e.nativeEvent.isComposing) {
        editor.markEventAsHandled(e);
        e.currentTarget.blur();
        editor.setEditingShape(null);
      }
    },
    [editor]
  );
  const renameFrame = (0, import_react144.useCallback)(
    (value) => {
      const shape = editor.getShape(id);
      if (!shape) return;
      const name2 = shape.props.name;
      if (name2 === value) return;
      editor.updateShapes([
        {
          id,
          type: "frame",
          props: { name: value }
        }
      ]);
    },
    [id, editor]
  );
  const handleBlur = (0, import_react144.useCallback)(
    (e) => {
      renameFrame(e.currentTarget.value);
    },
    [renameFrame]
  );
  const handleChange = (0, import_react144.useCallback)(
    (e) => {
      renameFrame(e.currentTarget.value);
    },
    [renameFrame]
  );
  (0, import_react144.useEffect)(() => {
    if (!isEditing) {
      promptOpen.current = false;
      return;
    }
    if (isEditing && shouldUseWindowPrompt && !promptOpen.current) {
      promptOpen.current = true;
      const shape = editor.getShape(id);
      const currentName = (shape == null ? void 0 : shape.props.name) ?? "";
      const newName = window.prompt(msg2("action.rename"), currentName);
      promptOpen.current = false;
      if (newName !== null) renameFrame(newName);
      editor.setEditingShape(null);
    }
  }, [isEditing, shouldUseWindowPrompt, id, msg2, renameFrame, editor]);
  return (0, import_jsx_runtime214.jsxs)(
    "div",
    {
      className: `tl-frame-label ${isEditing && !shouldUseWindowPrompt ? "tl-frame-label__editing" : ""}`,
      children: [
        (0, import_jsx_runtime214.jsx)(
          "input",
          {
            className: "tl-frame-name-input",
            ref,
            disabled: !isEditing || shouldUseWindowPrompt,
            readOnly: !isEditing || shouldUseWindowPrompt,
            style: { display: isEditing ? void 0 : "none" },
            value: name,
            autoFocus: !shouldUseWindowPrompt,
            onKeyDown: handleKeyDown2,
            onBlur: handleBlur,
            onChange: handleChange,
            onPointerDown: handlePointerDown,
            draggable: false
          }
        ),
        defaultEmptyAs(name, "Frame") + String.fromCharCode(8203)
      ]
    }
  );
});

// ../node_modules/tldraw/dist-esm/lib/shapes/frame/components/FrameHeading.mjs
var FrameHeading = (0, import_react145.memo)(function FrameHeading2({
  id,
  name,
  width,
  height,
  fill,
  stroke,
  color,
  offsetX,
  showColors
}) {
  const editor = useEditor();
  const { side, translation } = useValue(
    "shape rotation",
    () => {
      const shape = editor.getShape(id);
      if (!shape) {
        return {
          side: 0,
          translation: "translate(0, 0)"
        };
      }
      const labelSide = getFrameHeadingSide(editor, shape);
      return {
        side: labelSide,
        translation: getFrameHeadingTranslation(shape, labelSide, false)
      };
    },
    [editor, offsetX, id]
  );
  const rInput = (0, import_react145.useRef)(null);
  const isEditing = useIsEditing(id);
  (0, import_react145.useEffect)(() => {
    const el = rInput.current;
    if (el && isEditing) {
      el.focus();
      el.select();
    }
  }, [rInput, isEditing]);
  return (0, import_jsx_runtime215.jsx)(
    "div",
    {
      className: "tl-frame-heading",
      style: {
        overflow: isEditing ? "visible" : "hidden",
        maxWidth: `calc(var(--tl-zoom) * ${side === 0 || side === 2 ? Math.ceil(width) : Math.ceil(height)}px + ${showColors ? "0px" : "var(--tl-frame-offset-width)"})`,
        bottom: "100%",
        transform: `${translation} scale(var(--tl-scale)) translateX(${offsetX}px)`
      },
      children: (0, import_jsx_runtime215.jsx)(
        "div",
        {
          className: "tl-frame-heading-hit-area",
          style: { color, backgroundColor: fill, boxShadow: `inset 0px 0px 0px 1px ${stroke}` },
          children: (0, import_jsx_runtime215.jsx)(FrameLabelInput, { ref: rInput, id, name, isEditing })
        }
      )
    }
  );
});

// ../node_modules/tldraw/dist-esm/lib/shapes/frame/FrameShapeUtil.mjs
var FRAME_HEADING_EXTRA_WIDTH = 12;
var FRAME_HEADING_MIN_WIDTH = 32;
var FRAME_HEADING_NOCOLORS_OFFSET_X = -7;
var FRAME_HEADING_OFFSET_Y = 4;
function defaultEmptyAs(str, dflt) {
  if (str.match(/^\s*$/)) {
    return dflt;
  }
  return str;
}
var FrameShapeUtil = class extends BaseBoxShapeUtil {
  constructor() {
    super(...arguments);
    __publicField(this, "options", {
      showColors: false,
      resizeChildren: false
    });
  }
  // evil crimes :)
  // By default, showColors is off. Because they use style props, which are picked up
  // automatically, we don't have DefaultColorStyle in the props in the schema by default.
  // Instead, when someone calls .configure to turn the option on, we manually add in the color
  // style here so it plays nicely with the other editor APIs.
  static configure(options2) {
    const withOptions = super.configure.call(this, options2);
    if (options2.showColors) {
      ;
      withOptions.props = { ...withOptions.props, color: DefaultColorStyle };
    }
    return withOptions;
  }
  canEdit(shape, info) {
    return info.type === "click-header" || info.type === "unknown";
  }
  canResize() {
    return true;
  }
  canResizeChildren() {
    return this.options.resizeChildren;
  }
  isExportBoundsContainer() {
    return true;
  }
  getDefaultProps() {
    return { w: 160 * 2, h: 90 * 2, name: "", color: "black" };
  }
  getAriaDescriptor(shape) {
    return shape.props.name;
  }
  getGeometry(shape) {
    const { editor } = this;
    const z = editor.getEfficientZoomLevel();
    const labelSide = getFrameHeadingSide(editor, shape);
    const isVertical = labelSide % 2 === 1;
    const rotatedTopEdgeWidth = isVertical ? shape.props.h : shape.props.w;
    const opts = getFrameHeadingOpts(rotatedTopEdgeWidth, false);
    const headingSize = getFrameHeadingSize(editor, shape, opts);
    const isShowingFrameColors = this.options.showColors;
    const extraWidth = FRAME_HEADING_EXTRA_WIDTH / z;
    const minWidth = FRAME_HEADING_MIN_WIDTH / z;
    const maxWidth = rotatedTopEdgeWidth + (isShowingFrameColors ? 1 : extraWidth);
    const labelWidth = headingSize.w / z;
    const labelHeight = headingSize.h / z;
    const clampedLabelWidth = clamp(labelWidth + extraWidth, minWidth, maxWidth);
    const offsetX = (isShowingFrameColors ? -1 : FRAME_HEADING_NOCOLORS_OFFSET_X) / z;
    const offsetY = FRAME_HEADING_OFFSET_Y / z;
    const width = isVertical ? labelHeight : clampedLabelWidth;
    const height = isVertical ? clampedLabelWidth : labelHeight;
    let x, y;
    switch (labelSide) {
      case 0: {
        x = offsetX;
        y = -(labelHeight + offsetY);
        break;
      }
      case 1: {
        x = -(labelHeight + offsetY);
        y = shape.props.h - (offsetX + clampedLabelWidth);
        break;
      }
      case 2: {
        x = shape.props.w - (offsetX + clampedLabelWidth);
        y = shape.props.h + offsetY;
        break;
      }
      case 3: {
        x = shape.props.w + offsetY;
        y = offsetX;
        break;
      }
    }
    return new Group2d({
      children: [
        new Rectangle2d({
          width: shape.props.w,
          height: shape.props.h,
          isFilled: false
        }),
        new Rectangle2d({
          x,
          y,
          width,
          height,
          isFilled: true,
          isLabel: true,
          excludeFromShapeBounds: true
        })
      ]
    });
  }
  getText(shape) {
    return shape.props.name;
  }
  component(shape) {
    const theme = useDefaultColorTheme();
    const isCreating = useValue(
      "is creating this shape",
      () => {
        const resizingState = this.editor.getStateDescendant("select.resizing");
        if (!resizingState) return false;
        if (!resizingState.getIsActive()) return false;
        const info = resizingState == null ? void 0 : resizingState.info;
        if (!info) return false;
        return info.isCreating && this.editor.getOnlySelectedShapeId() === shape.id;
      },
      [shape.id]
    );
    const showFrameColors = this.options.showColors;
    const colorToUse = showFrameColors ? shape.props.color : "black";
    const frameFill = getColorValue(theme, colorToUse, "frameFill");
    const frameStroke = getColorValue(theme, colorToUse, "frameStroke");
    const frameHeadingStroke = showFrameColors ? getColorValue(theme, colorToUse, "frameHeadingStroke") : theme.background;
    const frameHeadingFill = showFrameColors ? getColorValue(theme, colorToUse, "frameHeadingFill") : theme.background;
    const frameHeadingText = getColorValue(theme, colorToUse, "frameText");
    return (0, import_jsx_runtime216.jsxs)(import_jsx_runtime216.Fragment, { children: [
      (0, import_jsx_runtime216.jsx)(SVGContainer, { children: (0, import_jsx_runtime216.jsx)(
        "rect",
        {
          className: (0, import_classnames36.default)("tl-frame__body", { "tl-frame__creating": isCreating }),
          fill: frameFill,
          stroke: frameStroke,
          style: {
            width: `calc(${shape.props.w}px + 1px / var(--tl-zoom))`,
            height: `calc(${shape.props.h}px + 1px / var(--tl-zoom))`,
            transform: `translate(calc(-0.5px / var(--tl-zoom)), calc(-0.5px / var(--tl-zoom)))`
          }
        }
      ) }),
      isCreating ? null : (0, import_jsx_runtime216.jsx)(
        FrameHeading,
        {
          id: shape.id,
          name: shape.props.name,
          fill: frameHeadingFill,
          stroke: frameHeadingStroke,
          color: frameHeadingText,
          width: shape.props.w,
          height: shape.props.h,
          offsetX: showFrameColors ? -1 : -7,
          showColors: this.options.showColors
        }
      )
    ] });
  }
  toSvg(shape, ctx) {
    const theme = getDefaultColorTheme({ isDarkMode: ctx.isDarkMode });
    const labelSide = getFrameHeadingSide(this.editor, shape);
    const isVertical = labelSide % 2 === 1;
    const rotatedTopEdgeWidth = isVertical ? shape.props.h : shape.props.w;
    const labelTranslate = getFrameHeadingTranslation(shape, labelSide, true);
    const opts = getFrameHeadingOpts(rotatedTopEdgeWidth - 12, true);
    const frameTitle = defaultEmptyAs(shape.props.name, "Frame") + String.fromCharCode(8203);
    const labelBounds = getFrameHeadingSize(this.editor, shape, opts);
    const spans = this.editor.textMeasure.measureTextSpans(frameTitle, opts);
    const text = createTextJsxFromSpans(this.editor, spans, opts);
    const showFrameColors = this.options.showColors;
    const colorToUse = showFrameColors ? shape.props.color : "black";
    const frameFill = getColorValue(theme, colorToUse, "frameFill");
    const frameStroke = getColorValue(theme, colorToUse, "frameStroke");
    const frameHeadingStroke = showFrameColors ? getColorValue(theme, colorToUse, "frameHeadingStroke") : theme.background;
    const frameHeadingFill = showFrameColors ? getColorValue(theme, colorToUse, "frameHeadingFill") : theme.background;
    const frameHeadingText = getColorValue(theme, colorToUse, "frameText");
    return (0, import_jsx_runtime216.jsxs)(import_jsx_runtime216.Fragment, { children: [
      (0, import_jsx_runtime216.jsx)(
        "rect",
        {
          width: shape.props.w,
          height: shape.props.h,
          fill: frameFill,
          stroke: frameStroke,
          strokeWidth: 1,
          x: 0,
          rx: 0,
          ry: 0
        }
      ),
      (0, import_jsx_runtime216.jsxs)("g", { fill: frameHeadingText, transform: labelTranslate, children: [
        (0, import_jsx_runtime216.jsx)(
          "rect",
          {
            x: labelBounds.x - (showFrameColors ? 0 : 6),
            y: labelBounds.y - 6,
            width: Math.min(rotatedTopEdgeWidth, labelBounds.width + 12),
            height: labelBounds.height,
            fill: frameHeadingFill,
            stroke: frameHeadingStroke,
            rx: 4,
            ry: 4
          }
        ),
        (0, import_jsx_runtime216.jsx)("g", { transform: `translate(${showFrameColors ? 8 : 0}, 4)`, children: text })
      ] })
    ] });
  }
  indicator(shape) {
    return (0, import_jsx_runtime216.jsx)(
      "rect",
      {
        width: toDomPrecision(shape.props.w),
        height: toDomPrecision(shape.props.h),
        className: `tl-frame-indicator`
      }
    );
  }
  providesBackgroundForChildren() {
    return true;
  }
  getClipPath(shape) {
    return this.editor.getShapeGeometry(shape.id).vertices;
  }
  canReceiveNewChildrenOfType(shape) {
    return !shape.isLocked;
  }
  onResize(shape, info) {
    return resizeBox(shape, info);
  }
  getInterpolatedProps(startShape, endShape, t2) {
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      w: lerp(startShape.props.w, endShape.props.w, t2),
      h: lerp(startShape.props.h, endShape.props.h, t2)
    };
  }
  onDoubleClickEdge(shape, info) {
    if (info.target !== "selection") return;
    const { handle } = info;
    if (!handle) return;
    const isHorizontalEdge = handle === "left" || handle === "right";
    const isVerticalEdge = handle === "top" || handle === "bottom";
    const childIds = this.editor.getSortedChildIdsForParent(shape.id);
    const children = compact(childIds.map((id) => this.editor.getShape(id)));
    if (!children.length) return;
    const { dx, dy, w, h: h2 } = getFrameChildrenBounds(children, this.editor, { padding: 10 });
    this.editor.run(() => {
      const changes = childIds.map((childId) => {
        const childShape = this.editor.getShape(childId);
        return {
          id: childShape.id,
          type: childShape.type,
          x: isHorizontalEdge ? childShape.x + dx : childShape.x,
          y: isVerticalEdge ? childShape.y + dy : childShape.y
        };
      });
      this.editor.updateShapes(changes);
    });
    return {
      id: shape.id,
      type: shape.type,
      props: {
        w: isHorizontalEdge ? w : shape.props.w,
        h: isVerticalEdge ? h2 : shape.props.h
      }
    };
  }
  onDoubleClickCorner(shape) {
    fitFrameToContent(this.editor, shape.id, { padding: 10 });
    return {
      id: shape.id,
      type: shape.type
    };
  }
  onDragShapesIn(shape, draggingShapes, { initialParentIds, initialIndices }) {
    const { editor } = this;
    if (draggingShapes.every((s) => s.parentId === shape.id)) return;
    let canRestoreOriginalIndices = false;
    const previousChildren = draggingShapes.filter((s) => shape.id === initialParentIds.get(s.id));
    if (previousChildren.length > 0) {
      const currentChildren = compact(
        editor.getSortedChildIdsForParent(shape).map((id) => editor.getShape(id))
      );
      if (previousChildren.every((s) => !currentChildren.find((c) => c.index === s.index))) {
        canRestoreOriginalIndices = true;
      }
    }
    if (draggingShapes.some((s) => editor.hasAncestor(shape, s.id))) return;
    editor.reparentShapes(draggingShapes, shape.id);
    if (canRestoreOriginalIndices) {
      for (const shape2 of previousChildren) {
        editor.updateShape({
          id: shape2.id,
          type: shape2.type,
          index: initialIndices.get(shape2.id)
        });
      }
    }
  }
  onDragShapesOut(shape, draggingShapes, info) {
    const { editor } = this;
    if (!info.nextDraggingOverShapeId) {
      editor.reparentShapes(
        draggingShapes.filter(
          (s) => s.parentId === shape.id && this.canReceiveNewChildrenOfType(s)
        ),
        editor.getCurrentPageId()
      );
    }
  }
};
__publicField(FrameShapeUtil, "type", "frame");
__publicField(FrameShapeUtil, "props", frameShapeProps);
__publicField(FrameShapeUtil, "migrations", frameShapeMigrations);

// ../node_modules/tldraw/dist-esm/lib/shapes/geo/GeoShapeUtil.mjs
var import_jsx_runtime218 = __toESM(require_jsx_runtime(), 1);

// ../node_modules/tldraw/dist-esm/lib/shapes/geo/components/GeoShapeBody.mjs
var import_jsx_runtime217 = __toESM(require_jsx_runtime(), 1);

// ../node_modules/tldraw/dist-esm/lib/shapes/geo/getGeoShapePath.mjs
var pathCache = new WeakCache();
function getGeoShapePath(shape) {
  return pathCache.get(shape, _getGeoPath);
}
function _getGeoPath(shape) {
  const w = Math.max(1, shape.props.w);
  const h2 = Math.max(1, shape.props.h + shape.props.growY);
  const cx = w / 2;
  const cy = h2 / 2;
  const sw = STROKE_SIZES[shape.props.size] * shape.props.scale;
  const isFilled = shape.props.fill !== "none";
  switch (shape.props.geo) {
    case "arrow-down": {
      const ox = w * 0.16;
      const oy = Math.min(w, h2) * 0.38;
      return new PathBuilder().moveTo(ox, 0, { geometry: { isFilled } }).lineTo(w - ox, 0).lineTo(w - ox, h2 - oy).lineTo(w, h2 - oy).lineTo(w / 2, h2).lineTo(0, h2 - oy).lineTo(ox, h2 - oy).close();
    }
    case "arrow-left": {
      const ox = Math.min(w, h2) * 0.38;
      const oy = h2 * 0.16;
      return new PathBuilder().moveTo(ox, 0, { geometry: { isFilled } }).lineTo(ox, oy).lineTo(w, oy).lineTo(w, h2 - oy).lineTo(ox, h2 - oy).lineTo(ox, h2).lineTo(0, h2 / 2).close();
    }
    case "arrow-right": {
      const ox = Math.min(w, h2) * 0.38;
      const oy = h2 * 0.16;
      return new PathBuilder().moveTo(0, oy, { geometry: { isFilled } }).lineTo(w - ox, oy).lineTo(w - ox, 0).lineTo(w, h2 / 2).lineTo(w - ox, h2).lineTo(w - ox, h2 - oy).lineTo(0, h2 - oy).close();
    }
    case "arrow-up": {
      const ox = w * 0.16;
      const oy = Math.min(w, h2) * 0.38;
      return new PathBuilder().moveTo(w / 2, 0, { geometry: { isFilled } }).lineTo(w, oy).lineTo(w - ox, oy).lineTo(w - ox, h2).lineTo(ox, h2).lineTo(ox, oy).lineTo(0, oy).close();
    }
    case "check-box": {
      const size4 = Math.min(w, h2) * 0.82;
      const ox = (w - size4) / 2;
      const oy = (h2 - size4) / 2;
      return new PathBuilder().moveTo(0, 0, { geometry: { isFilled } }).lineTo(w, 0).lineTo(w, h2).lineTo(0, h2).close().moveTo(clamp(ox + size4 * 0.25, 0, w), clamp(oy + size4 * 0.52, 0, h2), {
        geometry: { isInternal: true, isFilled: false },
        offset: 0
      }).lineTo(clamp(ox + size4 * 0.45, 0, w), clamp(oy + size4 * 0.82, 0, h2)).lineTo(clamp(ox + size4 * 0.82, 0, w), clamp(oy + size4 * 0.22, 0, h2), { offset: 0 });
    }
    case "diamond":
      return new PathBuilder().moveTo(cx, 0, { geometry: { isFilled } }).lineTo(w, cy).lineTo(cx, h2).lineTo(0, cy).close();
    case "ellipse":
      return new PathBuilder().moveTo(0, cy, { geometry: { isFilled } }).arcTo(cx, cy, false, true, 0, w, cy).arcTo(cx, cy, false, true, 0, 0, cy).close();
    case "heart": {
      const o = w / 4;
      const k = h2 / 4;
      return new PathBuilder().moveTo(cx, h2, { geometry: { isFilled } }).cubicBezierTo(0, k * 1.2, o * 1.5, k * 3, 0, k * 2.5).cubicBezierTo(cx, k * 0.9, 0, -k * 0.32, o * 1.85, -k * 0.32).cubicBezierTo(w, k * 1.2, o * 2.15, -k * 0.32, w, -k * 0.32).cubicBezierTo(cx, h2, w, k * 2.5, o * 2.5, k * 3).close();
    }
    case "hexagon":
      return PathBuilder.lineThroughPoints(getPolygonVertices(w, h2, 6), {
        geometry: { isFilled }
      }).close();
    case "octagon":
      return PathBuilder.lineThroughPoints(getPolygonVertices(w, h2, 8), {
        geometry: { isFilled }
      }).close();
    case "oval":
      return getStadiumPath(w, h2, isFilled);
    case "pentagon":
      return PathBuilder.lineThroughPoints(getPolygonVertices(w, h2, 5), {
        geometry: { isFilled }
      }).close();
    case "rectangle":
      return new PathBuilder().moveTo(0, 0, { geometry: { isFilled } }).lineTo(w, 0).lineTo(w, h2).lineTo(0, h2).close();
    case "rhombus": {
      const offset4 = Math.min(w * 0.38, h2 * 0.38);
      return new PathBuilder().moveTo(offset4, 0, { geometry: { isFilled } }).lineTo(w, 0).lineTo(w - offset4, h2).lineTo(0, h2).close();
    }
    case "rhombus-2": {
      const offset4 = Math.min(w * 0.38, h2 * 0.38);
      return new PathBuilder().moveTo(0, 0, { geometry: { isFilled } }).lineTo(w - offset4, 0).lineTo(w, h2).lineTo(offset4, h2).close();
    }
    case "star":
      return getStarPath(w, h2, isFilled);
    case "trapezoid": {
      const offset4 = Math.min(w * 0.38, h2 * 0.38);
      return new PathBuilder().moveTo(offset4, 0, { geometry: { isFilled } }).lineTo(w - offset4, 0).lineTo(w, h2).lineTo(0, h2).close();
    }
    case "triangle":
      return new PathBuilder().moveTo(cx, 0, { geometry: { isFilled } }).lineTo(w, h2).lineTo(0, h2).close();
    case "x-box":
      return getXBoxPath(w, h2, sw, shape.props.dash, isFilled);
    case "cloud":
      return getCloudPath(w, h2, shape.id, shape.props.size, shape.props.scale, isFilled);
    default:
      exhaustiveSwitchError(shape.props.geo);
  }
}
function getXBoxPath(w, h2, sw, dash, isFilled) {
  const cx = w / 2;
  const cy = h2 / 2;
  const path = new PathBuilder().moveTo(0, 0, { geometry: { isFilled } }).lineTo(w, 0).lineTo(w, h2).lineTo(0, h2).close();
  if (dash === "dashed" || dash === "dotted") {
    return path.moveTo(0, 0, {
      geometry: { isInternal: true, isFilled: false },
      dashStart: "skip",
      dashEnd: "outset"
    }).lineTo(cx, cy).moveTo(w, h2, {
      geometry: { isInternal: true, isFilled: false },
      dashStart: "skip",
      dashEnd: "outset"
    }).lineTo(cx, cy).moveTo(0, h2, {
      geometry: { isInternal: true, isFilled: false },
      dashStart: "skip",
      dashEnd: "outset"
    }).lineTo(cx, cy).moveTo(w, 0, {
      geometry: { isInternal: true, isFilled: false },
      dashStart: "skip",
      dashEnd: "outset"
    }).lineTo(cx, cy);
  }
  const inset = dash === "draw" ? 0.62 : 0;
  path.moveTo(clamp(sw * inset, 0, w), clamp(sw * inset, 0, h2), {
    geometry: { isInternal: true, isFilled: false }
  }).lineTo(clamp(w - sw * inset, 0, w), clamp(h2 - sw * inset, 0, h2)).moveTo(clamp(w - sw * inset, 0, w), clamp(sw * inset, 0, h2)).lineTo(clamp(sw * inset, 0, w), clamp(h2 - sw * inset, 0, h2));
  return path;
}
function getStadiumPath(w, h2, isFilled) {
  if (h2 > w) {
    const r2 = w / 2;
    return new PathBuilder().moveTo(0, r2, { geometry: { isFilled } }).arcTo(r2, r2, false, true, 0, w, r2).lineTo(w, h2 - r2).arcTo(r2, r2, false, true, 0, 0, h2 - r2).close();
  }
  const r = h2 / 2;
  return new PathBuilder().moveTo(r, h2, { geometry: { isFilled } }).arcTo(r, r, false, true, 0, r, 0).lineTo(w - r, 0).arcTo(r, r, false, true, 0, w - r, h2).close();
}
function getStarPath(w, h2, isFilled) {
  const sides2 = 5;
  const step = PI2 / sides2 / 2;
  const rightMostIndex = Math.floor(sides2 / 4) * 2;
  const leftMostIndex = sides2 * 2 - rightMostIndex;
  const topMostIndex = 0;
  const bottomMostIndex = Math.floor(sides2 / 2) * 2;
  const maxX = Math.cos(-HALF_PI + rightMostIndex * step) * w / 2;
  const minX = Math.cos(-HALF_PI + leftMostIndex * step) * w / 2;
  const minY = Math.sin(-HALF_PI + topMostIndex * step) * h2 / 2;
  const maxY = Math.sin(-HALF_PI + bottomMostIndex * step) * h2 / 2;
  const diffX = w - Math.abs(maxX - minX);
  const diffY = h2 - Math.abs(maxY - minY);
  const offsetX = w / 2 + minX - (w / 2 - maxX);
  const offsetY = h2 / 2 + minY - (h2 / 2 - maxY);
  const ratio = 1;
  const cx = (w - offsetX) / 2;
  const cy = (h2 - offsetY) / 2;
  const ox = (w + diffX) / 2;
  const oy = (h2 + diffY) / 2;
  const ix = ox * ratio / 2;
  const iy = oy * ratio / 2;
  return PathBuilder.lineThroughPoints(
    Array.from(Array(sides2 * 2), (_, i) => {
      const theta = -HALF_PI + i * step;
      return new Vec(
        cx + (i % 2 ? ix : ox) * Math.cos(theta),
        cy + (i % 2 ? iy : oy) * Math.sin(theta)
      );
    }),
    { geometry: { isFilled } }
  ).close();
}
function getOvalPerimeter(h2, w) {
  if (h2 > w) return (PI * (w / 2) + (h2 - w)) * 2;
  else return (PI * (h2 / 2) + (w - h2)) * 2;
}
function getPillPoints(width, height, numPoints) {
  const radius = Math.min(width, height) / 2;
  const longSide = Math.max(width, height) - radius * 2;
  const circumference = Math.PI * (radius * 2) + 2 * longSide;
  const spacing = circumference / numPoints;
  const sections = width > height ? [
    {
      type: "straight",
      start: new Vec(radius, 0),
      delta: new Vec(1, 0)
    },
    {
      type: "arc",
      center: new Vec(width - radius, radius),
      startAngle: -PI / 2
    },
    {
      type: "straight",
      start: new Vec(width - radius, height),
      delta: new Vec(-1, 0)
    },
    {
      type: "arc",
      center: new Vec(radius, radius),
      startAngle: PI / 2
    }
  ] : [
    {
      type: "straight",
      start: new Vec(width, radius),
      delta: new Vec(0, 1)
    },
    {
      type: "arc",
      center: new Vec(radius, height - radius),
      startAngle: 0
    },
    {
      type: "straight",
      start: new Vec(0, height - radius),
      delta: new Vec(0, -1)
    },
    {
      type: "arc",
      center: new Vec(radius, radius),
      startAngle: PI
    }
  ];
  let sectionOffset = 0;
  const points = [];
  for (let i = 0; i < numPoints; i++) {
    const section = sections[0];
    if (section.type === "straight") {
      points.push(Vec.Add(section.start, Vec.Mul(section.delta, sectionOffset)));
    } else {
      points.push(
        getPointOnCircle(section.center, radius, section.startAngle + sectionOffset / radius)
      );
    }
    sectionOffset += spacing;
    let sectionLength = section.type === "straight" ? longSide : PI * radius;
    while (sectionOffset > sectionLength) {
      sectionOffset -= sectionLength;
      sections.push(sections.shift());
      sectionLength = sections[0].type === "straight" ? longSide : PI * radius;
    }
  }
  return points;
}
var SIZES = {
  s: 50,
  m: 70,
  l: 100,
  xl: 130
};
var BUMP_PROTRUSION = 0.2;
function getCloudPath(width, height, seed, size4, scale, isFilled) {
  const path = new PathBuilder();
  const getRandom = rng(seed);
  const pillCircumference = getOvalPerimeter(width, height);
  const numBumps = Math.max(
    Math.ceil(pillCircumference / SIZES[size4]),
    6,
    Math.ceil(pillCircumference / Math.min(width, height))
  );
  const targetBumpProtrusion = pillCircumference / numBumps * BUMP_PROTRUSION;
  const innerWidth = Math.max(width - targetBumpProtrusion * 2, 1);
  const innerHeight2 = Math.max(height - targetBumpProtrusion * 2, 1);
  const innerCircumference = getOvalPerimeter(innerWidth, innerHeight2);
  const distanceBetweenPointsOnPerimeter = innerCircumference / numBumps;
  const paddingX = (width - innerWidth) / 2;
  const paddingY = (height - innerHeight2) / 2;
  const bumpPoints = getPillPoints(innerWidth, innerHeight2, numBumps).map((p) => {
    return p.addXY(paddingX, paddingY);
  });
  const maxWiggleX = width < 20 ? 0 : targetBumpProtrusion * 0.3;
  const maxWiggleY = height < 20 ? 0 : targetBumpProtrusion * 0.3;
  const wiggledPoints = bumpPoints.slice(0);
  for (let i = 0; i < Math.floor(numBumps / 2); i++) {
    wiggledPoints[i] = Vec.AddXY(
      wiggledPoints[i],
      getRandom() * maxWiggleX * scale,
      getRandom() * maxWiggleY * scale
    );
    wiggledPoints[numBumps - i - 1] = Vec.AddXY(
      wiggledPoints[numBumps - i - 1],
      getRandom() * maxWiggleX * scale,
      getRandom() * maxWiggleY * scale
    );
  }
  for (let i = 0; i < wiggledPoints.length; i++) {
    const j = i === wiggledPoints.length - 1 ? 0 : i + 1;
    const leftWigglePoint = wiggledPoints[i];
    const rightWigglePoint = wiggledPoints[j];
    const leftPoint = bumpPoints[i];
    const rightPoint = bumpPoints[j];
    const distanceBetweenOriginalPoints = Vec.Dist(leftPoint, rightPoint);
    const curvatureOffset = distanceBetweenPointsOnPerimeter - distanceBetweenOriginalPoints;
    const distanceBetweenWigglePoints = Vec.Dist(leftWigglePoint, rightWigglePoint);
    const relativeSize = distanceBetweenWigglePoints / distanceBetweenOriginalPoints;
    const finalDistance = (Math.max(paddingX, paddingY) + curvatureOffset) * relativeSize;
    const arcPoint = Vec.Lrp(leftPoint, rightPoint, 0.5).add(
      Vec.Sub(rightPoint, leftPoint).uni().per().mul(finalDistance)
    );
    if (arcPoint.x < 0) {
      arcPoint.x = 0;
    } else if (arcPoint.x > width) {
      arcPoint.x = width;
    }
    if (arcPoint.y < 0) {
      arcPoint.y = 0;
    } else if (arcPoint.y > height) {
      arcPoint.y = height;
    }
    const center = centerOfCircleFromThreePoints(leftWigglePoint, rightWigglePoint, arcPoint);
    const radius = Vec.Dist(
      center ? center : Vec.Average([leftWigglePoint, rightWigglePoint]),
      leftWigglePoint
    );
    if (i === 0) {
      path.moveTo(leftWigglePoint.x, leftWigglePoint.y, { geometry: { isFilled } });
    }
    path.circularArcTo(radius, false, true, rightWigglePoint.x, rightWigglePoint.y);
  }
  return path.close();
}

// ../node_modules/tldraw/dist-esm/lib/shapes/geo/components/GeoShapeBody.mjs
function GeoShapeBody({
  shape,
  shouldScale,
  forceSolid
}) {
  const scaleToUse = shouldScale ? shape.props.scale : 1;
  const theme = useDefaultColorTheme();
  const { props } = shape;
  const { color, fill, dash, size: size4 } = props;
  const strokeWidth = STROKE_SIZES2[size4] * scaleToUse;
  const path = getGeoShapePath(shape);
  const fillPath = dash === "draw" && !forceSolid ? path.toDrawD({ strokeWidth, randomSeed: shape.id, passes: 1, offset: 0, onlyFilled: true }) : path.toD({ onlyFilled: true });
  return (0, import_jsx_runtime217.jsxs)(import_jsx_runtime217.Fragment, { children: [
    (0, import_jsx_runtime217.jsx)(ShapeFill, { theme, d: fillPath, color, fill, scale: scaleToUse }),
    path.toSvg({
      style: dash,
      strokeWidth,
      forceSolid,
      randomSeed: shape.id,
      props: { fill: "none", stroke: getColorValue(theme, color, "solid") }
    })
  ] });
}

// ../node_modules/tldraw/dist-esm/lib/shapes/geo/GeoShapeUtil.mjs
var MIN_SIZE_WITH_LABEL = 17 * 3;
var GeoShapeUtil = class extends BaseBoxShapeUtil {
  constructor() {
    super(...arguments);
    __publicField(this, "options", {
      showTextOutline: true
    });
  }
  canEdit() {
    return true;
  }
  getDefaultProps() {
    return {
      w: 100,
      h: 100,
      geo: "rectangle",
      dash: "draw",
      growY: 0,
      url: "",
      scale: 1,
      // Text properties
      color: "black",
      labelColor: "black",
      fill: "none",
      size: "m",
      font: "draw",
      align: "middle",
      verticalAlign: "middle",
      richText: toRichText("")
    };
  }
  getGeometry(shape) {
    const { props } = shape;
    const { scale } = props;
    const path = getGeoShapePath(shape);
    const pathGeometry = path.toGeometry();
    const scaledW = Math.max(1, props.w);
    const scaledH = Math.max(1, props.h + props.growY);
    const unscaledW = scaledW / scale;
    const unscaledH = scaledH / scale;
    const isEmptyLabel = isEmptyRichText(props.richText);
    const unscaledLabelSize = isEmptyLabel ? EMPTY_LABEL_SIZE : getUnscaledLabelSize(this.editor, shape);
    const labelBounds = getLabelBounds(
      unscaledW,
      unscaledH,
      unscaledLabelSize,
      props.size,
      props.align,
      props.verticalAlign,
      scale
    );
    return new Group2d({
      children: [
        pathGeometry,
        new Rectangle2d({
          ...labelBounds,
          isFilled: true,
          isLabel: true,
          excludeFromShapeBounds: true,
          isEmptyLabel
        })
      ]
    });
  }
  getHandleSnapGeometry(shape) {
    const geometry = this.getGeometry(shape);
    const outline = geometry.children[0];
    switch (shape.props.geo) {
      case "arrow-down":
      case "arrow-left":
      case "arrow-right":
      case "arrow-up":
      case "check-box":
      case "diamond":
      case "hexagon":
      case "octagon":
      case "pentagon":
      case "rectangle":
      case "rhombus":
      case "rhombus-2":
      case "star":
      case "trapezoid":
      case "triangle":
      case "x-box":
        return { outline, points: [...outline.vertices, geometry.bounds.center] };
      case "cloud":
      case "ellipse":
      case "heart":
      case "oval":
        return { outline, points: [geometry.bounds.center] };
      default:
        exhaustiveSwitchError(shape.props.geo);
    }
  }
  getText(shape) {
    return renderPlaintextFromRichText(this.editor, shape.props.richText);
  }
  getFontFaces(shape) {
    if (isEmptyRichText(shape.props.richText)) {
      return EMPTY_ARRAY;
    }
    return getFontsFromRichText(this.editor, shape.props.richText, {
      family: `tldraw_${shape.props.font}`,
      weight: "normal",
      style: "normal"
    });
  }
  component(shape) {
    const { id, type, props } = shape;
    const { fill, font, align, verticalAlign, size: size4, richText } = props;
    const theme = useDefaultColorTheme();
    const { editor } = this;
    const isOnlySelected = useValue(
      "isGeoOnlySelected",
      () => shape.id === editor.getOnlySelectedShapeId(),
      [editor]
    );
    const isReadyForEditing = useIsReadyForEditing(editor, shape.id);
    const isEmpty = isEmptyRichText(shape.props.richText);
    const showHtmlContainer = isReadyForEditing || !isEmpty;
    const isForceSolid = useEfficientZoomThreshold(shape.props.scale * 0.25);
    return (0, import_jsx_runtime218.jsxs)(import_jsx_runtime218.Fragment, { children: [
      (0, import_jsx_runtime218.jsx)(SVGContainer, { children: (0, import_jsx_runtime218.jsx)(GeoShapeBody, { shape, shouldScale: true, forceSolid: isForceSolid }) }),
      showHtmlContainer && (0, import_jsx_runtime218.jsx)(
        HTMLContainer,
        {
          style: {
            overflow: "hidden",
            width: shape.props.w,
            height: shape.props.h + props.growY
          },
          children: (0, import_jsx_runtime218.jsx)(
            RichTextLabel,
            {
              shapeId: id,
              type,
              font,
              fontSize: LABEL_FONT_SIZES[size4] * shape.props.scale,
              lineHeight: TEXT_PROPS.lineHeight,
              padding: LABEL_PADDING * shape.props.scale,
              fill,
              align,
              verticalAlign,
              richText,
              isSelected: isOnlySelected,
              labelColor: getColorValue(theme, props.labelColor, "solid"),
              wrap: true,
              showTextOutline: this.options.showTextOutline
            }
          )
        }
      ),
      shape.props.url && (0, import_jsx_runtime218.jsx)(HyperlinkButton, { url: shape.props.url })
    ] });
  }
  indicator(shape) {
    const isZoomedOut = useEfficientZoomThreshold(shape.props.scale * 0.25);
    const { size: size4, dash, scale } = shape.props;
    const strokeWidth = STROKE_SIZES2[size4];
    const path = getGeoShapePath(shape);
    return path.toSvg({
      style: dash === "draw" ? "draw" : "solid",
      strokeWidth: 1,
      passes: 1,
      randomSeed: shape.id,
      offset: 0,
      roundness: strokeWidth * 2 * scale,
      props: { strokeWidth: void 0 },
      forceSolid: isZoomedOut
    });
  }
  toSvg(shape, ctx) {
    const scale = shape.props.scale;
    const newShape = {
      ...shape,
      props: {
        ...shape.props,
        w: shape.props.w / scale,
        h: (shape.props.h + shape.props.growY) / scale,
        growY: 0
        // growY throws off the path calculations, so we set it to 0
      }
    };
    const props = newShape.props;
    ctx.addExportDef(getFillDefForExport(props.fill));
    let textEl;
    if (!isEmptyRichText(props.richText)) {
      const theme = getDefaultColorTheme(ctx);
      const bounds = new Box(0, 0, props.w, (shape.props.h + shape.props.growY) / scale);
      textEl = (0, import_jsx_runtime218.jsx)(
        RichTextSVG,
        {
          fontSize: LABEL_FONT_SIZES[props.size],
          font: props.font,
          align: props.align,
          verticalAlign: props.verticalAlign,
          richText: props.richText,
          labelColor: getColorValue(theme, props.labelColor, "solid"),
          bounds,
          padding: LABEL_PADDING,
          showTextOutline: this.options.showTextOutline
        }
      );
    }
    return (0, import_jsx_runtime218.jsxs)(import_jsx_runtime218.Fragment, { children: [
      (0, import_jsx_runtime218.jsx)(GeoShapeBody, { shouldScale: false, shape: newShape, forceSolid: false }),
      textEl
    ] });
  }
  getCanvasSvgDefs() {
    return [getFillDefForCanvas()];
  }
  onResize(shape, { handle, newPoint, scaleX, scaleY, initialShape }) {
    const unscaledInitial = getUnscaledGeoProps(initialShape.props);
    let unscaledW = unscaledInitial.w * scaleX;
    let unscaledH = (unscaledInitial.h + unscaledInitial.growY) * scaleY;
    let overShrinkX = 0;
    let overShrinkY = 0;
    if (!isEmptyRichText(shape.props.richText)) {
      const unscaledLabelSize = getUnscaledLabelSize(this.editor, initialShape);
      const absUnscaledW = Math.abs(unscaledW);
      const absUnscaledH = Math.abs(unscaledH);
      const constrainedW = Math.max(absUnscaledW, unscaledLabelSize.w, MIN_SIZE_WITH_LABEL);
      const constrainedH = Math.max(absUnscaledH, unscaledLabelSize.h, MIN_SIZE_WITH_LABEL);
      overShrinkX = constrainedW - absUnscaledW;
      overShrinkY = constrainedH - absUnscaledH;
      unscaledW = constrainedW * Math.sign(unscaledW || 1);
      unscaledH = constrainedH * Math.sign(unscaledH || 1);
    }
    const scaledW = unscaledW * shape.props.scale;
    const scaledH = unscaledH * shape.props.scale;
    const offset4 = new Vec(0, 0);
    if (scaleX < 0) {
      offset4.x += scaledW;
    }
    if (handle === "left" || handle === "top_left" || handle === "bottom_left") {
      offset4.x += scaleX < 0 ? overShrinkX : -overShrinkX;
    }
    if (scaleY < 0) {
      offset4.y += scaledH;
    }
    if (handle === "top" || handle === "top_left" || handle === "top_right") {
      offset4.y += scaleY < 0 ? overShrinkY : -overShrinkY;
    }
    const { x, y } = offset4.rot(shape.rotation).add(newPoint);
    return {
      x,
      y,
      props: {
        w: Math.max(Math.abs(scaledW), 1),
        h: Math.max(Math.abs(scaledH), 1),
        growY: 0
      }
    };
  }
  onBeforeCreate(shape) {
    const { props } = shape;
    if (isEmptyRichText(props.richText)) {
      return props.growY !== 0 ? { ...shape, props: { ...props, growY: 0 } } : void 0;
    }
    const unscaledShapeH = props.h / props.scale;
    const unscaledLabelH = getUnscaledLabelSize(this.editor, shape).h;
    const unscaledGrowY = calculateGrowY(unscaledShapeH, unscaledLabelH, props.growY / props.scale);
    if (unscaledGrowY !== null) {
      return {
        ...shape,
        props: { ...props, growY: unscaledGrowY * props.scale }
      };
    }
  }
  onBeforeUpdate(prev, next) {
    const { props: prevProps } = prev;
    const { props: nextProps } = next;
    if ((0, import_lodash.default)(prevProps.richText, nextProps.richText) && prevProps.font === nextProps.font && prevProps.size === nextProps.size) {
      return;
    }
    const wasEmpty = isEmptyRichText(prevProps.richText);
    const isEmpty = isEmptyRichText(nextProps.richText);
    if (wasEmpty && isEmpty) {
      return;
    }
    if (isEmpty) {
      return nextProps.growY !== 0 ? { ...next, props: { ...nextProps, growY: 0 } } : void 0;
    }
    const unscaledPrev = getUnscaledGeoProps(prevProps);
    const unscaledLabelSize = getUnscaledLabelSize(this.editor, next);
    const { scale } = nextProps;
    if (wasEmpty && !isEmpty) {
      const expanded = expandShapeForFirstLabel(unscaledPrev.w, unscaledPrev.h, unscaledLabelSize);
      return {
        ...next,
        props: {
          ...nextProps,
          w: expanded.w * scale,
          h: expanded.h * scale,
          growY: 0
        }
      };
    }
    const unscaledNextW = next.props.w / scale;
    const needsWidthExpand = unscaledLabelSize.w > unscaledNextW;
    const unscaledGrowY = calculateGrowY(unscaledPrev.h, unscaledLabelSize.h, unscaledPrev.growY);
    if (unscaledGrowY !== null || needsWidthExpand) {
      return {
        ...next,
        props: {
          ...nextProps,
          growY: (unscaledGrowY ?? unscaledPrev.growY) * scale,
          w: Math.max(unscaledNextW, unscaledLabelSize.w) * scale
        }
      };
    }
  }
  onDoubleClick(shape) {
    if (this.editor.inputs.getAltKey()) {
      switch (shape.props.geo) {
        case "rectangle": {
          return {
            ...shape,
            props: {
              geo: "check-box"
            }
          };
        }
        case "check-box": {
          return {
            ...shape,
            props: {
              geo: "rectangle"
            }
          };
        }
      }
    }
    return;
  }
  getInterpolatedProps(startShape, endShape, t2) {
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      w: lerp(startShape.props.w, endShape.props.w, t2),
      h: lerp(startShape.props.h, endShape.props.h, t2),
      scale: lerp(startShape.props.scale, endShape.props.scale, t2)
    };
  }
};
__publicField(GeoShapeUtil, "type", "geo");
__publicField(GeoShapeUtil, "props", geoShapeProps);
__publicField(GeoShapeUtil, "migrations", geoShapeMigrations);
var MIN_WIDTHS = Object.freeze({
  s: 12,
  m: 14,
  l: 16,
  xl: 20
});
var EXTRA_PADDINGS = Object.freeze({
  s: 2,
  m: 3.5,
  l: 5,
  xl: 10
});
var EMPTY_LABEL_SIZE = Object.freeze({ w: 0, h: 0 });
var LABEL_EDGE_MARGIN = 8;
function getLabelBounds(unscaledShapeW, unscaledShapeH, unscaledLabelSize, size4, align, verticalAlign, scale) {
  const unscaledMinWidth = Math.min(100, unscaledShapeW / 2);
  const unscaledMinHeight = Math.min(
    LABEL_FONT_SIZES[size4] * TEXT_PROPS.lineHeight + LABEL_PADDING * 2,
    unscaledShapeH / 2
  );
  const unscaledLabelW = Math.min(
    unscaledShapeW,
    Math.max(
      unscaledLabelSize.w,
      Math.min(unscaledMinWidth, Math.max(1, unscaledShapeW - LABEL_EDGE_MARGIN))
    )
  );
  const unscaledLabelH = Math.min(
    unscaledShapeH,
    Math.max(
      unscaledLabelSize.h,
      Math.min(unscaledMinHeight, Math.max(1, unscaledShapeH - LABEL_EDGE_MARGIN))
    )
  );
  const unscaledX = align === "start" ? 0 : align === "end" ? unscaledShapeW - unscaledLabelW : (unscaledShapeW - unscaledLabelW) / 2;
  const unscaledY = verticalAlign === "start" ? 0 : verticalAlign === "end" ? unscaledShapeH - unscaledLabelH : (unscaledShapeH - unscaledLabelH) / 2;
  return {
    x: unscaledX * scale,
    y: unscaledY * scale,
    width: unscaledLabelW * scale,
    height: unscaledLabelH * scale
  };
}
function getUnscaledGeoProps(props) {
  const { w, h: h2, growY, scale } = props;
  return {
    w: w / scale,
    h: h2 / scale,
    growY: growY / scale
  };
}
function calculateGrowY(unscaledShapeH, unscaledLabelH, unscaledCurrentGrowY) {
  if (unscaledLabelH > unscaledShapeH) {
    return unscaledLabelH - unscaledShapeH;
  }
  if (unscaledCurrentGrowY > 0) {
    return 0;
  }
  return null;
}
function expandShapeForFirstLabel(unscaledW, unscaledH, unscaledLabelSize) {
  let w = Math.max(unscaledW, unscaledLabelSize.w);
  let h2 = Math.max(unscaledH, unscaledLabelSize.h);
  if (unscaledW < MIN_SIZE_WITH_LABEL && unscaledH < MIN_SIZE_WITH_LABEL) {
    w = Math.max(w, MIN_SIZE_WITH_LABEL);
    h2 = Math.max(h2, MIN_SIZE_WITH_LABEL);
    const maxDim = Math.max(w, h2);
    w = maxDim;
    h2 = maxDim;
  }
  return { w, h: h2 };
}
var labelSizesForGeo = new WeakCache();
function getUnscaledLabelSize(editor, shape) {
  return labelSizesForGeo.get(shape, () => {
    return measureUnscaledLabelSize(editor, shape);
  });
}
function measureUnscaledLabelSize(editor, shape) {
  const { richText, font, size: size4, w } = shape.props;
  const minWidth = MIN_WIDTHS[size4];
  const html = renderHtmlFromRichTextForMeasurement(editor, richText);
  const textSize = editor.textMeasure.measureHtml(html, {
    ...TEXT_PROPS,
    fontFamily: FONT_FAMILIES[font],
    fontSize: LABEL_FONT_SIZES[size4],
    minWidth,
    maxWidth: Math.max(
      // Guard because a DOM nodes can't be less 0
      0,
      // A 'w' width that we're setting as the min-width
      Math.ceil(minWidth + EXTRA_PADDINGS[size4]),
      // The actual text size
      Math.ceil(w / shape.props.scale - LABEL_PADDING * 2)
    )
  });
  return {
    w: textSize.w + LABEL_PADDING * 2,
    h: textSize.h + LABEL_PADDING * 2
  };
}

// ../node_modules/tldraw/dist-esm/lib/shapes/highlight/HighlightShapeUtil.mjs
var import_jsx_runtime219 = __toESM(require_jsx_runtime(), 1);

// ../node_modules/tldraw/dist-esm/lib/shapes/shared/useColorSpace.mjs
var import_react146 = __toESM(require_react(), 1);
function useColorSpace() {
  const [supportsP3, setSupportsP3] = (0, import_react146.useState)(false);
  (0, import_react146.useEffect)(() => {
    const supportsSyntax = CSS.supports("color", "color(display-p3 1 1 1)");
    const query = matchMedia("(color-gamut: p3)");
    setSupportsP3(supportsSyntax && query.matches);
    const onChange = () => setSupportsP3(supportsSyntax && query.matches);
    query.addEventListener("change", onChange);
    return () => query.removeEventListener("change", onChange);
  }, []);
  const forceSrgb = useValue(debugFlags.forceSrgb);
  return forceSrgb || !supportsP3 ? "srgb" : "p3";
}

// ../node_modules/tldraw/dist-esm/lib/shapes/highlight/HighlightShapeUtil.mjs
var HighlightShapeUtil = class extends ShapeUtil {
  constructor() {
    super(...arguments);
    __publicField(this, "options", {
      maxPointsPerShape: 600,
      underlayOpacity: 0.82,
      overlayOpacity: 0.35
    });
  }
  hideResizeHandles(shape) {
    return getIsDot2(shape);
  }
  hideRotateHandle(shape) {
    return getIsDot2(shape);
  }
  hideSelectionBoundsFg(shape) {
    return getIsDot2(shape);
  }
  getDefaultProps() {
    return {
      segments: [],
      color: "black",
      size: "m",
      isComplete: false,
      isPen: false,
      scale: 1,
      scaleX: 1,
      scaleY: 1
    };
  }
  getGeometry(shape) {
    const strokeWidth = getStrokeWidth(shape);
    if (getIsDot2(shape)) {
      return new Circle2d({
        x: -strokeWidth / 2,
        y: -strokeWidth / 2,
        radius: strokeWidth / 2,
        isFilled: true
      });
    }
    const { strokePoints, sw } = getHighlightStrokePoints(shape, strokeWidth, true);
    const opts = getHighlightFreehandSettings({ strokeWidth: sw, showAsComplete: true });
    setStrokePointRadii(strokePoints, opts);
    return new Polygon2d({
      points: getStrokeOutlinePoints(strokePoints, opts),
      isFilled: true
    });
  }
  component(shape) {
    const forceSolid = useHighlightForceSolid(this.editor, shape);
    const strokeWidth = getStrokeWidth(shape);
    return (0, import_jsx_runtime219.jsx)(SVGContainer, { children: (0, import_jsx_runtime219.jsx)(
      HighlightRenderer,
      {
        shape,
        forceSolid,
        strokeWidth,
        opacity: this.options.overlayOpacity
      }
    ) });
  }
  backgroundComponent(shape) {
    const forceSolid = useHighlightForceSolid(this.editor, shape);
    const strokeWidth = getStrokeWidth(shape);
    return (0, import_jsx_runtime219.jsx)(SVGContainer, { children: (0, import_jsx_runtime219.jsx)(
      HighlightRenderer,
      {
        shape,
        forceSolid,
        strokeWidth,
        opacity: this.options.underlayOpacity
      }
    ) });
  }
  indicator(shape) {
    const forceSolid = useHighlightForceSolid(this.editor, shape);
    const strokeWidth = getStrokeWidth(shape);
    const { strokePoints, sw } = getHighlightStrokePoints(shape, strokeWidth, forceSolid);
    const allPointsFromSegments = getPointsFromDrawSegments(
      shape.props.segments,
      shape.props.scaleX,
      shape.props.scaleY
    );
    let strokePath;
    if (strokePoints.length < 2) {
      strokePath = getIndicatorDot(allPointsFromSegments[0], sw);
    } else {
      strokePath = getSvgPathFromStrokePoints(strokePoints, false);
    }
    return (0, import_jsx_runtime219.jsx)("path", { d: strokePath });
  }
  toSvg(shape) {
    const strokeWidth = getStrokeWidth(shape);
    const forceSolid = strokeWidth < 1.5;
    const scaleFactor = 1 / shape.props.scale;
    return (0, import_jsx_runtime219.jsx)("g", { transform: `scale(${scaleFactor})`, children: (0, import_jsx_runtime219.jsx)(
      HighlightRenderer,
      {
        forceSolid,
        strokeWidth,
        shape,
        opacity: this.options.overlayOpacity
      }
    ) });
  }
  toBackgroundSvg(shape) {
    const strokeWidth = getStrokeWidth(shape);
    const forceSolid = strokeWidth < 1.5;
    const scaleFactor = 1 / shape.props.scale;
    return (0, import_jsx_runtime219.jsx)("g", { transform: `scale(${scaleFactor})`, children: (0, import_jsx_runtime219.jsx)(
      HighlightRenderer,
      {
        forceSolid,
        strokeWidth,
        shape,
        opacity: this.options.underlayOpacity
      }
    ) });
  }
  onResize(shape, info) {
    const { scaleX, scaleY } = info;
    return {
      props: {
        scaleX: scaleX * shape.props.scaleX,
        scaleY: scaleY * shape.props.scaleY
      }
    };
  }
  getInterpolatedProps(startShape, endShape, t2) {
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      ...endShape.props,
      segments: interpolateSegments(startShape.props.segments, endShape.props.segments, t2),
      scale: lerp(startShape.props.scale, endShape.props.scale, t2)
    };
  }
};
__publicField(HighlightShapeUtil, "type", "highlight");
__publicField(HighlightShapeUtil, "props", highlightShapeProps);
__publicField(HighlightShapeUtil, "migrations", highlightShapeMigrations);
function getShapeDot(point) {
  const r = 0.1;
  return `M ${point.x} ${point.y} m -${r}, 0 a ${r},${r} 0 1,0 ${r * 2},0 a ${r},${r} 0 1,0 -${r * 2},0`;
}
function getIndicatorDot(point, sw) {
  const r = sw / 2;
  return `M ${point.x} ${point.y} m -${r}, 0 a ${r},${r} 0 1,0 ${r * 2},0 a ${r},${r} 0 1,0 -${r * 2},0`;
}
function getHighlightStrokePoints(shape, strokeWidth, forceSolid) {
  var _a6;
  const allPointsFromSegments = getPointsFromDrawSegments(
    shape.props.segments,
    shape.props.scaleX,
    shape.props.scaleY
  );
  const showAsComplete = shape.props.isComplete || ((_a6 = last(shape.props.segments)) == null ? void 0 : _a6.type) === "straight";
  let sw = strokeWidth;
  if (!forceSolid && !shape.props.isPen && allPointsFromSegments.length === 1) {
    sw += rng(shape.id)() * (strokeWidth / 6);
  }
  const options2 = getHighlightFreehandSettings({
    strokeWidth: sw,
    showAsComplete
  });
  const strokePoints = getStrokePoints(allPointsFromSegments, options2);
  return { strokePoints, sw };
}
function getStrokeWidth(shape) {
  return FONT_SIZES[shape.props.size] * 1.12 * shape.props.scale;
}
function getIsDot2(shape) {
  return shape.props.segments.length === 1 && shape.props.segments[0].path.length < 24;
}
function HighlightRenderer({
  strokeWidth,
  forceSolid,
  shape,
  opacity
}) {
  var _a6;
  const theme = useDefaultColorTheme();
  const allPointsFromSegments = getPointsFromDrawSegments(
    shape.props.segments,
    shape.props.scaleX,
    shape.props.scaleY
  );
  let sw = strokeWidth;
  if (!forceSolid && !shape.props.isPen && allPointsFromSegments.length === 1) {
    sw += rng(shape.id)() * (sw / 6);
  }
  const options2 = getHighlightFreehandSettings({
    strokeWidth: sw,
    showAsComplete: shape.props.isComplete || ((_a6 = last(shape.props.segments)) == null ? void 0 : _a6.type) === "straight"
  });
  const strokePoints = getStrokePoints(allPointsFromSegments, options2);
  const solidStrokePath = strokePoints.length > 1 ? getSvgPathFromStrokePoints(strokePoints, false) : getShapeDot(allPointsFromSegments[0]);
  const colorSpace = useColorSpace();
  const color = getColorValue(
    theme,
    shape.props.color,
    colorSpace === "p3" ? "highlightP3" : "highlightSrgb"
  );
  return (0, import_jsx_runtime219.jsx)(
    "path",
    {
      d: solidStrokePath,
      strokeLinecap: "round",
      fill: "none",
      pointerEvents: "all",
      stroke: color,
      strokeWidth: sw,
      opacity
    }
  );
}
function useHighlightForceSolid(editor, shape) {
  return useValue(
    "forceSolid",
    () => {
      const sw = getStrokeWidth(shape);
      const zoomLevel = editor.getEfficientZoomLevel();
      if (sw / zoomLevel < 1.5) {
        return true;
      }
      return false;
    },
    [editor]
  );
}

// ../node_modules/tldraw/dist-esm/lib/shapes/image/ImageShapeUtil.mjs
var import_jsx_runtime221 = __toESM(require_jsx_runtime(), 1);
var import_classnames37 = __toESM(require_classnames(), 1);
var import_react148 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/shapes/shared/BrokenAssetIcon.mjs
var import_jsx_runtime220 = __toESM(require_jsx_runtime(), 1);
function BrokenAssetIcon() {
  return (0, import_jsx_runtime220.jsxs)(
    "svg",
    {
      width: "15",
      height: "15",
      viewBox: "0 0 30 30",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      stroke: "currentColor",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      children: [
        (0, import_jsx_runtime220.jsx)("path", { d: "M3,11 L3,3 11,3", strokeWidth: "2" }),
        (0, import_jsx_runtime220.jsx)("path", { d: "M19,27 L27,27 L27,19", strokeWidth: "2" }),
        (0, import_jsx_runtime220.jsx)("path", { d: "M27,3 L3,27", strokeWidth: "2" })
      ]
    }
  );
}

// ../node_modules/tldraw/dist-esm/lib/shapes/shared/useImageOrVideoAsset.mjs
var import_react147 = __toESM(require_react(), 1);
function useImageOrVideoAsset({ shapeId, assetId, width }) {
  const editor = useEditor();
  const exportInfo = useSvgExportContext();
  const exportIsReady = useDelaySvgExport();
  const [result, setResult] = (0, import_react147.useState)(() => ({
    asset: assetId ? editor.getAsset(assetId) ?? null : null,
    url: null
  }));
  const didAlreadyResolve = (0, import_react147.useRef)(false);
  const previousUrl = (0, import_react147.useRef)(null);
  (0, import_react147.useEffect)(() => {
    if (!assetId) return;
    let isCancelled = false;
    let cancelDebounceFn;
    const cleanupEffectScheduler = react("update state", () => {
      if (!exportInfo && shapeId && editor.getCulledShapes().has(shapeId)) return;
      const asset = editor.getAsset(assetId);
      if (!asset) {
        setResult((prev) => ({ ...prev, asset: null, url: null }));
        return;
      }
      if (!asset.props.src) {
        const preview = editor.getTemporaryAssetPreview(asset.id);
        if (preview) {
          if (previousUrl.current !== preview) {
            previousUrl.current = preview;
            setResult((prev) => ({ ...prev, isPlaceholder: true, url: preview }));
            exportIsReady();
          }
          return;
        }
      }
      const screenScale = exportInfo ? exportInfo.scale * (width / asset.props.w) : editor.getEfficientZoomLevel() * (width / asset.props.w);
      function resolve(asset2, url) {
        if (isCancelled) return;
        if (previousUrl.current === url) return;
        didAlreadyResolve.current = true;
        previousUrl.current = url;
        setResult({ asset: asset2, url });
        exportIsReady();
      }
      if (didAlreadyResolve.current) {
        let tick = 0;
        const resolveAssetAfterAWhile = () => {
          tick++;
          if (tick > 500 / 16) {
            resolveAssetUrl(editor, assetId, screenScale, exportInfo, (url) => resolve(asset, url));
            cancelDebounceFn == null ? void 0 : cancelDebounceFn();
          }
        };
        cancelDebounceFn == null ? void 0 : cancelDebounceFn();
        editor.on("tick", resolveAssetAfterAWhile);
        cancelDebounceFn = () => editor.off("tick", resolveAssetAfterAWhile);
      } else {
        resolveAssetUrl(editor, assetId, screenScale, exportInfo, (url) => resolve(asset, url));
      }
    });
    return () => {
      cleanupEffectScheduler();
      cancelDebounceFn == null ? void 0 : cancelDebounceFn();
      isCancelled = true;
    };
  }, [editor, assetId, exportInfo, exportIsReady, shapeId, width]);
  return result;
}
function resolveAssetUrl(editor, assetId, screenScale, exportInfo, callback) {
  editor.resolveAssetUrl(assetId, {
    screenScale,
    shouldResolveToOriginal: exportInfo ? exportInfo.pixelRatio === null : false,
    dpr: (exportInfo == null ? void 0 : exportInfo.pixelRatio) ?? void 0
  }).then((url) => {
    callback(url);
  });
}

// ../node_modules/tldraw/dist-esm/lib/shapes/image/ImageShapeUtil.mjs
async function getDataURIFromURL(url) {
  const response = await fetch2(url);
  const blob = await response.blob();
  return FileHelpers.blobToDataUrl(blob);
}
var imageSvgExportCache = new WeakCache();
var ImageShapeUtil = class extends BaseBoxShapeUtil {
  isAspectRatioLocked() {
    return true;
  }
  canCrop() {
    return true;
  }
  isExportBoundsContainer() {
    return true;
  }
  getDefaultProps() {
    return {
      w: 100,
      h: 100,
      assetId: null,
      playing: true,
      url: "",
      crop: null,
      flipX: false,
      flipY: false,
      altText: ""
    };
  }
  getGeometry(shape) {
    var _a6;
    if ((_a6 = shape.props.crop) == null ? void 0 : _a6.isCircle) {
      return new Ellipse2d({
        width: shape.props.w,
        height: shape.props.h,
        isFilled: true
      });
    }
    return new Rectangle2d({
      width: shape.props.w,
      height: shape.props.h,
      isFilled: true
    });
  }
  getAriaDescriptor(shape) {
    return shape.props.altText;
  }
  onResize(shape, info) {
    let resized = resizeBox(shape, info);
    const { flipX, flipY } = info.initialShape.props;
    const { scaleX, scaleY, mode } = info;
    resized = {
      ...resized,
      props: {
        ...resized.props,
        flipX: scaleX < 0 !== flipX,
        flipY: scaleY < 0 !== flipY
      }
    };
    if (!shape.props.crop) return resized;
    const flipCropHorizontally = (
      // We used the flip horizontally feature
      // We resized the shape past it's bounds, so it flipped
      mode === "scale_shape" && scaleX === -1 || mode === "resize_bounds" && flipX !== resized.props.flipX
    );
    const flipCropVertically = (
      // We used the flip vertically feature
      // We resized the shape past it's bounds, so it flipped
      mode === "scale_shape" && scaleY === -1 || mode === "resize_bounds" && flipY !== resized.props.flipY
    );
    const { topLeft, bottomRight } = shape.props.crop;
    resized.props.crop = {
      topLeft: {
        x: flipCropHorizontally ? 1 - bottomRight.x : topLeft.x,
        y: flipCropVertically ? 1 - bottomRight.y : topLeft.y
      },
      bottomRight: {
        x: flipCropHorizontally ? 1 - topLeft.x : bottomRight.x,
        y: flipCropVertically ? 1 - topLeft.y : bottomRight.y
      },
      isCircle: shape.props.crop.isCircle
    };
    return resized;
  }
  component(shape) {
    return (0, import_jsx_runtime221.jsx)(ImageShape, { shape });
  }
  indicator(shape) {
    var _a6;
    const isCropping = this.editor.getCroppingShapeId() === shape.id;
    if (isCropping) return null;
    if ((_a6 = shape.props.crop) == null ? void 0 : _a6.isCircle) {
      return (0, import_jsx_runtime221.jsx)(
        "ellipse",
        {
          cx: toDomPrecision(shape.props.w / 2),
          cy: toDomPrecision(shape.props.h / 2),
          rx: toDomPrecision(shape.props.w / 2),
          ry: toDomPrecision(shape.props.h / 2)
        }
      );
    }
    return (0, import_jsx_runtime221.jsx)("rect", { width: toDomPrecision(shape.props.w), height: toDomPrecision(shape.props.h) });
  }
  async toSvg(shape, ctx) {
    const props = shape.props;
    if (!props.assetId) return null;
    const asset = this.editor.getAsset(props.assetId);
    if (!asset) return null;
    const { w } = getUncroppedSize(shape.props, props.crop);
    const src = await imageSvgExportCache.get(asset, async () => {
      let src2 = await ctx.resolveAssetUrl(asset.id, w);
      if (!src2) return null;
      if (src2.startsWith("blob:") || src2.startsWith("http") || src2.startsWith("/") || src2.startsWith("./")) {
        src2 = await getDataURIFromURL(src2) || "";
      }
      if (getIsAnimated(this.editor, asset.id)) {
        const { promise } = getFirstFrameOfAnimatedImage(src2);
        src2 = await promise;
      }
      return src2;
    });
    if (!src) return null;
    return (0, import_jsx_runtime221.jsx)(SvgImage, { shape, src });
  }
  onDoubleClickEdge(shape) {
    const props = shape.props;
    if (!props) return;
    if (this.editor.getCroppingShapeId() !== shape.id) {
      return;
    }
    const crop = structuredClone(props.crop) || {
      topLeft: { x: 0, y: 0 },
      bottomRight: { x: 1, y: 1 }
    };
    const { w, h: h2 } = getUncroppedSize(shape.props, crop);
    const pointDelta = new Vec(crop.topLeft.x * w, crop.topLeft.y * h2).rot(shape.rotation);
    const partial = {
      id: shape.id,
      type: shape.type,
      x: shape.x - pointDelta.x,
      y: shape.y - pointDelta.y,
      props: {
        crop: {
          topLeft: { x: 0, y: 0 },
          bottomRight: { x: 1, y: 1 }
        },
        w,
        h: h2
      }
    };
    this.editor.updateShapes([partial]);
  }
  getInterpolatedProps(startShape, endShape, t2) {
    function interpolateCrop(startShape2, endShape2) {
      var _a6, _b3, _c, _d;
      if (startShape2.props.crop === null && endShape2.props.crop === null) return null;
      const startTL = ((_a6 = startShape2.props.crop) == null ? void 0 : _a6.topLeft) || { x: 0, y: 0 };
      const startBR = ((_b3 = startShape2.props.crop) == null ? void 0 : _b3.bottomRight) || { x: 1, y: 1 };
      const endTL = ((_c = endShape2.props.crop) == null ? void 0 : _c.topLeft) || { x: 0, y: 0 };
      const endBR = ((_d = endShape2.props.crop) == null ? void 0 : _d.bottomRight) || { x: 1, y: 1 };
      return {
        topLeft: { x: lerp(startTL.x, endTL.x, t2), y: lerp(startTL.y, endTL.y, t2) },
        bottomRight: { x: lerp(startBR.x, endBR.x, t2), y: lerp(startBR.y, endBR.y, t2) }
      };
    }
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      w: lerp(startShape.props.w, endShape.props.w, t2),
      h: lerp(startShape.props.h, endShape.props.h, t2),
      crop: interpolateCrop(startShape, endShape)
    };
  }
};
__publicField(ImageShapeUtil, "type", "image");
__publicField(ImageShapeUtil, "props", imageShapeProps);
__publicField(ImageShapeUtil, "migrations", imageShapeMigrations);
var ImageShape = (0, import_react148.memo)(function ImageShape2({ shape }) {
  var _a6, _b3;
  const editor = useEditor();
  const { w } = getUncroppedSize(shape.props, shape.props.crop);
  const { asset, url } = useImageOrVideoAsset({
    shapeId: shape.id,
    assetId: shape.props.assetId,
    width: w
  });
  const prefersReducedMotion = usePrefersReducedMotion();
  const [staticFrameSrc, setStaticFrameSrc] = (0, import_react148.useState)("");
  const [loadedUrl, setLoadedUrl] = (0, import_react148.useState)(null);
  const isAnimated = asset && getIsAnimated(editor, asset.id);
  (0, import_react148.useEffect)(() => {
    if (url && isAnimated) {
      const { promise, cancel } = getFirstFrameOfAnimatedImage(url);
      promise.then((dataUrl) => {
        setStaticFrameSrc(dataUrl);
        setLoadedUrl(url);
      });
      return () => {
        cancel();
      };
    }
  }, [editor, isAnimated, prefersReducedMotion, url]);
  const showCropPreview = useValue(
    "show crop preview",
    () => shape.id === editor.getOnlySelectedShapeId() && editor.getCroppingShapeId() === shape.id && editor.isIn("select.crop"),
    [editor, shape.id]
  );
  const reduceMotion = prefersReducedMotion && (((_a6 = asset == null ? void 0 : asset.props.mimeType) == null ? void 0 : _a6.includes("video")) || isAnimated);
  const containerStyle = getCroppedContainerStyle(shape);
  const nextSrc = url === loadedUrl ? null : url;
  const loadedSrc = reduceMotion ? staticFrameSrc : loadedUrl;
  if (!url && !(asset == null ? void 0 : asset.props.src)) {
    return (0, import_jsx_runtime221.jsxs)(
      HTMLContainer,
      {
        id: shape.id,
        style: {
          overflow: "hidden",
          width: shape.props.w,
          height: shape.props.h,
          color: "var(--tl-color-text-3)",
          backgroundColor: "var(--tl-color-low)",
          border: "1px solid var(--tl-color-low-border)"
        },
        children: [
          (0, import_jsx_runtime221.jsx)(
            "div",
            {
              className: (0, import_classnames37.default)("tl-image-container", asset && "tl-image-container-loading"),
              style: containerStyle,
              children: asset ? null : (0, import_jsx_runtime221.jsx)(BrokenAssetIcon, {})
            }
          ),
          "url" in shape.props && shape.props.url && (0, import_jsx_runtime221.jsx)(HyperlinkButton, { url: shape.props.url })
        ]
      }
    );
  }
  const crossOrigin = isAnimated ? "anonymous" : void 0;
  return (0, import_jsx_runtime221.jsxs)(import_jsx_runtime221.Fragment, { children: [
    showCropPreview && loadedSrc && (0, import_jsx_runtime221.jsx)("div", { style: containerStyle, children: (0, import_jsx_runtime221.jsx)(
      "img",
      {
        className: "tl-image",
        style: { ...getFlipStyle(shape), opacity: 0.1 },
        crossOrigin,
        src: loadedSrc,
        referrerPolicy: "strict-origin-when-cross-origin",
        draggable: false,
        alt: ""
      }
    ) }),
    (0, import_jsx_runtime221.jsxs)(
      HTMLContainer,
      {
        id: shape.id,
        style: {
          overflow: "hidden",
          width: shape.props.w,
          height: shape.props.h,
          borderRadius: ((_b3 = shape.props.crop) == null ? void 0 : _b3.isCircle) ? "50%" : void 0
        },
        children: [
          (0, import_jsx_runtime221.jsxs)("div", { className: (0, import_classnames37.default)("tl-image-container"), style: containerStyle, children: [
            loadedSrc && (0, import_jsx_runtime221.jsx)(
              "img",
              {
                className: "tl-image",
                style: getFlipStyle(shape),
                crossOrigin,
                src: loadedSrc,
                referrerPolicy: "strict-origin-when-cross-origin",
                draggable: false,
                alt: ""
              },
              loadedSrc
            ),
            nextSrc && (0, import_jsx_runtime221.jsx)(
              "img",
              {
                className: "tl-image",
                style: getFlipStyle(shape),
                crossOrigin,
                src: nextSrc,
                referrerPolicy: "strict-origin-when-cross-origin",
                draggable: false,
                alt: shape.props.altText,
                onLoad: () => setLoadedUrl(nextSrc)
              },
              nextSrc
            )
          ] }),
          shape.props.url && (0, import_jsx_runtime221.jsx)(HyperlinkButton, { url: shape.props.url })
        ]
      }
    )
  ] });
});
function getIsAnimated(editor, assetId) {
  const asset = assetId ? editor.getAsset(assetId) : void 0;
  if (!asset) return false;
  return "mimeType" in asset.props && MediaHelpers.isAnimatedImageType(asset == null ? void 0 : asset.props.mimeType) || "isAnimated" in asset.props && asset.props.isAnimated;
}
function getCroppedContainerStyle(shape) {
  const crop = shape.props.crop;
  const topLeft = crop == null ? void 0 : crop.topLeft;
  if (!topLeft) {
    return {
      width: shape.props.w,
      height: shape.props.h
    };
  }
  const { w, h: h2 } = getUncroppedSize(shape.props, crop);
  const offsetX = -topLeft.x * w;
  const offsetY = -topLeft.y * h2;
  return {
    transform: `translate(${offsetX}px, ${offsetY}px)`,
    width: w,
    height: h2
  };
}
function getFlipStyle(shape, size4) {
  const { flipX, flipY, crop } = shape.props;
  if (!flipX && !flipY) return void 0;
  let cropOffsetX;
  let cropOffsetY;
  if (crop) {
    const { w, h: h2 } = getUncroppedSize(shape.props, crop);
    const cropWidth = crop.bottomRight.x - crop.topLeft.x;
    const cropHeight = crop.bottomRight.y - crop.topLeft.y;
    cropOffsetX = modulate(crop.topLeft.x, [0, 1 - cropWidth], [0, w - shape.props.w]);
    cropOffsetY = modulate(crop.topLeft.y, [0, 1 - cropHeight], [0, h2 - shape.props.h]);
  }
  const scale = `scale(${flipX ? -1 : 1}, ${flipY ? -1 : 1})`;
  const translate = size4 ? `translate(${(flipX ? size4.width : 0) - (cropOffsetX ? cropOffsetX : 0)}px,
		             ${(flipY ? size4.height : 0) - (cropOffsetY ? cropOffsetY : 0)}px)` : "";
  return {
    transform: `${translate} ${scale}`,
    // in SVG, flipping around the center doesn't work so we use explicit width/height
    transformOrigin: size4 ? "0 0" : "center center"
  };
}
function SvgImage({ shape, src }) {
  const cropClipId = useUniqueSafeId();
  const containerStyle = getCroppedContainerStyle(shape);
  const crop = shape.props.crop;
  if (containerStyle.transform && crop) {
    const { transform: cropTransform, width, height } = containerStyle;
    const croppedWidth = (crop.bottomRight.x - crop.topLeft.x) * width;
    const croppedHeight = (crop.bottomRight.y - crop.topLeft.y) * height;
    const points = [
      new Vec(0, 0),
      new Vec(croppedWidth, 0),
      new Vec(croppedWidth, croppedHeight),
      new Vec(0, croppedHeight)
    ];
    const flip4 = getFlipStyle(shape, { width, height });
    return (0, import_jsx_runtime221.jsxs)(import_jsx_runtime221.Fragment, { children: [
      (0, import_jsx_runtime221.jsx)("defs", { children: (0, import_jsx_runtime221.jsx)("clipPath", { id: cropClipId, children: crop.isCircle ? (0, import_jsx_runtime221.jsx)(
        "ellipse",
        {
          cx: croppedWidth / 2,
          cy: croppedHeight / 2,
          rx: croppedWidth / 2,
          ry: croppedHeight / 2
        }
      ) : (0, import_jsx_runtime221.jsx)("polygon", { points: points.map((p) => `${p.x},${p.y}`).join(" ") }) }) }),
      (0, import_jsx_runtime221.jsx)("g", { clipPath: `url(#${cropClipId})`, children: (0, import_jsx_runtime221.jsx)(
        "image",
        {
          href: src,
          width,
          height,
          "aria-label": shape.props.altText,
          style: flip4 ? { ...flip4 } : { transform: cropTransform }
        }
      ) })
    ] });
  } else {
    return (0, import_jsx_runtime221.jsx)(
      "image",
      {
        href: src,
        width: shape.props.w,
        height: shape.props.h,
        "aria-label": shape.props.altText,
        style: getFlipStyle(shape, { width: shape.props.w, height: shape.props.h })
      }
    );
  }
}
function getFirstFrameOfAnimatedImage(url) {
  let cancelled = false;
  const promise = new Promise((resolve) => {
    const image = Image();
    image.onload = () => {
      if (cancelled) return;
      const canvas = document.createElement("canvas");
      canvas.width = image.width;
      canvas.height = image.height;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      ctx.drawImage(image, 0, 0);
      resolve(canvas.toDataURL());
    };
    image.crossOrigin = "anonymous";
    image.src = url;
  });
  return { promise, cancel: () => cancelled = true };
}

// ../node_modules/tldraw/dist-esm/lib/shapes/line/LineShapeUtil.mjs
var import_jsx_runtime222 = __toESM(require_jsx_runtime(), 1);
var handlesCache = new WeakCache();
var LineShapeUtil = class extends ShapeUtil {
  hideResizeHandles() {
    return true;
  }
  hideRotateHandle() {
    return true;
  }
  hideSelectionBoundsFg() {
    return true;
  }
  hideSelectionBoundsBg() {
    return true;
  }
  hideInMinimap() {
    return true;
  }
  getDefaultProps() {
    const [start, end] = getIndices(2);
    return {
      dash: "draw",
      size: "m",
      color: "black",
      spline: "line",
      points: {
        [start]: { id: start, index: start, x: 0, y: 0 },
        [end]: { id: end, index: end, x: 0.1, y: 0.1 }
      },
      scale: 1
    };
  }
  getGeometry(shape) {
    const geometry = getPathForLineShape(shape).toGeometry();
    assert(geometry instanceof PathBuilderGeometry2d);
    return geometry;
  }
  getHandles(shape) {
    return handlesCache.get(shape.props, () => {
      const spline = this.getGeometry(shape);
      const points = linePointsToArray(shape);
      const results = points.map((point) => ({
        ...point,
        id: point.index,
        type: "vertex",
        canSnap: true
      }));
      for (let i = 0; i < points.length - 1; i++) {
        const index2 = getIndexBetween(points[i].index, points[i + 1].index);
        const segment = spline.getSegments()[i];
        const point = segment.interpolateAlongEdge(0.5);
        results.push({
          id: index2,
          type: "create",
          index: index2,
          x: point.x,
          y: point.y,
          canSnap: true
        });
      }
      return results.sort(sortByIndex);
    });
  }
  //   Events
  onResize(shape, info) {
    const { scaleX, scaleY } = info;
    return {
      props: {
        points: mapObjectMapValues(shape.props.points, (_, { id, index: index2, x, y }) => ({
          id,
          index: index2,
          x: x * scaleX,
          y: y * scaleY
        }))
      }
    };
  }
  onBeforeCreate(next) {
    const {
      props: { points }
    } = next;
    const pointKeys = Object.keys(points);
    if (pointKeys.length < 2) {
      return;
    }
    const firstPoint = points[pointKeys[0]];
    const allSame = pointKeys.every((key) => {
      const point = points[key];
      return point.x === firstPoint.x && point.y === firstPoint.y;
    });
    if (allSame) {
      const lastKey = pointKeys[pointKeys.length - 1];
      points[lastKey] = {
        ...points[lastKey],
        x: points[lastKey].x + 0.1,
        y: points[lastKey].y + 0.1
      };
      return next;
    }
    return;
  }
  onHandleDrag(shape, { handle }) {
    const newPoint = maybeSnapToGrid(new Vec(handle.x, handle.y), this.editor);
    return {
      ...shape,
      props: {
        ...shape.props,
        points: {
          ...shape.props.points,
          [handle.id]: { id: handle.id, index: handle.index, x: newPoint.x, y: newPoint.y }
        }
      }
    };
  }
  onHandleDragStart(shape, { handle }) {
    if (handle.type === "create") {
      return {
        ...shape,
        props: {
          ...shape.props,
          points: {
            ...shape.props.points,
            [handle.index]: { id: handle.index, index: handle.index, x: handle.x, y: handle.y }
          }
        }
      };
    }
    return;
  }
  component(shape) {
    return (0, import_jsx_runtime222.jsx)(SVGContainer, { style: { minWidth: 50, minHeight: 50 }, children: (0, import_jsx_runtime222.jsx)(LineShapeSvg, { shape }) });
  }
  indicator(shape) {
    const strokeWidth = STROKE_SIZES[shape.props.size] * shape.props.scale;
    const path = getPathForLineShape(shape);
    const { dash } = shape.props;
    return path.toSvg({
      style: dash === "draw" ? "draw" : "solid",
      strokeWidth: 1,
      passes: 1,
      randomSeed: shape.id,
      offset: 0,
      roundness: strokeWidth * 2,
      props: { strokeWidth: void 0 }
    });
  }
  toSvg(shape) {
    return (0, import_jsx_runtime222.jsx)(LineShapeSvg, { shouldScale: true, shape });
  }
  getHandleSnapGeometry(shape) {
    const points = linePointsToArray(shape);
    return {
      points,
      getSelfSnapPoints: (handle) => {
        const index2 = this.getHandles(shape).filter((h2) => h2.type === "vertex").findIndex((h2) => h2.id === handle.id);
        return points.filter((_, i) => Math.abs(i - index2) > 1).map(Vec.From);
      },
      getSelfSnapOutline: (handle) => {
        const index2 = this.getHandles(shape).filter((h2) => h2.type === "vertex").findIndex((h2) => h2.id === handle.id);
        const segments = this.getGeometry(shape).getSegments().filter((_, i) => i !== index2 - 1 && i !== index2);
        if (!segments.length) return null;
        return new Group2d({ children: segments });
      }
    };
  }
  getInterpolatedProps(startShape, endShape, t2) {
    const startPoints = linePointsToArray(startShape);
    const endPoints = linePointsToArray(endShape);
    const pointsToUseStart = [];
    const pointsToUseEnd = [];
    let index2 = ZERO_INDEX_KEY;
    if (startPoints.length > endPoints.length) {
      for (let i = 0; i < startPoints.length; i++) {
        pointsToUseStart[i] = { ...startPoints[i] };
        if (endPoints[i] === void 0) {
          pointsToUseEnd[i] = { ...endPoints[endPoints.length - 1], id: index2 };
        } else {
          pointsToUseEnd[i] = { ...endPoints[i], id: index2 };
        }
        index2 = getIndexAbove(index2);
      }
    } else if (endPoints.length > startPoints.length) {
      for (let i = 0; i < endPoints.length; i++) {
        pointsToUseEnd[i] = { ...endPoints[i] };
        if (startPoints[i] === void 0) {
          pointsToUseStart[i] = {
            ...startPoints[startPoints.length - 1],
            id: index2
          };
        } else {
          pointsToUseStart[i] = { ...startPoints[i], id: index2 };
        }
        index2 = getIndexAbove(index2);
      }
    } else {
      for (let i = 0; i < endPoints.length; i++) {
        pointsToUseStart[i] = startPoints[i];
        pointsToUseEnd[i] = endPoints[i];
      }
    }
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      points: Object.fromEntries(
        pointsToUseStart.map((point, i) => {
          const endPoint = pointsToUseEnd[i];
          return [
            point.id,
            {
              ...point,
              x: lerp(point.x, endPoint.x, t2),
              y: lerp(point.y, endPoint.y, t2)
            }
          ];
        })
      ),
      scale: lerp(startShape.props.scale, endShape.props.scale, t2)
    };
  }
};
__publicField(LineShapeUtil, "type", "line");
__publicField(LineShapeUtil, "props", lineShapeProps);
__publicField(LineShapeUtil, "migrations", lineShapeMigrations);
function linePointsToArray(shape) {
  return Object.values(shape.props.points).sort(sortByIndex);
}
var pathCache2 = new WeakCache();
function getPathForLineShape(shape) {
  return pathCache2.get(shape, () => {
    const points = linePointsToArray(shape).map(Vec.From);
    switch (shape.props.spline) {
      case "cubic": {
        return PathBuilder.cubicSplineThroughPoints(points, { endOffsets: 0 });
      }
      case "line": {
        return PathBuilder.lineThroughPoints(points, { endOffsets: 0 });
      }
    }
  });
}
function LineShapeSvg({
  shape,
  shouldScale = false,
  forceSolid = false
}) {
  const theme = useDefaultColorTheme();
  const path = getPathForLineShape(shape);
  const { dash, color, size: size4 } = shape.props;
  const scaleFactor = 1 / shape.props.scale;
  const scale = shouldScale ? scaleFactor : 1;
  const strokeWidth = STROKE_SIZES[size4] * shape.props.scale;
  return path.toSvg({
    style: dash,
    strokeWidth,
    forceSolid,
    randomSeed: shape.id,
    props: {
      transform: `scale(${scale})`,
      stroke: getColorValue(theme, color, "solid"),
      fill: "none"
    }
  });
}

// ../node_modules/tldraw/dist-esm/lib/shapes/note/NoteShapeUtil.mjs
var import_jsx_runtime223 = __toESM(require_jsx_runtime(), 1);
var import_react149 = __toESM(require_react(), 1);
var NoteShapeUtil = class extends ShapeUtil {
  constructor() {
    super(...arguments);
    __publicField(this, "options", {
      resizeMode: "none"
    });
  }
  canEdit() {
    return true;
  }
  hideResizeHandles() {
    const { resizeMode } = this.options;
    switch (resizeMode) {
      case "none": {
        return true;
      }
      case "scale": {
        return false;
      }
      default: {
        throw exhaustiveSwitchError(resizeMode);
      }
    }
  }
  isAspectRatioLocked() {
    return this.options.resizeMode === "scale";
  }
  hideSelectionBoundsFg() {
    return false;
  }
  getDefaultProps() {
    return {
      color: "black",
      richText: toRichText(""),
      size: "m",
      font: "draw",
      align: "middle",
      verticalAlign: "middle",
      labelColor: "black",
      growY: 0,
      fontSizeAdjustment: 0,
      url: "",
      scale: 1
    };
  }
  getGeometry(shape) {
    const { labelHeight, labelWidth } = getLabelSize(this.editor, shape);
    const { scale } = shape.props;
    const lh = labelHeight * scale;
    const lw = labelWidth * scale;
    const nw = NOTE_SIZE * scale;
    const nh = getNoteHeight(shape);
    return new Group2d({
      children: [
        new Rectangle2d({ width: nw, height: nh, isFilled: true }),
        new Rectangle2d({
          x: shape.props.align === "start" ? 0 : shape.props.align === "end" ? nw - lw : (nw - lw) / 2,
          y: shape.props.verticalAlign === "start" ? 0 : shape.props.verticalAlign === "end" ? nh - lh : (nh - lh) / 2,
          width: lw,
          height: lh,
          isFilled: true,
          isLabel: true,
          excludeFromShapeBounds: true
        })
      ]
    });
  }
  getHandles(shape) {
    const { scale } = shape.props;
    const isCoarsePointer = this.editor.getInstanceState().isCoarsePointer;
    if (isCoarsePointer) return [];
    const zoom = this.editor.getEfficientZoomLevel();
    if (zoom * scale < 0.25) return [];
    const nh = getNoteHeight(shape);
    const nw = NOTE_SIZE * scale;
    const offset4 = CLONE_HANDLE_MARGIN / zoom * scale;
    if (zoom * scale < 0.5) {
      return [
        {
          id: "bottom",
          index: "a3",
          type: "clone",
          x: nw / 2,
          y: nh + offset4
        }
      ];
    }
    return [
      {
        id: "top",
        index: "a1",
        type: "clone",
        x: nw / 2,
        y: -offset4
      },
      {
        id: "right",
        index: "a2",
        type: "clone",
        x: nw + offset4,
        y: nh / 2
      },
      {
        id: "bottom",
        index: "a3",
        type: "clone",
        x: nw / 2,
        y: nh + offset4
      },
      {
        id: "left",
        index: "a4",
        type: "clone",
        x: -offset4,
        y: nh / 2
      }
    ];
  }
  onResize(shape, info) {
    const { resizeMode } = this.options;
    switch (resizeMode) {
      case "none": {
        return void 0;
      }
      case "scale": {
        return resizeScaled(shape, info);
      }
      default: {
        throw exhaustiveSwitchError(resizeMode);
      }
    }
  }
  getText(shape) {
    return renderPlaintextFromRichText(this.editor, shape.props.richText);
  }
  getFontFaces(shape) {
    if (isEmptyRichText(shape.props.richText)) {
      return EMPTY_ARRAY;
    }
    return getFontsFromRichText(this.editor, shape.props.richText, {
      family: `tldraw_${shape.props.font}`,
      weight: "normal",
      style: "normal"
    });
  }
  component(shape) {
    const {
      id,
      type,
      props: {
        labelColor,
        scale,
        color,
        font,
        size: size4,
        align,
        richText,
        verticalAlign,
        fontSizeAdjustment
      }
    } = shape;
    const handleKeyDown2 = useNoteKeydownHandler(id);
    const theme = useDefaultColorTheme();
    const nw = NOTE_SIZE * scale;
    const nh = getNoteHeight(shape);
    const rotation = useValue(
      "shape rotation",
      () => {
        var _a6;
        return ((_a6 = this.editor.getShapePageTransform(id)) == null ? void 0 : _a6.rotation()) ?? 0;
      },
      [this.editor]
    );
    const isDarkMode = useValue("dark mode", () => this.editor.user.getIsDarkMode(), [this.editor]);
    let hideShadows = useEfficientZoomThreshold(scale * 0.25);
    if (isDarkMode) hideShadows = true;
    const isSelected = shape.id === this.editor.getOnlySelectedShapeId();
    const isReadyForEditing = useIsReadyForEditing(this.editor, shape.id);
    const isEmpty = isEmptyRichText(richText);
    return (0, import_jsx_runtime223.jsxs)(import_jsx_runtime223.Fragment, { children: [
      (0, import_jsx_runtime223.jsx)(
        "div",
        {
          id,
          className: "tl-note__container",
          style: {
            width: nw,
            height: nh,
            backgroundColor: getColorValue(theme, color, "noteFill"),
            borderBottom: hideShadows ? isDarkMode ? `${2 * scale}px solid rgb(20, 20, 20)` : `${2 * scale}px solid rgb(144, 144, 144)` : "none",
            boxShadow: hideShadows ? "none" : getNoteShadow(shape.id, rotation, scale)
          },
          children: (isSelected || isReadyForEditing || !isEmpty) && (0, import_jsx_runtime223.jsx)(
            RichTextLabel,
            {
              shapeId: id,
              type,
              font,
              fontSize: (fontSizeAdjustment || LABEL_FONT_SIZES[size4]) * scale,
              lineHeight: TEXT_PROPS.lineHeight,
              align,
              verticalAlign,
              richText,
              isSelected,
              labelColor: labelColor === "black" ? getColorValue(theme, color, "noteText") : getColorValue(theme, labelColor, "fill"),
              wrap: true,
              padding: LABEL_PADDING * scale,
              hasCustomTabBehavior: true,
              showTextOutline: false,
              onKeyDown: handleKeyDown2
            }
          )
        }
      ),
      "url" in shape.props && shape.props.url && (0, import_jsx_runtime223.jsx)(HyperlinkButton, { url: shape.props.url })
    ] });
  }
  indicator(shape) {
    const { scale } = shape.props;
    return (0, import_jsx_runtime223.jsx)(
      "rect",
      {
        rx: scale,
        width: toDomPrecision(NOTE_SIZE * scale),
        height: toDomPrecision(getNoteHeight(shape))
      }
    );
  }
  toSvg(shape, ctx) {
    const theme = getDefaultColorTheme({ isDarkMode: ctx.isDarkMode });
    const bounds = getBoundsForSVG(shape);
    const textLabel = (0, import_jsx_runtime223.jsx)(
      RichTextSVG,
      {
        fontSize: shape.props.fontSizeAdjustment || LABEL_FONT_SIZES[shape.props.size],
        font: shape.props.font,
        align: shape.props.align,
        verticalAlign: shape.props.verticalAlign,
        richText: shape.props.richText,
        labelColor: getColorValue(theme, shape.props.color, "noteText"),
        bounds,
        padding: LABEL_PADDING,
        showTextOutline: false
      }
    );
    return (0, import_jsx_runtime223.jsxs)(import_jsx_runtime223.Fragment, { children: [
      (0, import_jsx_runtime223.jsx)("rect", { x: 5, y: 5, rx: 1, width: NOTE_SIZE - 10, height: bounds.h, fill: "rgba(0,0,0,.1)" }),
      (0, import_jsx_runtime223.jsx)(
        "rect",
        {
          rx: 1,
          width: NOTE_SIZE,
          height: bounds.h,
          fill: getColorValue(theme, shape.props.color, "noteFill")
        }
      ),
      textLabel
    ] });
  }
  onBeforeCreate(next) {
    return getNoteSizeAdjustments(this.editor, next);
  }
  onBeforeUpdate(prev, next) {
    if ((0, import_lodash.default)(prev.props.richText, next.props.richText) && prev.props.font === next.props.font && prev.props.size === next.props.size) {
      return;
    }
    return getNoteSizeAdjustments(this.editor, next);
  }
  getInterpolatedProps(startShape, endShape, t2) {
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      scale: lerp(startShape.props.scale, endShape.props.scale, t2)
    };
  }
};
__publicField(NoteShapeUtil, "type", "note");
__publicField(NoteShapeUtil, "props", noteShapeProps);
__publicField(NoteShapeUtil, "migrations", noteShapeMigrations);
function getNoteSizeAdjustments(editor, shape) {
  const { labelHeight, fontSizeAdjustment } = getLabelSize(editor, shape);
  const growY = Math.max(0, labelHeight - NOTE_SIZE);
  if (growY !== shape.props.growY || fontSizeAdjustment !== shape.props.fontSizeAdjustment) {
    return {
      ...shape,
      props: {
        ...shape.props,
        growY,
        fontSizeAdjustment
      }
    };
  }
}
function getNoteLabelSize(editor, shape) {
  const { richText } = shape.props;
  if (isEmptyRichText(richText)) {
    const minHeight = LABEL_FONT_SIZES[shape.props.size] * TEXT_PROPS.lineHeight + LABEL_PADDING * 2;
    return { labelHeight: minHeight, labelWidth: 100, fontSizeAdjustment: 0 };
  }
  const unadjustedFontSize = LABEL_FONT_SIZES[shape.props.size];
  let fontSizeAdjustment = 0;
  let iterations = 0;
  let labelHeight = NOTE_SIZE;
  let labelWidth = NOTE_SIZE;
  const FUZZ = 1;
  do {
    fontSizeAdjustment = Math.min(unadjustedFontSize, unadjustedFontSize - iterations);
    const html = renderHtmlFromRichTextForMeasurement(editor, richText);
    const nextTextSize = editor.textMeasure.measureHtml(html, {
      ...TEXT_PROPS,
      fontFamily: FONT_FAMILIES[shape.props.font],
      fontSize: fontSizeAdjustment,
      maxWidth: NOTE_SIZE - LABEL_PADDING * 2 - FUZZ,
      disableOverflowWrapBreaking: true,
      measureScrollWidth: true
    });
    labelHeight = nextTextSize.h + LABEL_PADDING * 2;
    labelWidth = nextTextSize.w + LABEL_PADDING * 2;
    if (fontSizeAdjustment <= 14) {
      const html2 = renderHtmlFromRichTextForMeasurement(editor, richText);
      const nextTextSizeWithOverflowBreak = editor.textMeasure.measureHtml(html2, {
        ...TEXT_PROPS,
        fontFamily: FONT_FAMILIES[shape.props.font],
        fontSize: fontSizeAdjustment,
        maxWidth: NOTE_SIZE - LABEL_PADDING * 2 - FUZZ
      });
      labelHeight = nextTextSizeWithOverflowBreak.h + LABEL_PADDING * 2;
      labelWidth = nextTextSizeWithOverflowBreak.w + LABEL_PADDING * 2;
      break;
    }
    if (nextTextSize.scrollWidth.toFixed(0) === nextTextSize.w.toFixed(0)) {
      break;
    }
  } while (iterations++ < 50);
  return {
    labelHeight,
    labelWidth,
    fontSizeAdjustment
  };
}
var labelSizesForNote = new WeakCache();
function getLabelSize(editor, shape) {
  return labelSizesForNote.get(shape, () => getNoteLabelSize(editor, shape));
}
function useNoteKeydownHandler(id) {
  const editor = useEditor();
  const translation = (0, import_react149.useContext)(TranslationsContext);
  return (0, import_react149.useCallback)(
    (e) => {
      const shape = editor.getShape(id);
      if (!shape) return;
      const isTab = e.key === "Tab";
      const isCmdEnter = (e.metaKey || e.ctrlKey) && e.key === "Enter";
      if (isTab || isCmdEnter) {
        e.preventDefault();
        const pageTransform = editor.getShapePageTransform(id);
        const pageRotation = pageTransform.rotation();
        const isRTL2 = !!((translation == null ? void 0 : translation.dir) === "rtl" || // todo: can we check a partial of the text, so that we don't have to render the whole thing?
        isRightToLeftLanguage(renderPlaintextFromRichText(editor, shape.props.richText)));
        const offsetLength = (NOTE_SIZE + editor.options.adjacentShapeMargin + // If we're growing down, we need to account for the current shape's growY
        (isCmdEnter && !e.shiftKey ? shape.props.growY : 0)) * shape.props.scale;
        const adjacentCenter = new Vec(
          isTab ? e.shiftKey != isRTL2 ? -1 : 1 : 0,
          isCmdEnter ? e.shiftKey ? -1 : 1 : 0
        ).mul(offsetLength).add(NOTE_CENTER_OFFSET.clone().mul(shape.props.scale)).rot(pageRotation).add(pageTransform.point());
        const newNote = getNoteShapeForAdjacentPosition(editor, shape, adjacentCenter, pageRotation);
        if (newNote) {
          startEditingShapeWithRichText(editor, newNote, { selectAll: true });
        }
      }
    },
    [id, editor, translation == null ? void 0 : translation.dir]
  );
}
function getNoteHeight(shape) {
  return (NOTE_SIZE + shape.props.growY) * shape.props.scale;
}
function getNoteShadow(id, rotation, scale) {
  const random = rng(id);
  const lift4 = Math.abs(random()) + 0.5;
  const oy = Math.cos(rotation);
  const a = 5 * scale;
  const b = 4 * scale;
  const c = 6 * scale;
  const d = 7 * scale;
  return `0px ${a - lift4}px ${a}px -${a}px rgba(15, 23, 31, .6),
	0px ${(b + lift4 * d) * Math.max(0, oy)}px ${c + lift4 * d}px -${b + lift4 * c}px rgba(15, 23, 31, ${(0.3 + lift4 * 0.1).toFixed(2)}), 
	0px ${48 * scale}px ${10 * scale}px -${10 * scale}px inset rgba(15, 23, 44, ${((0.022 + random() * 5e-3) * ((1 + oy) / 2)).toFixed(2)})`;
}
function getBoundsForSVG(shape) {
  return new Box(0, 0, NOTE_SIZE, NOTE_SIZE + shape.props.growY);
}

// ../node_modules/tldraw/dist-esm/lib/shapes/text/TextShapeUtil.mjs
var import_jsx_runtime224 = __toESM(require_jsx_runtime(), 1);
var import_react150 = __toESM(require_react(), 1);
var sizeCache = createComputedCache(
  "text size",
  (editor, shape) => {
    editor.fonts.trackFontsForShape(shape);
    return getTextSize(editor, shape.props);
  },
  { areRecordsEqual: (a, b) => a.props === b.props }
);
var TextShapeUtil = class extends ShapeUtil {
  constructor() {
    super(...arguments);
    __publicField(this, "options", {
      extraArrowHorizontalPadding: 10,
      showTextOutline: true
    });
  }
  getDefaultProps() {
    return {
      color: "black",
      size: "m",
      w: 8,
      font: "draw",
      textAlign: "start",
      autoSize: true,
      scale: 1,
      richText: toRichText("")
    };
  }
  getMinDimensions(shape) {
    return sizeCache.get(this.editor, shape.id);
  }
  getGeometry(shape, opts) {
    const { scale } = shape.props;
    const { width, height } = this.getMinDimensions(shape);
    const context = (opts == null ? void 0 : opts.context) ?? "none";
    return new Rectangle2d({
      x: (context === "@tldraw/arrow-without-arrowhead" ? -this.options.extraArrowHorizontalPadding : 0) * scale,
      width: (width + (context === "@tldraw/arrow-without-arrowhead" ? this.options.extraArrowHorizontalPadding * 2 : 0)) * scale,
      height: height * scale,
      isFilled: true,
      isLabel: true
    });
  }
  getFontFaces(shape) {
    return getFontsFromRichText(this.editor, shape.props.richText, {
      family: `tldraw_${shape.props.font}`,
      weight: "normal",
      style: "normal"
    });
  }
  getText(shape) {
    return renderPlaintextFromRichText(this.editor, shape.props.richText);
  }
  canEdit() {
    return true;
  }
  isAspectRatioLocked() {
    return true;
  }
  // WAIT NO THIS IS HARD CODED IN THE RESIZE HANDLER
  component(shape) {
    const {
      id,
      props: { font, size: size4, richText, color, scale, textAlign }
    } = shape;
    const { width, height } = this.getMinDimensions(shape);
    const isSelected = shape.id === this.editor.getOnlySelectedShapeId();
    const theme = useDefaultColorTheme();
    const handleKeyDown2 = useTextShapeKeydownHandler(id);
    return (0, import_jsx_runtime224.jsx)(
      RichTextLabel,
      {
        shapeId: id,
        classNamePrefix: "tl-text-shape",
        type: "text",
        font,
        fontSize: FONT_SIZES[size4],
        lineHeight: TEXT_PROPS.lineHeight,
        align: textAlign,
        verticalAlign: "middle",
        richText,
        labelColor: getColorValue(theme, color, "solid"),
        isSelected,
        textWidth: width,
        textHeight: height,
        showTextOutline: this.options.showTextOutline,
        style: {
          transform: `scale(${scale})`,
          transformOrigin: "top left"
        },
        wrap: true,
        onKeyDown: handleKeyDown2
      }
    );
  }
  indicator(shape) {
    const bounds = this.editor.getShapeGeometry(shape).bounds;
    const editor = useEditor();
    if (shape.props.autoSize && editor.getEditingShapeId() === shape.id) return null;
    return (0, import_jsx_runtime224.jsx)("rect", { width: toDomPrecision(bounds.width), height: toDomPrecision(bounds.height) });
  }
  toSvg(shape, ctx) {
    const bounds = this.editor.getShapeGeometry(shape).bounds;
    const width = bounds.width / (shape.props.scale ?? 1);
    const height = bounds.height / (shape.props.scale ?? 1);
    const theme = getDefaultColorTheme(ctx);
    const exportBounds = new Box(0, 0, width, height);
    return (0, import_jsx_runtime224.jsx)(
      RichTextSVG,
      {
        fontSize: FONT_SIZES[shape.props.size],
        font: shape.props.font,
        align: shape.props.textAlign,
        verticalAlign: "middle",
        richText: shape.props.richText,
        labelColor: getColorValue(theme, shape.props.color, "solid"),
        bounds: exportBounds,
        padding: 0,
        showTextOutline: this.options.showTextOutline
      }
    );
  }
  onResize(shape, info) {
    const { newPoint, initialBounds, initialShape, scaleX, handle } = info;
    if (info.mode === "scale_shape" || handle !== "right" && handle !== "left") {
      return {
        id: shape.id,
        type: shape.type,
        ...resizeScaled(shape, info)
      };
    } else {
      const nextWidth = Math.max(1, Math.abs(initialBounds.width * scaleX));
      const { x, y } = scaleX < 0 ? Vec.Sub(newPoint, Vec.FromAngle(shape.rotation).mul(nextWidth)) : newPoint;
      return {
        id: shape.id,
        type: shape.type,
        x,
        y,
        props: {
          w: nextWidth / initialShape.props.scale,
          autoSize: false
        }
      };
    }
  }
  onEditEnd(shape) {
    const trimmedText = renderPlaintextFromRichText(this.editor, shape.props.richText).trimEnd();
    if (trimmedText.length === 0) {
      this.editor.deleteShapes([shape.id]);
    }
  }
  onBeforeUpdate(prev, next) {
    if (!next.props.autoSize) return;
    const styleDidChange = prev.props.size !== next.props.size || prev.props.textAlign !== next.props.textAlign || prev.props.font !== next.props.font || prev.props.scale !== 1 && next.props.scale === 1;
    const textDidChange = !(0, import_lodash.default)(prev.props.richText, next.props.richText);
    if (!styleDidChange && !textDidChange) return;
    const boundsA = this.getMinDimensions(prev);
    const boundsB = getTextSize(this.editor, next.props);
    const wA = boundsA.width * prev.props.scale;
    const hA = boundsA.height * prev.props.scale;
    const wB = boundsB.width * next.props.scale;
    const hB = boundsB.height * next.props.scale;
    let delta;
    switch (next.props.textAlign) {
      case "middle": {
        delta = new Vec((wB - wA) / 2, textDidChange ? 0 : (hB - hA) / 2);
        break;
      }
      case "end": {
        delta = new Vec(wB - wA, textDidChange ? 0 : (hB - hA) / 2);
        break;
      }
      default: {
        if (textDidChange) break;
        delta = new Vec(0, (hB - hA) / 2);
        break;
      }
    }
    if (delta) {
      delta.rot(next.rotation);
      const { x, y } = next;
      return {
        ...next,
        x: x - delta.x,
        y: y - delta.y,
        props: { ...next.props, w: wB }
      };
    } else {
      return {
        ...next,
        props: { ...next.props, w: wB }
      };
    }
  }
  // 	todo: The edge doubleclicking feels like a mistake more often than
  //  not, especially on multiline text. Removed June 16 2024
  // override onDoubleClickEdge = (shape: TLTextShape) => {
  // 	// If the shape has a fixed width, set it to autoSize.
  // 	if (!shape.props.autoSize) {
  // 		return {
  // 			id: shape.id,
  // 			type: shape.type,
  // 			props: {
  // 				autoSize: true,
  // 			},
  // 		}
  // 	}
  // 	// If the shape is scaled, reset the scale to 1.
  // 	if (shape.props.scale !== 1) {
  // 		return {
  // 			id: shape.id,
  // 			type: shape.type,
  // 			props: {
  // 				scale: 1,
  // 			},
  // 		}
  // 	}
  // }
};
__publicField(TextShapeUtil, "type", "text");
__publicField(TextShapeUtil, "props", textShapeProps);
__publicField(TextShapeUtil, "migrations", textShapeMigrations);
function getTextSize(editor, props) {
  const { font, richText, size: size4, w } = props;
  const minWidth = 16;
  const fontSize = FONT_SIZES[size4];
  const maybeFixedWidth = props.autoSize ? null : Math.max(minWidth, Math.floor(w));
  const html = renderHtmlFromRichTextForMeasurement(editor, richText);
  const result = editor.textMeasure.measureHtml(html, {
    ...TEXT_PROPS,
    fontFamily: FONT_FAMILIES[font],
    fontSize,
    maxWidth: maybeFixedWidth
  });
  return {
    width: maybeFixedWidth ?? Math.max(minWidth, result.w + 1),
    height: Math.max(fontSize, result.h)
  };
}
function useTextShapeKeydownHandler(id) {
  const editor = useEditor();
  return (0, import_react150.useCallback)(
    (e) => {
      if (editor.getEditingShapeId() !== id) return;
      switch (e.key) {
        case "Enter": {
          if (e.ctrlKey || e.metaKey) {
            editor.complete();
          }
          break;
        }
      }
    },
    [editor, id]
  );
}

// ../node_modules/tldraw/dist-esm/lib/shapes/video/VideoShapeUtil.mjs
var import_jsx_runtime225 = __toESM(require_jsx_runtime(), 1);
var import_classnames38 = __toESM(require_classnames(), 1);
var import_react151 = __toESM(require_react(), 1);
var videoSvgExportCache = new WeakCache();
var VideoShapeUtil = class extends BaseBoxShapeUtil {
  constructor() {
    super(...arguments);
    __publicField(this, "options", {
      autoplay: true
    });
  }
  canEdit() {
    return true;
  }
  isAspectRatioLocked() {
    return true;
  }
  getDefaultProps() {
    return {
      w: 100,
      h: 100,
      assetId: null,
      autoplay: this.options.autoplay,
      url: "",
      altText: "",
      // Not used, but once upon a time were used to sync video state between users
      time: 0,
      playing: true
    };
  }
  getAriaDescriptor(shape) {
    return shape.props.altText;
  }
  component(shape) {
    return (0, import_jsx_runtime225.jsx)(VideoShape, { shape });
  }
  indicator(shape) {
    return (0, import_jsx_runtime225.jsx)("rect", { width: toDomPrecision(shape.props.w), height: toDomPrecision(shape.props.h) });
  }
  async toSvg(shape, ctx) {
    const props = shape.props;
    if (!props.assetId) return null;
    const asset = this.editor.getAsset(props.assetId);
    if (!asset) return null;
    const src = await videoSvgExportCache.get(asset, async () => {
      const assetUrl = await ctx.resolveAssetUrl(asset.id, props.w);
      if (!assetUrl) return null;
      const video = await MediaHelpers.loadVideo(assetUrl);
      return await MediaHelpers.getVideoFrameAsDataUrl(video, 0);
    });
    if (!src) return null;
    return (0, import_jsx_runtime225.jsx)("image", { href: src, width: props.w, height: props.h, "aria-label": shape.props.altText });
  }
};
__publicField(VideoShapeUtil, "type", "video");
__publicField(VideoShapeUtil, "props", videoShapeProps);
__publicField(VideoShapeUtil, "migrations", videoShapeMigrations);
var VideoShape = (0, import_react151.memo)(function VideoShape2({ shape }) {
  const editor = useEditor();
  const showControls = editor.getShapeGeometry(shape).bounds.w * editor.getEfficientZoomLevel() >= 110;
  const isEditing = useIsEditing(shape.id);
  const prefersReducedMotion = usePrefersReducedMotion();
  const { Spinner: Spinner2 } = useEditorComponents();
  const { asset, url } = useImageOrVideoAsset({
    shapeId: shape.id,
    assetId: shape.props.assetId,
    width: shape.props.w
  });
  const rVideo = (0, import_react151.useRef)(null);
  const [isLoaded, setIsLoaded] = (0, import_react151.useState)(false);
  const handleLoadedData = (0, import_react151.useCallback)((e) => {
    const video = e.currentTarget;
    if (!video) return;
    setIsLoaded(true);
  }, []);
  const [isFullscreen, setIsFullscreen] = (0, import_react151.useState)(false);
  (0, import_react151.useEffect)(() => {
    const fullscreenChange = () => setIsFullscreen(document.fullscreenElement === rVideo.current);
    document.addEventListener("fullscreenchange", fullscreenChange);
    return () => document.removeEventListener("fullscreenchange", fullscreenChange);
  });
  (0, import_react151.useEffect)(() => {
    const video = rVideo.current;
    if (!video) return;
    if (isEditing) {
      if (document.activeElement !== video) {
        video.focus();
      }
    }
  }, [isEditing, isLoaded]);
  return (0, import_jsx_runtime225.jsxs)(import_jsx_runtime225.Fragment, { children: [
    (0, import_jsx_runtime225.jsx)(
      HTMLContainer,
      {
        id: shape.id,
        style: {
          color: "var(--tl-color-text-3)",
          backgroundColor: asset ? "transparent" : "var(--tl-color-low)",
          border: asset ? "none" : "1px solid var(--tl-color-low-border)"
        },
        children: (0, import_jsx_runtime225.jsx)("div", { className: "tl-counter-scaled", children: (0, import_jsx_runtime225.jsx)("div", { className: "tl-video-container", children: !asset ? (0, import_jsx_runtime225.jsx)(BrokenAssetIcon, {}) : Spinner2 && !asset.props.src ? (0, import_jsx_runtime225.jsx)(Spinner2, {}) : url ? (0, import_jsx_runtime225.jsxs)(import_jsx_runtime225.Fragment, { children: [
          (0, import_jsx_runtime225.jsx)(
            "video",
            {
              ref: rVideo,
              style: isEditing ? { pointerEvents: "all" } : !isLoaded ? { display: "none" } : void 0,
              className: (0, import_classnames38.default)("tl-video", `tl-video-shape-${shape.id.split(":")[1]}`, {
                "tl-video-is-fullscreen": isFullscreen
              }),
              width: "100%",
              height: "100%",
              draggable: false,
              playsInline: true,
              autoPlay: shape.props.autoplay && !prefersReducedMotion,
              muted: true,
              loop: true,
              disableRemotePlayback: true,
              disablePictureInPicture: true,
              controls: isEditing && showControls,
              onLoadedData: handleLoadedData,
              hidden: !isLoaded,
              "aria-label": shape.props.altText,
              children: (0, import_jsx_runtime225.jsx)("source", { src: url })
            },
            url
          ),
          !isLoaded && Spinner2 && (0, import_jsx_runtime225.jsx)(Spinner2, {})
        ] }) : null }) })
      }
    ),
    "url" in shape.props && shape.props.url && (0, import_jsx_runtime225.jsx)(HyperlinkButton, { url: shape.props.url })
  ] });
});

// ../node_modules/tldraw/dist-esm/lib/defaultShapeUtils.mjs
var defaultShapeUtils = [
  TextShapeUtil,
  BookmarkShapeUtil,
  DrawShapeUtil,
  GeoShapeUtil,
  NoteShapeUtil,
  LineShapeUtil,
  FrameShapeUtil,
  ArrowShapeUtil,
  HighlightShapeUtil,
  EmbedShapeUtil,
  ImageShapeUtil,
  VideoShapeUtil
];

// ../node_modules/tldraw/dist-esm/lib/defaultSideEffects.mjs
function registerDefaultSideEffects(editor) {
  return editor.sideEffects.register({
    instance_page_state: {
      afterChange: (prev, next) => {
        if (prev.croppingShapeId !== next.croppingShapeId) {
          const isInCroppingState = editor.isIn("select.crop");
          if (!prev.croppingShapeId && next.croppingShapeId) {
            if (!isInCroppingState) {
              editor.setCurrentTool("select.crop.idle");
            }
          } else if (prev.croppingShapeId && !next.croppingShapeId) {
            if (isInCroppingState) {
              editor.setCurrentTool("select.idle");
            }
          }
        }
        if (prev.editingShapeId !== next.editingShapeId) {
          if (!prev.editingShapeId && next.editingShapeId) {
            if (!editor.isIn("select.editing_shape")) {
              const shape = editor.getEditingShape();
              if (shape && shape.type === "text" && editor.isInAny("text.pointing", "select.resizing") && editor.getInstanceState().isToolLocked) {
                editor.setCurrentTool("select.editing_shape", {
                  target: "shape",
                  shape,
                  isCreatingTextWhileToolLocked: true
                });
              } else {
                editor.setCurrentTool("select.editing_shape", {
                  target: "shape",
                  shape
                });
              }
            }
          } else if (prev.editingShapeId && !next.editingShapeId) {
            if (editor.isIn("select.editing_shape")) {
              editor.setCurrentTool("select.idle");
            }
          }
        }
      }
    }
  });
}

// ../node_modules/tldraw/dist-esm/lib/tools/EraserTool/childStates/Erasing.mjs
var Erasing = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "info", {});
    __publicField(this, "scribbleId", "id");
    __publicField(this, "markId", "");
    __publicField(this, "excludedShapeIds", /* @__PURE__ */ new Set());
    __publicField(this, "_isHoldingAccelKey", false);
    __publicField(this, "_firstErasingShapeId", null);
    __publicField(this, "_erasingShapeIds", []);
  }
  onEnter(info) {
    this._isHoldingAccelKey = isAccelKey(this.editor.inputs);
    this._firstErasingShapeId = this.editor.getErasingShapeIds()[0];
    this._erasingShapeIds = this.editor.getErasingShapeIds();
    this.markId = this.editor.markHistoryStoppingPoint("erase scribble begin");
    this.info = info;
    const originPagePoint = this.editor.inputs.getOriginPagePoint();
    this.excludedShapeIds = new Set(
      this.editor.getCurrentPageShapes().filter((shape) => {
        if (this.editor.isShapeOrAncestorLocked(shape)) return true;
        if (this.editor.isShapeOfType(shape, "group") || this.editor.isShapeOfType(shape, "frame")) {
          const pointInShapeShape = this.editor.getPointInShapeSpace(shape, originPagePoint);
          const geometry = this.editor.getShapeGeometry(shape);
          return geometry.bounds.containsPoint(pointInShapeShape);
        }
        return false;
      }).map((shape) => shape.id)
    );
    const scribble = this.editor.scribbles.addScribble({
      color: "muted-1",
      size: 12
    });
    this.scribbleId = scribble.id;
    this.update();
  }
  pushPointToScribble() {
    const { x, y } = this.editor.inputs.getCurrentPagePoint();
    this.editor.scribbles.addPoint(this.scribbleId, x, y);
  }
  onExit() {
    this.editor.setErasingShapes([]);
    this.editor.scribbles.stop(this.scribbleId);
  }
  onPointerMove() {
    this.update();
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  onKeyUp() {
    this._isHoldingAccelKey = isAccelKey(this.editor.inputs);
    this.update();
  }
  onKeyDown() {
    this._isHoldingAccelKey = isAccelKey(this.editor.inputs);
    this.update();
  }
  update() {
    const { editor, excludedShapeIds } = this;
    const erasingShapeIds = editor.getErasingShapeIds();
    const zoomLevel = editor.getZoomLevel();
    const currentPageShapes = editor.getCurrentPageRenderingShapesSorted();
    const currentPagePoint = editor.inputs.getCurrentPagePoint();
    const previousPagePoint = editor.inputs.getPreviousPagePoint();
    this.pushPointToScribble();
    const erasing = new Set(erasingShapeIds);
    const minDist = this.editor.options.hitTestMargin / zoomLevel;
    for (const shape of currentPageShapes) {
      if (editor.isShapeOfType(shape, "group")) continue;
      const pageMask = editor.getShapeMask(shape.id);
      if (pageMask && !pointInPolygon(currentPagePoint, pageMask)) {
        continue;
      }
      const geometry = editor.getShapeGeometry(shape);
      const pageTransform = editor.getShapePageTransform(shape);
      if (!geometry || !pageTransform) continue;
      const pt = pageTransform.clone().invert();
      const A = pt.applyToPoint(previousPagePoint);
      const B = pt.applyToPoint(currentPagePoint);
      const { bounds } = geometry;
      if (bounds.minX - minDist > Math.max(A.x, B.x) || bounds.minY - minDist > Math.max(A.y, B.y) || bounds.maxX + minDist < Math.min(A.x, B.x) || bounds.maxY + minDist < Math.min(A.y, B.y)) {
        continue;
      }
      if (geometry.hitTestLineSegment(A, B, minDist)) {
        erasing.add(editor.getOutermostSelectableShape(shape).id);
      }
      this._erasingShapeIds = [...erasing];
    }
    if (this._isHoldingAccelKey && this._firstErasingShapeId) {
      const erasingShapeId = this._firstErasingShapeId;
      if (erasingShapeId && this.editor.getShape(erasingShapeId)) {
        editor.setErasingShapes([erasingShapeId]);
      }
      return;
    }
    this.editor.setErasingShapes(this._erasingShapeIds.filter((id) => !excludedShapeIds.has(id)));
  }
  complete() {
    const { editor } = this;
    editor.deleteShapes(editor.getCurrentPageState().erasingShapeIds);
    this.parent.transition("idle");
    this._erasingShapeIds = [];
    this._firstErasingShapeId = null;
  }
  cancel() {
    const { editor } = this;
    editor.bailToMark(this.markId);
    this.parent.transition("idle", this.info);
  }
};
__publicField(Erasing, "id", "erasing");

// ../node_modules/tldraw/dist-esm/lib/tools/EraserTool/childStates/Idle.mjs
var Idle8 = class extends StateNode {
  onPointerDown(info) {
    this.parent.transition("pointing", info);
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
};
__publicField(Idle8, "id", "idle");

// ../node_modules/tldraw/dist-esm/lib/tools/EraserTool/childStates/Pointing.mjs
var Pointing7 = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "_isHoldingAccelKey", false);
  }
  onEnter() {
    this._isHoldingAccelKey = isAccelKey(this.editor.inputs);
    const zoomLevel = this.editor.getZoomLevel();
    const currentPageShapesSorted = this.editor.getCurrentPageRenderingShapesSorted();
    const currentPagePoint = this.editor.inputs.getCurrentPagePoint();
    const erasing = /* @__PURE__ */ new Set();
    const initialSize = erasing.size;
    for (let n = currentPageShapesSorted.length, i = n - 1; i >= 0; i--) {
      const shape = currentPageShapesSorted[i];
      if (this.editor.isShapeOrAncestorLocked(shape) || this.editor.isShapeOfType(shape, "group")) {
        continue;
      }
      if (this.editor.isPointInShape(shape, currentPagePoint, {
        hitInside: false,
        margin: this.editor.options.hitTestMargin / zoomLevel
      })) {
        const hitShape = this.editor.getOutermostSelectableShape(shape);
        if (this.editor.isShapeOfType(hitShape, "frame") && erasing.size > initialSize) {
          break;
        }
        erasing.add(hitShape.id);
        if (this._isHoldingAccelKey) {
          break;
        }
      }
    }
    this.editor.setErasingShapes([...erasing]);
  }
  onKeyUp() {
    this._isHoldingAccelKey = isAccelKey(this.editor.inputs);
  }
  onKeyDown() {
    this._isHoldingAccelKey = isAccelKey(this.editor.inputs);
  }
  onLongPress(info) {
    this.startErasing(info);
  }
  onExit(_info, to) {
    if (to !== "erasing") {
      this.editor.setErasingShapes([]);
    }
  }
  onPointerMove(info) {
    if (this._isHoldingAccelKey) return;
    if (this.editor.inputs.getIsDragging()) {
      this.startErasing(info);
    }
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    this.cancel();
  }
  startErasing(info) {
    this.parent.transition("erasing", info);
  }
  complete() {
    const erasingShapeIds = this.editor.getErasingShapeIds();
    if (erasingShapeIds.length) {
      this.editor.markHistoryStoppingPoint("erase end");
      this.editor.deleteShapes(erasingShapeIds);
    }
    this.parent.transition("idle");
  }
  cancel() {
    this.parent.transition("idle");
  }
};
__publicField(Pointing7, "id", "pointing");

// ../node_modules/tldraw/dist-esm/lib/tools/EraserTool/EraserTool.mjs
var EraserTool = class extends StateNode {
  static children() {
    return [Idle8, Pointing7, Erasing];
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
};
__publicField(EraserTool, "id", "eraser");
__publicField(EraserTool, "initial", "idle");
__publicField(EraserTool, "isLockable", false);

// ../node_modules/tldraw/dist-esm/lib/tools/HandTool/childStates/Dragging.mjs
var Dragging2 = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "initialCamera", new Vec());
  }
  onEnter() {
    this.initialCamera = Vec.From(this.editor.getCamera());
    this.update();
  }
  onPointerMove() {
    this.update();
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.parent.transition("idle");
  }
  onComplete() {
    this.complete();
  }
  update() {
    const { initialCamera, editor } = this;
    const currentScreenPoint = editor.inputs.getCurrentScreenPoint();
    const originScreenPoint = editor.inputs.getOriginScreenPoint();
    const delta = Vec.Sub(currentScreenPoint, originScreenPoint).div(editor.getZoomLevel());
    if (delta.len2() === 0) return;
    editor.setCamera(initialCamera.clone().add(delta));
  }
  complete() {
    const { editor } = this;
    const pointerVelocity = editor.inputs.getPointerVelocity();
    const velocityAtPointerUp = Math.min(pointerVelocity.len(), 2);
    if (velocityAtPointerUp > 0.1) {
      this.editor.slideCamera({ speed: velocityAtPointerUp, direction: pointerVelocity });
    }
    this.parent.transition("idle");
  }
};
__publicField(Dragging2, "id", "dragging");

// ../node_modules/tldraw/dist-esm/lib/tools/HandTool/childStates/Idle.mjs
var Idle9 = class extends StateNode {
  onEnter() {
    this.editor.setCursor({ type: "grab", rotation: 0 });
  }
  onPointerDown(info) {
    this.parent.transition("pointing", info);
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
};
__publicField(Idle9, "id", "idle");

// ../node_modules/tldraw/dist-esm/lib/tools/HandTool/childStates/Pointing.mjs
var Pointing8 = class extends StateNode {
  onEnter() {
    this.editor.stopCameraAnimation();
    this.editor.setCursor({ type: "grabbing", rotation: 0 });
  }
  onLongPress() {
    this.startDragging();
  }
  onPointerMove() {
    if (this.editor.inputs.getIsDragging()) {
      this.startDragging();
    }
  }
  startDragging() {
    this.parent.transition("dragging");
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    this.complete();
  }
  complete() {
    this.parent.transition("idle");
  }
};
__publicField(Pointing8, "id", "pointing");

// ../node_modules/tldraw/dist-esm/lib/tools/HandTool/HandTool.mjs
var HandTool = class extends StateNode {
  static children() {
    return [Idle9, Pointing8, Dragging2];
  }
  onDoubleClick(info) {
    if (info.phase === "settle") {
      const currentScreenPoint = this.editor.inputs.getCurrentScreenPoint();
      this.editor.zoomIn(currentScreenPoint, {
        animation: { duration: 220, easing: EASINGS.easeOutQuint }
      });
    }
  }
  onTripleClick(info) {
    if (info.phase === "settle") {
      const currentScreenPoint = this.editor.inputs.getCurrentScreenPoint();
      this.editor.zoomOut(currentScreenPoint, {
        animation: { duration: 320, easing: EASINGS.easeOutQuint }
      });
    }
  }
  onQuadrupleClick(info) {
    if (info.phase === "settle") {
      const zoomLevel = this.editor.getZoomLevel();
      const currentScreenPoint = this.editor.inputs.getCurrentScreenPoint();
      if (zoomLevel === 1) {
        this.editor.zoomToFit({ animation: { duration: 400, easing: EASINGS.easeOutQuint } });
      } else {
        this.editor.resetZoom(currentScreenPoint, {
          animation: { duration: 320, easing: EASINGS.easeOutQuint }
        });
      }
    }
  }
};
__publicField(HandTool, "id", "hand");
__publicField(HandTool, "initial", "idle");
__publicField(HandTool, "isLockable", false);

// ../node_modules/tldraw/dist-esm/lib/tools/LaserTool/childStates/Idle.mjs
var Idle10 = class extends StateNode {
  onCancel() {
    this.editor.setCurrentTool("select");
  }
  onPointerDown(info) {
    this.parent.transition("lasering", info);
  }
};
__publicField(Idle10, "id", "idle");

// ../node_modules/tldraw/dist-esm/lib/tools/LaserTool/childStates/Lasering.mjs
var Lasering = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "scribbleId", "id");
  }
  onEnter() {
    const scribble = this.editor.scribbles.addScribble({
      color: "laser",
      opacity: 0.7,
      size: 4,
      delay: this.editor.options.laserDelayMs,
      shrink: 0.05,
      taper: true
    });
    this.scribbleId = scribble.id;
    this.pushPointToScribble();
  }
  onExit() {
    this.editor.scribbles.stop(this.scribbleId);
  }
  onPointerMove() {
    this.pushPointToScribble();
  }
  onPointerUp() {
    this.complete();
  }
  pushPointToScribble() {
    const { x, y } = this.editor.inputs.getCurrentPagePoint();
    this.editor.scribbles.addPoint(this.scribbleId, x, y);
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  complete() {
    this.parent.transition("idle");
  }
  cancel() {
    this.parent.transition("idle");
  }
};
__publicField(Lasering, "id", "lasering");

// ../node_modules/tldraw/dist-esm/lib/tools/LaserTool/LaserTool.mjs
var LaserTool = class extends StateNode {
  static children() {
    return [Idle10, Lasering];
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
};
__publicField(LaserTool, "id", "laser");
__publicField(LaserTool, "initial", "idle");
__publicField(LaserTool, "isLockable", false);

// ../node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/Brushing.mjs
var Brushing = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "info", {});
    __publicField(this, "initialSelectedShapeIds", []);
    __publicField(this, "excludedShapeIds", /* @__PURE__ */ new Set());
    __publicField(this, "isWrapMode", false);
    __publicField(this, "viewportDidChange", false);
  }
  cleanupViewportChangeReactor() {
  }
  // cleanup function for the viewport reactor
  onEnter(info) {
    const { editor } = this;
    const altKey2 = editor.inputs.getAltKey();
    this.isWrapMode = editor.user.getIsWrapMode();
    this.viewportDidChange = false;
    let isInitialCheck = true;
    this.cleanupViewportChangeReactor = react("viewport change while brushing", () => {
      editor.getViewportPageBounds();
      if (!isInitialCheck && !this.viewportDidChange) {
        this.viewportDidChange = true;
      }
    });
    if (altKey2) {
      this.parent.transition("scribble_brushing", info);
      return;
    }
    this.excludedShapeIds = new Set(
      editor.getCurrentPageShapes().filter(
        (shape) => editor.isShapeOfType(shape, "group") || editor.isShapeOrAncestorLocked(shape)
      ).map((shape) => shape.id)
    );
    this.info = info;
    this.initialSelectedShapeIds = editor.getSelectedShapeIds().slice();
    this.hitTestShapes();
    isInitialCheck = false;
  }
  onExit() {
    this.initialSelectedShapeIds = [];
    this.editor.updateInstanceState({ brush: null });
    this.cleanupViewportChangeReactor();
  }
  onTick({ elapsed }) {
    const { editor } = this;
    editor.edgeScrollManager.updateEdgeScrolling(elapsed);
  }
  onPointerMove() {
    this.hitTestShapes();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onCancel(info) {
    this.editor.setSelectedShapes(this.initialSelectedShapeIds);
    this.parent.transition("idle", info);
  }
  onKeyDown(info) {
    if (this.editor.inputs.getAltKey()) {
      this.parent.transition("scribble_brushing", info);
    } else {
      this.hitTestShapes();
    }
  }
  onKeyUp() {
    this.hitTestShapes();
  }
  complete() {
    this.hitTestShapes();
    this.parent.transition("idle");
  }
  hitTestShapes() {
    const { editor, excludedShapeIds, isWrapMode } = this;
    const originPagePoint = editor.inputs.getOriginPagePoint();
    const currentPagePoint = editor.inputs.getCurrentPagePoint();
    const shiftKey = editor.inputs.getShiftKey();
    const ctrlKey2 = editor.inputs.getCtrlKey();
    const results = new Set(shiftKey ? this.initialSelectedShapeIds : []);
    const isWrapping = isWrapMode ? !ctrlKey2 : ctrlKey2;
    const brush = Box.FromPoints([originPagePoint, currentPagePoint]);
    const { corners } = brush;
    let A, B, shape, pageBounds, pageTransform, localCorners;
    const brushBoxIsInsideViewport = editor.getViewportPageBounds().contains(brush);
    const shapesToHitTest = brushBoxIsInsideViewport && !this.viewportDidChange ? editor.getCurrentPageRenderingShapesSorted() : editor.getCurrentPageShapesSorted();
    const currentPageId = editor.getCurrentPageId();
    testAllShapes: for (let i = 0, n = shapesToHitTest.length; i < n; i++) {
      shape = shapesToHitTest[i];
      if (excludedShapeIds.has(shape.id) || results.has(shape.id)) continue testAllShapes;
      pageBounds = editor.getShapePageBounds(shape);
      if (!pageBounds) continue testAllShapes;
      if (brush.contains(pageBounds)) {
        this.handleHit(shape, currentPagePoint, currentPageId, results, corners);
        continue testAllShapes;
      }
      if (isWrapping || editor.isShapeOfType(shape, "frame")) {
        continue testAllShapes;
      }
      if (brush.collides(pageBounds)) {
        pageTransform = editor.getShapePageTransform(shape);
        if (!pageTransform) continue testAllShapes;
        localCorners = pageTransform.clone().invert().applyToPoints(corners);
        const geometry = editor.getShapeGeometry(shape);
        hitTestBrushEdges: for (let i2 = 0; i2 < 4; i2++) {
          A = localCorners[i2];
          B = localCorners[(i2 + 1) % 4];
          if (geometry.hitTestLineSegment(A, B, 0)) {
            this.handleHit(shape, currentPagePoint, currentPageId, results, corners);
            break hitTestBrushEdges;
          }
        }
      }
    }
    const currentBrush = editor.getInstanceState().brush;
    if (!currentBrush || !brush.equals(currentBrush)) {
      editor.updateInstanceState({ brush: { ...brush.toJson() } });
    }
    const current = editor.getSelectedShapeIds();
    if (current.length !== results.size || current.some((id) => !results.has(id))) {
      editor.setSelectedShapes(Array.from(results));
    }
  }
  onInterrupt() {
    this.editor.updateInstanceState({ brush: null });
  }
  handleHit(shape, currentPagePoint, currentPageId, results, corners) {
    if (shape.parentId === currentPageId) {
      results.add(shape.id);
      return;
    }
    const selectedShape = this.editor.getOutermostSelectableShape(shape);
    const pageMask = this.editor.getShapeMask(selectedShape.id);
    if (pageMask && !polygonsIntersect(pageMask, corners) && !pointInPolygon(currentPagePoint, pageMask)) {
      return;
    }
    results.add(selectedShape.id);
  }
};
__publicField(Brushing, "id", "brushing");

// ../node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/PointingResizeHandle.mjs
var CursorTypeMap = {
  bottom: "ns-resize",
  top: "ns-resize",
  left: "ew-resize",
  right: "ew-resize",
  bottom_left: "nesw-resize",
  bottom_right: "nwse-resize",
  top_left: "nwse-resize",
  top_right: "nesw-resize",
  bottom_left_rotate: "swne-rotate",
  bottom_right_rotate: "senw-rotate",
  top_left_rotate: "nwse-rotate",
  top_right_rotate: "nesw-rotate",
  mobile_rotate: "grabbing"
};
var PointingResizeHandle = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "info", {});
  }
  updateCursor() {
    const selected = this.editor.getSelectedShapes();
    const cursorType = CursorTypeMap[this.info.handle];
    this.editor.setCursor({
      type: cursorType,
      rotation: selected.length === 1 ? this.editor.getSelectionRotation() : 0
    });
  }
  onEnter(info) {
    this.info = info;
    if (typeof info.onInteractionEnd === "string") {
      this.parent.setCurrentToolIdMask(info.onInteractionEnd);
    }
    this.updateCursor();
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0);
  }
  onPointerMove() {
    if (this.editor.inputs.getIsDragging()) {
      this.startResizing();
    }
  }
  onLongPress() {
    this.startResizing();
  }
  startResizing() {
    if (this.editor.getIsReadonly()) return;
    this.parent.transition("resizing", this.info);
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  complete() {
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        this.editor.setCurrentTool(onInteractionEnd, {});
      } else {
        onInteractionEnd();
      }
      return;
    }
    this.parent.transition("idle");
  }
  cancel() {
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        this.editor.setCurrentTool(onInteractionEnd, {});
      } else {
        onInteractionEnd();
      }
      return;
    }
    this.parent.transition("idle");
  }
};
__publicField(PointingResizeHandle, "id", "pointing_resize_handle");

// ../node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/Crop/children/Cropping.mjs
var Cropping = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "info", {});
    __publicField(this, "markId", "");
    __publicField(this, "snapshot", {});
  }
  onEnter(info) {
    this.info = info;
    if (typeof info.onInteractionEnd === "string") {
      this.parent.setCurrentToolIdMask(info.onInteractionEnd);
    }
    this.markId = this.editor.markHistoryStoppingPoint("cropping");
    this.snapshot = this.createSnapshot();
    this.updateShapes();
  }
  onPointerMove() {
    this.updateShapes();
  }
  onKeyDown() {
    this.updateShapes();
  }
  onKeyUp() {
    this.updateShapes();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0);
  }
  updateCursor() {
    const selectedShape = this.editor.getSelectedShapes()[0];
    if (!selectedShape) return;
    const cursorType = CursorTypeMap[this.info.handle];
    this.editor.setCursor({ type: cursorType, rotation: this.editor.getSelectionRotation() });
  }
  updateShapes() {
    var _a6;
    const { shape, cursorHandleOffset } = this.snapshot;
    if (!shape) return;
    const util = this.editor.getShapeUtil(shape.type);
    if (!util) return;
    const shiftKey = this.editor.inputs.getShiftKey();
    const currentPagePoint = this.editor.inputs.getCurrentPagePoint().clone().sub(cursorHandleOffset);
    const originPagePoint = this.editor.inputs.getOriginPagePoint().clone().sub(cursorHandleOffset);
    const change = currentPagePoint.clone().sub(originPagePoint).rot(-shape.rotation);
    const crop = shape.props.crop ?? getDefaultCrop();
    const uncroppedSize = getUncroppedSize(shape.props, crop);
    const cropFn = ((_a6 = util.onCrop) == null ? void 0 : _a6.bind(util)) ?? getCropBox;
    const partial = cropFn(shape, {
      handle: this.info.handle,
      change,
      crop,
      uncroppedSize,
      initialShape: this.snapshot.shape,
      aspectRatioLocked: shiftKey
    });
    if (!partial) return;
    this.editor.updateShapes([
      {
        id: shape.id,
        type: shape.type,
        ...partial
      }
    ]);
    this.updateCursor();
  }
  complete() {
    this.updateShapes();
    kickoutOccludedShapes(this.editor, [this.snapshot.shape.id]);
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        this.editor.setCurrentTool(onInteractionEnd, this.info);
      } else {
        onInteractionEnd();
      }
    } else {
      this.editor.setCroppingShape(null);
      this.editor.setCurrentTool("select.idle");
    }
  }
  cancel() {
    this.editor.bailToMark(this.markId);
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        this.editor.setCurrentTool(onInteractionEnd, this.info);
      } else {
        onInteractionEnd();
      }
    } else {
      this.editor.setCroppingShape(null);
      this.editor.setCurrentTool("select.idle");
    }
  }
  createSnapshot() {
    const selectionRotation = this.editor.getSelectionRotation();
    const originPagePoint = this.editor.inputs.getOriginPagePoint();
    const shape = this.editor.getOnlySelectedShape();
    const selectionBounds = this.editor.getSelectionRotatedPageBounds();
    const dragHandlePoint = Vec.RotWith(
      selectionBounds.getHandlePoint(this.info.handle),
      selectionBounds.point,
      selectionRotation
    );
    const cursorHandleOffset = Vec.Sub(originPagePoint, dragHandlePoint);
    return {
      shape,
      cursorHandleOffset
    };
  }
};
__publicField(Cropping, "id", "cropping");

// ../node_modules/tldraw/dist-esm/lib/tools/selection-logic/getHitShapeOnCanvasPointerDown.mjs
function getHitShapeOnCanvasPointerDown(editor, hitLabels = false) {
  const zoomLevel = editor.getZoomLevel();
  const currentPagePoint = editor.inputs.getCurrentPagePoint();
  return (
    // hovered shape at point
    // selected shape at point
    editor.getShapeAtPoint(currentPagePoint, {
      hitInside: false,
      hitLabels,
      margin: editor.options.hitTestMargin / zoomLevel,
      renderingOnly: true
    }) ?? editor.getSelectedShapeAtPoint(currentPagePoint)
  );
}

// ../node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/Crop/children/crop_helpers.mjs
function getTranslateCroppedImageChange(editor, shape, delta) {
  if (!shape) {
    throw Error("Needs to translate a cropped shape!");
  }
  const { crop: oldCrop } = shape.props;
  if (!oldCrop) {
    return;
  }
  const flatten = editor.inputs.getShiftKey() ? Math.abs(delta.x) < Math.abs(delta.y) ? "x" : "y" : null;
  if (flatten === "x") {
    delta.x = 0;
  } else if (flatten === "y") {
    delta.y = 0;
  }
  delta.rot(-shape.rotation);
  const { w, h: h2 } = getUncroppedSize(shape.props, oldCrop);
  const xCropSize = oldCrop.bottomRight.x - oldCrop.topLeft.x;
  const yCropSize = oldCrop.bottomRight.y - oldCrop.topLeft.y;
  const newCrop = structuredClone(oldCrop);
  const xMinWithCrop = 1 - xCropSize;
  const yMinWithCrop = 1 - yCropSize;
  newCrop.topLeft.x = clamp(newCrop.topLeft.x - delta.x / w, 0, xMinWithCrop);
  newCrop.topLeft.y = clamp(newCrop.topLeft.y - delta.y / h2, 0, yMinWithCrop);
  newCrop.bottomRight.x = newCrop.topLeft.x + xCropSize;
  newCrop.bottomRight.y = newCrop.topLeft.y + yCropSize;
  const partial = {
    id: shape.id,
    type: shape.type,
    props: {
      crop: newCrop
    }
  };
  return partial;
}

// ../node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/Crop/children/Idle.mjs
var Idle11 = class extends StateNode {
  onEnter() {
    this.editor.setCursor({ type: "default", rotation: 0 });
    const onlySelectedShape = this.editor.getOnlySelectedShape();
    if (onlySelectedShape) {
      this.editor.setCroppingShape(onlySelectedShape.id);
    }
  }
  onExit() {
    this.editor.setCursor({ type: "default", rotation: 0 });
  }
  onCancel() {
    this.editor.setCroppingShape(null);
    this.editor.setCurrentTool("select.idle", {});
  }
  onPointerDown(info) {
    var _a6;
    if (info.accelKey) {
      this.cancel();
      this.editor.root.handleEvent(info);
      return;
    }
    switch (info.target) {
      case "canvas": {
        const hitShape = getHitShapeOnCanvasPointerDown(this.editor);
        if (hitShape && !this.editor.isShapeOfType(hitShape, "group")) {
          this.onPointerDown({
            ...info,
            shape: hitShape,
            target: "shape"
          });
          return;
        }
        this.cancel();
        this.editor.root.handleEvent(info);
        break;
      }
      case "shape": {
        if (info.shape.id === this.editor.getCroppingShapeId()) {
          this.editor.setCurrentTool("select.crop.pointing_crop", info);
          return;
        } else {
          if ((_a6 = this.editor.getShapeUtil(info.shape)) == null ? void 0 : _a6.canCrop(info.shape)) {
            this.editor.setCroppingShape(info.shape.id);
            this.editor.setSelectedShapes([info.shape.id]);
            this.editor.setCurrentTool("select.crop.pointing_crop", info);
          } else {
            this.cancel();
            this.editor.root.handleEvent(info);
          }
        }
        break;
      }
      case "selection": {
        switch (info.handle) {
          case "mobile_rotate":
          case "top_left_rotate":
          case "top_right_rotate":
          case "bottom_left_rotate":
          case "bottom_right_rotate": {
            this.editor.setCurrentTool("select.pointing_rotate_handle", {
              ...info,
              onInteractionEnd: "select.crop.idle"
            });
            break;
          }
          case "top":
          case "right":
          case "bottom":
          case "left":
          case "top_left":
          case "top_right":
          case "bottom_left":
          case "bottom_right": {
            this.editor.setCurrentTool("select.crop.pointing_crop_handle", {
              ...info,
              onInteractionEnd: "select.crop.idle"
            });
            break;
          }
          default: {
            this.cancel();
          }
        }
        break;
      }
    }
  }
  onDoubleClick(info) {
    var _a6;
    if (this.editor.inputs.getShiftKey() || info.phase !== "up") return;
    const croppingShapeId = this.editor.getCroppingShapeId();
    if (!croppingShapeId) return;
    const shape = this.editor.getShape(croppingShapeId);
    if (!shape) return;
    const util = this.editor.getShapeUtil(shape);
    if (!util) return;
    if (info.target === "selection") {
      (_a6 = util.onDoubleClickEdge) == null ? void 0 : _a6.call(util, shape, info);
      return;
    }
    this.cancel();
    this.editor.root.handleEvent(info);
  }
  onKeyDown() {
    this.nudgeCroppingImage(false);
  }
  onKeyRepeat() {
    this.nudgeCroppingImage(true);
  }
  onKeyUp(info) {
    switch (info.key) {
      case "Enter": {
        this.editor.setCroppingShape(null);
        this.editor.setCurrentTool("select.idle", {});
        break;
      }
    }
  }
  cancel() {
    this.editor.setCroppingShape(null);
    this.editor.setCurrentTool("select.idle", {});
  }
  nudgeCroppingImage(ephemeral = false) {
    const {
      editor: {
        inputs: { keys: keys3 }
      }
    } = this;
    const shiftKey = keys3.has("ShiftLeft");
    const delta = new Vec(0, 0);
    if (keys3.has("ArrowLeft")) delta.x += 1;
    if (keys3.has("ArrowRight")) delta.x -= 1;
    if (keys3.has("ArrowUp")) delta.y += 1;
    if (keys3.has("ArrowDown")) delta.y -= 1;
    if (delta.equals(new Vec(0, 0))) return;
    if (shiftKey) delta.mul(10);
    const shape = this.editor.getShape(this.editor.getCroppingShapeId());
    if (!shape) return;
    const partial = getTranslateCroppedImageChange(this.editor, shape, delta);
    if (partial) {
      if (!ephemeral) {
        this.editor.markHistoryStoppingPoint("translate crop");
      }
      this.editor.updateShapes([partial]);
    }
  }
};
__publicField(Idle11, "id", "idle");

// ../node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/Crop/children/PointingCrop.mjs
var PointingCrop = class extends StateNode {
  onCancel() {
    this.editor.setCurrentTool("select.crop.idle", {});
  }
  onPointerMove(info) {
    if (this.editor.inputs.getIsDragging()) {
      this.startDragging(info);
    }
  }
  onLongPress(info) {
    this.startDragging(info);
  }
  onPointerUp(info) {
    this.editor.setCurrentTool("select.crop.idle", info);
  }
  startDragging(info) {
    this.editor.setCurrentTool("select.crop.translating_crop", info);
  }
};
__publicField(PointingCrop, "id", "pointing_crop");

// ../node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/Crop/children/PointingCropHandle.mjs
var PointingCropHandle = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "info", {});
  }
  onEnter(info) {
    this.info = info;
    if (typeof info.onInteractionEnd === "string") {
      this.parent.setCurrentToolIdMask(info.onInteractionEnd);
    }
    const selectedShape = this.editor.getSelectedShapes()[0];
    if (!selectedShape) return;
    const cursorType = CursorTypeMap[this.info.handle];
    this.editor.setCursor({ type: cursorType, rotation: this.editor.getSelectionRotation() });
    this.editor.setCroppingShape(selectedShape.id);
  }
  onExit() {
    this.editor.setCursor({ type: "default", rotation: 0 });
    this.parent.setCurrentToolIdMask(void 0);
  }
  onPointerMove() {
    if (this.editor.inputs.getIsDragging()) {
      this.startCropping();
    }
  }
  onLongPress() {
    this.startCropping();
  }
  startCropping() {
    if (this.editor.getIsReadonly()) return;
    this.parent.transition("cropping", {
      ...this.info,
      onInteractionEnd: this.info.onInteractionEnd
    });
  }
  onPointerUp() {
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        this.editor.setCurrentTool(onInteractionEnd, this.info);
      } else {
        onInteractionEnd();
      }
      return;
    }
    this.editor.setCroppingShape(null);
    this.editor.setCurrentTool("select.idle");
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  cancel() {
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        this.editor.setCurrentTool(onInteractionEnd, this.info);
      } else {
        onInteractionEnd();
      }
      return;
    }
    this.editor.setCroppingShape(null);
    this.editor.setCurrentTool("select.idle");
  }
};
__publicField(PointingCropHandle, "id", "pointing_crop_handle");

// ../node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/Crop/children/TranslatingCrop.mjs
var TranslatingCrop = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "info", {});
    __publicField(this, "markId", "");
    __publicField(this, "snapshot", {});
  }
  onEnter(info) {
    this.info = info;
    this.snapshot = this.createSnapshot();
    this.markId = this.editor.markHistoryStoppingPoint("translating_crop");
    this.editor.setCursor({ type: "move", rotation: 0 });
    this.updateShapes();
  }
  onExit() {
    this.editor.setCursor({ type: "default", rotation: 0 });
  }
  onPointerMove() {
    this.updateShapes();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onKeyDown(info) {
    switch (info.key) {
      case "Alt":
      case "Shift": {
        this.updateShapes();
        return;
      }
    }
  }
  onKeyUp(info) {
    switch (info.key) {
      case "Enter": {
        this.complete();
        return;
      }
      case "Alt":
      case "Shift": {
        this.updateShapes();
      }
    }
  }
  complete() {
    this.updateShapes();
    this.editor.setCurrentTool("select.crop.idle", this.info);
  }
  cancel() {
    this.editor.bailToMark(this.markId);
    this.editor.setCurrentTool("select.crop.idle", this.info);
  }
  createSnapshot() {
    const shape = this.editor.getOnlySelectedShape();
    return { shape };
  }
  updateShapes() {
    const shape = this.snapshot.shape;
    if (!shape) return;
    const originPagePoint = this.editor.inputs.getOriginPagePoint();
    const currentPagePoint = this.editor.inputs.getCurrentPagePoint();
    const delta = currentPagePoint.clone().sub(originPagePoint);
    const partial = getTranslateCroppedImageChange(this.editor, shape, delta);
    if (partial) {
      this.editor.updateShapes([partial]);
    }
  }
};
__publicField(TranslatingCrop, "id", "translating_crop");

// ../node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/Crop/Crop.mjs
var Crop = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "markId", "");
    __publicField(this, "didExit", false);
  }
  static children() {
    return [Idle11, TranslatingCrop, PointingCrop, PointingCropHandle, Cropping];
  }
  onEnter() {
    this.didExit = false;
    this.markId = this.editor.markHistoryStoppingPoint("crop");
  }
  onExit() {
    if (!this.didExit) {
      this.didExit = true;
      this.editor.squashToMark(this.markId);
    }
  }
  onCancel() {
    if (!this.didExit) {
      this.didExit = true;
      this.editor.bailToMark(this.markId);
    }
  }
};
__publicField(Crop, "id", "crop");
__publicField(Crop, "initial", "idle");

// ../node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/DraggingHandle.mjs
var DraggingHandle = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "shapeId");
    __publicField(this, "initialHandle");
    __publicField(this, "initialAdjacentHandle");
    __publicField(this, "initialPagePoint");
    __publicField(this, "markId");
    __publicField(this, "initialPageTransform");
    __publicField(this, "initialPageRotation");
    __publicField(this, "info");
    __publicField(this, "isPrecise", false);
    __publicField(this, "isPreciseId", null);
    __publicField(this, "pointingId", null);
    // Only relevant to arrows
    __publicField(this, "exactTimeout", -1);
  }
  onEnter(info) {
    var _a6;
    const { shape, isCreating, creatingMarkId, handle } = info;
    this.info = info;
    if (typeof info.onInteractionEnd === "string") {
      this.parent.setCurrentToolIdMask(info.onInteractionEnd);
    }
    this.shapeId = shape.id;
    this.markId = "";
    if (isCreating) {
      if (creatingMarkId) {
        this.markId = creatingMarkId;
      } else {
        const markId = this.editor.getMarkIdMatching(
          `creating:${this.editor.getOnlySelectedShapeId()}`
        );
        if (markId) {
          this.markId = markId;
        }
      }
    } else {
      this.markId = this.editor.markHistoryStoppingPoint("dragging handle");
    }
    this.initialHandle = structuredClone(handle);
    this.initialPageTransform = this.editor.getShapePageTransform(shape);
    this.initialPageRotation = this.initialPageTransform.rotation();
    this.initialPagePoint = this.editor.inputs.getOriginPagePoint().clone();
    this.editor.setCursor({ type: isCreating ? "cross" : "grabbing", rotation: 0 });
    const handles = this.editor.getShapeHandles(shape).sort(sortByIndex);
    const index2 = handles.findIndex((h2) => h2.id === info.handle.id);
    this.initialAdjacentHandle = null;
    if (info.handle.snapReferenceHandleId) {
      const customHandle = handles.find((h2) => h2.id === info.handle.snapReferenceHandleId);
      if (customHandle) {
        this.initialAdjacentHandle = customHandle;
      }
    }
    if (!this.initialAdjacentHandle) {
      for (let i = index2 + 1; i < handles.length; i++) {
        const handle2 = handles[i];
        if (handle2.type === "vertex" && handle2.id !== "middle" && handle2.id !== info.handle.id) {
          this.initialAdjacentHandle = handle2;
          break;
        }
      }
      if (!this.initialAdjacentHandle) {
        for (let i = handles.length - 1; i >= 0; i--) {
          const handle2 = handles[i];
          if (handle2.type === "vertex" && handle2.id !== "middle" && handle2.id !== info.handle.id) {
            this.initialAdjacentHandle = handle2;
            break;
          }
        }
      }
    }
    if (this.editor.isShapeOfType(shape, "arrow")) {
      const initialBinding = getArrowBindings(this.editor, shape)[info.handle.id];
      this.isPrecise = false;
      if (initialBinding) {
        this.isPrecise = initialBinding.props.isPrecise;
        if (this.isPrecise) {
          this.isPreciseId = initialBinding.toId;
        } else {
          this.resetExactTimeout();
        }
      }
    }
    const handleDragInfo = {
      handle: this.initialHandle,
      isPrecise: this.isPrecise,
      isCreatingShape: !!this.info.isCreating,
      initial: shape
    };
    const util = this.editor.getShapeUtil(shape);
    const startChanges = (_a6 = util.onHandleDragStart) == null ? void 0 : _a6.call(util, shape, handleDragInfo);
    if (startChanges) {
      this.editor.updateShapes([{ ...startChanges, id: shape.id, type: shape.type }]);
    }
    this.update();
    this.editor.select(this.shapeId);
  }
  // Only relevant to arrows
  resetExactTimeout() {
    const arrowUtil = this.editor.getShapeUtil("arrow");
    const timeoutValue = arrowUtil.options.pointingPreciseTimeout;
    if (this.exactTimeout !== -1) {
      this.clearExactTimeout();
    }
    this.exactTimeout = this.editor.timers.setTimeout(() => {
      if (this.getIsActive() && !this.isPrecise) {
        this.isPrecise = true;
        this.isPreciseId = this.pointingId;
        this.update();
      }
      this.exactTimeout = -1;
    }, timeoutValue);
  }
  // Only relevant to arrows
  clearExactTimeout() {
    if (this.exactTimeout !== -1) {
      clearTimeout(this.exactTimeout);
      this.exactTimeout = -1;
    }
  }
  onPointerMove() {
    this.update();
  }
  onKeyDown() {
    this.update();
  }
  onKeyUp() {
    this.update();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.update();
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0);
    clearArrowTargetState(this.editor);
    this.editor.snaps.clearIndicators();
    this.editor.setCursor({ type: "default", rotation: 0 });
  }
  complete() {
    var _a6;
    this.editor.snaps.clearIndicators();
    kickoutOccludedShapes(this.editor, [this.shapeId]);
    const shape = this.editor.getShape(this.shapeId);
    if (shape) {
      const util = this.editor.getShapeUtil(shape);
      const handleDragInfo = {
        handle: this.initialHandle,
        isPrecise: this.isPrecise,
        isCreatingShape: !!this.info.isCreating,
        initial: this.info.shape
      };
      const endChanges = (_a6 = util.onHandleDragEnd) == null ? void 0 : _a6.call(util, shape, handleDragInfo);
      if (endChanges) {
        this.editor.updateShapes([{ ...endChanges, id: shape.id }]);
      }
    }
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        if (this.editor.getInstanceState().isToolLocked && onInteractionEnd) {
          this.editor.setCurrentTool(onInteractionEnd, { shapeId: this.shapeId });
          return;
        }
      } else {
        onInteractionEnd == null ? void 0 : onInteractionEnd();
        return;
      }
    }
    this.parent.transition("idle");
  }
  cancel() {
    var _a6;
    const shape = this.editor.getShape(this.shapeId);
    if (shape) {
      const util = this.editor.getShapeUtil(shape);
      const handleDragInfo = {
        handle: this.initialHandle,
        isPrecise: this.isPrecise,
        isCreatingShape: !!this.info.isCreating,
        initial: this.info.shape
      };
      (_a6 = util.onHandleDragCancel) == null ? void 0 : _a6.call(util, shape, handleDragInfo);
    }
    this.editor.bailToMark(this.markId);
    this.editor.snaps.clearIndicators();
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        this.editor.setCurrentTool(onInteractionEnd, { shapeId: this.shapeId });
      } else {
        onInteractionEnd == null ? void 0 : onInteractionEnd();
      }
      return;
    }
    this.parent.transition("idle");
  }
  update() {
    var _a6;
    const { editor, shapeId, initialPagePoint } = this;
    const { initialHandle, initialPageRotation, initialAdjacentHandle } = this;
    const isSnapMode = this.editor.user.getIsSnapMode();
    const { snaps } = editor;
    const currentPagePoint = editor.inputs.getCurrentPagePoint();
    const shiftKey = editor.inputs.getShiftKey();
    const ctrlKey2 = editor.inputs.getCtrlKey();
    const altKey2 = editor.inputs.getAltKey();
    const pointerVelocity = editor.inputs.getPointerVelocity();
    const initial = this.info.shape;
    const shape = editor.getShape(shapeId);
    if (!shape) return;
    const util = editor.getShapeUtil(shape);
    const initialBinding = editor.isShapeOfType(shape, "arrow") ? getArrowBindings(editor, shape)[initialHandle.id] : void 0;
    let point = currentPagePoint.clone().sub(initialPagePoint).rot(-initialPageRotation).add(initialHandle);
    if (shiftKey && initialAdjacentHandle && initialHandle.id !== "middle") {
      const angle = Vec.Angle(initialAdjacentHandle, point);
      const snappedAngle = snapAngle(angle, 24);
      const angleDifference = snappedAngle - angle;
      point = Vec.RotWith(point, initialAdjacentHandle, angleDifference);
    }
    editor.snaps.clearIndicators();
    let nextHandle = { ...initialHandle, x: point.x, y: point.y };
    let canSnap = false;
    if (initialHandle.canSnap && initialHandle.snapType) {
      warnOnce(
        "canSnap is deprecated. Cannot use both canSnap and snapType together - snapping disabled. Please use only snapType."
      );
    } else {
      canSnap = initialHandle.canSnap || initialHandle.snapType !== void 0;
    }
    if (canSnap && (isSnapMode ? !ctrlKey2 : ctrlKey2)) {
      const pageTransform = editor.getShapePageTransform(shape.id);
      if (!pageTransform) throw Error("Expected a page transform");
      const snap = snaps.handles.snapHandle({ currentShapeId: shapeId, handle: nextHandle });
      if (snap) {
        snap.nudge.rot(-editor.getShapeParentTransform(shape).rotation());
        point.add(snap.nudge);
        nextHandle = { ...initialHandle, x: point.x, y: point.y };
      }
    }
    const changes = (_a6 = util.onHandleDrag) == null ? void 0 : _a6.call(util, shape, {
      handle: nextHandle,
      isPrecise: this.isPrecise || altKey2,
      isCreatingShape: !!this.info.isCreating,
      initial
    });
    const next = { id: shape.id, type: shape.type, ...changes };
    if (initialHandle.type === "vertex" && this.editor.isShapeOfType(shape, "arrow")) {
      const bindingAfter = getArrowBindings(editor, shape)[initialHandle.id];
      if (bindingAfter) {
        if ((initialBinding == null ? void 0 : initialBinding.toId) !== bindingAfter.toId) {
          this.pointingId = bindingAfter.toId;
          this.isPrecise = pointerVelocity.len() < 0.5 || altKey2;
          this.isPreciseId = this.isPrecise ? bindingAfter.toId : null;
          this.resetExactTimeout();
        }
      } else {
        if (initialBinding) {
          this.pointingId = null;
          this.isPrecise = false;
          this.isPreciseId = null;
          this.resetExactTimeout();
        }
      }
    }
    if (changes) {
      editor.updateShapes([next]);
    }
  }
};
__publicField(DraggingHandle, "id", "dragging_handle");

// ../node_modules/tldraw/dist-esm/lib/utils/shapes/shapes.mjs
function getTextLabels(geometry) {
  if (geometry.isLabel) {
    return [geometry];
  }
  if (geometry instanceof Group2d) {
    return geometry.children.filter((child) => child.isLabel);
  }
  return [];
}

// ../node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/EditingShape.mjs
var EditingShape = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "hitLabelOnShapeForPointerUp", null);
    __publicField(this, "info", {});
    __publicField(this, "didPointerDownOnEditingShape", false);
  }
  isTextInputFocused() {
    var _a6, _b3, _c;
    const container = this.editor.getContainer();
    return container.contains(document.activeElement) && (((_a6 = document.activeElement) == null ? void 0 : _a6.nodeName) === "INPUT" || ((_b3 = document.activeElement) == null ? void 0 : _b3.nodeName) === "TEXTAREA" || ((_c = document.activeElement) == null ? void 0 : _c.isContentEditable));
  }
  onEnter(info) {
    const editingShape = this.editor.getEditingShape();
    if (!editingShape) throw Error("Entered editing state without an editing shape");
    this.hitLabelOnShapeForPointerUp = null;
    this.didPointerDownOnEditingShape = false;
    this.info = info;
    if (info.isCreatingTextWhileToolLocked) {
      this.parent.setCurrentToolIdMask("text");
    }
    updateHoveredShapeId(this.editor);
    this.editor.select(editingShape);
  }
  onExit() {
    const { editingShapeId } = this.editor.getCurrentPageState();
    if (!editingShapeId) return;
    this.editor.setEditingShape(null);
    updateHoveredShapeId.cancel();
    if (this.info.isCreatingTextWhileToolLocked) {
      this.parent.setCurrentToolIdMask(void 0);
      this.editor.setCurrentTool("text", {});
    }
  }
  onPointerMove(info) {
    if (this.hitLabelOnShapeForPointerUp && this.editor.inputs.getIsDragging()) {
      if (this.editor.getIsReadonly()) return;
      if (this.hitLabelOnShapeForPointerUp.isLocked) return;
      this.editor.select(this.hitLabelOnShapeForPointerUp);
      this.parent.transition("translating", info);
      this.hitLabelOnShapeForPointerUp = null;
      return;
    }
    if (this.didPointerDownOnEditingShape && this.editor.inputs.isDragging) {
      if (this.editor.getIsReadonly()) return;
      const editingShape = this.editor.getEditingShape();
      if (!editingShape || editingShape.isLocked) return;
      if (!this.isTextInputFocused()) {
        this.editor.select(editingShape);
        this.parent.transition("translating", info);
        this.didPointerDownOnEditingShape = false;
        return;
      }
      this.didPointerDownOnEditingShape = false;
    }
    switch (info.target) {
      case "shape":
      case "canvas": {
        updateHoveredShapeId(this.editor);
        return;
      }
    }
  }
  onPointerDown(info) {
    this.hitLabelOnShapeForPointerUp = null;
    this.didPointerDownOnEditingShape = false;
    switch (info.target) {
      // N.B. This bit of logic has a bit of history to it.
      // There was a PR that got rid of this logic: https://github.com/tldraw/tldraw/pull/4237
      // But here we bring it back to help support the new rich text world.
      // The original issue which is visible in the video attachments in the PR now seem
      // to have been resolved anyway via some other layer.
      case "canvas": {
        const hitShape = getHitShapeOnCanvasPointerDown(
          this.editor,
          true
          /* hitLabels */
        );
        if (hitShape) {
          this.onPointerDown({
            ...info,
            shape: hitShape,
            target: "shape"
          });
          return;
        }
        break;
      }
      case "shape": {
        const { shape: selectingShape } = info;
        const editingShape = this.editor.getEditingShape();
        if (!editingShape) {
          throw Error("Expected an editing shape!");
        }
        const geometry = this.editor.getShapeUtil(selectingShape).getGeometry(selectingShape);
        const textLabels = getTextLabels(geometry);
        const textLabel = textLabels.length === 1 ? textLabels[0] : void 0;
        const isEmptyTextShape = this.editor.isShapeOfType(editingShape, "text") && renderPlaintextFromRichText(this.editor, editingShape.props.richText).trim() === "";
        if (textLabel && !isEmptyTextShape) {
          const pointInShapeSpace = this.editor.getPointInShapeSpace(
            selectingShape,
            this.editor.inputs.getCurrentPagePoint()
          );
          if (textLabel.bounds.containsPoint(pointInShapeSpace, 0) && textLabel.hitTestPoint(pointInShapeSpace)) {
            if (selectingShape.id === editingShape.id) {
              this.didPointerDownOnEditingShape = true;
              return;
            } else {
              this.hitLabelOnShapeForPointerUp = selectingShape;
              this.editor.markHistoryStoppingPoint("editing on pointer up");
              this.editor.select(selectingShape.id);
              return;
            }
          }
        } else {
          if (selectingShape.id === editingShape.id) {
            if (this.editor.isShapeOfType(selectingShape, "frame")) {
              this.editor.setEditingShape(null);
              this.parent.transition("idle", info);
            }
          } else {
            this.parent.transition("pointing_shape", info);
            return;
          }
          return;
        }
        break;
      }
    }
    this.parent.transition("idle", info);
    this.editor.root.handleEvent(info);
  }
  onPointerUp(info) {
    var _a6;
    if (this.didPointerDownOnEditingShape) {
      this.didPointerDownOnEditingShape = false;
      if (!this.isTextInputFocused()) {
        (_a6 = this.editor.getRichTextEditor()) == null ? void 0 : _a6.commands.focus("all");
        return;
      }
    }
    const hitShape = this.hitLabelOnShapeForPointerUp;
    if (!hitShape) return;
    this.hitLabelOnShapeForPointerUp = null;
    const util = this.editor.getShapeUtil(hitShape);
    if (hitShape.isLocked) return;
    if (this.editor.getIsReadonly()) {
      if (!util.canEditInReadonly(hitShape)) {
        this.parent.transition("pointing_shape", info);
        return;
      }
    }
    this.editor.select(hitShape.id);
    const currentEditingShape = this.editor.getEditingShape();
    const isEditToEditAction = currentEditingShape && currentEditingShape.id !== hitShape.id;
    this.editor.setEditingShape(hitShape.id);
    const isMobile = tlenv.isIos || tlenv.isAndroid;
    if (!isMobile || !isEditToEditAction) {
      this.editor.emit("place-caret", { shapeId: hitShape.id, point: info.point });
    } else if (isMobile && isEditToEditAction) {
      this.editor.emit("select-all-text", { shapeId: hitShape.id });
    }
    updateHoveredShapeId(this.editor);
  }
  onComplete(info) {
    this.editor.getContainer().focus();
    this.parent.transition("idle", info);
  }
  onCancel(info) {
    this.editor.getContainer().focus();
    this.parent.transition("idle", info);
  }
};
__publicField(EditingShape, "id", "editing_shape");

// ../node_modules/tldraw/dist-esm/lib/tools/selection-logic/selectOnCanvasPointerUp.mjs
function selectOnCanvasPointerUp(editor, info) {
  const selectedShapeIds = editor.getSelectedShapeIds();
  const currentPagePoint = editor.inputs.getCurrentPagePoint();
  const { shiftKey, altKey: altKey2, accelKey } = info;
  const additiveSelectionKey = shiftKey || accelKey;
  const hitShape = editor.getShapeAtPoint(currentPagePoint, {
    hitInside: false,
    margin: editor.options.hitTestMargin / editor.getZoomLevel(),
    hitLabels: true,
    renderingOnly: true,
    filter: (shape) => !shape.isLocked
  });
  if (hitShape) {
    const outermostSelectableShape = editor.getOutermostSelectableShape(hitShape);
    if (additiveSelectionKey && !altKey2) {
      editor.cancelDoubleClick();
      if (selectedShapeIds.includes(outermostSelectableShape.id)) {
        editor.markHistoryStoppingPoint("deselecting shape");
        editor.deselect(outermostSelectableShape);
      } else {
        editor.markHistoryStoppingPoint("shift selecting shape");
        editor.setSelectedShapes([...selectedShapeIds, outermostSelectableShape.id]);
      }
    } else {
      let shapeToSelect = void 0;
      if (outermostSelectableShape === hitShape) {
        shapeToSelect = hitShape;
      } else {
        if (outermostSelectableShape.id === editor.getFocusedGroupId() || selectedShapeIds.includes(outermostSelectableShape.id)) {
          shapeToSelect = hitShape;
        } else {
          shapeToSelect = outermostSelectableShape;
        }
      }
      if (shapeToSelect && !selectedShapeIds.includes(shapeToSelect.id)) {
        editor.markHistoryStoppingPoint("selecting shape");
        editor.select(shapeToSelect.id);
      }
    }
  } else {
    if (additiveSelectionKey) {
      return;
    } else {
      if (selectedShapeIds.length > 0) {
        editor.markHistoryStoppingPoint("selecting none");
        editor.selectNone();
      }
      const focusedGroupId = editor.getFocusedGroupId();
      if (isShapeId(focusedGroupId)) {
        const groupShape = editor.getShape(focusedGroupId);
        if (!editor.isPointInShape(groupShape, currentPagePoint, { margin: 0, hitInside: true })) {
          editor.setFocusedGroup(null);
        }
      }
    }
  }
}

// ../node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/Idle.mjs
var SKIPPED_KEYS_FOR_AUTO_EDITING = [
  "Delete",
  "Backspace",
  "[",
  "]",
  "Enter",
  " ",
  "Shift",
  "Tab"
];
var Idle12 = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "selectedShapesOnKeyDown", []);
  }
  onEnter() {
    this.parent.setCurrentToolIdMask(void 0);
    updateHoveredShapeId(this.editor);
    this.selectedShapesOnKeyDown = [];
    this.editor.setCursor({ type: "default", rotation: 0 });
  }
  onExit() {
    updateHoveredShapeId.cancel();
  }
  onPointerMove() {
    updateHoveredShapeId(this.editor);
  }
  onPointerDown(info) {
    switch (info.target) {
      case "canvas": {
        const hitShape = getHitShapeOnCanvasPointerDown(this.editor);
        if (hitShape && !hitShape.isLocked) {
          this.onPointerDown({
            ...info,
            shape: hitShape,
            target: "shape"
          });
          return;
        }
        const selectedShapeIds = this.editor.getSelectedShapeIds();
        const onlySelectedShape = this.editor.getOnlySelectedShape();
        const currentPagePoint = this.editor.inputs.getCurrentPagePoint();
        if (selectedShapeIds.length > 1 || onlySelectedShape && !this.editor.getShapeUtil(onlySelectedShape).hideSelectionBoundsBg(onlySelectedShape)) {
          if (isPointInRotatedSelectionBounds(this.editor, currentPagePoint)) {
            this.onPointerDown({
              ...info,
              target: "selection"
            });
            return;
          }
        }
        this.parent.transition("pointing_canvas", info);
        break;
      }
      case "shape": {
        const { shape } = info;
        if (this.editor.isShapeOrAncestorLocked(shape)) {
          this.parent.transition("pointing_canvas", info);
          break;
        }
        this.parent.transition("pointing_shape", info);
        break;
      }
      case "handle": {
        if (this.editor.getIsReadonly()) break;
        if (this.editor.inputs.getAltKey()) {
          this.parent.transition("pointing_shape", info);
        } else {
          this.parent.transition("pointing_handle", info);
        }
        break;
      }
      case "selection": {
        switch (info.handle) {
          case "mobile_rotate":
          case "top_left_rotate":
          case "top_right_rotate":
          case "bottom_left_rotate":
          case "bottom_right_rotate": {
            if (info.accelKey) {
              this.parent.transition("brushing", info);
              break;
            }
            this.parent.transition("pointing_rotate_handle", info);
            break;
          }
          case "top":
          case "right":
          case "bottom":
          case "left":
          case "top_left":
          case "top_right":
          case "bottom_left":
          case "bottom_right": {
            const onlySelectedShape = this.editor.getOnlySelectedShape();
            if (info.ctrlKey && this.editor.canCropShape(onlySelectedShape)) {
              this.parent.transition("crop.pointing_crop_handle", info);
            } else {
              if (info.accelKey) {
                this.parent.transition("brushing", info);
                break;
              }
              this.parent.transition("pointing_resize_handle", info);
            }
            break;
          }
          default: {
            const hoveredShape = this.editor.getHoveredShape();
            if (hoveredShape && !this.editor.getSelectedShapeIds().includes(hoveredShape.id) && !hoveredShape.isLocked) {
              this.onPointerDown({
                ...info,
                shape: hoveredShape,
                target: "shape"
              });
              return;
            }
            this.parent.transition("pointing_selection", info);
          }
        }
        break;
      }
    }
  }
  onDoubleClick(info) {
    var _a6, _b3, _c, _d, _e;
    if (this.editor.inputs.getShiftKey() || info.phase !== "up") return;
    if (info.ctrlKey || info.shiftKey) return;
    switch (info.target) {
      case "canvas": {
        const hoveredShape = this.editor.getHoveredShape();
        const currentPagePoint = this.editor.inputs.getCurrentPagePoint();
        const hitShape = hoveredShape && !this.editor.isShapeOfType(hoveredShape, "group") ? hoveredShape : this.editor.getSelectedShapeAtPoint(currentPagePoint) ?? this.editor.getShapeAtPoint(currentPagePoint, {
          margin: this.editor.options.hitTestMargin / this.editor.getZoomLevel(),
          hitInside: false
        });
        const focusedGroupId = this.editor.getFocusedGroupId();
        if (hitShape) {
          if (this.editor.isShapeOfType(hitShape, "group")) {
            selectOnCanvasPointerUp(this.editor, info);
            return;
          } else {
            const parent = this.editor.getShape(hitShape.parentId);
            if (parent && this.editor.isShapeOfType(parent, "group")) {
              if (focusedGroupId && parent.id === focusedGroupId) {
              } else {
                selectOnCanvasPointerUp(this.editor, info);
                return;
              }
            }
          }
          this.onDoubleClick({
            ...info,
            shape: hitShape,
            target: "shape"
          });
          return;
        }
        if (!this.editor.inputs.getShiftKey()) {
          this.handleDoubleClickOnCanvas(info);
        }
        break;
      }
      case "selection": {
        const onlySelectedShape = this.editor.getOnlySelectedShape();
        if (onlySelectedShape) {
          const util = this.editor.getShapeUtil(onlySelectedShape);
          const isEdge = info.handle === "right" || info.handle === "left" || info.handle === "top" || info.handle === "bottom";
          const isCorner = info.handle === "top_left" || info.handle === "top_right" || info.handle === "bottom_right" || info.handle === "bottom_left";
          if (this.editor.getIsReadonly()) {
            if (this.editor.canEditShape(onlySelectedShape, {
              type: isCorner ? "double-click-corner" : isEdge ? "double-click-edge" : "double-click"
            })) {
              this.startEditingShape(
                onlySelectedShape,
                info,
                true
                /* select all */
              );
            }
            break;
          }
          if (isEdge) {
            const change = (_a6 = util.onDoubleClickEdge) == null ? void 0 : _a6.call(util, onlySelectedShape, info);
            if (change) {
              this.editor.markHistoryStoppingPoint("double click edge");
              this.editor.updateShapes([change]);
              kickoutOccludedShapes(this.editor, [onlySelectedShape.id]);
              return;
            }
          }
          if (isCorner) {
            const change = (_b3 = util.onDoubleClickCorner) == null ? void 0 : _b3.call(util, onlySelectedShape, info);
            if (change) {
              this.editor.markHistoryStoppingPoint("double click corner");
              this.editor.updateShapes([change]);
              kickoutOccludedShapes(this.editor, [onlySelectedShape.id]);
              return;
            }
          }
          if (this.editor.canCropShape(onlySelectedShape)) {
            this.parent.transition("crop", info);
            return;
          }
          if (this.editor.canEditShape(onlySelectedShape)) {
            this.startEditingShape(
              onlySelectedShape,
              info,
              true
              /* select all */
            );
          }
        }
        break;
      }
      case "shape": {
        const { shape } = info;
        const util = this.editor.getShapeUtil(shape);
        if (shape.type !== "video" && shape.type !== "embed" && this.editor.getIsReadonly()) break;
        if (util.onDoubleClick) {
          const change = (_c = util.onDoubleClick) == null ? void 0 : _c.call(util, shape);
          if (change) {
            this.editor.updateShapes([change]);
            return;
          }
        }
        if (util.canCrop(shape) && !this.editor.isShapeOrAncestorLocked(shape)) {
          this.editor.markHistoryStoppingPoint("select and crop");
          this.editor.select((_d = info.shape) == null ? void 0 : _d.id);
          this.parent.transition("crop", info);
          return;
        }
        if (this.editor.canEditShape(shape)) {
          this.startEditingShape(
            shape,
            info,
            true
            /* select all */
          );
        } else {
          this.handleDoubleClickOnCanvas(info);
        }
        break;
      }
      case "handle": {
        if (this.editor.getIsReadonly()) break;
        const { shape, handle } = info;
        const util = this.editor.getShapeUtil(shape);
        const changes = (_e = util.onDoubleClickHandle) == null ? void 0 : _e.call(util, shape, handle);
        if (changes) {
          this.editor.updateShapes([changes]);
        } else {
          if (this.editor.canEditShape(shape)) {
            this.startEditingShape(
              shape,
              info,
              true
              /* select all */
            );
          }
        }
      }
    }
  }
  onRightClick(info) {
    switch (info.target) {
      case "canvas": {
        const hoveredShape = this.editor.getHoveredShape();
        const hitShape = hoveredShape && !this.editor.isShapeOfType(hoveredShape, "group") ? hoveredShape : this.editor.getShapeAtPoint(this.editor.inputs.getCurrentPagePoint(), {
          margin: this.editor.options.hitTestMargin / this.editor.getZoomLevel(),
          hitInside: false,
          hitLabels: true,
          hitLocked: true,
          hitFrameInside: true,
          renderingOnly: true
        });
        if (hitShape) {
          this.onRightClick({
            ...info,
            shape: hitShape,
            target: "shape"
          });
          return;
        }
        const selectedShapeIds = this.editor.getSelectedShapeIds();
        const onlySelectedShape = this.editor.getOnlySelectedShape();
        const currentPagePoint = this.editor.inputs.getCurrentPagePoint();
        if (selectedShapeIds.length > 1 || onlySelectedShape && !this.editor.getShapeUtil(onlySelectedShape).hideSelectionBoundsBg(onlySelectedShape)) {
          if (isPointInRotatedSelectionBounds(this.editor, currentPagePoint)) {
            this.onRightClick({
              ...info,
              target: "selection"
            });
            return;
          }
        }
        this.editor.selectNone();
        break;
      }
      case "shape": {
        const { selectedShapeIds } = this.editor.getCurrentPageState();
        const { shape } = info;
        const targetShape = this.editor.getOutermostSelectableShape(
          shape,
          (parent) => !selectedShapeIds.includes(parent.id)
        );
        if (!selectedShapeIds.includes(targetShape.id) && !this.editor.findShapeAncestor(
          targetShape,
          (shape2) => selectedShapeIds.includes(shape2.id)
        )) {
          this.editor.markHistoryStoppingPoint("selecting shape");
          this.editor.setSelectedShapes([targetShape.id]);
        }
        break;
      }
    }
  }
  onCancel() {
    if (this.editor.getFocusedGroupId() !== this.editor.getCurrentPageId() && this.editor.getSelectedShapeIds().length > 0) {
      this.editor.popFocusedGroupId();
    } else {
      this.editor.markHistoryStoppingPoint("clearing selection");
      this.editor.selectNone();
    }
  }
  onKeyDown(info) {
    this.selectedShapesOnKeyDown = this.editor.getSelectedShapes();
    switch (info.code) {
      case "ArrowLeft":
      case "ArrowRight":
      case "ArrowUp":
      case "ArrowDown": {
        if (info.accelKey) {
          if (info.shiftKey) {
            if (info.code === "ArrowDown") {
              this.editor.selectFirstChildShape();
            } else if (info.code === "ArrowUp") {
              this.editor.selectParentShape();
            }
          } else {
            this.editor.selectAdjacentShape(
              info.code.replace("Arrow", "").toLowerCase()
            );
          }
          return;
        }
        this.nudgeSelectedShapes(false);
        return;
      }
    }
    if (debugFlags["editOnType"].get()) {
      if (!SKIPPED_KEYS_FOR_AUTO_EDITING.includes(info.key) && !info.altKey && !info.ctrlKey) {
        const onlySelectedShape = this.editor.getOnlySelectedShape();
        if (onlySelectedShape && // If it's a note shape, then edit on type
        this.editor.isShapeOfType(onlySelectedShape, "note") && // If it's not locked or anything
        this.editor.canEditShape(onlySelectedShape)) {
          this.startEditingShape(
            onlySelectedShape,
            {
              ...info,
              target: "shape",
              shape: onlySelectedShape
            },
            true
            /* select all */
          );
          return;
        }
      }
    }
  }
  onKeyRepeat(info) {
    switch (info.code) {
      case "ArrowLeft":
      case "ArrowRight":
      case "ArrowUp":
      case "ArrowDown": {
        if (info.accelKey) {
          this.editor.selectAdjacentShape(
            info.code.replace("Arrow", "").toLowerCase()
          );
          return;
        }
        this.nudgeSelectedShapes(true);
        break;
      }
      case "Tab": {
        const selectedShapes = this.editor.getSelectedShapes();
        if (selectedShapes.length && !info.altKey) {
          this.editor.selectAdjacentShape(info.shiftKey ? "prev" : "next");
        }
        break;
      }
    }
  }
  onKeyUp(info) {
    switch (info.key) {
      case "Enter": {
        if (!this.selectedShapesOnKeyDown.length) return;
        const selectedShapes = this.editor.getSelectedShapes();
        if (selectedShapes.every((shape) => this.editor.isShapeOfType(shape, "group"))) {
          this.editor.setSelectedShapes(
            selectedShapes.flatMap((shape) => this.editor.getSortedChildIdsForParent(shape.id))
          );
          return;
        }
        const onlySelectedShape = this.editor.getOnlySelectedShape();
        if (onlySelectedShape && this.editor.canEditShape(onlySelectedShape, { type: "press_enter" })) {
          this.startEditingShape(
            onlySelectedShape,
            {
              ...info,
              target: "shape",
              shape: onlySelectedShape
            },
            true
            /* select all */
          );
          return;
        }
        if (this.editor.canCropShape(onlySelectedShape)) {
          this.parent.transition("crop", info);
        }
        break;
      }
      case "Tab": {
        const selectedShapes = this.editor.getSelectedShapes();
        if (selectedShapes.length && !info.altKey) {
          this.editor.selectAdjacentShape(info.shiftKey ? "prev" : "next");
        }
        break;
      }
    }
  }
  startEditingShape(shape, info, shouldSelectAll) {
    const { editor } = this;
    this.editor.markHistoryStoppingPoint("editing shape");
    if (hasRichText(shape)) {
      startEditingShapeWithRichText(editor, shape, { selectAll: shouldSelectAll });
    } else {
      editor.setEditingShape(shape);
    }
    this.parent.transition("editing_shape", info);
  }
  isOverArrowLabelTest(shape) {
    if (!shape) return false;
    return isOverArrowLabel(this.editor, shape);
  }
  handleDoubleClickOnCanvas(info) {
    if (this.editor.getIsReadonly()) return;
    if (!this.editor.options.createTextOnCanvasDoubleClick) return;
    this.editor.markHistoryStoppingPoint("creating text shape");
    const id = createShapeId();
    const { x, y } = this.editor.inputs.getCurrentPagePoint();
    this.editor.createShapes([
      {
        id,
        type: "text",
        x,
        y,
        props: {
          richText: toRichText(""),
          autoSize: true
        }
      }
    ]);
    const shape = this.editor.getShape(id);
    if (!shape) return;
    if (!this.editor.canEditShape(shape)) return;
    startEditingShapeWithRichText(this.editor, id, { info });
  }
  nudgeSelectedShapes(ephemeral = false) {
    const {
      editor: {
        inputs: { keys: keys3 }
      }
    } = this;
    const shiftKey = keys3.has("ShiftLeft");
    const delta = new Vec(0, 0);
    if (keys3.has("ArrowLeft")) delta.x -= 1;
    if (keys3.has("ArrowRight")) delta.x += 1;
    if (keys3.has("ArrowUp")) delta.y -= 1;
    if (keys3.has("ArrowDown")) delta.y += 1;
    if (delta.equals(new Vec(0, 0))) return;
    if (!ephemeral) this.editor.markHistoryStoppingPoint("nudge shapes");
    const { gridSize } = this.editor.getDocumentSettings();
    const step = this.editor.getInstanceState().isGridMode ? shiftKey ? gridSize * GRID_INCREMENT : gridSize : shiftKey ? MAJOR_NUDGE_FACTOR : MINOR_NUDGE_FACTOR;
    const selectedShapeIds = this.editor.getSelectedShapeIds();
    this.editor.nudgeShapes(selectedShapeIds, delta.mul(step));
    kickoutOccludedShapes(this.editor, selectedShapeIds);
  }
};
__publicField(Idle12, "id", "idle");
var MAJOR_NUDGE_FACTOR = 10;
var MINOR_NUDGE_FACTOR = 1;
var GRID_INCREMENT = 5;
function isPointInRotatedSelectionBounds(editor, point) {
  const selectionBounds = editor.getSelectionRotatedPageBounds();
  if (!selectionBounds) return false;
  const selectionRotation = editor.getSelectionRotation();
  if (!selectionRotation) return selectionBounds.containsPoint(point);
  return pointInPolygon(
    point,
    selectionBounds.corners.map((c) => Vec.RotWith(c, selectionBounds.point, selectionRotation))
  );
}

// ../node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/PointingArrowLabel.mjs
var PointingArrowLabel = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "shapeId", "");
    __publicField(this, "markId", "");
    __publicField(this, "wasAlreadySelected", false);
    __publicField(this, "didDrag", false);
    __publicField(this, "didCtrlOnEnter", false);
    __publicField(this, "info", {});
    __publicField(this, "_labelDragOffset", new Vec(0, 0));
  }
  updateCursor() {
    this.editor.setCursor({ type: "grabbing", rotation: 0 });
  }
  onEnter(info) {
    const { shape } = info;
    if (typeof info.onInteractionEnd === "string") {
      this.parent.setCurrentToolIdMask(info.onInteractionEnd);
    }
    this.info = info;
    this.shapeId = shape.id;
    this.didDrag = false;
    this.didCtrlOnEnter = info.accelKey;
    this.wasAlreadySelected = this.editor.getOnlySelectedShapeId() === shape.id;
    this.updateCursor();
    const geometry = this.editor.getShapeGeometry(shape);
    const labelGeometry = geometry.children[1];
    if (!labelGeometry) {
      throw Error(`Expected to find an arrow label geometry for shape: ${shape.id}`);
    }
    const currentPagePoint = this.editor.inputs.getCurrentPagePoint();
    const pointInShapeSpace = this.editor.getPointInShapeSpace(shape, currentPagePoint);
    this._labelDragOffset = Vec.Sub(labelGeometry.center, pointInShapeSpace);
    this.markId = this.editor.markHistoryStoppingPoint("label-drag start");
    const additiveSelectionKey = info.shiftKey || info.accelKey;
    if (additiveSelectionKey) {
      const selectedShapeIds = this.editor.getSelectedShapeIds();
      this.editor.setSelectedShapes([...selectedShapeIds, this.shapeId]);
      return;
    }
    this.editor.setSelectedShapes([this.shapeId]);
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0);
    this.editor.setCursor({ type: "default", rotation: 0 });
  }
  onPointerMove() {
    const isDragging = this.editor.inputs.getIsDragging();
    if (!isDragging) return;
    if (this.didCtrlOnEnter) {
      this.parent.transition("brushing", this.info);
      return;
    }
    const shape = this.editor.getShape(this.shapeId);
    if (!shape) return;
    const options2 = this.editor.getShapeUtil("arrow").options;
    const geometry = getArrowBodyGeometry(this.editor, shape);
    const transform = this.editor.getShapePageTransform(shape.id);
    const pointInShapeSpace = this.editor.getPointInShapeSpace(shape, this.editor.inputs.getCurrentPagePoint()).add(this._labelDragOffset);
    const defaultLabelPosition = getArrowLabelDefaultPosition(this.editor, shape);
    let nextLabelPosition = geometry.uninterpolateAlongEdge(pointInShapeSpace);
    if (isNaN(nextLabelPosition)) {
      nextLabelPosition = defaultLabelPosition;
    }
    const nextLabelPoint = transform.applyToPoint(geometry.interpolateAlongEdge(nextLabelPosition));
    const labelDefaultPoint = transform.applyToPoint(
      geometry.interpolateAlongEdge(defaultLabelPosition)
    );
    if (Vec.DistMin(
      nextLabelPoint,
      labelDefaultPoint,
      options2.labelCenterSnapDistance / this.editor.getZoomLevel()
    )) {
      nextLabelPosition = defaultLabelPosition;
    }
    this.didDrag = true;
    this.editor.updateShape({
      id: shape.id,
      type: shape.type,
      props: { labelPosition: nextLabelPosition }
    });
  }
  onPointerUp() {
    const shape = this.editor.getShape(this.shapeId);
    if (!shape) return;
    if (this.didDrag || !this.wasAlreadySelected) {
      this.complete();
    } else if (this.editor.canEditShape(shape)) {
      startEditingShapeWithRichText(this.editor, shape.id);
    }
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  complete() {
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        this.editor.setCurrentTool(onInteractionEnd, {});
      } else {
        onInteractionEnd();
      }
      return;
    }
    this.parent.transition("idle");
  }
  cancel() {
    this.editor.bailToMark(this.markId);
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        this.editor.setCurrentTool(onInteractionEnd, {});
      } else {
        onInteractionEnd();
      }
      return;
    }
    this.parent.transition("idle");
  }
};
__publicField(PointingArrowLabel, "id", "pointing_arrow_label");

// ../node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/PointingCanvas.mjs
var PointingCanvas = class extends StateNode {
  onEnter(info) {
    const additiveSelectionKey = info.shiftKey || info.accelKey;
    if (!additiveSelectionKey) {
      if (this.editor.getSelectedShapeIds().length > 0) {
        this.editor.markHistoryStoppingPoint("selecting none");
        this.editor.selectNone();
      }
    }
  }
  onPointerMove(info) {
    if (this.editor.inputs.getIsDragging()) {
      this.parent.transition("brushing", info);
    }
  }
  onPointerUp(info) {
    selectOnCanvasPointerUp(this.editor, info);
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    this.parent.transition("idle");
  }
  complete() {
    this.parent.transition("idle");
  }
};
__publicField(PointingCanvas, "id", "pointing_canvas");

// ../node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/PointingHandle.mjs
var PointingHandle = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "didCtrlOnEnter", false);
    __publicField(this, "info", {});
  }
  onEnter(info) {
    this.info = info;
    this.didCtrlOnEnter = info.accelKey;
    const { shape } = info;
    if (this.editor.isShapeOfType(shape, "arrow")) {
      const initialBindings = getArrowBindings(this.editor, shape);
      const currentBinding = initialBindings[info.handle.id];
      const oppositeBinding = initialBindings[info.handle.id === "start" ? "end" : "start"];
      const arrowTransform = this.editor.getShapePageTransform(shape.id);
      if (currentBinding) {
        updateArrowTargetState({
          editor: this.editor,
          pointInPageSpace: arrowTransform.applyToPoint(info.handle),
          arrow: shape,
          isPrecise: currentBinding.props.isPrecise,
          currentBinding,
          oppositeBinding
        });
      }
    }
    this.editor.setCursor({ type: "grabbing", rotation: 0 });
  }
  onExit() {
    this.editor.setHintingShapes([]);
    this.editor.setCursor({ type: "default", rotation: 0 });
  }
  onPointerUp() {
    const { shape, handle } = this.info;
    if (this.editor.isShapeOfType(shape, "note")) {
      const { editor } = this;
      const nextNote = getNoteForAdjacentPosition(editor, shape, handle, false);
      if (nextNote) {
        startEditingShapeWithRichText(editor, nextNote, { selectAll: true });
        return;
      }
    }
    this.parent.transition("idle", this.info);
  }
  onPointerMove(info) {
    const { editor } = this;
    if (editor.inputs.getIsDragging()) {
      if (this.didCtrlOnEnter) {
        this.parent.transition("brushing", info);
      } else {
        this.startDraggingHandle();
      }
    }
  }
  onLongPress() {
    this.startDraggingHandle();
  }
  startDraggingHandle() {
    const { editor } = this;
    if (editor.getIsReadonly()) return;
    const { shape, handle } = this.info;
    if (editor.isShapeOfType(shape, "note")) {
      const nextNote = getNoteForAdjacentPosition(editor, shape, handle, true);
      if (nextNote) {
        const centeredOnPointer = editor.getPointInParentSpace(nextNote, editor.inputs.getOriginPagePoint()).sub(Vec.Rot(NOTE_CENTER_OFFSET.clone().mul(shape.props.scale), nextNote.rotation));
        editor.updateShape({ ...nextNote, x: centeredOnPointer.x, y: centeredOnPointer.y });
        editor.setHoveredShape(nextNote.id).select(nextNote.id).setCurrentTool("select.translating", {
          ...this.info,
          target: "shape",
          shape: editor.getShape(nextNote),
          onInteractionEnd: "note",
          isCreating: true,
          onCreate: () => {
            startEditingShapeWithRichText(editor, nextNote, { selectAll: true });
          }
        });
        return;
      }
    }
    this.parent.transition("dragging_handle", this.info);
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  cancel() {
    this.parent.transition("idle");
  }
};
__publicField(PointingHandle, "id", "pointing_handle");
function getNoteForAdjacentPosition(editor, shape, handle, forceNew) {
  const pageTransform = editor.getShapePageTransform(shape.id);
  const pagePoint = pageTransform.point();
  const pageRotation = pageTransform.rotation();
  const positions = getNoteAdjacentPositions(
    editor,
    pagePoint,
    pageRotation,
    shape.props.growY * shape.props.scale,
    0,
    shape.props.scale
  );
  const position = positions[handle.index];
  if (position) {
    return getNoteShapeForAdjacentPosition(editor, shape, position, pageRotation, forceNew);
  }
}

// ../node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/PointingRotateHandle.mjs
var PointingRotateHandle = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "info", {});
  }
  updateCursor() {
    this.editor.setCursor({
      type: CursorTypeMap[this.info.handle],
      rotation: this.editor.getSelectionRotation()
    });
  }
  onEnter(info) {
    this.info = info;
    if (typeof info.onInteractionEnd === "string") {
      this.parent.setCurrentToolIdMask(info.onInteractionEnd);
    }
    this.updateCursor();
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0);
    this.editor.setCursor({ type: "default", rotation: 0 });
  }
  onPointerMove() {
    if (this.editor.inputs.getIsDragging()) {
      this.startRotating();
    }
  }
  onLongPress() {
    this.startRotating();
  }
  startRotating() {
    if (this.editor.getIsReadonly()) return;
    this.parent.transition("rotating", this.info);
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  complete() {
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        this.editor.setCurrentTool(onInteractionEnd, {});
      } else {
        onInteractionEnd == null ? void 0 : onInteractionEnd();
      }
      return;
    }
    this.parent.transition("idle");
  }
  cancel() {
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        this.editor.setCurrentTool(onInteractionEnd, {});
      } else {
        onInteractionEnd();
      }
      return;
    }
    this.parent.transition("idle");
  }
};
__publicField(PointingRotateHandle, "id", "pointing_rotate_handle");

// ../node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/PointingSelection.mjs
var PointingSelection = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "info", {});
  }
  onEnter(info) {
    this.info = info;
  }
  onPointerUp(info) {
    selectOnCanvasPointerUp(this.editor, info);
    this.parent.transition("idle", info);
  }
  onPointerMove(info) {
    if (this.editor.inputs.getIsDragging()) {
      this.startTranslating(info);
    }
  }
  onLongPress(info) {
    this.startTranslating(info);
  }
  startTranslating(info) {
    if (this.editor.getIsReadonly()) return;
    this.parent.transition("translating", info);
  }
  onDoubleClick(info) {
    var _a6, _b3;
    const hoveredShape = this.editor.getHoveredShape();
    const hitShape = hoveredShape && !this.editor.isShapeOfType(hoveredShape, "group") ? hoveredShape : this.editor.getShapeAtPoint(this.editor.inputs.getCurrentPagePoint(), {
      hitInside: true,
      margin: 0,
      renderingOnly: true
    });
    if (hitShape) {
      this.parent.transition("idle");
      (_b3 = (_a6 = this.parent).onDoubleClick) == null ? void 0 : _b3.call(_a6, {
        ...info,
        target: "shape",
        shape: this.editor.getShape(hitShape)
      });
      return;
    }
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  cancel() {
    this.parent.transition("idle");
  }
};
__publicField(PointingSelection, "id", "pointing_selection");

// ../node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/PointingShape.mjs
var PointingShape = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "hitShape", {});
    __publicField(this, "hitShapeForPointerUp", {});
    __publicField(this, "isDoubleClick", false);
    __publicField(this, "didCtrlOnEnter", false);
    __publicField(this, "didSelectOnEnter", false);
  }
  onEnter(info) {
    const selectedShapeIds = this.editor.getSelectedShapeIds();
    const selectionBounds = this.editor.getSelectionRotatedPageBounds();
    const focusedGroupId = this.editor.getFocusedGroupId();
    const currentPagePoint = this.editor.inputs.getCurrentPagePoint();
    const { shiftKey, altKey: altKey2, accelKey } = info;
    this.hitShape = info.shape;
    this.isDoubleClick = false;
    this.didCtrlOnEnter = accelKey;
    const outermostSelectingShape = this.editor.getOutermostSelectableShape(info.shape);
    const selectedAncestor = this.editor.findShapeAncestor(
      outermostSelectingShape,
      (parent) => selectedShapeIds.includes(parent.id)
    );
    if (this.didCtrlOnEnter || // If the shape has an onClick handler
    this.editor.getShapeUtil(info.shape).onClick || // ...or if the shape is the focused layer (e.g. group)
    outermostSelectingShape.id === focusedGroupId || // ...or if the shape is within the selection
    selectedShapeIds.includes(outermostSelectingShape.id) || // ...or if an ancestor of the shape is selected
    selectedAncestor || // ...or if the current point is NOT within the selection bounds
    selectedShapeIds.length > 1 && (selectionBounds == null ? void 0 : selectionBounds.containsPoint(currentPagePoint))) {
      this.didSelectOnEnter = false;
      this.hitShapeForPointerUp = outermostSelectingShape;
      return;
    }
    this.didSelectOnEnter = true;
    if (shiftKey && !altKey2) {
      this.editor.cancelDoubleClick();
      if (!selectedShapeIds.includes(outermostSelectingShape.id)) {
        this.editor.markHistoryStoppingPoint("shift selecting shape");
        this.editor.setSelectedShapes([...selectedShapeIds, outermostSelectingShape.id]);
      }
    } else {
      this.editor.markHistoryStoppingPoint("selecting shape");
      this.editor.setSelectedShapes([outermostSelectingShape.id]);
    }
  }
  onPointerUp(info) {
    var _a6;
    const selectedShapeIds = this.editor.getSelectedShapeIds();
    const focusedGroupId = this.editor.getFocusedGroupId();
    const zoomLevel = this.editor.getZoomLevel();
    const currentPagePoint = this.editor.inputs.getCurrentPagePoint();
    const additiveSelectionKey = info.shiftKey || info.accelKey;
    const hitShape = this.editor.getShapeAtPoint(currentPagePoint, {
      margin: this.editor.options.hitTestMargin / zoomLevel,
      hitInside: true,
      renderingOnly: true
    }) ?? this.hitShape;
    const selectingShape = hitShape ? this.editor.getOutermostSelectableShape(hitShape) : this.hitShapeForPointerUp;
    if (selectingShape) {
      const util = this.editor.getShapeUtil(selectingShape);
      if (util.onClick) {
        const change = (_a6 = util.onClick) == null ? void 0 : _a6.call(util, selectingShape);
        if (change) {
          this.editor.markHistoryStoppingPoint("shape on click");
          this.editor.updateShapes([change]);
          this.parent.transition("idle", info);
          return;
        }
      }
      if (selectingShape.id === focusedGroupId) {
        if (selectedShapeIds.length > 0) {
          this.editor.markHistoryStoppingPoint("clearing shape ids");
          this.editor.setSelectedShapes([]);
        } else {
          this.editor.popFocusedGroupId();
        }
        this.parent.transition("idle", info);
        return;
      }
    }
    if (!this.didSelectOnEnter) {
      const outermostSelectableShape = this.editor.getOutermostSelectableShape(
        hitShape,
        // if a group is selected, we want to stop before reaching that group
        // so we can drill down into the group
        (parent) => !selectedShapeIds.includes(parent.id)
      );
      if (selectedShapeIds.includes(outermostSelectableShape.id)) {
        if (additiveSelectionKey) {
          this.editor.markHistoryStoppingPoint("deselecting on pointer up");
          this.editor.deselect(selectingShape);
        } else {
          if (selectedShapeIds.includes(selectingShape.id)) {
            if (selectedShapeIds.length === 1) {
              const geometry = this.editor.getShapeUtil(selectingShape).getGeometry(selectingShape);
              const textLabels = getTextLabels(geometry);
              const textLabel = textLabels.length === 1 ? textLabels[0] : void 0;
              if (textLabel) {
                const pointInShapeSpace = this.editor.getPointInShapeSpace(
                  selectingShape,
                  currentPagePoint
                );
                if (textLabel.bounds.containsPoint(pointInShapeSpace, 0) && textLabel.hitTestPoint(pointInShapeSpace)) {
                  this.editor.run(() => {
                    this.editor.markHistoryStoppingPoint("editing on pointer up");
                    this.editor.select(selectingShape.id);
                    if (!this.editor.canEditShape(selectingShape)) return;
                    this.editor.setEditingShape(selectingShape.id);
                    this.editor.setCurrentTool("select.editing_shape");
                    if (this.isDoubleClick) {
                      this.editor.emit("select-all-text", { shapeId: selectingShape.id });
                    } else {
                      this.editor.emit("place-caret", {
                        shapeId: selectingShape.id,
                        point: info.point
                      });
                    }
                  });
                  return;
                }
              }
            }
            this.editor.markHistoryStoppingPoint("selecting on pointer up");
            this.editor.select(selectingShape.id);
          } else {
            this.editor.markHistoryStoppingPoint("selecting on pointer up");
            this.editor.select(selectingShape);
          }
        }
      } else if (additiveSelectionKey) {
        const ancestors = this.editor.getShapeAncestors(outermostSelectableShape);
        this.editor.markHistoryStoppingPoint("shift deselecting on pointer up");
        this.editor.setSelectedShapes([
          ...this.editor.getSelectedShapeIds().filter((id) => !ancestors.find((a) => a.id === id)),
          outermostSelectableShape.id
        ]);
      } else {
        this.editor.markHistoryStoppingPoint("selecting on pointer up");
        this.editor.setSelectedShapes([outermostSelectableShape.id]);
      }
    }
    this.parent.transition("idle", info);
  }
  onDoubleClick() {
    this.isDoubleClick = true;
  }
  onPointerMove(info) {
    if (this.editor.inputs.getIsDragging()) {
      if (isOverArrowLabel(this.editor, this.hitShape)) {
        this.parent.transition("pointing_arrow_label", { ...info, shape: this.hitShape });
        return;
      }
      if (this.didCtrlOnEnter) {
        this.parent.transition("brushing", info);
      } else {
        this.startTranslating(info);
      }
    }
  }
  onLongPress(info) {
    this.startTranslating(info);
  }
  startTranslating(info) {
    if (this.editor.getIsReadonly()) return;
    this.editor.focus();
    this.parent.transition("translating", info);
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  cancel() {
    this.parent.transition("idle");
  }
};
__publicField(PointingShape, "id", "pointing_shape");

// ../node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/Resizing.mjs
var Resizing = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "info", {});
    __publicField(this, "markId", "");
    // A switch to detect when the user is holding ctrl
    __publicField(this, "didHoldCommand", false);
    // we transition into the resizing state from the geo pointing state, which starts with a shape of size w: 1, h: 1,
    // so if the user drags x: +50, y: +50 after mouseDown, the shape will be w: 51, h: 51, which is too many pixels, alas
    // so we allow passing a further offset into this state to negate such issues
    __publicField(this, "creationCursorOffset", { x: 0, y: 0 });
    __publicField(this, "snapshot", {});
  }
  onEnter(info) {
    const { isCreating = false, creatingMarkId, creationCursorOffset = { x: 0, y: 0 } } = info;
    this.info = info;
    this.didHoldCommand = false;
    if (typeof info.onInteractionEnd === "string") {
      this.parent.setCurrentToolIdMask(info.onInteractionEnd);
    }
    this.creationCursorOffset = creationCursorOffset;
    try {
      this.snapshot = this._createSnapshot();
    } catch (e) {
      console.error(e);
      this.cancel();
      return;
    }
    this.markId = "";
    if (isCreating) {
      if (creatingMarkId) {
        this.markId = creatingMarkId;
      } else {
        const markId = this.editor.getMarkIdMatching(
          `creating:${this.editor.getOnlySelectedShapeId()}`
        );
        if (markId) {
          this.markId = markId;
        }
      }
    } else {
      this.markId = this.editor.markHistoryStoppingPoint("starting resizing");
    }
    if (isCreating) {
      this.editor.setCursor({ type: "cross", rotation: 0 });
    }
    this.handleResizeStart();
    this.updateShapes();
  }
  onTick({ elapsed }) {
    const { editor } = this;
    editor.edgeScrollManager.updateEdgeScrolling(elapsed);
  }
  onPointerMove() {
    this.updateShapes();
  }
  onKeyDown() {
    this.updateShapes();
  }
  onKeyUp() {
    this.updateShapes();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  cancel() {
    const { shapeSnapshots } = this.snapshot;
    shapeSnapshots.forEach(({ shape }) => {
      var _a6;
      const current = this.editor.getShape(shape.id);
      if (current) {
        const util = this.editor.getShapeUtil(shape);
        (_a6 = util.onResizeCancel) == null ? void 0 : _a6.call(util, shape, current);
      }
    });
    this.editor.bailToMark(this.markId);
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        this.editor.setCurrentTool(onInteractionEnd, {});
      } else {
        onInteractionEnd();
      }
      return;
    }
    this.parent.transition("idle");
  }
  complete() {
    var _a6, _b3;
    kickoutOccludedShapes(this.editor, this.snapshot.selectedShapeIds);
    this.handleResizeEnd();
    if (this.info.isCreating && this.info.onCreate) {
      (_b3 = (_a6 = this.info).onCreate) == null ? void 0 : _b3.call(_a6, this.editor.getOnlySelectedShape());
      return;
    }
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        if (this.editor.getInstanceState().isToolLocked) {
          this.editor.setCurrentTool(onInteractionEnd, {});
          return;
        }
      } else {
        onInteractionEnd();
        return;
      }
    }
    this.parent.transition("idle");
  }
  handleResizeStart() {
    const { shapeSnapshots } = this.snapshot;
    const changes = [];
    shapeSnapshots.forEach(({ shape }) => {
      var _a6;
      const util = this.editor.getShapeUtil(shape);
      const change = (_a6 = util.onResizeStart) == null ? void 0 : _a6.call(util, shape);
      if (change) {
        changes.push(change);
      }
    });
    if (changes.length > 0) {
      this.editor.updateShapes(changes);
    }
  }
  handleResizeEnd() {
    const { shapeSnapshots } = this.snapshot;
    const changes = [];
    shapeSnapshots.forEach(({ shape }) => {
      var _a6;
      const current = this.editor.getShape(shape.id);
      const util = this.editor.getShapeUtil(shape);
      const change = (_a6 = util.onResizeEnd) == null ? void 0 : _a6.call(util, shape, current);
      if (change) {
        changes.push(change);
      }
    });
    if (changes.length > 0) {
      this.editor.updateShapes(changes);
    }
  }
  updateShapes() {
    const altKey2 = this.editor.inputs.getAltKey();
    const shiftKey = this.editor.inputs.getShiftKey();
    const {
      frames,
      shapeSnapshots,
      selectionBounds,
      cursorHandleOffset,
      selectedShapeIds,
      selectionRotation,
      canShapesDeform
    } = this.snapshot;
    let isAspectRatioLocked = shiftKey || !canShapesDeform;
    if (shapeSnapshots.size === 1) {
      const onlySnapshot = [...shapeSnapshots.values()][0];
      if (this.editor.isShapeOfType(onlySnapshot.shape, "text")) {
        isAspectRatioLocked = !(this.info.handle === "left" || this.info.handle === "right");
      }
    }
    const isHoldingAccel = isAccelKey(this.editor.inputs);
    const currentPagePoint = this.editor.inputs.getCurrentPagePoint().clone().sub(cursorHandleOffset).sub(this.creationCursorOffset);
    const originPagePoint = this.editor.inputs.getOriginPagePoint().clone().sub(cursorHandleOffset);
    if (this.editor.getInstanceState().isGridMode && !isHoldingAccel) {
      const { gridSize } = this.editor.getDocumentSettings();
      currentPagePoint.snapToGrid(gridSize);
    }
    const dragHandle = this.info.handle;
    const scaleOriginHandle = rotateSelectionHandle2(dragHandle, Math.PI);
    this.editor.snaps.clearIndicators();
    const shouldSnap = this.editor.user.getIsSnapMode() ? !isHoldingAccel : isHoldingAccel;
    if (shouldSnap && selectionRotation % HALF_PI === 0) {
      const { nudge } = this.editor.snaps.shapeBounds.snapResizeShapes({
        dragDelta: Vec.Sub(currentPagePoint, originPagePoint),
        initialSelectionPageBounds: this.snapshot.initialSelectionPageBounds,
        handle: rotateSelectionHandle2(dragHandle, selectionRotation),
        isAspectRatioLocked,
        isResizingFromCenter: altKey2
      });
      currentPagePoint.add(nudge);
    }
    const scaleOriginPage = Vec.RotWith(
      altKey2 ? selectionBounds.center : selectionBounds.getHandlePoint(scaleOriginHandle),
      selectionBounds.point,
      selectionRotation
    );
    const distanceFromScaleOriginNow = Vec.Sub(currentPagePoint, scaleOriginPage).rot(
      -selectionRotation
    );
    const distanceFromScaleOriginAtStart = Vec.Sub(originPagePoint, scaleOriginPage).rot(
      -selectionRotation
    );
    const scale = Vec.DivV(distanceFromScaleOriginNow, distanceFromScaleOriginAtStart);
    if (!Number.isFinite(scale.x)) scale.x = 1;
    if (!Number.isFinite(scale.y)) scale.y = 1;
    const isXLocked = dragHandle === "top" || dragHandle === "bottom";
    const isYLocked = dragHandle === "left" || dragHandle === "right";
    if (isAspectRatioLocked) {
      if (isYLocked) {
        scale.y = Math.abs(scale.x);
      } else if (isXLocked) {
        scale.x = Math.abs(scale.y);
      } else if (Math.abs(scale.x) > Math.abs(scale.y)) {
        scale.y = Math.abs(scale.x) * (scale.y < 0 ? -1 : 1);
      } else {
        scale.x = Math.abs(scale.y) * (scale.x < 0 ? -1 : 1);
      }
    } else {
      if (isXLocked) {
        scale.x = 1;
      }
      if (isYLocked) {
        scale.y = 1;
      }
    }
    if (!this.info.isCreating) {
      this.updateCursor({
        dragHandle,
        isFlippedX: scale.x < 0,
        isFlippedY: scale.y < 0,
        rotation: selectionRotation
      });
    }
    for (const id of shapeSnapshots.keys()) {
      const snapshot = shapeSnapshots.get(id);
      this.editor.resizeShape(id, scale, {
        initialShape: snapshot.shape,
        initialBounds: snapshot.bounds,
        initialPageTransform: snapshot.pageTransform,
        dragHandle,
        mode: selectedShapeIds.length === 1 && id === selectedShapeIds[0] ? "resize_bounds" : "scale_shape",
        scaleOrigin: scaleOriginPage,
        isAspectRatioLocked,
        scaleAxisRotation: selectionRotation,
        skipStartAndEndCallbacks: true
      });
    }
    if (isHoldingAccel) {
      this.didHoldCommand = true;
      for (const { id, children } of frames) {
        if (!children.length) continue;
        const initial = shapeSnapshots.get(id).shape;
        const current = this.editor.getShape(id);
        if (!(initial && current)) continue;
        const dx = current.x - initial.x;
        const dy = current.y - initial.y;
        const delta = new Vec(dx, dy).rot(-initial.rotation);
        if (delta.x !== 0 || delta.y !== 0) {
          for (const child of children) {
            this.editor.updateShape({
              id: child.id,
              type: child.type,
              x: child.x - delta.x,
              y: child.y - delta.y
            });
          }
        }
      }
    } else if (this.didHoldCommand) {
      this.didHoldCommand = false;
      for (const { children } of frames) {
        if (!children.length) continue;
        for (const child of children) {
          this.editor.updateShape({
            id: child.id,
            type: child.type,
            x: child.x,
            y: child.y
          });
        }
      }
    }
  }
  // ---
  updateCursor({
    dragHandle,
    isFlippedX,
    isFlippedY,
    rotation
  }) {
    const nextCursor = { ...this.editor.getInstanceState().cursor };
    switch (dragHandle) {
      case "top_left":
      case "bottom_right": {
        nextCursor.type = "nwse-resize";
        if (isFlippedX !== isFlippedY) {
          nextCursor.type = "nesw-resize";
        }
        break;
      }
      case "top_right":
      case "bottom_left": {
        nextCursor.type = "nesw-resize";
        if (isFlippedX !== isFlippedY) {
          nextCursor.type = "nwse-resize";
        }
        break;
      }
    }
    nextCursor.rotation = rotation;
    this.editor.setCursor(nextCursor);
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0);
    this.editor.setCursor({ type: "default", rotation: 0 });
    this.editor.snaps.clearIndicators();
  }
  _createSnapshot() {
    const { editor } = this;
    const selectedShapeIds = editor.getSelectedShapeIds();
    const selectionRotation = editor.getSelectionRotation();
    const originPagePoint = editor.inputs.getOriginPagePoint();
    const selectionBounds = editor.getSelectionRotatedPageBounds();
    if (!selectionBounds) throw Error("Resizing but nothing is selected");
    const dragHandlePoint = Vec.RotWith(
      selectionBounds.getHandlePoint(this.info.handle),
      selectionBounds.point,
      selectionRotation
    );
    const cursorHandleOffset = Vec.Sub(originPagePoint, dragHandlePoint);
    const shapeSnapshots = /* @__PURE__ */ new Map();
    const frames = [];
    const populateResizingShapes = (shapeId) => {
      const shape = editor.getShape(shapeId);
      if (!shape) return false;
      const util = editor.getShapeUtil(shape);
      if (util.canResize(shape)) {
        const pageTransform = editor.getShapePageTransform(shape);
        shapeSnapshots.set(shape.id, {
          shape,
          bounds: editor.getShapeGeometry(shape).bounds,
          pageTransform,
          pageRotation: Mat.Decompose(pageTransform).rotation,
          isAspectRatioLocked: util.isAspectRatioLocked(shape)
        });
      }
      if (editor.isShapeOfType(shape, "frame")) {
        frames.push({
          id: shape.id,
          children: compact(
            editor.getSortedChildIdsForParent(shape).map((id) => editor.getShape(id))
          )
        });
      }
      if (!util.canResizeChildren(shape)) return false;
    };
    selectedShapeIds.forEach((shapeId) => {
      const keepDescending = populateResizingShapes(shapeId);
      if (keepDescending === false) return;
      editor.visitDescendants(shapeId, populateResizingShapes);
    });
    const canShapesDeform = ![...shapeSnapshots.values()].some(
      (shape) => !areAnglesCompatible(shape.pageRotation, selectionRotation) || shape.isAspectRatioLocked
    );
    return {
      shapeSnapshots,
      selectionBounds,
      cursorHandleOffset,
      selectionRotation,
      selectedShapeIds,
      canShapesDeform,
      initialSelectionPageBounds: this.editor.getSelectionPageBounds(),
      frames
    };
  }
};
__publicField(Resizing, "id", "resizing");
var ORDERED_SELECTION_HANDLES2 = [
  "top",
  "top_right",
  "right",
  "bottom_right",
  "bottom",
  "bottom_left",
  "left",
  "top_left"
];
function rotateSelectionHandle2(handle, rotation) {
  rotation = rotation % PI2;
  const numSteps = Math.round(rotation / (PI / 4));
  const currentIndex = ORDERED_SELECTION_HANDLES2.indexOf(handle);
  return ORDERED_SELECTION_HANDLES2[(currentIndex + numSteps) % ORDERED_SELECTION_HANDLES2.length];
}

// ../node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/Rotating.mjs
var ONE_DEGREE = Math.PI / 180;
var Rotating = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "snapshot", {});
    __publicField(this, "info", {});
    __publicField(this, "markId", "");
  }
  onEnter(info) {
    this.info = info;
    if (typeof info.onInteractionEnd === "string") {
      this.parent.setCurrentToolIdMask(info.onInteractionEnd);
    }
    this.markId = this.editor.markHistoryStoppingPoint("rotate start");
    const snapshot = getRotationSnapshot({
      editor: this.editor,
      ids: this.editor.getSelectedShapeIds()
    });
    if (!snapshot) return this.parent.transition("idle", this.info);
    this.snapshot = snapshot;
    const newSelectionRotation = this._getRotationFromPointerPosition({
      snapToNearestDegree: false
    });
    applyRotationToSnapshotShapes({
      editor: this.editor,
      delta: this._getRotationFromPointerPosition({ snapToNearestDegree: false }),
      snapshot: this.snapshot,
      stage: "start"
    });
    this.editor.setCursor({
      type: CursorTypeMap[this.info.handle],
      rotation: newSelectionRotation + this.snapshot.initialShapesRotation
    });
  }
  onExit() {
    this.editor.setCursor({ type: "default", rotation: 0 });
    this.parent.setCurrentToolIdMask(void 0);
    this.snapshot = {};
  }
  onPointerMove() {
    this.update();
  }
  onKeyDown() {
    this.update();
  }
  onKeyUp() {
    this.update();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  // ---
  update() {
    const newSelectionRotation = this._getRotationFromPointerPosition({
      snapToNearestDegree: false
    });
    applyRotationToSnapshotShapes({
      editor: this.editor,
      delta: newSelectionRotation,
      snapshot: this.snapshot,
      stage: "update"
    });
    this.editor.setCursor({
      type: CursorTypeMap[this.info.handle],
      rotation: newSelectionRotation + this.snapshot.initialShapesRotation
    });
  }
  cancel() {
    const { shapeSnapshots } = this.snapshot;
    shapeSnapshots.forEach(({ shape }) => {
      var _a6;
      const current = this.editor.getShape(shape.id);
      if (current) {
        const util = this.editor.getShapeUtil(shape);
        (_a6 = util.onRotateCancel) == null ? void 0 : _a6.call(util, shape, current);
      }
    });
    this.editor.bailToMark(this.markId);
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        this.editor.setCurrentTool(onInteractionEnd, this.info);
      } else {
        onInteractionEnd();
      }
      return;
    }
    this.parent.transition("idle", this.info);
  }
  complete() {
    applyRotationToSnapshotShapes({
      editor: this.editor,
      delta: this._getRotationFromPointerPosition({ snapToNearestDegree: true }),
      snapshot: this.snapshot,
      stage: "end"
    });
    kickoutOccludedShapes(
      this.editor,
      this.snapshot.shapeSnapshots.map((s) => s.shape.id)
    );
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        this.editor.setCurrentTool(onInteractionEnd, this.info);
      } else {
        onInteractionEnd();
      }
      return;
    }
    this.parent.transition("idle", this.info);
  }
  _getRotationFromPointerPosition({ snapToNearestDegree }) {
    const shiftKey = this.editor.inputs.getShiftKey();
    const currentPagePoint = this.editor.inputs.getCurrentPagePoint();
    const { initialCursorAngle, initialShapesRotation, initialPageCenter } = this.snapshot;
    const preSnapRotationDelta = initialPageCenter.angle(currentPagePoint) - initialCursorAngle;
    let newSelectionRotation = initialShapesRotation + preSnapRotationDelta;
    if (shiftKey) {
      newSelectionRotation = snapAngle(newSelectionRotation, 24);
    } else if (snapToNearestDegree) {
      newSelectionRotation = Math.round(newSelectionRotation / ONE_DEGREE) * ONE_DEGREE;
      if (this.editor.getInstanceState().isCoarsePointer) {
        const snappedToRightAngle = snapAngle(newSelectionRotation, 4);
        const angleToRightAngle = shortAngleDist(newSelectionRotation, snappedToRightAngle);
        if (Math.abs(angleToRightAngle) < degreesToRadians(5)) {
          newSelectionRotation = snappedToRightAngle;
        }
      }
    }
    return newSelectionRotation - initialShapesRotation;
  }
};
__publicField(Rotating, "id", "rotating");

// ../node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/ScribbleBrushing.mjs
var ScribbleBrushing = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "hits", /* @__PURE__ */ new Set());
    __publicField(this, "size", 0);
    __publicField(this, "scribbleId", "id");
    __publicField(this, "initialSelectedShapeIds", /* @__PURE__ */ new Set());
    __publicField(this, "newlySelectedShapeIds", /* @__PURE__ */ new Set());
  }
  onEnter() {
    this.initialSelectedShapeIds = new Set(
      this.editor.inputs.getShiftKey() ? this.editor.getSelectedShapeIds() : []
    );
    this.newlySelectedShapeIds = /* @__PURE__ */ new Set();
    this.size = 0;
    this.hits.clear();
    const scribbleItem = this.editor.scribbles.addScribble({
      color: "selection-stroke",
      opacity: 0.32,
      size: 12
    });
    this.scribbleId = scribbleItem.id;
    this.updateScribbleSelection(true);
    this.editor.updateInstanceState({ brush: null });
  }
  onExit() {
    this.editor.scribbles.stop(this.scribbleId);
  }
  onPointerMove() {
    this.updateScribbleSelection(true);
  }
  onPointerUp() {
    this.complete();
  }
  onKeyDown() {
    this.updateScribbleSelection(false);
  }
  onKeyUp() {
    if (!this.editor.inputs.getAltKey()) {
      this.parent.transition("brushing");
    } else {
      this.updateScribbleSelection(false);
    }
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  pushPointToScribble() {
    const { x, y } = this.editor.inputs.getCurrentPagePoint();
    this.editor.scribbles.addPoint(this.scribbleId, x, y);
  }
  updateScribbleSelection(addPoint) {
    const { editor } = this;
    const currentPageShapes = this.editor.getCurrentPageRenderingShapesSorted();
    const shiftKey = this.editor.inputs.getShiftKey();
    const originPagePoint = this.editor.inputs.getOriginPagePoint();
    const previousPagePoint = this.editor.inputs.getPreviousPagePoint();
    const currentPagePoint = this.editor.inputs.getCurrentPagePoint();
    const { newlySelectedShapeIds, initialSelectedShapeIds } = this;
    if (addPoint) {
      this.pushPointToScribble();
    }
    const shapes = currentPageShapes;
    let shape, geometry, A, B;
    const minDist = 0;
    for (let i = 0, n = shapes.length; i < n; i++) {
      shape = shapes[i];
      if (editor.isShapeOfType(shape, "group") || newlySelectedShapeIds.has(shape.id) || editor.isShapeOrAncestorLocked(shape)) {
        continue;
      }
      geometry = editor.getShapeGeometry(shape);
      if (editor.isShapeOfType(shape, "frame") && geometry.bounds.containsPoint(editor.getPointInShapeSpace(shape, originPagePoint))) {
        continue;
      }
      const pageTransform = editor.getShapePageTransform(shape);
      if (!geometry || !pageTransform) continue;
      const pt = pageTransform.clone().invert();
      A = pt.applyToPoint(previousPagePoint);
      B = pt.applyToPoint(currentPagePoint);
      const { bounds } = geometry;
      if (bounds.minX - minDist > Math.max(A.x, B.x) || bounds.minY - minDist > Math.max(A.y, B.y) || bounds.maxX + minDist < Math.min(A.x, B.x) || bounds.maxY + minDist < Math.min(A.y, B.y)) {
        continue;
      }
      if (geometry.hitTestLineSegment(A, B, minDist)) {
        const outermostShape = this.editor.getOutermostSelectableShape(shape);
        const pageMask = this.editor.getShapeMask(outermostShape.id);
        if (pageMask) {
          const intersection = intersectLineSegmentPolygon(
            previousPagePoint,
            currentPagePoint,
            pageMask
          );
          if (intersection !== null) {
            const isInMask = pointInPolygon(currentPagePoint, pageMask);
            if (!isInMask) continue;
          }
        }
        newlySelectedShapeIds.add(outermostShape.id);
      }
    }
    const current = editor.getSelectedShapeIds();
    const next = new Set(
      shiftKey ? [...newlySelectedShapeIds, ...initialSelectedShapeIds] : [...newlySelectedShapeIds]
    );
    if (current.length !== next.size || current.some((id) => !next.has(id))) {
      this.editor.setSelectedShapes(Array.from(next));
    }
  }
  complete() {
    this.updateScribbleSelection(true);
    this.parent.transition("idle");
  }
  cancel() {
    this.editor.setSelectedShapes([...this.initialSelectedShapeIds]);
    this.parent.transition("idle");
  }
};
__publicField(ScribbleBrushing, "id", "scribble_brushing");

// ../node_modules/tldraw/dist-esm/lib/tools/SelectTool/DragAndDropManager.mjs
var __create12 = Object.create;
var __defProp14 = Object.defineProperty;
var __getOwnPropDesc12 = Object.getOwnPropertyDescriptor;
var __knownSymbol12 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError12 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp12 = (obj, key, value) => key in obj ? __defProp14(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name12 = (target, value) => __defProp14(target, "name", { value, configurable: true });
var __decoratorStart12 = (base2) => [, , , __create12((base2 == null ? void 0 : base2[__knownSymbol12("metadata")]) ?? null)];
var __decoratorStrings12 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn12 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError12("Function expected") : fn;
var __decoratorContext12 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings12[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError12("Already initialized") : fns.push(__expectFn12(fn || null)) });
var __decoratorMetadata12 = (array, target) => __defNormalProp12(target, __knownSymbol12("metadata"), array[3]);
var __runInitializers12 = (array, flags, self2, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self2) : value = fns[i].call(self2, value);
  return value;
};
var __decorateElement12 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings12[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc12(k < 4 ? target : { get [name]() {
    return __privateGet13(this, extra);
  }, set [name](x) {
    return __privateSet13(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name12(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name12(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext12(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn12(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet13 : __privateMethod12)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet13(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn12(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError12("Object expected");
    else __expectFn12(fn = it.get) && (desc.get = fn), __expectFn12(fn = it.set) && (desc.set = fn), __expectFn12(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata12(array, target), desc && __defProp14(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __publicField13 = (obj, key, value) => __defNormalProp12(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck12 = (obj, member, msg2) => member.has(obj) || __typeError12("Cannot " + msg2);
var __privateIn12 = (member, obj) => Object(obj) !== obj ? __typeError12('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet13 = (obj, member, getter) => (__accessCheck12(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet13 = (obj, member, value, setter) => (__accessCheck12(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod12 = (obj, member, method) => (__accessCheck12(obj, member, "access private method"), method);
var _dispose_dec2;
var _init12;
var SLOW_POINTER_LAG_DURATION = 320;
var FAST_POINTER_LAG_DURATION = 60;
_dispose_dec2 = [bind];
var DragAndDropManager = class {
  constructor(editor) {
    this.editor = editor;
    __runInitializers12(_init12, 5, this);
    __publicField13(this, "shapesToActuallyMove", []);
    __publicField13(this, "draggedOverShapeIds", /* @__PURE__ */ new Set());
    __publicField13(this, "initialGroupIds", /* @__PURE__ */ new Map());
    __publicField13(this, "initialParentIds", /* @__PURE__ */ new Map());
    __publicField13(this, "initialIndices", /* @__PURE__ */ new Map());
    __publicField13(this, "initialDraggingOverShape");
    __publicField13(this, "prevDraggingOverShape");
    __publicField13(this, "prevPagePoint", new Vec());
    __publicField13(this, "intervalTimerId", -1);
    editor.disposables.add(this.dispose);
  }
  startDraggingShapes(movingShapes, point, cb) {
    const { editor } = this;
    if (this.intervalTimerId !== -1) return;
    const shapesToActuallyMove = new Set(movingShapes);
    const movingGroups = /* @__PURE__ */ new Set();
    for (const shape of shapesToActuallyMove) {
      const parent = editor.getShapeParent(shape);
      if (parent && editor.isShapeOfType(parent, "group")) {
        if (!movingGroups.has(parent)) {
          movingGroups.add(parent);
        }
      }
    }
    for (const movingGroup of movingGroups) {
      const children = compact(
        editor.getSortedChildIdsForParent(movingGroup).map((id) => editor.getShape(id))
      );
      shapesToActuallyMove.add(movingGroup);
      for (const child of children) {
        shapesToActuallyMove.delete(child);
      }
    }
    this.initialParentIds.clear();
    for (const shape of shapesToActuallyMove) {
      const parent = editor.getShapeParent(shape);
      if (parent) {
        this.initialParentIds.set(shape.id, parent.id);
      }
      this.initialIndices.set(shape.id, shape.index);
      const group = editor.findShapeAncestor(shape, (s) => editor.isShapeOfType(s, "group"));
      if (group) {
        this.initialGroupIds.set(shape.id, group.id);
      }
    }
    const allShapes = editor.getCurrentPageShapesSorted();
    this.shapesToActuallyMove = Array.from(shapesToActuallyMove).filter((s) => !s.isLocked).sort((a, b) => allShapes.indexOf(a) - allShapes.indexOf(b));
    this.initialDraggingOverShape = editor.getDraggingOverShape(point, this.shapesToActuallyMove);
    this.prevDraggingOverShape = this.initialDraggingOverShape;
    this.updateDraggingShapes(point, cb);
    let skip2of3FramesWhileMovingFast = 0;
    this.intervalTimerId = this.editor.timers.setInterval(
      () => {
        skip2of3FramesWhileMovingFast++;
        if (skip2of3FramesWhileMovingFast % 3 && this.editor.inputs.getPointerVelocity().len() > 0.5) {
          return;
        }
        this.updateDraggingShapes(editor.inputs.getCurrentPagePoint(), cb);
      },
      movingShapes.length > 10 ? SLOW_POINTER_LAG_DURATION : FAST_POINTER_LAG_DURATION
    );
  }
  dropShapes(shapes) {
    var _a6, _b3;
    const { editor } = this;
    const currentPagePoint = editor.inputs.getCurrentPagePoint();
    this.updateDraggingShapes(currentPagePoint);
    const draggingOverShape = editor.getDraggingOverShape(currentPagePoint, shapes);
    if (draggingOverShape) {
      const util = editor.getShapeUtil(draggingOverShape);
      (_b3 = util.onDropShapesOver) == null ? void 0 : _b3.call(util, draggingOverShape, shapes, {
        initialDraggingOverShapeId: ((_a6 = this.initialDraggingOverShape) == null ? void 0 : _a6.id) ?? null,
        initialParentIds: this.initialParentIds,
        initialIndices: this.initialIndices
      });
    }
    this.dispose();
  }
  clear() {
    clearInterval(this.intervalTimerId);
    this.intervalTimerId = -1;
    this.initialParentIds.clear();
    this.initialIndices.clear();
    this.shapesToActuallyMove = [];
    this.initialDraggingOverShape = void 0;
    this.prevDraggingOverShape = void 0;
    this.editor.setHintingShapes([]);
  }
  dispose() {
    this.clear();
  }
  updateDraggingShapes(point, cb) {
    const { editor } = this;
    const draggingShapes = compact(this.shapesToActuallyMove.map((s) => editor.getShape(s)));
    if (!draggingShapes.length) return;
    const nextDraggingOverShape = editor.getDraggingOverShape(point, this.shapesToActuallyMove);
    const currentPagePoint = editor.inputs.getCurrentPagePoint();
    const cursorDidMove = !this.prevPagePoint.equals(currentPagePoint);
    this.prevPagePoint.setTo(currentPagePoint);
    editor.run(() => {
      var _a6, _b3, _c, _d, _e, _f, _g, _h;
      if (((_a6 = this.prevDraggingOverShape) == null ? void 0 : _a6.id) === (nextDraggingOverShape == null ? void 0 : nextDraggingOverShape.id)) {
        if (cursorDidMove && nextDraggingOverShape && isShapeId(nextDraggingOverShape.id) && !editor.inputs.getPreviousPagePoint().equals(currentPagePoint)) {
          const util = editor.getShapeUtil(nextDraggingOverShape);
          (_c = util.onDragShapesOver) == null ? void 0 : _c.call(util, nextDraggingOverShape, draggingShapes, {
            initialDraggingOverShapeId: ((_b3 = this.initialDraggingOverShape) == null ? void 0 : _b3.id) ?? null,
            initialParentIds: this.initialParentIds,
            initialIndices: this.initialIndices
          });
        }
        return;
      }
      if (this.prevDraggingOverShape) {
        const util = editor.getShapeUtil(this.prevDraggingOverShape);
        (_e = util.onDragShapesOut) == null ? void 0 : _e.call(util, this.editor.getShape(this.prevDraggingOverShape), draggingShapes, {
          nextDraggingOverShapeId: (nextDraggingOverShape == null ? void 0 : nextDraggingOverShape.id) ?? null,
          initialDraggingOverShapeId: ((_d = this.initialDraggingOverShape) == null ? void 0 : _d.id) ?? null,
          initialParentIds: this.initialParentIds,
          initialIndices: this.initialIndices
        });
      }
      if (nextDraggingOverShape) {
        const util = editor.getShapeUtil(nextDraggingOverShape);
        (_h = util.onDragShapesIn) == null ? void 0 : _h.call(util, nextDraggingOverShape, draggingShapes, {
          initialDraggingOverShapeId: ((_f = this.initialDraggingOverShape) == null ? void 0 : _f.id) ?? null,
          prevDraggingOverShapeId: ((_g = this.prevDraggingOverShape) == null ? void 0 : _g.id) ?? null,
          initialParentIds: this.initialParentIds,
          initialIndices: this.initialIndices
        });
        editor.setHintingShapes([nextDraggingOverShape.id]);
      } else if (this.prevDraggingOverShape) {
        editor.setHintingShapes([]);
      }
      cb == null ? void 0 : cb();
    });
    this.prevDraggingOverShape = nextDraggingOverShape;
  }
};
_init12 = __decoratorStart12(null);
__decorateElement12(_init12, 1, "dispose", _dispose_dec2, DragAndDropManager);
__decoratorMetadata12(_init12, DragAndDropManager);

// ../node_modules/tldraw/dist-esm/lib/tools/SelectTool/childStates/Translating.mjs
var __create13 = Object.create;
var __defProp15 = Object.defineProperty;
var __getOwnPropDesc13 = Object.getOwnPropertyDescriptor;
var __knownSymbol13 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError13 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp13 = (obj, key, value) => key in obj ? __defProp15(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name13 = (target, value) => __defProp15(target, "name", { value, configurable: true });
var __decoratorStart13 = (base2) => [, , , __create13((base2 == null ? void 0 : base2[__knownSymbol13("metadata")]) ?? null)];
var __decoratorStrings13 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn13 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError13("Function expected") : fn;
var __decoratorContext13 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings13[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError13("Already initialized") : fns.push(__expectFn13(fn || null)) });
var __decoratorMetadata13 = (array, target) => __defNormalProp13(target, __knownSymbol13("metadata"), array[3]);
var __runInitializers13 = (array, flags, self2, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self2) : value = fns[i].call(self2, value);
  return value;
};
var __decorateElement13 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings13[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc13(k < 4 ? target : { get [name]() {
    return __privateGet14(this, extra);
  }, set [name](x) {
    return __privateSet14(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name13(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name13(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext13(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn13(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet14 : __privateMethod13)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet14(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn13(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError13("Object expected");
    else __expectFn13(fn = it.get) && (desc.get = fn), __expectFn13(fn = it.set) && (desc.set = fn), __expectFn13(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata13(array, target), desc && __defProp15(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __publicField14 = (obj, key, value) => __defNormalProp13(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck13 = (obj, member, msg2) => member.has(obj) || __typeError13("Cannot " + msg2);
var __privateIn13 = (member, obj) => Object(obj) !== obj ? __typeError13('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet14 = (obj, member, getter) => (__accessCheck13(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet14 = (obj, member, value, setter) => (__accessCheck13(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod13 = (obj, member, method) => (__accessCheck13(obj, member, "access private method"), method);
var _updateParentTransforms_dec;
var _a5;
var _init13;
var Translating = class extends (_a5 = StateNode, _updateParentTransforms_dec = [bind], _a5) {
  constructor() {
    super(...arguments);
    __runInitializers13(_init13, 5, this);
    __publicField14(this, "info", {});
    __publicField14(this, "selectionSnapshot", {});
    __publicField14(this, "snapshot", {});
    __publicField14(this, "markId", "");
    __publicField14(this, "isCloning", false);
    __publicField14(this, "isCreating", false);
    __publicField14(this, "dragAndDropManager", new DragAndDropManager(this.editor));
  }
  onCreate(_shape) {
    return;
  }
  onEnter(info) {
    var _a6;
    const { isCreating = false, creatingMarkId, onCreate = () => void 0 } = info;
    if (!((_a6 = this.editor.getSelectedShapeIds()) == null ? void 0 : _a6.length)) {
      this.parent.transition("idle");
      return;
    }
    this.info = info;
    if (typeof info.onInteractionEnd === "string") {
      this.parent.setCurrentToolIdMask(info.onInteractionEnd);
    }
    this.isCreating = isCreating;
    this.markId = "";
    if (isCreating) {
      if (creatingMarkId) {
        this.markId = creatingMarkId;
      } else {
        const markId = this.editor.getMarkIdMatching(
          `creating:${this.editor.getOnlySelectedShapeId()}`
        );
        if (markId) {
          this.markId = markId;
        }
      }
    } else {
      this.markId = this.editor.markHistoryStoppingPoint("translating");
    }
    this.onCreate = onCreate;
    this.isCloning = false;
    this.info = info;
    this.editor.setCursor({ type: "move", rotation: 0 });
    this.selectionSnapshot = getTranslatingSnapshot(this.editor);
    if (!this.isCreating) {
      if (this.editor.inputs.getAltKey()) {
        this.startCloning();
        if (this.isCloning) return;
      }
    }
    this.snapshot = this.selectionSnapshot;
    this.handleStart();
    this.updateShapes();
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0);
    this.selectionSnapshot = {};
    this.snapshot = {};
    this.editor.snaps.clearIndicators();
    this.editor.setCursor({ type: "default", rotation: 0 });
    this.dragAndDropManager.clear();
  }
  onTick({ elapsed }) {
    const { editor } = this;
    editor.edgeScrollManager.updateEdgeScrolling(elapsed);
  }
  onPointerMove() {
    this.updateShapes();
  }
  onKeyDown() {
    if (this.editor.inputs.getAltKey() && !this.isCloning) {
      this.startCloning();
      if (this.isCloning) return;
    }
    this.updateShapes();
  }
  onKeyUp() {
    if (!this.editor.inputs.getAltKey() && this.isCloning) {
      this.stopCloning();
      return;
    }
    this.updateShapes();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  startCloning() {
    if (this.isCreating) return;
    const shapeIds = Array.from(this.editor.getSelectedShapeIds());
    if (!this.editor.canCreateShapes(shapeIds)) return;
    this.isCloning = true;
    this.reset();
    this.markId = this.editor.markHistoryStoppingPoint("translate cloning");
    this.editor.duplicateShapes(Array.from(this.editor.getSelectedShapeIds()));
    this.snapshot = getTranslatingSnapshot(this.editor);
    this.handleStart();
    this.updateShapes();
  }
  stopCloning() {
    this.isCloning = false;
    this.snapshot = this.selectionSnapshot;
    this.reset();
    this.markId = this.editor.markHistoryStoppingPoint("translate");
    this.updateShapes();
  }
  reset() {
    this.editor.bailToMark(this.markId);
  }
  complete() {
    var _a6;
    this.updateShapes();
    this.dragAndDropManager.dropShapes(this.snapshot.movingShapes);
    this.handleEnd();
    kickoutOccludedShapes(
      this.editor,
      this.snapshot.movingShapes.map((s) => s.id)
    );
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        if (this.editor.getInstanceState().isToolLocked) {
          this.editor.setCurrentTool(onInteractionEnd);
          return;
        }
      } else {
        onInteractionEnd();
        return;
      }
    }
    if (this.isCreating) {
      (_a6 = this.onCreate) == null ? void 0 : _a6.call(this, this.editor.getOnlySelectedShape());
    } else {
      this.parent.transition("idle");
    }
  }
  cancel() {
    const { movingShapes } = this.snapshot;
    movingShapes.forEach((shape) => {
      var _a6;
      const current = this.editor.getShape(shape.id);
      if (current) {
        const util = this.editor.getShapeUtil(shape);
        (_a6 = util.onTranslateCancel) == null ? void 0 : _a6.call(util, shape, current);
      }
    });
    this.reset();
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      if (typeof onInteractionEnd === "string") {
        this.editor.setCurrentTool(onInteractionEnd);
      } else {
        onInteractionEnd();
      }
      return;
    }
    this.parent.transition("idle", this.info);
  }
  handleStart() {
    const { movingShapes } = this.snapshot;
    const changes = [];
    movingShapes.forEach((shape) => {
      var _a6;
      const util = this.editor.getShapeUtil(shape);
      const change = (_a6 = util.onTranslateStart) == null ? void 0 : _a6.call(util, shape);
      if (change) {
        changes.push(change);
      }
    });
    if (changes.length > 0) {
      this.editor.updateShapes(changes);
    }
    this.dragAndDropManager.startDraggingShapes(
      // Get fresh shapes from the snapshot, in case onTranslateStart mutates the shape
      compact(this.snapshot.movingShapes.map((s) => this.editor.getShape(s.id))),
      // Start from the place where the user started dragging
      this.editor.inputs.getOriginPagePoint(),
      this.updateParentTransforms
    );
    this.editor.setHoveredShape(null);
  }
  handleEnd() {
    const { movingShapes } = this.snapshot;
    if (this.isCloning && movingShapes.length > 0) {
      const currentAveragePagePoint = Vec.Average(
        movingShapes.map((s) => this.editor.getShapePageTransform(s.id).point())
      );
      const offset4 = Vec.Sub(currentAveragePagePoint, this.selectionSnapshot.averagePagePoint);
      if (!Vec.IsNaN(offset4)) {
        this.editor.updateInstanceState({
          duplicateProps: {
            shapeIds: movingShapes.map((s) => s.id),
            offset: { x: offset4.x, y: offset4.y }
          }
        });
      }
    }
    const changes = [];
    movingShapes.forEach((shape) => {
      var _a6;
      const current = this.editor.getShape(shape.id);
      const util = this.editor.getShapeUtil(shape);
      const change = (_a6 = util.onTranslateEnd) == null ? void 0 : _a6.call(util, shape, current);
      if (change) {
        changes.push(change);
      }
    });
    if (changes.length > 0) {
      this.editor.updateShapes(changes);
    }
  }
  updateShapes() {
    const { snapshot } = this;
    this.dragAndDropManager.startDraggingShapes(
      snapshot.movingShapes,
      this.editor.inputs.getOriginPagePoint(),
      this.updateParentTransforms
    );
    moveShapesToPoint({
      editor: this.editor,
      snapshot
    });
    const { movingShapes } = snapshot;
    const changes = [];
    movingShapes.forEach((shape) => {
      var _a6;
      const current = this.editor.getShape(shape.id);
      const util = this.editor.getShapeUtil(shape);
      const change = (_a6 = util.onTranslate) == null ? void 0 : _a6.call(util, shape, current);
      if (change) {
        changes.push(change);
      }
    });
    if (changes.length > 0) {
      this.editor.updateShapes(changes);
    }
  }
  updateParentTransforms() {
    const {
      editor,
      snapshot: { shapeSnapshots }
    } = this;
    const movingShapes = [];
    shapeSnapshots.forEach((shapeSnapshot) => {
      const shape = editor.getShape(shapeSnapshot.shape.id);
      if (!shape) return null;
      movingShapes.push(shape);
      const parentTransform = isPageId(shape.parentId) ? null : Mat.Inverse(editor.getShapePageTransform(shape.parentId));
      shapeSnapshot.parentTransform = parentTransform;
    });
  }
};
_init13 = __decoratorStart13(_a5);
__decorateElement13(_init13, 1, "updateParentTransforms", _updateParentTransforms_dec, Translating);
__decoratorMetadata13(_init13, Translating);
__publicField14(Translating, "id", "translating");
function getTranslatingSnapshot(editor) {
  var _a6;
  const movingShapes = [];
  const pagePoints = [];
  const selectedShapeIds = editor.getSelectedShapeIds();
  const shapeSnapshots = compact(
    selectedShapeIds.map((id) => {
      const shape = editor.getShape(id);
      if (!shape) return null;
      movingShapes.push(shape);
      const pageTransform = editor.getShapePageTransform(id);
      const pagePoint = pageTransform.point();
      const pageRotation = pageTransform.rotation();
      pagePoints.push(pagePoint);
      const parentTransform = PageRecordType.isId(shape.parentId) ? null : Mat.Inverse(editor.getShapePageTransform(shape.parentId));
      return {
        shape,
        pagePoint,
        pageRotation,
        parentTransform
      };
    })
  );
  const onlySelectedShape = editor.getOnlySelectedShape();
  let initialSnapPoints = [];
  if (onlySelectedShape) {
    initialSnapPoints = editor.snaps.shapeBounds.getSnapPoints(onlySelectedShape.id);
  } else {
    const selectionPageBounds = editor.getSelectionPageBounds();
    if (selectionPageBounds) {
      initialSnapPoints = selectionPageBounds.cornersAndCenter.map((p, i) => ({
        id: "selection:" + i,
        x: p.x,
        y: p.y
      }));
    }
  }
  let noteAdjacentPositions;
  let noteSnapshot;
  const originPagePoint = editor.inputs.getOriginPagePoint();
  const allHoveredNotes = shapeSnapshots.filter(
    (s) => editor.isShapeOfType(s.shape, "note") && editor.isPointInShape(s.shape, originPagePoint)
  );
  if (allHoveredNotes.length === 0) {
  } else if (allHoveredNotes.length === 1) {
    noteSnapshot = allHoveredNotes[0];
  } else {
    const allShapesSorted = editor.getCurrentPageShapesSorted();
    noteSnapshot = (_a6 = allHoveredNotes.map((s) => ({
      snapshot: s,
      index: allShapesSorted.findIndex((shape) => shape.id === s.shape.id)
    })).sort((a, b) => b.index - a.index)[0]) == null ? void 0 : _a6.snapshot;
  }
  if (noteSnapshot) {
    noteAdjacentPositions = getAvailableNoteAdjacentPositions(
      editor,
      noteSnapshot.pageRotation,
      noteSnapshot.shape.props.scale,
      noteSnapshot.shape.props.growY ?? 0
    );
  }
  return {
    averagePagePoint: Vec.Average(pagePoints),
    movingShapes,
    shapeSnapshots,
    initialPageBounds: editor.getSelectionPageBounds(),
    initialSnapPoints,
    noteAdjacentPositions,
    noteSnapshot
  };
}
function moveShapesToPoint({
  editor,
  snapshot
}) {
  const { inputs } = editor;
  const {
    noteSnapshot,
    noteAdjacentPositions,
    initialPageBounds,
    initialSnapPoints,
    shapeSnapshots,
    averagePagePoint
  } = snapshot;
  const shiftKey = editor.inputs.getShiftKey();
  const accelKey = editor.inputs.getAccelKey();
  const isGridMode = editor.getInstanceState().isGridMode;
  const gridSize = editor.getDocumentSettings().gridSize;
  const delta = Vec.Sub(inputs.getCurrentPagePoint(), inputs.getOriginPagePoint());
  const flatten = shiftKey ? Math.abs(delta.x) < Math.abs(delta.y) ? "x" : "y" : null;
  if (flatten === "x") {
    delta.x = 0;
  } else if (flatten === "y") {
    delta.y = 0;
  }
  editor.snaps.clearIndicators();
  const isSnapping = editor.user.getIsSnapMode() ? !accelKey : accelKey;
  let snappedToPit = false;
  if (isSnapping && editor.inputs.getPointerVelocity().len() < 0.5) {
    const { nudge } = editor.snaps.shapeBounds.snapTranslateShapes({
      dragDelta: delta,
      initialSelectionPageBounds: initialPageBounds,
      lockedAxis: flatten,
      initialSelectionSnapPoints: initialSnapPoints
    });
    delta.add(nudge);
  } else {
    if (noteSnapshot && noteAdjacentPositions) {
      const { scale } = noteSnapshot.shape.props;
      const pageCenter = noteSnapshot.pagePoint.clone().add(delta).add(NOTE_CENTER_OFFSET.clone().mul(scale).rot(noteSnapshot.pageRotation));
      let min3 = NOTE_ADJACENT_POSITION_SNAP_RADIUS / editor.getZoomLevel();
      let offset4 = new Vec(0, 0);
      for (const pit of noteAdjacentPositions) {
        const deltaToPit = Vec.Sub(pageCenter, pit);
        const dist = deltaToPit.len();
        if (dist < min3) {
          snappedToPit = true;
          min3 = dist;
          offset4 = deltaToPit;
        }
      }
      delta.sub(offset4);
    }
  }
  const averageSnappedPoint = Vec.Add(averagePagePoint, delta);
  const snapIndicators = editor.snaps.getIndicators();
  if (isGridMode && !accelKey && !snappedToPit && snapIndicators.length === 0) {
    averageSnappedPoint.snapToGrid(gridSize);
  }
  const averageSnap = Vec.Sub(averageSnappedPoint, averagePagePoint);
  editor.updateShapes(
    compact(
      shapeSnapshots.map(({ shape, pagePoint, parentTransform }) => {
        const newPagePoint = Vec.Add(pagePoint, averageSnap);
        const newLocalPoint = parentTransform ? Mat.applyToPoint(parentTransform, newPagePoint) : newPagePoint;
        return {
          id: shape.id,
          type: shape.type,
          x: newLocalPoint.x,
          y: newLocalPoint.y
        };
      })
    )
  );
}

// ../node_modules/tldraw/dist-esm/lib/tools/SelectTool/SelectTool.mjs
var SelectTool = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "reactor");
  }
  static children() {
    return [
      Crop,
      Cropping,
      Idle12,
      PointingCanvas,
      PointingShape,
      Translating,
      Brushing,
      ScribbleBrushing,
      PointingCropHandle,
      PointingSelection,
      PointingResizeHandle,
      EditingShape,
      Resizing,
      Rotating,
      PointingRotateHandle,
      PointingArrowLabel,
      PointingHandle,
      DraggingHandle
    ];
  }
  // We want to clean up the duplicate props when the selection changes
  cleanUpDuplicateProps() {
    const selectedShapeIds = this.editor.getSelectedShapeIds();
    const instance = this.editor.getInstanceState();
    if (!instance.duplicateProps) return;
    const duplicatedShapes = new Set(instance.duplicateProps.shapeIds);
    if (selectedShapeIds.length === duplicatedShapes.size && selectedShapeIds.every((shapeId) => duplicatedShapes.has(shapeId))) {
      return;
    }
    this.editor.updateInstanceState({
      duplicateProps: null
    });
  }
  onEnter() {
    this.reactor = react("clean duplicate props", () => {
      try {
        this.cleanUpDuplicateProps();
      } catch (e) {
        if (typeof process !== "undefined" && false) {
        } else {
          console.error(e);
        }
      }
    });
  }
  onExit() {
    var _a6;
    (_a6 = this.reactor) == null ? void 0 : _a6.call(this);
    if (this.editor.getCurrentPageState().editingShapeId) {
      this.editor.setEditingShape(null);
    }
  }
};
__publicField(SelectTool, "id", "select");
__publicField(SelectTool, "initial", "idle");
__publicField(SelectTool, "isLockable", false);

// ../node_modules/tldraw/dist-esm/lib/tools/ZoomTool/childStates/Idle.mjs
var Idle13 = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "info", {});
  }
  onEnter(info) {
    this.info = info;
  }
  onPointerDown() {
    this.parent.transition("pointing", this.info);
  }
};
__publicField(Idle13, "id", "idle");

// ../node_modules/tldraw/dist-esm/lib/tools/ZoomTool/childStates/Pointing.mjs
var Pointing9 = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "info", {});
  }
  onEnter(info) {
    this.info = info;
  }
  onPointerUp() {
    this.complete();
  }
  onPointerMove() {
    if (this.editor.inputs.getIsDragging()) {
      this.parent.transition("zoom_brushing", this.info);
    }
  }
  onCancel() {
    this.cancel();
  }
  complete() {
    const currentScreenPoint = this.editor.inputs.getCurrentScreenPoint();
    if (this.editor.inputs.getAltKey()) {
      this.editor.zoomOut(currentScreenPoint, { animation: { duration: 220 } });
    } else {
      this.editor.zoomIn(currentScreenPoint, { animation: { duration: 220 } });
    }
    this.parent.transition("idle", this.info);
  }
  cancel() {
    this.parent.transition("idle", this.info);
  }
};
__publicField(Pointing9, "id", "pointing");

// ../node_modules/tldraw/dist-esm/lib/tools/ZoomTool/childStates/ZoomBrushing.mjs
var ZoomBrushing = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "info", {});
    __publicField(this, "zoomBrush", new Box());
  }
  onEnter(info) {
    this.info = info;
    this.update();
  }
  onExit() {
    this.editor.updateInstanceState({ zoomBrush: null });
  }
  onPointerMove() {
    this.update();
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  update() {
    const originPagePoint = this.editor.inputs.getOriginPagePoint();
    const currentPagePoint = this.editor.inputs.getCurrentPagePoint();
    this.zoomBrush.setTo(Box.FromPoints([originPagePoint, currentPagePoint]));
    this.editor.updateInstanceState({ zoomBrush: this.zoomBrush.toJson() });
  }
  cancel() {
    this.parent.transition("idle", this.info);
  }
  complete() {
    const { zoomBrush } = this;
    const threshold = 8 / this.editor.getZoomLevel();
    if (zoomBrush.width < threshold && zoomBrush.height < threshold) {
      const point = this.editor.inputs.getCurrentScreenPoint();
      if (this.editor.inputs.getAltKey()) {
        this.editor.zoomOut(point, { animation: { duration: 220 } });
      } else {
        this.editor.zoomIn(point, { animation: { duration: 220 } });
      }
    } else {
      const targetZoom = this.editor.inputs.getAltKey() ? this.editor.getZoomLevel() / 2 : void 0;
      this.editor.zoomToBounds(zoomBrush, { targetZoom, animation: { duration: 220 } });
    }
    this.parent.transition("idle", this.info);
  }
};
__publicField(ZoomBrushing, "id", "zoom_brushing");

// ../node_modules/tldraw/dist-esm/lib/tools/ZoomTool/ZoomTool.mjs
var ZoomTool = class extends StateNode {
  constructor() {
    super(...arguments);
    __publicField(this, "info", {});
  }
  static children() {
    return [Idle13, ZoomBrushing, Pointing9];
  }
  onEnter(info) {
    this.info = info;
    this.parent.setCurrentToolIdMask(info.onInteractionEnd);
    this.updateCursor();
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0);
    this.editor.updateInstanceState({ zoomBrush: null, cursor: { type: "default", rotation: 0 } });
    this.parent.setCurrentToolIdMask(void 0);
  }
  onKeyDown() {
    this.updateCursor();
  }
  onKeyUp(info) {
    this.updateCursor();
    if (info.code === "KeyZ") {
      this.complete();
    }
  }
  onInterrupt() {
    this.complete();
  }
  complete() {
    if (this.info.onInteractionEnd && this.info.onInteractionEnd !== "select") {
      this.editor.setCurrentTool(this.info.onInteractionEnd, this.info);
    } else {
      this.parent.transition("select");
    }
  }
  updateCursor() {
    if (this.editor.inputs.getAltKey()) {
      this.editor.setCursor({ type: "zoom-out", rotation: 0 });
    } else {
      this.editor.setCursor({ type: "zoom-in", rotation: 0 });
    }
  }
};
__publicField(ZoomTool, "id", "zoom");
__publicField(ZoomTool, "initial", "idle");
__publicField(ZoomTool, "isLockable", false);

// ../node_modules/tldraw/dist-esm/lib/defaultTools.mjs
var defaultTools = [EraserTool, HandTool, LaserTool, ZoomTool, SelectTool];

// ../node_modules/tldraw/dist-esm/lib/shapes/shared/PlainTextLabel.mjs
var import_jsx_runtime227 = __toESM(require_jsx_runtime(), 1);
var import_classnames39 = __toESM(require_classnames(), 1);
var import_react153 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/shapes/text/PlainTextArea.mjs
var import_jsx_runtime226 = __toESM(require_jsx_runtime(), 1);
var import_react152 = __toESM(require_react(), 1);
var PlainTextArea = import_react152.default.forwardRef(function TextArea({
  isEditing,
  text,
  handleFocus,
  handleChange,
  handleKeyDown: handleKeyDown2,
  handlePaste,
  handleBlur,
  handleInputPointerDown,
  handleDoubleClick: handleDoubleClick2
}, ref) {
  const editor = useEditor();
  const onChange = (e) => {
    handleChange({ plaintext: e.target.value });
  };
  return (0, import_jsx_runtime226.jsx)(
    "textarea",
    {
      ref,
      className: "tl-text tl-text-input",
      name: "text",
      tabIndex: -1,
      disabled: !isEditing,
      readOnly: !isEditing,
      autoComplete: "off",
      autoCapitalize: "off",
      autoCorrect: "off",
      autoSave: "off",
      placeholder: "",
      spellCheck: "true",
      wrap: "off",
      dir: "auto",
      defaultValue: text,
      onFocus: handleFocus,
      onChange,
      onKeyDown: (e) => handleKeyDown2(e.nativeEvent),
      onBlur: handleBlur,
      onTouchEnd: editor.markEventAsHandled,
      onContextMenu: isEditing ? (e) => e.stopPropagation() : void 0,
      onPointerDown: handleInputPointerDown,
      onPaste: handlePaste,
      onDoubleClick: handleDoubleClick2,
      onDragStart: preventDefault
    }
  );
});

// ../node_modules/tldraw/dist-esm/lib/shapes/shared/PlainTextLabel.mjs
var PlainTextLabel = import_react153.default.memo(function PlainTextLabel2({
  shapeId,
  type,
  text: plaintext,
  labelColor,
  font,
  fontSize,
  lineHeight,
  align,
  verticalAlign,
  wrap: wrap3,
  isSelected,
  padding = 0,
  onKeyDown: handleKeyDownCustom,
  classNamePrefix,
  style: style2,
  textWidth,
  textHeight,
  showTextOutline = true
}) {
  const { rInput, isEmpty, isEditing, isReadyForEditing, ...editableTextRest } = useEditablePlainText(shapeId, type, plaintext);
  const finalPlainText = TextHelpers.normalizeTextForDom(plaintext || "");
  const hasText = finalPlainText.length > 0;
  const legacyAlign = isLegacyAlign(align);
  if (!isEditing && !hasText) {
    return null;
  }
  const cssPrefix = classNamePrefix || "tl-text";
  return (0, import_jsx_runtime227.jsx)(
    "div",
    {
      className: `${cssPrefix}-label tl-text-wrapper tl-plain-text-wrapper`,
      "aria-hidden": !isEditing,
      "data-font": font,
      "data-align": align,
      "data-hastext": !isEmpty,
      "data-isediting": isEditing,
      "data-is-ready-for-editing": isReadyForEditing,
      "data-textwrap": !!wrap3,
      "data-isselected": isSelected,
      style: {
        justifyContent: align === "middle" || legacyAlign ? "center" : align,
        alignItems: verticalAlign === "middle" ? "center" : verticalAlign,
        padding,
        ...style2
      },
      children: (0, import_jsx_runtime227.jsxs)(
        "div",
        {
          className: `${cssPrefix}-label__inner tl-text-content__wrapper`,
          style: {
            fontSize,
            lineHeight: lineHeight.toString(),
            minHeight: Math.floor(fontSize * lineHeight) + "px",
            minWidth: Math.ceil(textWidth || 0),
            color: labelColor,
            width: textWidth ? Math.ceil(textWidth) : void 0,
            height: textHeight ? Math.ceil(textHeight) : void 0
          },
          children: [
            (0, import_jsx_runtime227.jsx)(
              "div",
              {
                className: (0, import_classnames39.default)(
                  `${cssPrefix} tl-text tl-text-content`,
                  showTextOutline ? "tl-text__outline" : "tl-text__no-outline"
                ),
                dir: "auto",
                children: finalPlainText.split("\n").map((lineOfText, index2) => (0, import_jsx_runtime227.jsx)("div", { dir: "auto", children: lineOfText }, index2))
              }
            ),
            (isReadyForEditing || isSelected) && (0, import_jsx_runtime227.jsx)(
              PlainTextArea,
              {
                ref: rInput,
                text: plaintext,
                isEditing,
                shapeId,
                ...editableTextRest,
                handleKeyDown: handleKeyDownCustom ?? editableTextRest.handleKeyDown
              }
            )
          ]
        }
      )
    }
  );
});

// ../node_modules/tldraw/dist-esm/lib/Tldraw.mjs
var import_jsx_runtime231 = __toESM(require_jsx_runtime(), 1);
var import_react158 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/TldrawUi.mjs
var import_jsx_runtime229 = __toESM(require_jsx_runtime(), 1);
var import_classnames40 = __toESM(require_classnames(), 1);
var import_react157 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/context/TldrawUiContextProvider.mjs
var import_jsx_runtime228 = __toESM(require_jsx_runtime(), 1);

// ../node_modules/tldraw/dist-esm/lib/ui/assetUrls.mjs
var import_react155 = __toESM(require_react(), 1);

// ../node_modules/tldraw/dist-esm/lib/utils/static-assets/assetUrls.mjs
var import_react154 = __toESM(require_react(), 1);
var defaultEditorAssetUrls = {
  fonts: {
    tldraw_mono: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexMono-Medium.woff2`,
    tldraw_mono_italic: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexMono-MediumItalic.woff2`,
    tldraw_mono_bold: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexMono-Bold.woff2`,
    tldraw_mono_italic_bold: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexMono-BoldItalic.woff2`,
    tldraw_serif: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexSerif-Medium.woff2`,
    tldraw_serif_italic: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexSerif-MediumItalic.woff2`,
    tldraw_serif_bold: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexSerif-Bold.woff2`,
    tldraw_serif_italic_bold: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexSerif-BoldItalic.woff2`,
    tldraw_sans: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexSans-Medium.woff2`,
    tldraw_sans_italic: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexSans-MediumItalic.woff2`,
    tldraw_sans_bold: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexSans-Bold.woff2`,
    tldraw_sans_italic_bold: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexSans-BoldItalic.woff2`,
    tldraw_draw: `${getDefaultCdnBaseUrl()}/fonts/Shantell_Sans-Informal_Regular.woff2`,
    tldraw_draw_italic: `${getDefaultCdnBaseUrl()}/fonts/Shantell_Sans-Informal_Regular_Italic.woff2`,
    tldraw_draw_bold: `${getDefaultCdnBaseUrl()}/fonts/Shantell_Sans-Informal_Bold.woff2`,
    tldraw_draw_italic_bold: `${getDefaultCdnBaseUrl()}/fonts/Shantell_Sans-Informal_Bold_Italic.woff2`
  }
};
function setDefaultEditorAssetUrls(assetUrls) {
  defaultEditorAssetUrls = assetUrls;
}
function useDefaultEditorAssetsWithOverrides(overrides) {
  return (0, import_react154.useMemo)(() => {
    if (!overrides) return defaultEditorAssetUrls;
    return {
      fonts: { ...defaultEditorAssetUrls.fonts, ...overrides == null ? void 0 : overrides.fonts }
    };
  }, [overrides]);
}

// ../node_modules/tldraw/dist-esm/lib/ui/icon-types.mjs
var iconTypes = [
  "align-bottom",
  "align-center-horizontal",
  "align-center-vertical",
  "align-left",
  "align-right",
  "align-top",
  "alt",
  "arrow-arc",
  "arrow-cycle",
  "arrow-elbow",
  "arrow-left",
  "arrowhead-arrow",
  "arrowhead-bar",
  "arrowhead-diamond",
  "arrowhead-dot",
  "arrowhead-none",
  "arrowhead-square",
  "arrowhead-triangle-inverted",
  "arrowhead-triangle",
  "blob",
  "bold",
  "bookmark",
  "bring-forward",
  "bring-to-front",
  "broken",
  "bulletList",
  "check-circle",
  "check",
  "chevron-down",
  "chevron-left",
  "chevron-right",
  "chevron-up",
  "chevrons-ne",
  "chevrons-sw",
  "clipboard-copied",
  "clipboard-copy",
  "code",
  "color",
  "comment",
  "corners",
  "crop",
  "cross-2",
  "cross-circle",
  "dash-dashed",
  "dash-dotted",
  "dash-draw",
  "dash-solid",
  "disconnected",
  "discord",
  "distribute-horizontal",
  "distribute-vertical",
  "dot",
  "dots-horizontal",
  "dots-vertical",
  "download",
  "drag-handle-dots",
  "duplicate",
  "edit",
  "external-link",
  "fill-fill",
  "fill-none",
  "fill-pattern",
  "fill-semi",
  "fill-solid",
  "follow",
  "following",
  "font-draw",
  "font-mono",
  "font-sans",
  "font-serif",
  "geo-arrow-down",
  "geo-arrow-left",
  "geo-arrow-right",
  "geo-arrow-up",
  "geo-check-box",
  "geo-cloud",
  "geo-diamond",
  "geo-ellipse",
  "geo-heart",
  "geo-hexagon",
  "geo-octagon",
  "geo-oval",
  "geo-pentagon",
  "geo-rectangle",
  "geo-rhombus-2",
  "geo-rhombus",
  "geo-star",
  "geo-trapezoid",
  "geo-triangle",
  "geo-x-box",
  "github",
  "group",
  "heading",
  "help-circle",
  "highlight",
  "horizontal-align-end",
  "horizontal-align-middle",
  "horizontal-align-start",
  "info-circle",
  "italic",
  "leading",
  "link",
  "list",
  "lock",
  "manual",
  "menu",
  "minus",
  "mixed",
  "pack",
  "plus",
  "question-mark-circle",
  "question-mark",
  "redo",
  "reset-zoom",
  "rotate-ccw",
  "rotate-cw",
  "send-backward",
  "send-to-back",
  "share-1",
  "size-extra-large",
  "size-large",
  "size-medium",
  "size-small",
  "spline-cubic",
  "spline-line",
  "stack-horizontal",
  "stack-vertical",
  "status-offline",
  "stretch-horizontal",
  "stretch-vertical",
  "strike",
  "text-align-center",
  "text-align-left",
  "text-align-right",
  "toggle-off",
  "toggle-on",
  "tool-arrow",
  "tool-eraser",
  "tool-frame",
  "tool-hand",
  "tool-highlight",
  "tool-laser",
  "tool-line",
  "tool-media",
  "tool-note",
  "tool-pencil",
  "tool-pointer",
  "tool-screenshot",
  "tool-text",
  "trash",
  "twitter",
  "underline",
  "undo",
  "ungroup",
  "unlock",
  "vertical-align-end",
  "vertical-align-middle",
  "vertical-align-start",
  "warning-triangle",
  "zoom-in",
  "zoom-out"
];

// ../node_modules/tldraw/dist-esm/lib/ui/assetUrls.mjs
var defaultUiAssetUrls = {
  ...defaultEditorAssetUrls,
  icons: Object.fromEntries(
    iconTypes.map((name) => [name, `${getDefaultCdnBaseUrl()}/icons/icon/0_merged.svg#${name}`])
  ),
  translations: Object.fromEntries(
    LANGUAGES.map((lang) => [
      lang.locale,
      `${getDefaultCdnBaseUrl()}/translations/${lang.locale}.json`
    ])
  ),
  embedIcons: Object.fromEntries(
    DEFAULT_EMBED_DEFINITIONS.map((def) => [
      def.type,
      `${getDefaultCdnBaseUrl()}/embed-icons/${def.type}.png`
    ])
  )
};
function setDefaultUiAssetUrls(urls) {
  defaultUiAssetUrls = urls;
}
function useDefaultUiAssetUrlsWithOverrides(overrides) {
  return (0, import_react155.useMemo)(() => {
    if (!overrides) return defaultUiAssetUrls;
    return {
      fonts: Object.assign({ ...defaultUiAssetUrls.fonts }, { ...overrides == null ? void 0 : overrides.fonts }),
      icons: Object.assign({ ...defaultUiAssetUrls.icons }, { ...overrides == null ? void 0 : overrides.icons }),
      embedIcons: Object.assign({ ...defaultUiAssetUrls.embedIcons }, { ...overrides == null ? void 0 : overrides.embedIcons }),
      translations: Object.assign(
        { ...defaultUiAssetUrls.translations },
        { ...overrides == null ? void 0 : overrides.translations }
      )
    };
  }, [overrides]);
}

// ../node_modules/tldraw/dist-esm/lib/ui/context/TldrawUiContextProvider.mjs
var TldrawUiContextProvider = track(function TldrawUiContextProvider2({
  overrides,
  components,
  assetUrls,
  onUiEvent,
  forceMobile,
  mediaMimeTypes,
  children
}) {
  const editor = useMaybeEditor();
  return (0, import_jsx_runtime228.jsx)(MimeTypeContext.Provider, { value: mediaMimeTypes, children: (0, import_jsx_runtime228.jsx)(TldrawUiTooltipProvider, { children: (0, import_jsx_runtime228.jsx)(AssetUrlsProvider, { assetUrls: useDefaultUiAssetUrlsWithOverrides(assetUrls), children: (0, import_jsx_runtime228.jsx)(
    TldrawUiTranslationProvider,
    {
      overrides: useMergedTranslationOverrides(overrides),
      locale: (editor == null ? void 0 : editor.user.getLocale()) ?? defaultUserPreferences.locale,
      children: (0, import_jsx_runtime228.jsx)(TldrawUiEventsProvider, { onEvent: onUiEvent, children: (0, import_jsx_runtime228.jsx)(TldrawUiToastsProvider, { children: (0, import_jsx_runtime228.jsx)(TldrawUiDialogsProvider, { context: "tla", children: (0, import_jsx_runtime228.jsx)(TldrawUiA11yProvider, { children: (0, import_jsx_runtime228.jsx)(BreakPointProvider, { forceMobile, children: (0, import_jsx_runtime228.jsx)(TldrawUiComponentsProvider, { overrides: components, children: (0, import_jsx_runtime228.jsx)(InternalProviders, { overrides, children }) }) }) }) }) }) })
    }
  ) }) }) });
});
function InternalProviders({
  overrides,
  children
}) {
  const mergedOverrides = useMergedOverrides(overrides);
  return (0, import_jsx_runtime228.jsx)(ActionsProvider, { overrides: mergedOverrides.actions, children: (0, import_jsx_runtime228.jsx)(ToolsProvider, { overrides: mergedOverrides.tools, children }) });
}

// ../node_modules/tldraw/dist-esm/lib/ui/hooks/useEditorEvents.mjs
var import_react156 = __toESM(require_react(), 1);
function useEditorEvents() {
  const editor = useEditor();
  const { addToast } = useToasts();
  (0, import_react156.useEffect)(() => {
    function handleMaxShapes({ name, count: count3 }) {
      addToast({
        title: "Maximum shapes reached",
        description: `You've reached the maximum number of shapes allowed on ${name} (${count3}). Please delete some shapes or move to a different page to continue.`,
        severity: "warning"
      });
    }
    editor.addListener("max-shapes", handleMaxShapes);
    return () => {
      editor.removeListener("max-shapes", handleMaxShapes);
    };
  }, [editor, addToast]);
}

// ../node_modules/tldraw/dist-esm/lib/ui/TldrawUi.mjs
var TldrawUi = import_react157.default.memo(function TldrawUi2({
  renderDebugMenuItems,
  children,
  hideUi,
  components,
  ...rest
}) {
  return (0, import_jsx_runtime229.jsx)(TldrawUiContextProvider, { ...rest, components, children: (0, import_jsx_runtime229.jsx)(TldrawUiInner, { hideUi, renderDebugMenuItems, children }) });
});
var TldrawUiInner = import_react157.default.memo(function TldrawUiInner2({
  children,
  hideUi,
  ...rest
}) {
  useKeyboardShortcuts();
  useNativeClipboardEvents();
  return (0, import_jsx_runtime229.jsxs)(import_jsx_runtime229.Fragment, { children: [
    children,
    hideUi ? null : (0, import_jsx_runtime229.jsx)(TldrawUiContent, { ...rest })
  ] });
});
var TldrawUiContent = import_react157.default.memo(function TldrawUI() {
  const editor = useEditor();
  const msg2 = useTranslation();
  const breakpoint = useBreakpoint();
  const isReadonlyMode = useReadonly();
  const isFocusMode = useValue("focus", () => editor.getInstanceState().isFocusMode, [editor]);
  const isDebugMode = useValue("debug", () => editor.getInstanceState().isDebugMode, [editor]);
  const {
    SharePanel,
    TopPanel,
    MenuPanel: MenuPanel2,
    StylePanel,
    Toolbar: Toolbar2,
    HelpMenu,
    NavigationPanel,
    HelperButtons,
    DebugPanel,
    Toasts,
    Dialogs,
    A11y
  } = useTldrawUiComponents();
  useEditorEvents();
  const rIsEditingAnything = (0, import_react157.useRef)(false);
  const rHidingTimeout = (0, import_react157.useRef)(-1);
  const [hideToolbarWhileEditing, setHideToolbarWhileEditing] = (0, import_react157.useState)(false);
  useReactor(
    "update hide toolbar while delayed",
    () => {
      const isMobileEnvironment = tlenv.isIos || tlenv.isAndroid;
      if (!isMobileEnvironment) return;
      const editingShape = editor.getEditingShapeId();
      if (editingShape === null) {
        if (rIsEditingAnything.current) {
          rIsEditingAnything.current = false;
          clearTimeout(rHidingTimeout.current);
          if (tlenv.isAndroid) {
            rHidingTimeout.current = editor.timers.setTimeout(() => {
              setHideToolbarWhileEditing(false);
            }, 150);
          } else {
            setHideToolbarWhileEditing(false);
          }
        }
        return;
      }
      if (!rIsEditingAnything.current) {
        rIsEditingAnything.current = true;
        clearTimeout(rHidingTimeout.current);
        setHideToolbarWhileEditing(true);
      }
    },
    []
  );
  const { "toggle-focus-mode": toggleFocus } = useActions();
  const { breakpointsAbove, breakpointsBelow } = (0, import_react157.useMemo)(() => {
    const breakpointsAbove2 = [];
    const breakpointsBelow2 = [];
    for (let bp = 0; bp < PORTRAIT_BREAKPOINTS.length; bp++) {
      if (bp <= breakpoint) {
        breakpointsAbove2.push(bp);
      } else {
        breakpointsBelow2.push(bp);
      }
    }
    return { breakpointsAbove: breakpointsAbove2, breakpointsBelow: breakpointsBelow2 };
  }, [breakpoint]);
  return (0, import_jsx_runtime229.jsxs)(
    "div",
    {
      className: (0, import_classnames40.default)("tlui-layout", {
        "tlui-layout__mobile": breakpoint < PORTRAIT_BREAKPOINT.TABLET_SM
      }),
      "data-iseditinganything": hideToolbarWhileEditing,
      "data-breakpoint": breakpoint,
      "data-breakpoints-above": breakpointsAbove.join(" "),
      "data-breakpoints-below": breakpointsBelow.join(" "),
      children: [
        (0, import_jsx_runtime229.jsx)(SkipToMainContent, {}),
        isFocusMode ? (0, import_jsx_runtime229.jsx)("div", { className: "tlui-layout__top", children: (0, import_jsx_runtime229.jsx)(
          TldrawUiButton,
          {
            type: "icon",
            className: "tlui-focus-button",
            title: msg2("focus-mode.toggle-focus-mode"),
            onClick: () => toggleFocus.onSelect("menu"),
            children: (0, import_jsx_runtime229.jsx)(TldrawUiButtonIcon, { icon: "dot" })
          }
        ) }) : (0, import_jsx_runtime229.jsxs)(import_jsx_runtime229.Fragment, { children: [
          (0, import_jsx_runtime229.jsxs)("div", { className: "tlui-layout__top", children: [
            (0, import_jsx_runtime229.jsxs)("div", { className: "tlui-layout__top__left", children: [
              MenuPanel2 && (0, import_jsx_runtime229.jsx)(MenuPanel2, {}),
              HelperButtons && (0, import_jsx_runtime229.jsx)(HelperButtons, {})
            ] }),
            (0, import_jsx_runtime229.jsx)("div", { className: "tlui-layout__top__center", children: TopPanel && (0, import_jsx_runtime229.jsx)(TopPanel, {}) }),
            (0, import_jsx_runtime229.jsxs)("div", { className: "tlui-layout__top__right", children: [
              SharePanel && (0, import_jsx_runtime229.jsx)(SharePanel, {}),
              StylePanel && breakpoint >= PORTRAIT_BREAKPOINT.TABLET_SM && !isReadonlyMode && (0, import_jsx_runtime229.jsx)(StylePanel, {})
            ] })
          ] }),
          (0, import_jsx_runtime229.jsxs)("div", { className: "tlui-layout__bottom", children: [
            (0, import_jsx_runtime229.jsxs)("div", { className: "tlui-layout__bottom__main", children: [
              NavigationPanel && (0, import_jsx_runtime229.jsx)(NavigationPanel, {}),
              Toolbar2 && (0, import_jsx_runtime229.jsx)(Toolbar2, {}),
              HelpMenu && (0, import_jsx_runtime229.jsx)(HelpMenu, {})
            ] }),
            isDebugMode && DebugPanel && (0, import_jsx_runtime229.jsx)(DebugPanel, {}),
            A11y && (0, import_jsx_runtime229.jsx)(A11y, {})
          ] })
        ] }),
        Toasts && (0, import_jsx_runtime229.jsx)(Toasts, {}),
        Dialogs && (0, import_jsx_runtime229.jsx)(Dialogs, {})
      ]
    }
  );
});
function TldrawUiInFrontOfTheCanvas() {
  const { RichTextToolbar, ImageToolbar, VideoToolbar, CursorChatBubble: CursorChatBubble3, FollowingIndicator } = useTldrawUiComponents();
  return (0, import_jsx_runtime229.jsxs)(import_jsx_runtime229.Fragment, { children: [
    RichTextToolbar && (0, import_jsx_runtime229.jsx)(RichTextToolbar, {}),
    ImageToolbar && (0, import_jsx_runtime229.jsx)(ImageToolbar, {}),
    VideoToolbar && (0, import_jsx_runtime229.jsx)(VideoToolbar, {}),
    FollowingIndicator && (0, import_jsx_runtime229.jsx)(FollowingIndicator, {}),
    CursorChatBubble3 && (0, import_jsx_runtime229.jsx)(CursorChatBubble3, {})
  ] });
}

// ../node_modules/tldraw/dist-esm/lib/ui/components/LoadingScreen.mjs
var import_jsx_runtime230 = __toESM(require_jsx_runtime(), 1);
var LoadingScreen2 = () => {
  const { Spinner: Spinner2 } = useEditorComponents();
  return (0, import_jsx_runtime230.jsx)(LoadingScreen, { children: Spinner2 ? (0, import_jsx_runtime230.jsx)(Spinner2, {}) : null });
};

// ../node_modules/tldraw/dist-esm/lib/Tldraw.mjs
var allDefaultTools = [...defaultTools, ...defaultShapeTools];
function Tldraw(props) {
  var _a6;
  const {
    children,
    maxImageDimension,
    maxAssetSize,
    acceptedImageMimeTypes,
    acceptedVideoMimeTypes,
    onMount,
    components = {},
    shapeUtils = [],
    bindingUtils = [],
    tools = [],
    embeds,
    textOptions,
    ...rest
  } = props;
  const _components = useShallowObjectIdentity(components);
  const CustomInFrontOfTheCanvas = components == null ? void 0 : components.InFrontOfTheCanvas;
  const InFrontOfTheCanvas = (0, import_react158.useMemo)(() => {
    if (rest.hideUi) return CustomInFrontOfTheCanvas ?? null;
    if (!CustomInFrontOfTheCanvas) return TldrawUiInFrontOfTheCanvas;
    return () => (0, import_jsx_runtime231.jsxs)(import_jsx_runtime231.Fragment, { children: [
      (0, import_jsx_runtime231.jsx)(TldrawUiInFrontOfTheCanvas, {}),
      (0, import_jsx_runtime231.jsx)(CustomInFrontOfTheCanvas, {})
    ] });
  }, [rest.hideUi, CustomInFrontOfTheCanvas]);
  const componentsWithDefault = (0, import_react158.useMemo)(
    () => ({
      Scribble: TldrawScribble,
      ShapeIndicators: TldrawShapeIndicators,
      CollaboratorScribble: TldrawScribble,
      SelectionForeground: TldrawSelectionForeground,
      Handles: TldrawHandles,
      Overlays: TldrawOverlays,
      Spinner,
      LoadingScreen: LoadingScreen2,
      ..._components,
      InFrontOfTheCanvas
    }),
    [_components, InFrontOfTheCanvas]
  );
  const _shapeUtils = useShallowArrayIdentity(shapeUtils);
  const shapeUtilsWithDefaults = (0, import_react158.useMemo)(
    () => mergeArraysAndReplaceDefaults("type", _shapeUtils, defaultShapeUtils),
    [_shapeUtils]
  );
  const _bindingUtils = useShallowArrayIdentity(bindingUtils);
  const bindingUtilsWithDefaults = (0, import_react158.useMemo)(
    () => mergeArraysAndReplaceDefaults("type", _bindingUtils, defaultBindingUtils),
    [_bindingUtils]
  );
  const _tools = useShallowArrayIdentity(tools);
  const toolsWithDefaults = (0, import_react158.useMemo)(
    () => mergeArraysAndReplaceDefaults("id", _tools, allDefaultTools),
    [_tools]
  );
  const _imageMimeTypes = useShallowArrayIdentity(
    acceptedImageMimeTypes ?? DEFAULT_SUPPORTED_IMAGE_TYPES
  );
  const _videoMimeTypes = useShallowArrayIdentity(
    acceptedVideoMimeTypes ?? DEFAULT_SUPPORT_VIDEO_TYPES
  );
  const textOptionsWithDefaults = (0, import_react158.useMemo)(() => {
    return {
      addFontsFromNode: defaultAddFontsFromNode,
      ...textOptions,
      tipTapConfig: {
        extensions: tipTapDefaultExtensions,
        ...textOptions == null ? void 0 : textOptions.tipTapConfig
      }
    };
  }, [textOptions]);
  const mediaMimeTypes = (0, import_react158.useMemo)(
    () => [..._imageMimeTypes, ..._videoMimeTypes],
    [_imageMimeTypes, _videoMimeTypes]
  );
  const assets = useDefaultEditorAssetsWithOverrides(rest.assetUrls);
  const embedShapeUtil = shapeUtilsWithDefaults.find((util) => util.type === "embed");
  if (embedShapeUtil && embeds) {
    EmbedShapeUtil.setEmbedDefinitions(embeds);
  }
  return (
    // We provide an extra higher layer of asset+translations providers here so that
    // loading UI (which is rendered outside of TldrawUi) may be translated.
    // Ideally we would refactor to hoist all the UI context providers we can up here. Maybe later.
    (0, import_jsx_runtime231.jsx)(
      AssetUrlsProvider,
      { assetUrls: useDefaultUiAssetUrlsWithOverrides(rest.assetUrls), children: (0, import_jsx_runtime231.jsx)(
        TldrawUiTranslationProvider,
        {
          overrides: useMergedTranslationOverrides(rest.overrides),
          locale: ((_a6 = rest.user) == null ? void 0 : _a6.userPreferences.get().locale) ?? defaultUserPreferences.locale,
          children: (0, import_jsx_runtime231.jsx)(
            TldrawEditor,
            {
              initialState: "select",
              ...rest,
              components: componentsWithDefault,
              shapeUtils: shapeUtilsWithDefaults,
              bindingUtils: bindingUtilsWithDefaults,
              tools: toolsWithDefaults,
              textOptions: textOptionsWithDefaults,
              assetUrls: assets,
              children: (0, import_jsx_runtime231.jsxs)(TldrawUi, { ...rest, components: componentsWithDefault, mediaMimeTypes, children: [
                (0, import_jsx_runtime231.jsx)(
                  InsideOfEditorAndUiContext,
                  {
                    maxImageDimension,
                    maxAssetSize,
                    acceptedImageMimeTypes: _imageMimeTypes,
                    acceptedVideoMimeTypes: _videoMimeTypes,
                    onMount
                  }
                ),
                children
              ] })
            }
          )
        }
      ) }
    )
  );
}
function InsideOfEditorAndUiContext({
  maxImageDimension,
  maxAssetSize,
  acceptedImageMimeTypes,
  acceptedVideoMimeTypes,
  onMount
}) {
  const editor = useEditor();
  const toasts = useToasts();
  const msg2 = useTranslation();
  const trackEvent = useUiEvents();
  useOnMount(() => {
    const unsubs = [];
    unsubs.push(registerDefaultSideEffects(editor));
    editor.fonts.requestFonts(allDefaultFontFaces);
    editor.once("edit", () => trackEvent("edit", { source: "unknown" }));
    registerDefaultExternalContentHandlers(editor, {
      maxImageDimension,
      maxAssetSize,
      acceptedImageMimeTypes,
      acceptedVideoMimeTypes,
      toasts,
      msg: msg2
    });
    unsubs.push(editor.store.props.onMount(editor));
    unsubs.push(onMount == null ? void 0 : onMount(editor));
    return () => {
      unsubs.forEach((fn) => fn == null ? void 0 : fn());
    };
  });
  const { Canvas } = useEditorComponents();
  const { ContextMenu: ContextMenu2 } = useTldrawUiComponents();
  if (ContextMenu2) {
    return (0, import_jsx_runtime231.jsx)(ContextMenu2, {});
  }
  if (Canvas) {
    return (0, import_jsx_runtime231.jsx)(Canvas, {});
  }
  return null;
}

// ../node_modules/tldraw/dist-esm/lib/TldrawImage.mjs
var import_jsx_runtime232 = __toESM(require_jsx_runtime(), 1);
var import_react159 = __toESM(require_react(), 1);
var defaultTextOptions = {
  tipTapConfig: {
    extensions: tipTapDefaultExtensions
  },
  addFontsFromNode: defaultAddFontsFromNode
};
var TldrawImage = (0, import_react159.memo)(function TldrawImage2(props) {
  const [url, setUrl] = (0, import_react159.useState)(null);
  const [container, setContainer] = (0, import_react159.useState)(null);
  const _shapeUtils = useShallowArrayIdentity(props.shapeUtils ?? []);
  const shapeUtilsWithDefaults = (0, import_react159.useMemo)(
    () => mergeArraysAndReplaceDefaults("type", _shapeUtils, defaultShapeUtils),
    [_shapeUtils]
  );
  const _bindingUtils = useShallowArrayIdentity(props.bindingUtils ?? []);
  const bindingUtilsWithDefaults = (0, import_react159.useMemo)(
    () => mergeArraysAndReplaceDefaults("type", _bindingUtils, defaultBindingUtils),
    [_bindingUtils]
  );
  const store = useTLStore({ snapshot: props.snapshot, shapeUtils: shapeUtilsWithDefaults });
  const {
    pageId,
    bounds,
    scale,
    pixelRatio,
    background,
    padding,
    darkMode,
    preserveAspectRatio,
    format = "svg",
    licenseKey,
    assetUrls,
    textOptions = defaultTextOptions
  } = props;
  const assetUrlsWithOverrides = useDefaultEditorAssetsWithOverrides(assetUrls);
  (0, import_react159.useLayoutEffect)(() => {
    if (!container) return;
    if (!store) return;
    let isCancelled = false;
    const tempElm = document.createElement("div");
    container.appendChild(tempElm);
    container.classList.add("tl-container", "tl-theme__light");
    const editor = new Editor({
      store,
      shapeUtils: shapeUtilsWithDefaults,
      bindingUtils: bindingUtilsWithDefaults,
      tools: [],
      getContainer: () => tempElm,
      licenseKey,
      fontAssetUrls: assetUrlsWithOverrides.fonts,
      textOptions
    });
    if (pageId) editor.setCurrentPage(pageId);
    const shapeIds = editor.getCurrentPageShapeIds();
    async function setSvg() {
      await editor.fonts.loadRequiredFontsForCurrentPage(editor.options.maxFontsToLoadBeforeRender);
      const imageResult = await editor.toImage([...shapeIds], {
        bounds,
        scale,
        background,
        padding,
        darkMode,
        preserveAspectRatio,
        format
      });
      if (!imageResult || isCancelled) return;
      const url2 = URL.createObjectURL(imageResult.blob);
      setUrl(url2);
      editor.dispose();
    }
    setSvg();
    return () => {
      isCancelled = true;
    };
  }, [
    format,
    container,
    store,
    shapeUtilsWithDefaults,
    bindingUtilsWithDefaults,
    pageId,
    bounds,
    scale,
    background,
    padding,
    darkMode,
    preserveAspectRatio,
    licenseKey,
    pixelRatio,
    assetUrlsWithOverrides,
    textOptions
  ]);
  (0, import_react159.useEffect)(() => {
    return () => {
      if (url) URL.revokeObjectURL(url);
    };
  }, [url]);
  return (0, import_jsx_runtime232.jsx)("div", { ref: setContainer, style: { position: "relative", width: "100%", height: "100%" }, children: url && (0, import_jsx_runtime232.jsx)(
    "img",
    {
      src: url,
      referrerPolicy: "strict-origin-when-cross-origin",
      style: { width: "100%", height: "100%" }
    }
  ) });
});

// ../node_modules/tldraw/dist-esm/lib/ui/components/HelpMenu/DefaultHelpMenu.mjs
var import_jsx_runtime233 = __toESM(require_jsx_runtime(), 1);
var import_react160 = __toESM(require_react(), 1);
var DefaultHelpMenu = (0, import_react160.memo)(function DefaultHelpMenu2({ children }) {
  const msg2 = useTranslation();
  const breakpoint = useBreakpoint();
  const ref = (0, import_react160.useRef)(null);
  usePassThroughWheelEvents(ref);
  const content = children ?? (0, import_jsx_runtime233.jsx)(DefaultHelpMenuContent, {});
  if (breakpoint < PORTRAIT_BREAKPOINT.MOBILE) return null;
  return (0, import_jsx_runtime233.jsx)("div", { ref, className: "tlui-help-menu", children: (0, import_jsx_runtime233.jsxs)(TldrawUiDropdownMenuRoot, { id: "help menu", children: [
    (0, import_jsx_runtime233.jsx)(TldrawUiDropdownMenuTrigger, { children: (0, import_jsx_runtime233.jsx)(TldrawUiButton, { type: "help", title: msg2("help-menu.title"), "data-testid": "help-menu.button", children: (0, import_jsx_runtime233.jsx)(TldrawUiButtonIcon, { icon: "question-mark", small: true }) }) }),
    (0, import_jsx_runtime233.jsx)(TldrawUiDropdownMenuContent, { side: "top", align: "end", alignOffset: 0, sideOffset: 8, children: (0, import_jsx_runtime233.jsx)(TldrawUiMenuContextProvider, { type: "menu", sourceId: "help-menu", children: content }) })
  ] }) });
});

// ../node_modules/tldraw/dist-esm/lib/ui/components/TopPanel/CenteredTopPanelContainer.mjs
var import_jsx_runtime234 = __toESM(require_jsx_runtime(), 1);
var import_react161 = __toESM(require_react(), 1);
function CenteredTopPanelContainer({
  maxWidth = 420,
  ignoreRightWidth = 0,
  stylePanelWidth = 148,
  marginBetweenZones = 12,
  squeezeAmount = 52,
  children
}) {
  const ref = (0, import_react161.useRef)(null);
  const breakpoint = useBreakpoint();
  const updateLayout = (0, import_react161.useCallback)(() => {
    const element = ref.current;
    if (!element) return;
    const layoutTop = element.parentElement.parentElement;
    const leftPanel = layoutTop.querySelector(".tlui-layout__top__left");
    const rightPanel = layoutTop.querySelector(".tlui-layout__top__right");
    const totalWidth = layoutTop.offsetWidth;
    const leftWidth = leftPanel.offsetWidth;
    const rightWidth = rightPanel.offsetWidth;
    const selfWidth = element.offsetWidth - ignoreRightWidth;
    let xCoordIfCentered = (totalWidth - selfWidth) / 2;
    if (totalWidth % 2 !== 0) {
      xCoordIfCentered -= 0.5;
    }
    const xCoordIfLeftAligned = leftWidth + marginBetweenZones;
    const left = element.offsetLeft;
    const maxWidthProperty = Math.min(
      totalWidth - rightWidth - leftWidth - 2 * marginBetweenZones,
      maxWidth
    );
    const xCoord = Math.max(xCoordIfCentered, xCoordIfLeftAligned) - left;
    if (rightPanel.offsetWidth > stylePanelWidth && breakpoint <= 6) {
      element.style.setProperty("max-width", maxWidthProperty - squeezeAmount + "px");
    } else {
      element.style.setProperty("max-width", maxWidthProperty + "px");
    }
    element.style.setProperty("transform", `translate(${xCoord}px, 0px)`);
  }, [breakpoint, ignoreRightWidth, marginBetweenZones, maxWidth, squeezeAmount, stylePanelWidth]);
  (0, import_react161.useLayoutEffect)(() => {
    const element = ref.current;
    if (!element) return;
    const layoutTop = element.parentElement.parentElement;
    const leftPanel = layoutTop.querySelector(".tlui-layout__top__left");
    const rightPanel = layoutTop.querySelector(".tlui-layout__top__right");
    const observer = new ResizeObserver(updateLayout);
    observer.observe(leftPanel);
    observer.observe(rightPanel);
    observer.observe(layoutTop);
    observer.observe(element);
    updateLayout();
    return () => {
      observer.disconnect();
    };
  }, [updateLayout]);
  (0, import_react161.useLayoutEffect)(() => {
    updateLayout();
  });
  return (0, import_jsx_runtime234.jsx)("div", { ref, className: "tlui-top-panel__container", children });
}

// ../node_modules/tldraw/dist-esm/lib/utils/assets/preload-font.mjs
async function preloadFont(id, font) {
  const {
    url,
    style: style2 = "normal",
    weight = "500",
    display,
    featureSettings,
    stretch,
    unicodeRange,
    variant,
    format
  } = font;
  const descriptors = {
    style: style2,
    weight,
    display,
    featureSettings,
    stretch,
    unicodeRange,
    // @ts-expect-error why is this here
    variant
  };
  const fontInstance = new FontFace(id, `url(${url})`, descriptors);
  await fontInstance.load();
  document.fonts.add(fontInstance);
  fontInstance.$$_url = url;
  fontInstance.$$_fontface = `
@font-face {
	font-family: ${fontInstance.family};
	font-stretch: ${fontInstance.stretch};
	font-weight: ${fontInstance.weight};
	font-style: ${fontInstance.style};
	src: url("${url}") format("${format}")
}`;
  return fontInstance;
}

// ../node_modules/tldraw/dist-esm/lib/utils/tldr/buildFromV1Document.mjs
var TLDRAW_V1_VERSION = 15.5;
function buildFromV1Document(editor, _document) {
  let document2 = _document;
  editor.run(() => {
    document2 = migrate2(document2, TLDRAW_V1_VERSION);
    editor.cancel().cancel().cancel().cancel();
    const firstPageId = editor.getPages()[0].id;
    editor.setCurrentPage(firstPageId);
    for (const page of editor.getPages().slice(1)) {
      editor.deletePage(page.id);
    }
    editor.selectAll();
    editor.deleteShapes(editor.getSelectedShapeIds());
    const v1AssetIdsToV2AssetIds = /* @__PURE__ */ new Map();
    Object.values(document2.assets ?? {}).forEach((v1Asset) => {
      switch (v1Asset.type) {
        case "image": {
          const assetId = AssetRecordType.createId();
          v1AssetIdsToV2AssetIds.set(v1Asset.id, assetId);
          const placeholderAsset = {
            id: assetId,
            typeName: "asset",
            type: "image",
            props: {
              w: coerceDimension(v1Asset.size[0]),
              h: coerceDimension(v1Asset.size[1]),
              name: v1Asset.fileName ?? "Untitled",
              isAnimated: false,
              mimeType: null,
              src: v1Asset.src
            },
            meta: {}
          };
          editor.createAssets([placeholderAsset]);
          tryMigrateAsset(editor, placeholderAsset);
          break;
        }
        case "video":
          {
            const assetId = AssetRecordType.createId();
            v1AssetIdsToV2AssetIds.set(v1Asset.id, assetId);
            editor.createAssets([
              {
                id: assetId,
                typeName: "asset",
                type: "video",
                props: {
                  w: coerceDimension(v1Asset.size[0]),
                  h: coerceDimension(v1Asset.size[1]),
                  name: v1Asset.fileName ?? "Untitled",
                  isAnimated: true,
                  mimeType: null,
                  src: v1Asset.src
                },
                meta: {}
              }
            ]);
          }
          break;
      }
    });
    const v1PageIdsToV2PageIds = /* @__PURE__ */ new Map();
    Object.values(document2.pages ?? {}).sort((a, b) => (a.childIndex ?? 1) < (b.childIndex ?? 1) ? -1 : 1).forEach((v1Page, i) => {
      if (i === 0) {
        v1PageIdsToV2PageIds.set(v1Page.id, editor.getCurrentPageId());
      } else {
        const pageId = PageRecordType.createId();
        v1PageIdsToV2PageIds.set(v1Page.id, pageId);
        editor.createPage({ name: v1Page.name ?? "Page", id: pageId });
      }
    });
    Object.values(document2.pages ?? {}).sort((a, b) => (a.childIndex ?? 1) < (b.childIndex ?? 1) ? -1 : 1).forEach((v1Page) => {
      editor.setCurrentPage(v1PageIdsToV2PageIds.get(v1Page.id));
      const v1ShapeIdsToV2ShapeIds = /* @__PURE__ */ new Map();
      const v1GroupShapeIdsToV1ChildIds = /* @__PURE__ */ new Map();
      const v1Shapes = Object.values(v1Page.shapes ?? {}).sort((a, b) => a.childIndex < b.childIndex ? -1 : 1).slice(0, editor.options.maxShapesPerPage);
      v1Shapes.forEach((v1Shape) => {
        if (v1Shape.type !== "group") return;
        const shapeId = createShapeId();
        v1ShapeIdsToV2ShapeIds.set(v1Shape.id, shapeId);
        v1GroupShapeIdsToV1ChildIds.set(v1Shape.id, []);
      });
      function decideNotToCreateShape(v1Shape) {
        v1ShapeIdsToV2ShapeIds.delete(v1Shape.id);
        const v1GroupParent = v1GroupShapeIdsToV1ChildIds.has(v1Shape.parentId);
        if (v1GroupParent) {
          const ids = v1GroupShapeIdsToV1ChildIds.get(v1Shape.parentId).filter((id) => id !== v1Shape.id);
          v1GroupShapeIdsToV1ChildIds.set(v1Shape.parentId, ids);
        }
      }
      v1Shapes.forEach((v1Shape) => {
        var _a6, _b3;
        if (v1Shape.type === "group") {
          return;
        }
        const shapeId = createShapeId();
        v1ShapeIdsToV2ShapeIds.set(v1Shape.id, shapeId);
        if (v1Shape.parentId !== v1Page.id) {
          if (v1GroupShapeIdsToV1ChildIds.has(v1Shape.parentId)) {
            v1GroupShapeIdsToV1ChildIds.get(v1Shape.parentId).push(v1Shape.id);
          } else {
            console.warn("parent does not exist", v1Shape);
          }
        }
        const parentId = v1PageIdsToV2PageIds.get(v1Page.id);
        const inCommon = {
          id: shapeId,
          parentId,
          x: coerceNumber(v1Shape.point[0]),
          y: coerceNumber(v1Shape.point[1]),
          rotation: 0,
          isLocked: !!v1Shape.isLocked
        };
        switch (v1Shape.type) {
          case "sticky": {
            editor.createShapes([
              {
                ...inCommon,
                type: "note",
                props: {
                  richText: toRichText(v1Shape.text ?? ""),
                  color: getV2Color(v1Shape.style.color),
                  size: getV2Size(v1Shape.style.size),
                  font: getV2Font(v1Shape.style.font),
                  align: getV2Align(v1Shape.style.textAlign)
                }
              }
            ]);
            break;
          }
          case "rectangle": {
            editor.createShapes([
              {
                ...inCommon,
                type: "geo",
                props: {
                  geo: "rectangle",
                  w: coerceDimension(v1Shape.size[0]),
                  h: coerceDimension(v1Shape.size[1]),
                  richText: toRichText(v1Shape.label ?? ""),
                  fill: getV2Fill(v1Shape.style.isFilled, v1Shape.style.color),
                  labelColor: getV2Color(v1Shape.style.color),
                  color: getV2Color(v1Shape.style.color),
                  size: getV2Size(v1Shape.style.size),
                  font: getV2Font(v1Shape.style.font),
                  dash: getV2Dash(v1Shape.style.dash),
                  align: "middle"
                }
              }
            ]);
            const pageBoundsBeforeLabel = editor.getShapePageBounds(inCommon.id);
            editor.updateShapes([
              {
                id: inCommon.id,
                type: "geo",
                props: {
                  richText: toRichText(v1Shape.label ?? "")
                }
              }
            ]);
            if (pageBoundsBeforeLabel.width === pageBoundsBeforeLabel.height) {
              const shape = editor.getShape(inCommon.id);
              const { growY } = shape.props;
              const w = coerceDimension(shape.props.w);
              const h2 = coerceDimension(shape.props.h);
              const newW = w + growY / 2;
              const newH = h2 + growY / 2;
              editor.updateShapes([
                {
                  id: inCommon.id,
                  type: "geo",
                  x: coerceNumber(shape.x) - (newW - w) / 2,
                  y: coerceNumber(shape.y) - (newH - h2) / 2,
                  props: {
                    w: newW,
                    h: newH
                  }
                }
              ]);
            }
            break;
          }
          case "triangle": {
            editor.createShapes([
              {
                ...inCommon,
                type: "geo",
                props: {
                  geo: "triangle",
                  w: coerceDimension(v1Shape.size[0]),
                  h: coerceDimension(v1Shape.size[1]),
                  fill: getV2Fill(v1Shape.style.isFilled, v1Shape.style.color),
                  labelColor: getV2Color(v1Shape.style.color),
                  color: getV2Color(v1Shape.style.color),
                  size: getV2Size(v1Shape.style.size),
                  font: getV2Font(v1Shape.style.font),
                  dash: getV2Dash(v1Shape.style.dash),
                  align: "middle"
                }
              }
            ]);
            const pageBoundsBeforeLabel = editor.getShapePageBounds(inCommon.id);
            editor.updateShapes([
              {
                id: inCommon.id,
                type: "geo",
                props: {
                  richText: toRichText(v1Shape.label ?? "")
                }
              }
            ]);
            if (pageBoundsBeforeLabel.width === pageBoundsBeforeLabel.height) {
              const shape = editor.getShape(inCommon.id);
              const { growY } = shape.props;
              const w = coerceDimension(shape.props.w);
              const h2 = coerceDimension(shape.props.h);
              const newW = w + growY / 2;
              const newH = h2 + growY / 2;
              editor.updateShapes([
                {
                  id: inCommon.id,
                  type: "geo",
                  x: coerceNumber(shape.x) - (newW - w) / 2,
                  y: coerceNumber(shape.y) - (newH - h2) / 2,
                  props: {
                    w: newW,
                    h: newH
                  }
                }
              ]);
            }
            break;
          }
          case "ellipse": {
            editor.createShapes([
              {
                ...inCommon,
                type: "geo",
                props: {
                  geo: "ellipse",
                  w: coerceDimension(v1Shape.radius[0]) * 2,
                  h: coerceDimension(v1Shape.radius[1]) * 2,
                  fill: getV2Fill(v1Shape.style.isFilled, v1Shape.style.color),
                  labelColor: getV2Color(v1Shape.style.color),
                  color: getV2Color(v1Shape.style.color),
                  size: getV2Size(v1Shape.style.size),
                  font: getV2Font(v1Shape.style.font),
                  dash: getV2Dash(v1Shape.style.dash),
                  align: "middle"
                }
              }
            ]);
            const pageBoundsBeforeLabel = editor.getShapePageBounds(inCommon.id);
            editor.updateShapes([
              {
                id: inCommon.id,
                type: "geo",
                props: {
                  richText: toRichText(v1Shape.label ?? "")
                }
              }
            ]);
            if (pageBoundsBeforeLabel.width === pageBoundsBeforeLabel.height) {
              const shape = editor.getShape(inCommon.id);
              const { growY } = shape.props;
              const w = coerceDimension(shape.props.w);
              const h2 = coerceDimension(shape.props.h);
              const newW = w + growY / 2;
              const newH = h2 + growY / 2;
              editor.updateShapes([
                {
                  id: inCommon.id,
                  type: "geo",
                  x: coerceNumber(shape.x) - (newW - w) / 2,
                  y: coerceNumber(shape.y) - (newH - h2) / 2,
                  props: {
                    w: newW,
                    h: newH
                  }
                }
              ]);
            }
            break;
          }
          case "draw": {
            if (v1Shape.points.length === 0) {
              decideNotToCreateShape(v1Shape);
              break;
            }
            const points = v1Shape.points.map(getV2Point);
            const base64Points = b64Vecs.encodePoints(points);
            editor.createShapes([
              {
                ...inCommon,
                type: "draw",
                props: {
                  fill: getV2Fill(v1Shape.style.isFilled, v1Shape.style.color),
                  color: getV2Color(v1Shape.style.color),
                  size: getV2Size(v1Shape.style.size),
                  dash: getV2Dash(v1Shape.style.dash),
                  isPen: false,
                  isComplete: v1Shape.isComplete,
                  segments: [{ type: "free", path: base64Points }],
                  scale: 1,
                  scaleX: 1,
                  scaleY: 1
                }
              }
            ]);
            break;
          }
          case "arrow": {
            const v1Bend = coerceNumber(v1Shape.bend);
            const v1Start = getV2Point(v1Shape.handles.start.point);
            const v1End = getV2Point(v1Shape.handles.end.point);
            const dist = Vec.Dist(v1Start, v1End);
            const v2Bend = dist * -v1Bend / 2;
            editor.createShapes([
              {
                ...inCommon,
                type: "arrow",
                props: {
                  richText: toRichText(v1Shape.label ?? ""),
                  color: getV2Color(v1Shape.style.color),
                  labelColor: getV2Color(v1Shape.style.color),
                  size: getV2Size(v1Shape.style.size),
                  font: getV2Font(v1Shape.style.font),
                  dash: getV2Dash(v1Shape.style.dash),
                  arrowheadStart: getV2Arrowhead((_a6 = v1Shape.decorations) == null ? void 0 : _a6.start),
                  arrowheadEnd: getV2Arrowhead((_b3 = v1Shape.decorations) == null ? void 0 : _b3.end),
                  start: {
                    x: coerceNumber(v1Shape.handles.start.point[0]),
                    y: coerceNumber(v1Shape.handles.start.point[1])
                  },
                  end: {
                    x: coerceNumber(v1Shape.handles.end.point[0]),
                    y: coerceNumber(v1Shape.handles.end.point[1])
                  },
                  bend: v2Bend
                }
              }
            ]);
            break;
          }
          case "text": {
            editor.createShapes([
              {
                ...inCommon,
                type: "text",
                props: {
                  richText: toRichText(v1Shape.text ?? " "),
                  color: getV2Color(v1Shape.style.color),
                  size: getV2TextSize(v1Shape.style.size),
                  font: getV2Font(v1Shape.style.font),
                  textAlign: getV2TextAlign(v1Shape.style.textAlign),
                  scale: v1Shape.style.scale ?? 1
                }
              }
            ]);
            break;
          }
          case "image": {
            const assetId = v1AssetIdsToV2AssetIds.get(v1Shape.assetId);
            if (!assetId) {
              console.warn("Could not find asset id", v1Shape.assetId);
              return;
            }
            editor.createShapes([
              {
                ...inCommon,
                type: "image",
                props: {
                  w: coerceDimension(v1Shape.size[0]),
                  h: coerceDimension(v1Shape.size[1]),
                  assetId
                }
              }
            ]);
            break;
          }
          case "video": {
            const assetId = v1AssetIdsToV2AssetIds.get(v1Shape.assetId);
            if (!assetId) {
              console.warn("Could not find asset id", v1Shape.assetId);
              return;
            }
            editor.createShapes([
              {
                ...inCommon,
                type: "video",
                props: {
                  w: coerceDimension(v1Shape.size[0]),
                  h: coerceDimension(v1Shape.size[1]),
                  assetId
                }
              }
            ]);
            break;
          }
        }
        const rotation = coerceNumber(v1Shape.rotation);
        if (rotation !== 0) {
          editor.select(shapeId);
          editor.rotateShapesBy([shapeId], rotation);
        }
      });
      v1GroupShapeIdsToV1ChildIds.forEach((v1ChildIds, v1GroupId) => {
        const v2ChildShapeIds = v1ChildIds.map((id) => v1ShapeIdsToV2ShapeIds.get(id));
        const v2GroupId = v1ShapeIdsToV2ShapeIds.get(v1GroupId);
        editor.groupShapes(v2ChildShapeIds, { groupId: v2GroupId });
        const v1Group = v1Page.shapes[v1GroupId];
        const rotation = coerceNumber(v1Group.rotation);
        if (rotation !== 0) {
          editor.select(v2GroupId);
          editor.rotateShapesBy([v2GroupId], rotation);
        }
      });
      v1Shapes.forEach((v1Shape) => {
        if (v1Shape.type !== "arrow") {
          return;
        }
        const v2ShapeId = v1ShapeIdsToV2ShapeIds.get(v1Shape.id);
        const util = editor.getShapeUtil("arrow");
        editor.inputs.setCtrlKey(false);
        for (const handleId of ["start", "end"]) {
          const bindingId = v1Shape.handles[handleId].bindingId;
          if (bindingId) {
            const binding = v1Page.bindings[bindingId];
            if (!binding) {
              continue;
            }
            const targetId = v1ShapeIdsToV2ShapeIds.get(binding.toId);
            const targetShape = editor.getShape(targetId);
            if (!targetShape) continue;
            if (targetId) {
              const bounds2 = editor.getShapePageBounds(targetId);
              const v2ShapeFresh = editor.getShape(v2ShapeId);
              const nx = clamp((coerceNumber(binding.point[0]) + 0.5) / 2, 0.2, 0.8);
              const ny = clamp((coerceNumber(binding.point[1]) + 0.5) / 2, 0.2, 0.8);
              const point = editor.getPointInShapeSpace(v2ShapeFresh, {
                x: bounds2.minX + bounds2.width * nx,
                y: bounds2.minY + bounds2.height * ny
              });
              const handles = editor.getShapeHandles(v2ShapeFresh);
              const change = util.onHandleDrag(v2ShapeFresh, {
                handle: {
                  ...handles.find((h2) => h2.id === handleId),
                  x: point.x,
                  y: point.y
                },
                isPrecise: point.x !== 0.5 || point.y !== 0.5,
                isCreatingShape: true
              });
              if (change) {
                editor.updateShape(change);
              }
              const freshBinding = getArrowBindings(
                editor,
                editor.getShape(v2ShapeId)
              )[handleId];
              if (freshBinding) {
                const updatedFreshBinding = structuredClone(freshBinding);
                if (binding.distance === 0) {
                  updatedFreshBinding.props.isExact = true;
                }
                if (updatedFreshBinding.toId !== targetId) {
                  updatedFreshBinding.toId = targetId;
                  updatedFreshBinding.props.normalizedAnchor = { x: nx, y: ny };
                }
                editor.updateBinding(updatedFreshBinding);
              }
            }
          }
        }
      });
    });
    editor.setCurrentPage(firstPageId);
    editor.clearHistory();
    editor.selectNone();
    const bounds = editor.getCurrentPageBounds();
    if (bounds) {
      editor.zoomToBounds(bounds, { targetZoom: 1 });
    }
  });
}
function coerceNumber(n) {
  if (typeof n !== "number") return 0;
  if (Number.isNaN(n)) return 0;
  if (!Number.isFinite(n)) return 0;
  return n;
}
function coerceDimension(d) {
  const n = coerceNumber(d);
  if (n <= 0) return 1;
  return n;
}
async function tryMigrateAsset(editor, placeholderAsset) {
  try {
    if (placeholderAsset.type === "bookmark" || !placeholderAsset.props.src) return;
    const response = await fetch2(placeholderAsset.props.src);
    if (!response.ok) return;
    const file = new File([await response.blob()], placeholderAsset.props.name, {
      type: response.headers.get("content-type") ?? placeholderAsset.props.mimeType ?? void 0
    });
    const newAsset = await editor.getAssetForExternalContent({ type: "file", file });
    if (!newAsset) throw new Error("Could not get asset for external content");
    if (newAsset.type === "bookmark") return;
    editor.updateAssets([
      {
        id: placeholderAsset.id,
        type: placeholderAsset.type,
        props: {
          ...newAsset.props,
          name: placeholderAsset.props.name
        }
      }
    ]);
  } catch {
  }
}
function migrate2(document2, newVersion) {
  const { version: version2 = 0 } = document2;
  if (!document2.assets) {
    document2.assets = {};
  }
  const assetIdsInUse = /* @__PURE__ */ new Set();
  Object.values(document2.pages).forEach(
    (page) => Object.values(page.shapes).forEach((shape) => {
      const { parentId, children, assetId } = shape;
      if (assetId) {
        assetIdsInUse.add(assetId);
      }
      if (parentId !== page.id && !page.shapes[parentId]) {
        console.warn("Encountered a shape with a missing parent!");
        shape.parentId = page.id;
      }
      if (shape.type === "group" && children) {
        children.forEach((childId) => {
          if (!page.shapes[childId]) {
            console.warn("Encountered a parent with a missing child!", shape.id, childId);
            children == null ? void 0 : children.splice(children.indexOf(childId), 1);
          }
        });
      }
    })
  );
  Object.keys(document2.assets).forEach((assetId) => {
    if (!assetIdsInUse.has(assetId)) {
      delete document2.assets[assetId];
    }
  });
  if (version2 !== newVersion) {
    if (version2 < 14) {
      Object.values(document2.pages).forEach((page) => {
        Object.values(page.shapes).filter(
          (shape) => shape.type === "text"
          /* Text */
        ).forEach((shape) => {
          if (shape.style.font === void 0) {
            ;
            shape.style.font = "script";
          }
        });
      });
    }
    if (version2 <= 13) {
      Object.values(document2.pages).forEach((page) => {
        Object.values(page.bindings).forEach((binding) => {
          Object.assign(binding, binding.meta);
        });
        Object.values(page.shapes).forEach((shape) => {
          Object.entries(shape.style).forEach(([id, style2]) => {
            if (typeof style2 === "string") {
              shape.style[id] = style2.toLowerCase();
            }
          });
          if (shape.type === "arrow") {
            if (shape.decorations) {
              Object.entries(shape.decorations).forEach(([id, decoration]) => {
                if (decoration === "Arrow") {
                  shape.decorations = {
                    ...shape.decorations,
                    [id]: "arrow"
                    /* Arrow */
                  };
                }
              });
            }
          }
        });
      });
    }
    if (version2 <= 13.1 && document2.name == null) {
      document2.name = "New Document";
    }
    if (version2 < 15 && document2.assets == null) {
      document2.assets = {};
    }
    Object.values(document2.pages).forEach((page) => {
      Object.values(page.shapes).forEach((shape) => {
        if (version2 < 15.2) {
          if ((shape.type === "image" || shape.type === "video") && shape.style.isFilled == null) {
            shape.style.isFilled = true;
          }
        }
        if (version2 < 15.3) {
          if (shape.type === "rectangle" || shape.type === "triangle" || shape.type === "ellipse" || shape.type === "arrow") {
            if ("text" in shape && typeof shape.text === "string") {
              shape.label = shape.text;
            }
            if (!shape.label) {
              shape.label = "";
            }
            if (!shape.labelPoint) {
              shape.labelPoint = [0.5, 0.5];
            }
          }
        }
      });
    });
  }
  Object.values(document2.pageStates).forEach((pageState) => {
    pageState.selectedIds = pageState.selectedIds.filter((id) => {
      return document2.pages[pageState.id].shapes[id] !== void 0;
    });
    pageState.bindingId = void 0;
    pageState.editingId = void 0;
    pageState.hoveredId = void 0;
    pageState.pointedId = void 0;
  });
  document2.version = newVersion;
  return document2;
}
var TLV1ShapeType = ((TLV1ShapeType2) => {
  TLV1ShapeType2["Sticky"] = "sticky";
  TLV1ShapeType2["Ellipse"] = "ellipse";
  TLV1ShapeType2["Rectangle"] = "rectangle";
  TLV1ShapeType2["Triangle"] = "triangle";
  TLV1ShapeType2["Draw"] = "draw";
  TLV1ShapeType2["Arrow"] = "arrow";
  TLV1ShapeType2["Text"] = "text";
  TLV1ShapeType2["Group"] = "group";
  TLV1ShapeType2["Image"] = "image";
  TLV1ShapeType2["Video"] = "video";
  return TLV1ShapeType2;
})(TLV1ShapeType || {});
var TLV1ColorStyle = ((TLV1ColorStyle2) => {
  TLV1ColorStyle2["White"] = "white";
  TLV1ColorStyle2["LightGray"] = "lightGray";
  TLV1ColorStyle2["Gray"] = "gray";
  TLV1ColorStyle2["Black"] = "black";
  TLV1ColorStyle2["Green"] = "green";
  TLV1ColorStyle2["Cyan"] = "cyan";
  TLV1ColorStyle2["Blue"] = "blue";
  TLV1ColorStyle2["Indigo"] = "indigo";
  TLV1ColorStyle2["Violet"] = "violet";
  TLV1ColorStyle2["Red"] = "red";
  TLV1ColorStyle2["Orange"] = "orange";
  TLV1ColorStyle2["Yellow"] = "yellow";
  return TLV1ColorStyle2;
})(TLV1ColorStyle || {});
var TLV1SizeStyle = ((TLV1SizeStyle2) => {
  TLV1SizeStyle2["Small"] = "small";
  TLV1SizeStyle2["Medium"] = "medium";
  TLV1SizeStyle2["Large"] = "large";
  return TLV1SizeStyle2;
})(TLV1SizeStyle || {});
var TLV1DashStyle = ((TLV1DashStyle2) => {
  TLV1DashStyle2["Draw"] = "draw";
  TLV1DashStyle2["Solid"] = "solid";
  TLV1DashStyle2["Dashed"] = "dashed";
  TLV1DashStyle2["Dotted"] = "dotted";
  return TLV1DashStyle2;
})(TLV1DashStyle || {});
var TLV1AlignStyle = ((TLV1AlignStyle2) => {
  TLV1AlignStyle2["Start"] = "start";
  TLV1AlignStyle2["Middle"] = "middle";
  TLV1AlignStyle2["End"] = "end";
  TLV1AlignStyle2["Justify"] = "justify";
  return TLV1AlignStyle2;
})(TLV1AlignStyle || {});
var TLV1FontStyle = ((TLV1FontStyle2) => {
  TLV1FontStyle2["Script"] = "script";
  TLV1FontStyle2["Sans"] = "sans";
  TLV1FontStyle2["Serif"] = "serif";
  TLV1FontStyle2["Mono"] = "mono";
  return TLV1FontStyle2;
})(TLV1FontStyle || {});
var TLV1Decoration = ((TLV1Decoration2) => {
  TLV1Decoration2["Arrow"] = "arrow";
  return TLV1Decoration2;
})(TLV1Decoration || {});
var TLV1AssetType = ((TLV1AssetType2) => {
  TLV1AssetType2["Image"] = "image";
  TLV1AssetType2["Video"] = "video";
  return TLV1AssetType2;
})(TLV1AssetType || {});
var v1ColorsToV2Colors = {
  [
    "white"
    /* White */
  ]: "black",
  [
    "black"
    /* Black */
  ]: "black",
  [
    "lightGray"
    /* LightGray */
  ]: "grey",
  [
    "gray"
    /* Gray */
  ]: "grey",
  [
    "green"
    /* Green */
  ]: "light-green",
  [
    "cyan"
    /* Cyan */
  ]: "green",
  [
    "blue"
    /* Blue */
  ]: "light-blue",
  [
    "indigo"
    /* Indigo */
  ]: "blue",
  [
    "orange"
    /* Orange */
  ]: "orange",
  [
    "yellow"
    /* Yellow */
  ]: "yellow",
  [
    "red"
    /* Red */
  ]: "red",
  [
    "violet"
    /* Violet */
  ]: "light-violet"
};
var v1FontsToV2Fonts = {
  [
    "mono"
    /* Mono */
  ]: "mono",
  [
    "sans"
    /* Sans */
  ]: "sans",
  [
    "script"
    /* Script */
  ]: "draw",
  [
    "serif"
    /* Serif */
  ]: "serif"
};
var v1AlignsToV2Aligns = {
  [
    "start"
    /* Start */
  ]: "start",
  [
    "middle"
    /* Middle */
  ]: "middle",
  [
    "end"
    /* End */
  ]: "end",
  [
    "justify"
    /* Justify */
  ]: "start"
};
var v1TextAlignsToV2TextAligns = {
  [
    "start"
    /* Start */
  ]: "start",
  [
    "middle"
    /* Middle */
  ]: "middle",
  [
    "end"
    /* End */
  ]: "end",
  [
    "justify"
    /* Justify */
  ]: "start"
};
var v1TextSizesToV2TextSizes = {
  [
    "small"
    /* Small */
  ]: "s",
  [
    "medium"
    /* Medium */
  ]: "l",
  [
    "large"
    /* Large */
  ]: "xl"
};
var v1SizesToV2Sizes = {
  [
    "small"
    /* Small */
  ]: "m",
  [
    "medium"
    /* Medium */
  ]: "l",
  [
    "large"
    /* Large */
  ]: "xl"
};
var v1DashesToV2Dashes = {
  [
    "solid"
    /* Solid */
  ]: "solid",
  [
    "dashed"
    /* Dashed */
  ]: "dashed",
  [
    "dotted"
    /* Dotted */
  ]: "dotted",
  [
    "draw"
    /* Draw */
  ]: "draw"
};
function getV2Color(color) {
  return color ? v1ColorsToV2Colors[color] ?? "black" : "black";
}
function getV2Font(font) {
  return font ? v1FontsToV2Fonts[font] ?? "draw" : "draw";
}
function getV2Align(align) {
  return align ? v1AlignsToV2Aligns[align] ?? "middle" : "middle";
}
function getV2TextAlign(align) {
  return align ? v1TextAlignsToV2TextAligns[align] ?? "middle" : "middle";
}
function getV2TextSize(size4) {
  return size4 ? v1TextSizesToV2TextSizes[size4] ?? "m" : "m";
}
function getV2Size(size4) {
  return size4 ? v1SizesToV2Sizes[size4] ?? "l" : "l";
}
function getV2Dash(dash) {
  return dash ? v1DashesToV2Dashes[dash] ?? "draw" : "draw";
}
function getV2Point(point) {
  return {
    x: coerceNumber(point[0]),
    y: coerceNumber(point[1]),
    z: point[2] == null ? 0.5 : coerceNumber(point[2])
  };
}
function getV2Arrowhead(decoration) {
  return decoration === "arrow" ? "arrow" : "none";
}
function getV2Fill(isFilled, color) {
  return isFilled ? color === "black" || color === "white" ? "semi" : "solid" : "none";
}

// ../node_modules/tldraw/dist-esm/lib/utils/tldr/file.mjs
var TLDRAW_FILE_MIMETYPE = "application/vnd.tldraw+json";
var TLDRAW_FILE_EXTENSION = ".tldr";
var LATEST_TLDRAW_FILE_FORMAT_VERSION = 1;
var schemaV1 = validation_exports.object({
  schemaVersion: validation_exports.literal(1),
  storeVersion: validation_exports.positiveInteger,
  recordVersions: validation_exports.dict(
    validation_exports.string,
    validation_exports.object({
      version: validation_exports.positiveInteger,
      subTypeVersions: validation_exports.dict(validation_exports.string, validation_exports.positiveInteger).optional(),
      subTypeKey: validation_exports.string.optional()
    })
  )
});
var schemaV2 = validation_exports.object({
  schemaVersion: validation_exports.literal(2),
  sequences: validation_exports.dict(validation_exports.string, validation_exports.positiveInteger)
});
var tldrawFileValidator = validation_exports.object({
  tldrawFileFormatVersion: validation_exports.nonZeroInteger,
  schema: validation_exports.numberUnion("schemaVersion", {
    1: schemaV1,
    2: schemaV2
  }),
  records: validation_exports.arrayOf(
    validation_exports.object({
      id: validation_exports.string,
      typeName: validation_exports.string
    }).allowUnknownProperties()
  )
});
function isV1File(data) {
  var _a6;
  try {
    if ((_a6 = data.document) == null ? void 0 : _a6.version) {
      return true;
    }
    return false;
  } catch {
    return false;
  }
}
function parseTldrawJsonFile({
  json,
  schema
}) {
  let data;
  try {
    data = tldrawFileValidator.validate(JSON.parse(json));
  } catch (e) {
    try {
      data = JSON.parse(json);
      if (isV1File(data)) {
        return Result.err({ type: "v1File", data });
      }
    } catch {
    }
    return Result.err({ type: "notATldrawFile", cause: e });
  }
  if (data.tldrawFileFormatVersion > LATEST_TLDRAW_FILE_FORMAT_VERSION) {
    return Result.err({
      type: "fileFormatVersionTooNew",
      version: data.tldrawFileFormatVersion
    });
  }
  let migrationResult;
  let storeSnapshot;
  try {
    const records = pruneUnusedAssets(data.records);
    storeSnapshot = Object.fromEntries(records.map((r) => [r.id, r]));
    migrationResult = schema.migrateStoreSnapshot({ store: storeSnapshot, schema: data.schema });
  } catch (e) {
    return Result.err({ type: "invalidRecords", cause: e });
  }
  if (migrationResult.type === "error") {
    return Result.err({ type: "migrationFailed", reason: migrationResult.reason });
  }
  try {
    return Result.ok(
      createTLStore({
        snapshot: { store: storeSnapshot, schema: data.schema },
        schema
      })
    );
  } catch (e) {
    return Result.err({ type: "invalidRecords", cause: e });
  }
}
function pruneUnusedAssets(records) {
  const usedAssets = /* @__PURE__ */ new Set();
  for (const record of records) {
    if (record.typeName === "shape" && "assetId" in record.props && record.props.assetId) {
      usedAssets.add(record.props.assetId);
    }
  }
  return records.filter((r) => r.typeName !== "asset" || usedAssets.has(r.id));
}
async function serializeTldrawJson(editor) {
  const records = [];
  for (const record of editor.store.allRecords()) {
    switch (record.typeName) {
      case "asset":
        if (record.type !== "bookmark" && record.props.src && !record.props.src.startsWith("data:")) {
          let assetSrcToSave;
          try {
            let src = record.props.src;
            if (!src.startsWith("http")) {
              src = await editor.resolveAssetUrl(record.id, { shouldResolveToOriginal: true }) || "";
            }
            assetSrcToSave = await FileHelpers.blobToDataUrl(await (await fetch2(src)).blob());
          } catch {
            assetSrcToSave = record.props.src;
          }
          records.push({
            ...record,
            props: {
              ...record.props,
              src: assetSrcToSave
            }
          });
        } else {
          records.push(record);
        }
        break;
      default:
        records.push(record);
        break;
    }
  }
  return JSON.stringify({
    tldrawFileFormatVersion: LATEST_TLDRAW_FILE_FORMAT_VERSION,
    schema: editor.store.schema.serialize(),
    records: pruneUnusedAssets(records)
  });
}
async function serializeTldrawJsonBlob(editor) {
  return new Blob([await serializeTldrawJson(editor)], { type: TLDRAW_FILE_MIMETYPE });
}
async function parseAndLoadDocument(editor, document2, msg2, addToast, onV1FileLoad, forceDarkMode) {
  const parseFileResult = parseTldrawJsonFile({
    schema: editor.store.schema,
    json: document2
  });
  if (!parseFileResult.ok) {
    let description;
    switch (parseFileResult.error.type) {
      case "notATldrawFile":
        editor.annotateError(parseFileResult.error.cause, {
          origin: "file-system.open.parse",
          willCrashApp: false,
          tags: { parseErrorType: parseFileResult.error.type }
        });
        reportError(parseFileResult.error.cause);
        description = msg2("file-system.file-open-error.not-a-tldraw-file");
        break;
      case "fileFormatVersionTooNew":
        description = msg2("file-system.file-open-error.file-format-version-too-new");
        break;
      case "migrationFailed":
        if (parseFileResult.error.reason === MigrationFailureReason.TargetVersionTooNew) {
          description = msg2("file-system.file-open-error.file-format-version-too-new");
        } else {
          description = msg2("file-system.file-open-error.generic-corrupted-file");
        }
        break;
      case "invalidRecords":
        editor.annotateError(parseFileResult.error.cause, {
          origin: "file-system.open.parse",
          willCrashApp: false,
          tags: { parseErrorType: parseFileResult.error.type }
        });
        reportError(parseFileResult.error.cause);
        description = msg2("file-system.file-open-error.generic-corrupted-file");
        break;
      case "v1File": {
        buildFromV1Document(editor, parseFileResult.error.data.document);
        onV1FileLoad == null ? void 0 : onV1FileLoad();
        return;
      }
      default:
        exhaustiveSwitchError(parseFileResult.error, "type");
    }
    addToast({
      title: msg2("file-system.file-open-error.title"),
      description,
      severity: "error"
    });
    return;
  }
  transact(() => {
    const snapshot = parseFileResult.value.getStoreSnapshot();
    editor.loadSnapshot(snapshot);
    editor.clearHistory();
    extractAssets(editor, snapshot, msg2, addToast);
    const bounds = editor.getCurrentPageBounds();
    if (bounds) {
      editor.zoomToBounds(bounds, { targetZoom: 1, immediate: true });
    }
  });
  if (forceDarkMode) editor.user.updateUserPreferences({ colorScheme: "dark" });
}
async function extractAssets(editor, snapshot, msg2, addToast) {
  const mediaAssets = /* @__PURE__ */ new Map();
  for (const record of Object.values(snapshot.store)) {
    if (record.typeName === "asset" && record.props.src && record.props.src.startsWith("data:") && (record.type === "image" || record.type === "video")) {
      mediaAssets.set(record.id, record);
    }
  }
  Promise.allSettled(
    [...mediaAssets].map(async ([id, asset]) => {
      try {
        const blob = await fetch2(asset.props.src).then((r) => r.blob());
        const file = new File([blob], asset.props.name, {
          type: asset.props.mimeType
        });
        const newAsset = await editor.getAssetForExternalContent({
          type: "file",
          file
        });
        if (!newAsset) {
          throw Error("Could not create an asset");
        }
        editor.updateAssets([{ ...newAsset, id }]);
      } catch (error) {
        addToast({
          title: msg2("assets.files.upload-failed"),
          severity: "error"
        });
        console.error(error);
        return;
      }
    })
  );
}

// ../node_modules/tldraw/dist-esm/index.mjs
registerTldrawLibraryVersion(
  "tldraw",
  "4.3.1",
  "esm"
);
var export_isEqual = import_lodash.default;
var export_isEqualWith = import_lodash2.default;
var export_throttle = import_lodash3.default;
export {
  ARROW_LABEL_FONT_SIZES,
  ASPECT_RATIO_OPTIONS,
  ASPECT_RATIO_TO_VALUE,
  AccessibilityMenu,
  AlignMenuItems,
  Arc2d,
  ArrangeMenuSubmenu,
  ArrayOfValidator,
  ArraySet,
  ArrowBindingUtil,
  ArrowDownToolbarItem,
  ArrowLeftToolbarItem,
  ArrowRightToolbarItem,
  ArrowShapeArrowheadEndStyle,
  ArrowShapeArrowheadStartStyle,
  ArrowShapeKindStyle,
  ArrowShapeTool,
  ArrowShapeUtil,
  ArrowToolbarItem,
  ArrowUpToolbarItem,
  AssetRecordType,
  AssetToolbarItem,
  AssetUrlsProvider,
  AtomMap,
  AtomSet,
  BaseBoxShapeTool,
  BaseBoxShapeUtil,
  BindingUtil,
  BookmarkShapeUtil,
  BoundsSnaps,
  Box,
  BreakPointProvider,
  CameraRecordType,
  CenteredTopPanelContainer,
  CheckBoxToolbarItem,
  Circle2d,
  ClickManager,
  ClipboardMenuGroup,
  CloudToolbarItem,
  ColorSchemeMenu,
  ContainerProvider,
  DefaultContextMenu as ContextMenu,
  ConversionsMenuGroup,
  ConvertToBookmarkMenuItem,
  ConvertToEmbedMenuItem,
  CopyAsMenuGroup,
  CopyMenuItem,
  CubicBezier2d,
  CubicSpline2d,
  CursorChatItem,
  CutMenuItem,
  DEFAULT_ANIMATION_OPTIONS,
  DEFAULT_CAMERA_OPTIONS,
  DEFAULT_EMBED_DEFINITIONS,
  DEFAULT_MAX_ASSET_SIZE,
  DEFAULT_MAX_IMAGE_DIMENSION,
  DEFAULT_SUPPORTED_IMAGE_TYPES,
  DEFAULT_SUPPORTED_MEDIA_TYPES,
  DEFAULT_SUPPORTED_MEDIA_TYPE_LIST,
  DEFAULT_SUPPORT_VIDEO_TYPES,
  DebugFlags,
  DefaultA11yAnnouncer,
  DefaultActionsMenu,
  DefaultActionsMenuContent,
  DefaultBackground,
  DefaultBrush,
  DefaultCanvas,
  DefaultCollaboratorHint,
  DefaultColorStyle,
  DefaultColorThemePalette,
  DefaultContextMenu,
  DefaultContextMenuContent,
  DefaultCursor,
  DefaultDashStyle,
  DefaultDebugMenu,
  DefaultDebugMenuContent,
  DefaultDialogs,
  DefaultErrorFallback,
  DefaultFillStyle,
  DefaultFollowingIndicator,
  DefaultFontFaces,
  DefaultFontFamilies,
  DefaultFontStyle,
  DefaultGrid,
  DefaultHandle,
  DefaultHandles,
  DefaultHelpMenu,
  DefaultHelpMenuContent,
  DefaultHelperButtons,
  DefaultHelperButtonsContent,
  DefaultHorizontalAlignStyle,
  DefaultImageToolbar,
  DefaultImageToolbarContent,
  DefaultKeyboardShortcutsDialog,
  DefaultKeyboardShortcutsDialogContent,
  DefaultLabelColorStyle,
  DefaultMainMenu,
  DefaultMainMenuContent,
  DefaultMenuPanel,
  DefaultMinimap,
  DefaultNavigationPanel,
  DefaultPageMenu,
  DefaultQuickActions,
  DefaultQuickActionsContent,
  DefaultRichTextToolbar,
  DefaultRichTextToolbarContent,
  DefaultScribble,
  DefaultSelectionBackground,
  DefaultSelectionForeground,
  DefaultShapeIndicator,
  DefaultShapeIndicators,
  DefaultShapeWrapper,
  DefaultSharePanel,
  DefaultSizeStyle,
  DefaultSnapIndicator,
  DefaultSpinner,
  DefaultStylePanel,
  DefaultStylePanelContent,
  DefaultSvgDefs,
  DefaultTextAlignStyle,
  DefaultToasts,
  DefaultToolbar,
  DefaultToolbarContent,
  DefaultVerticalAlignStyle,
  DefaultVideoToolbar,
  DefaultVideoToolbarContent,
  DefaultZoomMenu,
  DefaultZoomMenuContent,
  DeleteMenuItem,
  DiamondToolbarItem,
  DictValidator,
  DistributeMenuItems,
  DocumentRecordType,
  DrawShapeTool,
  DrawShapeUtil,
  DrawToolbarItem,
  DuplicateMenuItem,
  EASINGS,
  EMPTY_ARRAY,
  EVENT_NAME_MAP,
  Edge2d,
  EdgeScrollManager,
  EditLinkMenuItem2 as EditLinkMenuItem,
  EditMenuSubmenu,
  EditSubmenu,
  Editor,
  EditorAtom,
  EditorContext,
  EditorProvider,
  EffectScheduler,
  ElbowArrowSnap,
  Ellipse2d,
  EllipseToolbarItem,
  EmbedShapeUtil,
  EnumStyleProp,
  EraserTool,
  EraserToolbarItem,
  ErrorBoundary,
  ErrorScreen,
  ExampleDialog,
  ExecutionQueue,
  ExportFileContentSubMenu,
  ExtrasGroup,
  FONT_FAMILIES,
  FONT_SIZES,
  FeatureFlags,
  FileHelpers,
  FitFrameToContentMenuItem,
  FontManager,
  FrameShapeTool,
  FrameShapeUtil,
  FrameToolbarItem,
  GeoShapeGeoStyle,
  GeoShapeTool,
  GeoShapeUtil,
  Geometry2d,
  Geometry2dFilters,
  Group2d,
  GroupMenuItem2 as GroupMenuItem,
  GroupOrUngroupMenuItem,
  GroupShapeUtil,
  HALF_PI,
  HTMLContainer,
  HandTool,
  HandToolbarItem,
  HandleSnaps,
  HeartToolbarItem,
  HexagonToolbarItem,
  HighlightShapeTool,
  HighlightShapeUtil,
  HighlightToolbarItem,
  HistoryManager,
  Image,
  ImageShapeCrop,
  ImageShapeUtil,
  IncrementalSetConstructor,
  InputsManager,
  InstancePageStateRecordType,
  InstancePresenceRecordType,
  KeyboardShiftEnterTweakExtension,
  KeyboardShortcutsMenuItem,
  LABEL_FONT_SIZES,
  LANGUAGES,
  LICENSE_TIMEOUT,
  LanguageMenu,
  LaserTool,
  LaserToolbarItem,
  LicenseManager,
  LineShapeSplineStyle,
  LineShapeTool,
  LineShapeUtil,
  LineToolbarItem,
  LoadingScreen,
  LocalIndexedDb,
  LockGroup,
  Mat,
  MediaHelpers,
  MenuClickCapture,
  MigrationFailureReason,
  MiscMenuGroup,
  MobileStylePanel,
  MoveToPageMenu,
  NoteShapeTool,
  NoteShapeUtil,
  NoteToolbarItem,
  ObjectValidator,
  OfflineIndicator,
  OptionalErrorBoundary,
  OvalToolbarItem,
  OverflowingToolbar,
  PI,
  PI2,
  PORTRAIT_BREAKPOINT,
  PageItemInput,
  PageItemSubmenu,
  PageRecordType,
  PasteMenuItem,
  PathBuilder,
  PathBuilderGeometry2d,
  PeopleMenu,
  PerformanceTracker,
  PlainTextArea,
  PlainTextLabel,
  PngHelpers,
  Point2d,
  PointerRecordType,
  Polygon2d,
  Polyline2d,
  PreferencesGroup,
  PrintItem,
  RESET_VALUE,
  ROTATE_CORNER_TO_SELECTION_CORNER,
  ReadonlySharedStyleMap,
  RecordType,
  Rectangle2d,
  RectangleToolbarItem,
  RemoveFrameMenuItem,
  ReorderMenuItems,
  ReorderMenuSubmenu,
  Result,
  RhombusToolbarItem,
  RichTextArea,
  RichTextLabel,
  RichTextSVG,
  RotateCWMenuItem,
  SIDES,
  SIN,
  STROKE_SIZES2 as STROKE_SIZES,
  STRUCTURED_CLONE_OBJECT_PROTOTYPE,
  SVGContainer,
  ScribbleManager,
  SelectAllMenuItem,
  SelectTool,
  SelectToolbarItem,
  ShapeUtil,
  SharedStyleMap,
  SnapManager,
  Spinner,
  StackMenuItems,
  Stadium2d,
  StarToolbarItem,
  StateNode,
  Store,
  StoreQueries,
  StoreSchema,
  StoreSideEffects,
  StylePanelArrowKindPicker,
  StylePanelArrowheadPicker,
  StylePanelButtonPicker,
  StylePanelButtonPickerInline,
  StylePanelColorPicker,
  StylePanelContextProvider,
  StylePanelDashPicker,
  StylePanelDoubleDropdownPicker,
  StylePanelDoubleDropdownPickerInline,
  StylePanelDropdownPicker,
  StylePanelDropdownPickerInline,
  StylePanelFillPicker,
  StylePanelFontPicker,
  StylePanelGeoShapePicker,
  StylePanelLabelAlignPicker,
  StylePanelOpacityPicker,
  StylePanelSection,
  StylePanelSizePicker,
  StylePanelSplinePicker,
  StylePanelSubheading,
  StylePanelTextAlignPicker,
  StyleProp,
  validation_exports as T,
  TAB_ID,
  TEXT_PROPS,
  TLDOCUMENT_ID,
  TLDRAW_FILE_EXTENSION,
  TLINSTANCE_ID,
  TLPOINTER_ID,
  TLV1AlignStyle,
  TLV1AssetType,
  TLV1ColorStyle,
  TLV1DashStyle,
  TLV1Decoration,
  TLV1FontStyle,
  TLV1ShapeType,
  TLV1SizeStyle,
  TL_CANVAS_UI_COLOR_TYPES,
  TL_CURSOR_TYPES,
  TL_HANDLE_TYPES,
  TL_SCRIBBLE_STATES,
  Table,
  TextManager,
  TextShapeTool,
  TextShapeUtil,
  TextToolbarItem,
  TickManager,
  Timers,
  Tldraw,
  TldrawArrowHints,
  TldrawCropHandles,
  TldrawEditor,
  TldrawHandles,
  TldrawImage,
  TldrawOverlays,
  TldrawScribble,
  TldrawSelectionForeground,
  TldrawShapeIndicators,
  TldrawUi,
  TldrawUiA11yProvider,
  TldrawUiButton,
  TldrawUiButtonCheck,
  TldrawUiButtonIcon,
  TldrawUiButtonLabel,
  TldrawUiColumn,
  TldrawUiComponentsProvider,
  TldrawUiContextProvider,
  TldrawUiContextualToolbar,
  TldrawUiDialogBody,
  TldrawUiDialogCloseButton,
  TldrawUiDialogFooter,
  TldrawUiDialogHeader,
  TldrawUiDialogTitle,
  TldrawUiDialogsProvider,
  TldrawUiDropdownMenuCheckboxItem,
  TldrawUiDropdownMenuContent,
  TldrawUiDropdownMenuGroup,
  TldrawUiDropdownMenuIndicator,
  TldrawUiDropdownMenuItem,
  TldrawUiDropdownMenuRoot,
  TldrawUiDropdownMenuSub,
  TldrawUiDropdownMenuSubTrigger,
  TldrawUiDropdownMenuTrigger,
  TldrawUiEventsProvider,
  TldrawUiGrid,
  TldrawUiIcon,
  TldrawUiInFrontOfTheCanvas,
  TldrawUiInput,
  TldrawUiKbd,
  TldrawUiMenuActionCheckboxItem,
  TldrawUiMenuActionItem,
  TldrawUiMenuCheckboxItem,
  TldrawUiMenuContextProvider,
  TldrawUiMenuGroup,
  TldrawUiMenuItem,
  TldrawUiMenuSubmenu,
  TldrawUiMenuToolItem,
  TldrawUiOrientationProvider,
  TldrawUiPopover,
  TldrawUiPopoverContent,
  TldrawUiPopoverTrigger,
  TldrawUiRow,
  TldrawUiSlider,
  TldrawUiToastsProvider,
  TldrawUiToolbar,
  TldrawUiToolbarButton,
  TldrawUiToolbarToggleGroup,
  TldrawUiToolbarToggleItem,
  TldrawUiTooltip,
  TldrawUiTooltipProvider,
  TldrawUiTranslationProvider,
  ToggleAutoSizeMenuItem,
  ToggleDebugModeItem,
  ToggleDynamicSizeModeItem,
  ToggleEdgeScrollingItem,
  ToggleEnhancedA11yModeItem,
  ToggleFocusModeItem,
  ToggleGridItem,
  ToggleKeyboardShortcutsItem,
  ToggleLockMenuItem,
  TogglePasteAtCursorItem,
  ToggleReduceMotionItem,
  ToggleSnapModeItem,
  ToggleToolLockItem,
  ToggleToolLockedButton,
  ToggleTransparentBgMenuItem,
  ToggleWrapModeItem,
  ToolbarItem,
  TransformedGeometry2d,
  TrapezoidToolbarItem,
  TriangleToolbarItem,
  UNINITIALIZED,
  USER_COLORS,
  UndoRedoGroup,
  UngroupMenuItem2 as UngroupMenuItem,
  UnionValidator,
  UnlockAllMenuItem,
  UserPreferencesManager,
  Validator,
  Vec,
  VideoShapeUtil,
  ViewSubmenu,
  WeakCache,
  XBoxToolbarItem,
  ZERO_INDEX_KEY,
  ZoomOrRotateMenuItem,
  ZoomTo100MenuItem,
  ZoomToFitMenuItem,
  ZoomToSelectionMenuItem,
  ZoomTool,
  activeElementShouldCaptureKeys,
  allDefaultFontFaces,
  angleDistance,
  annotateError,
  applyRotationToSnapshotShapes,
  approximately,
  areAnglesCompatible,
  areArraysShallowEqual,
  areObjectsShallowEqual,
  arrowBindingMigrations,
  arrowBindingProps,
  arrowBindingVersions,
  arrowShapeMigrations,
  arrowShapeProps,
  arrowShapeVersions,
  assert,
  assertExists,
  assertIdType,
  assetIdValidator,
  assetMigrations,
  assetValidator,
  atom,
  average,
  b64Vecs,
  bind,
  bindingIdValidator,
  bookmarkShapeMigrations,
  bookmarkShapeProps,
  boxModelValidator,
  buildFromV1Document,
  canonicalizeRotation,
  canvasUiColorTypeValidator,
  centerOfCircleFromThreePoints,
  centerSelectionAroundPoint,
  clamp,
  clampRadians,
  clampToBrowserMaxCanvasSize,
  clearArrowTargetState,
  clearLocalStorage,
  clearSessionStorage,
  clockwiseAngleDist,
  compact,
  compressLegacySegments,
  computed,
  containBoxSize,
  copyAs,
  coreShapes,
  counterClockwiseAngleDist,
  createAssetValidator,
  createBindingId,
  createBindingPropsMigrationIds,
  createBindingPropsMigrationSequence,
  createBindingValidator,
  createBookmarkFromUrl,
  createComputedCache,
  createDebugValue,
  createDeepLinkString,
  createEmptyBookmarkShape,
  createEmptyRecordsDiff,
  createMigrationIds,
  createMigrationSequence,
  createPresenceStateDerivation,
  createRecordMigrationSequence,
  createRecordType,
  createSessionStateSnapshotSignal,
  createShapeId,
  createShapePropsMigrationIds,
  createShapePropsMigrationSequence,
  createShapeValidator,
  createShapesForAssets,
  createTLSchema,
  createTLSchemaFromUtils,
  createTLStore,
  createTLUser,
  dataUrlToFile,
  debounce,
  debugFlags,
  dedupe,
  defaultAddFontsFromNode,
  defaultBindingSchemas,
  defaultBindingUtils,
  defaultColorNames,
  defaultEditorAssetUrls,
  defaultHandleExternalEmbedContent,
  defaultHandleExternalExcalidrawContent,
  defaultHandleExternalFileAsset,
  defaultHandleExternalFileContent,
  defaultHandleExternalSvgTextContent,
  defaultHandleExternalTextContent,
  defaultHandleExternalTldrawContent,
  defaultHandleExternalUrlAsset,
  defaultHandleExternalUrlContent,
  defaultShapeSchemas,
  defaultShapeTools,
  defaultShapeUtils,
  defaultTldrawOptions,
  defaultTools,
  defaultUserPreferences,
  deferAsyncEffects,
  degreesToRadians,
  deleteFromLocalStorage,
  deleteFromSessionStorage,
  devFreeze,
  downloadFile,
  downsizeImage,
  drawShapeMigrations,
  drawShapeProps,
  embedShapeMigrations,
  embedShapePermissionDefaults,
  embedShapeProps,
  exhaustiveSwitchError,
  exportAs,
  extractSessionStateFromLegacySnapshot,
  featureFlags,
  fetch2 as fetch,
  filterEntries,
  fitFrameToContent,
  fpsThrottle,
  frameShapeMigrations,
  frameShapeProps,
  geoShapeMigrations,
  geoShapeProps,
  getArcMeasure,
  getArrowBindings,
  getArrowInfo,
  getArrowTargetState,
  getArrowTerminalsInArrowSpace,
  getAssetInfo,
  getChangedKeys,
  getColorValue,
  getComputedInstance,
  getCropBox,
  getCursor,
  getDefaultCdnBaseUrl,
  getDefaultColorTheme,
  getDefaultCrop,
  getDefaultTranslationLocale,
  getDefaultUserPresence,
  getDroppedShapesToNewParents,
  getEmbedInfo,
  getErrorAnnotations,
  getFirstFromIterable,
  getFontsFromRichText,
  getFreshUserPreferences,
  getFromLocalStorage,
  getFromSessionStorage,
  getHashForBuffer,
  getHashForObject,
  getHashForString,
  getHitShapeOnCanvasPointerDown,
  getIncrementedName,
  getIndexAbove,
  getIndexBelow,
  getIndexBetween,
  getIndices,
  getIndicesAbove,
  getIndicesBelow,
  getIndicesBetween,
  getMediaAssetInfoPartial,
  getOwnProperty,
  getPerfectDashProps,
  getPointInArcT,
  getPointOnCircle,
  getPointerInfo,
  getPointsFromDrawSegment,
  getPointsFromDrawSegments,
  getPointsOnArc,
  getPolygonVertices,
  getRotationSnapshot,
  getShapePropKeysByStyle,
  getSnapshot,
  getStroke,
  getStrokeOutlinePoints,
  getStrokePoints,
  getSvgAsImage,
  getSvgPathFromPoints,
  getSvgPathFromStrokePoints,
  getUncroppedSize,
  getUserPreferences,
  getVerticesCountForArcLength,
  groupBy,
  groupShapeMigrations,
  groupShapeProps,
  hardReset,
  hardResetEditor,
  hasOwnProperty,
  hideAllTooltips,
  highlightShapeMigrations,
  highlightShapeProps,
  idValidator,
  imageShapeMigrations,
  imageShapeProps,
  inlineBase64AssetStore,
  intersectCircleCircle,
  intersectCirclePolygon,
  intersectCirclePolyline,
  intersectLineSegmentCircle,
  intersectLineSegmentLineSegment,
  intersectLineSegmentPolygon,
  intersectLineSegmentPolyline,
  intersectPolygonBounds,
  intersectPolygonPolygon,
  invLerp,
  isAccelKey,
  isAtom,
  isBinding,
  isBindingId,
  isDefined,
  isDocument,
  export_isEqual as isEqual,
  isEqualAllowingForFloatingPointErrors,
  export_isEqualWith as isEqualWith,
  isNativeStructuredClone,
  isNonNull,
  isNonNullish,
  isPageId,
  isRecordsDiffEmpty,
  isSafeFloat,
  isShape,
  isShapeId,
  isSignal,
  isUninitialized,
  kickoutOccludedShapes,
  last,
  lerp,
  lineShapeMigrations,
  lineShapeProps,
  linesIntersect,
  lns,
  loadSessionStateSnapshotIntoStore,
  loadSnapshot,
  localStorageAtom,
  loopToHtmlElement,
  mapObjectMapValues,
  maxBy,
  maybeSnapToGrid,
  measureAverageDuration,
  measureCbDuration,
  measureDuration,
  mergeArraysAndReplaceDefaults,
  minBy,
  mockUniqueId,
  modulate,
  noop,
  normalizeWheel,
  noteShapeMigrations,
  noteShapeProps,
  notifyIfFileNotAllowed,
  objectMapEntries,
  objectMapEntriesIterable,
  objectMapFromEntries,
  objectMapKeys,
  objectMapValues,
  omit,
  omitFromStackTrace,
  onDragFromToolbarToCreateShape,
  opacityValidator,
  openWindow,
  pageIdValidator,
  parentIdValidator,
  parseAndLoadDocument,
  parseDeepLinkString,
  parseMigrationId,
  parseTldrawJsonFile,
  partition,
  perimeterOfEllipse,
  pluckPreservingValues,
  pointInPolygon,
  polygonIntersectsPolyline,
  polygonsIntersect,
  precise,
  preloadFont,
  preventDefault,
  promiseWithResolve,
  putExcalidrawContent,
  radiansToDegrees,
  rangeIntersection,
  react,
  reactor,
  refreshPage,
  registerDefaultExternalContentHandlers,
  registerDefaultSideEffects,
  registerTldrawLibraryVersion,
  releasePointerCapture,
  removeFrame,
  renderHtmlFromRichText,
  renderHtmlFromRichTextForMeasurement,
  renderPlaintextFromRichText,
  renderRichTextFromHTML,
  resizeBox,
  resizeScaled,
  restoreUniqueId,
  retry,
  reverseRecordsDiff,
  richTextValidator,
  rng,
  rootBindingMigrations,
  rootShapeMigrations,
  rotateArray,
  rotateSelectionHandle,
  runtime,
  safeParseUrl,
  sanitizeId,
  scribbleValidator,
  serializeTldrawJson,
  serializeTldrawJsonBlob,
  setDefaultEditorAssetUrls,
  setDefaultUiAssetUrls,
  setInLocalStorage,
  setInSessionStorage,
  setPointerCapture,
  setRuntimeOverrides,
  setStrokePointRadii,
  setUserPreferences,
  shapeIdValidator,
  shortAngleDist,
  sleep,
  snapAngle,
  sortById,
  sortByIndex,
  sortByMaybeIndex,
  squashRecordDiffs,
  squashRecordDiffsMutable,
  startEditingShapeWithRichText,
  stopEventPropagation,
  stringEnum,
  structuredClone,
  suffixSafeId,
  textShapeMigrations,
  textShapeProps,
  export_throttle as throttle,
  throttleToNextFrame,
  tipTapDefaultExtensions,
  tlenv,
  tlenvReactive,
  tlmenus,
  tltime,
  toDomPrecision,
  toFixed,
  toPrecision,
  toRichText,
  track,
  transact,
  transaction,
  truncateStringWithEllipsis,
  uniq,
  uniqueId,
  unsafe__withoutCapture,
  unwrapLabel,
  updateArrowTargetState,
  useA11y,
  useActions,
  useAssetUrls,
  useAtom,
  useBreakpoint,
  useCanRedo,
  useCanUndo,
  useCollaborationStatus,
  useComputed,
  useContainer,
  useContainerIfExists,
  useCopyAs,
  useCurrentTranslation,
  useDefaultColorTheme,
  useDefaultHelpers,
  useDelaySvgExport,
  useDialogs,
  useEditablePlainText,
  useEditableRichText,
  useEditor,
  useEditorComponents,
  useEvent,
  useExportAs,
  useGlobalMenuIsOpen,
  useImageOrVideoAsset,
  useIsCropping,
  useIsDarkMode,
  useIsEditing,
  useIsToolSelected,
  useKeyboardShortcuts,
  useLocalStorageState,
  useLocalStore,
  useMaybeEditor,
  useMenuClipboardEvents,
  useMenuIsOpen,
  useNativeClipboardEvents,
  useOnMount,
  usePassThroughMouseOverEvents,
  usePassThroughWheelEvents,
  usePeerIds,
  usePrefersReducedMotion,
  usePresence,
  useQuickReactor,
  useReactiveEvent,
  useReactor,
  useReadonly,
  useRefState,
  useRelevantStyles,
  useSelectedShapesAnnouncer,
  useSelectionEvents,
  useShallowArrayIdentity,
  useShallowObjectIdentity,
  useSharedSafeId,
  useShowCollaborationUi,
  useStateTracking,
  useStylePanelContext,
  useSvgExportContext,
  useTLSchemaFromUtils,
  useTLStore,
  useTldrawUiComponents,
  useTldrawUiOrientation,
  useTldrawUser,
  useToasts,
  useTools,
  useTransform,
  useTranslation,
  useUiEvents,
  useUniqueSafeId,
  useUnlockedSelectedShapesCount,
  useValue,
  useViewportHeight,
  userTypeValidator,
  validateIndexKey,
  vecModelValidator,
  videoShapeMigrations,
  videoShapeProps,
  warnDeprecatedGetter,
  warnOnce,
  whyAmIRunning,
  withDiff
};
/*! Bundled license information:

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@tldraw/store/dist-esm/lib/ImmutableMap.mjs:
  (*!
   * This file was lovingly and delicately extracted from Immutable.js
   * MIT License: https://github.com/immutable-js/immutable-js/blob/main/LICENSE
   * Copyright (c) 2014-present, Lee Byron and other contributors.
   *)

@tldraw/editor/dist-esm/lib/utils/browserCanvasMaxSize.mjs:
  (*!
   * Extracted from https://github.com/jhildenbiddle/canvas-size
   * MIT License: https://github.com/jhildenbiddle/canvas-size/blob/master/LICENSE
   * Copyright (c) John Hildenbiddle
   *)

@tldraw/editor/dist-esm/lib/hooks/useScreenBounds.mjs:
  (*!
   * Author: excalidraw
   * MIT License: https://github.com/excalidraw/excalidraw/blob/master/LICENSE
   * https://github.com/excalidraw/excalidraw/blob/48c3465b19f10ec755b3eb84e21a01a468e96e43/packages/excalidraw/utils.ts#L600
   *)

@tldraw/editor/dist-esm/lib/hooks/useViewportHeight.mjs:
  (*!
   * BSD License: https://github.com/outline/rich-markdown-editor/blob/main/LICENSE
   * Copyright (c) 2020 General Outline, Inc (https://www.getoutline.com/) and individual contributors.
   *
   * Returns the height of the viewport.
   * This is mainly to account for virtual keyboards on mobile devices.
   *
   * N.B. On iOS, you have to take into account the offsetTop as well so that you get an accurate position
   * while using the virtual keyboard.
   *)

tldraw/dist-esm/lib/shapes/shared/PathBuilder.mjs:
  (*!
   * Adapted from https://github.com/adobe-webplatform/Snap.svg/tree/master
   * Apache License: https://github.com/adobe-webplatform/Snap.svg/blob/master/LICENSE
   * https://github.com/adobe-webplatform/Snap.svg/blob/c8e483c9694517e24b282f8f59f985629f4994ce/dist/snap.svg.js#L5786
   *)
*/
//# sourceMappingURL=tldraw.js.map
